<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide Bindings for Python</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_2_python.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Halide Bindings for Python</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="halide-bindings-for-python"></a></p>
<ul>
<li><a class="el" href="#halide-bindings-for-python">Halide Bindings for Python</a><ul>
<li><a class="el" href="#acquiring-the-python-bindings">Acquiring the Python bindings</a></li>
<li><a class="el" href="#building-the-python-bindings">Building the Python bindings</a><ul>
<li><a class="el" href="#using-cmake-directly">Using CMake directly</a></li>
<li><a class="el" href="#using-wheel-infrastructure">Using wheel infrastructure</a></li>
</ul>
</li>
<li><a class="el" href="#documentation-and-examples">Documentation and Examples</a></li>
<li><a class="el" href="#differences-from-c-api">Differences from C++ API</a></li>
<li><a class="el" href="#example-of-simple-usage">Example of Simple Usage</a></li>
<li><a class="el" href="#halide-generators-in-python">Halide Generators In Python</a><ul>
<li><a class="el" href="#writing-a-generator-in-python">Writing a Generator in Python</a><ul>
<li><a class="el" href="#hlgeneratorname">`hl.generator(&quot;name&quot;)`</a></li>
<li><a class="el" href="#hlgeneratorparam">hl.GeneratorParam</a></li>
<li><a class="el" href="#hlinputbuffer-hlinputscalar">hl.InputBuffer, hl.InputScalar</a></li>
<li><a class="el" href="#hloutputbuffer-hloutputscalar">hl.OutputBuffer, hl.OutputScalar</a></li>
<li><a class="el" href="#names">Names</a></li>
<li><a class="el" href="#generate-method">generate() method</a></li>
<li><a class="el" href="#types-for-inputs-and-outputs">Types for Inputs and Outputs</a></li>
</ul>
</li>
<li><a class="el" href="#using-a-generator-for-jit-compilation">Using a Generator for JIT compilation</a></li>
<li><a class="el" href="#using-a-generator-for-aot-compilation">Using a Generator for AOT compilation</a></li>
<li><a class="el" href="#calling-generator-produced-code-from-python">Calling Generator-Produced code from Python</a></li>
<li><a class="el" href="#advanced-generator-related-topics">Advanced Generator-Related Topics</a><ul>
<li><a class="el" href="#generator-aliases">Generator Aliases</a></li>
<li><a class="el" href="#dynamic-inputs-and-outputs">Dynamic Inputs and Outputs</a></li>
<li><a class="el" href="#calling-a-generator-directly">Calling a Generator Directly</a></li>
<li><a class="el" href="#the-lifecycle-of-a-generator">The Lifecycle Of A Generator</a></li>
<li><a class="el" href="#notable-differences-between-c-and-python-generators">Notable Differences Between C++ and Python Generators</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="#keeping-up-to-date">Keeping Up To Date</a></li>
<li><a class="el" href="#license">License</a></li>
</ul>
</li>
</ul>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> provides Python bindings for most of its public API. Python 3.8 (or higher) is required. The Python bindings are supported on 64-bit Linux, OSX, and Windows systems.</p>
<p>In addition to the ability to write just-in-time <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code using Python, you can write <a class="el" href="#halide-generators-in-python">Generators</a> using the Python bindings, which can simplify build-system integration (since no C++ metacompilation step is required).</p>
<p>You can also use existing <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Generators (written in either C++ or Python) to produce Python extensions that can be used within Python code.</p>
<h1><a class="anchor" id="acquiring-the-python-bindings"></a>
Acquiring the Python bindings</h1>
<p>As of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> 19.0.0, we provide binary wheels on PyPI which include the Python bindings and the C++/CMake package for native development. Full releases may be installed with <code>pip</code> like so:</p>
<div class="fragment"><div class="line">$ pip install halide</div>
</div><!-- fragment --><p>Every commit to <code>main</code> is published to Test PyPI as a development version and these may be installed with a few extra flags:</p>
<div class="fragment"><div class="line">$ pip install halide --pre --extra-index-url https://test.pypi.org/simple</div>
</div><!-- fragment --><p>Currently, we provide wheels for: Windows x86-64, macOS x86-64, macOS arm64, and Linux x86-64. The Linux wheels are built for manylinux_2_28, which makes them broadly compatible (Debian 10, Ubuntu 18.10, Fedora 29).</p>
<h1><a class="anchor" id="building-the-python-bindings"></a>
Building the Python bindings</h1>
<p>If <code>pip</code> isn't enough for your purposes, or you are developing <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> directly, you have two options for building and using the Python bindings. Note that the bindings require <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to be built with RTTI and exceptions <b>enabled</b>, which in turn requires LLVM to be built with RTTI, but this is not the default for LLVM.</p>
<h2><a class="anchor" id="using-cmake-directly"></a>
Using CMake directly</h2>
<p>Before configuring with CMake, you should ensure you have prerequisite packages installed in your local Python environment. The best way to get set up is to use a virtual environment:</p>
<div class="fragment"><div class="line">$ python3 -m venv venv</div>
<div class="line">$ . venv/bin/activate</div>
<div class="line">$ python3 -m pip install -U pip &quot;setuptools[core]&quot; wheel</div>
<div class="line">$ python3 -m pip install -r requirements.txt</div>
</div><!-- fragment --><p>Then build and install <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>:</p>
<div class="fragment"><div class="line">$ cmake -G Ninja -S . -B build \</div>
<div class="line">        -DCMAKE_BUILD_TYPE=Release \ </div>
<div class="line">        -DWITH_PYTHON_BINDINGS=ON</div>
<div class="line">$ cmake --build build</div>
<div class="line">$ cmake --install build --prefix .local</div>
</div><!-- fragment --><p>Now you can set the <code>PYTHONPATH</code> variable to point to the freshly built Python package:</p>
<div class="fragment"><div class="line">$ export PYTHONPATH=&quot;$PWD/.local/lib/python3/site-packages&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="using-wheel-infrastructure"></a>
Using wheel infrastructure</h2>
<p>You can also follow the same procedure that we use to build the published wheels. First, create a virtual environment as before, but omit <code>requirements.txt</code></p>
<div class="fragment"><div class="line">$ python3 -m venv venv</div>
<div class="line">$ . venv/bin/activate</div>
<div class="line">$ python3 -m pip install -U pip &quot;setuptools[core]&quot; wheel</div>
</div><!-- fragment --><p>Next, ensure you have installed <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s dependencies to locations where CMake can find them, given your environment. The variables <code>Halide_LLVM_ROOT</code>, <code>flatbuffers_ROOT</code>, and <code>wabt_ROOT</code> specify locations for the relevant packages directly. If they are all installed to a common prefix, you can add it to the environment variable <code>CMAKE_PREFIX_PATH</code>.</p>
<p>Then it should be as simple as:</p>
<div class="fragment"><div class="line">$ pip install .</div>
</div><!-- fragment --><h1><a class="anchor" id="documentation-and-examples"></a>
Documentation and Examples</h1>
<p>As mentioned elsewhere, the Python API attempts to mimic the <a href="http://halide-lang.org/docs">C++ Halide API</a> as directly as possible; there isn't separate Python-specific documentation for the API at this time.</p>
<p>For now, examine the code for the example applications in the <code>test/apps/</code> and <code>tutorial/</code> subdirectories.</p>
<p>The tests run as part of the standard CTest infrastructure and are labeled with the <code>python</code> label. You can run the Python tests specifically by running:</p>
<div class="fragment"><div class="line">$ ctest -L python</div>
</div><!-- fragment --><p>from the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> build directory.</p>
<h1><a class="anchor" id="differences-from-c-api"></a>
Differences from C++ API</h1>
<p>The Python bindings attempt to mimic the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> C++ API as closely as possible, with some differences where the C++ idiom is either inappropriate or impossible:</p>
<ul>
<li><p class="startli">Most APIs that take a variadic argument list of ints in C++ take an explicit list in Python. For instance, the usual version of the <code>Buffer</code> ctor in C++ offers both variadic and list versions:</p>
<div class="fragment"><div class="line">Buffer&lt;&gt;(Type t, <span class="keywordtype">int</span> extent_dim_0, <span class="keywordtype">int</span> extent_dim_1, ...., extent_dim_N, <span class="keywordtype">string</span> name = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">Buffer&lt;&gt;(Type t, vector&lt;int&gt; extents, <span class="keywordtype">string</span> name = <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p class="startli">In Python, only the second variant is provided.</p>
</li>
<li><code>Func</code> and <code>Buffer</code> access is done using <code>[]</code> rather than <code>()</code><ul>
<li>For zero-dimensional <code>Func</code> and <code>Buffer</code>, you must explicitly specify <code>[()]</code> &ndash; that is, use an empty tuple as the index &ndash; because <code>[]</code> is not syntactically acceptable in Python.</li>
</ul>
</li>
<li>Some classes in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> API aren't provided because standard Python idioms are a better fit:<ul>
<li><code><a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Halide::Tuple</a></code> doesn't exist in the Python bindings; an ordinary Python tuple of <code><a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Halide::Expr</a></code> is used instead.</li>
<li><code><a class="el" href="class_halide_1_1_realization.html" title="A Realization is a vector of references to existing Buffer objects.">Halide::Realization</a></code> doesn't exist in the Python bindings; an ordinary Python tuple of <code><a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Halide::Buffer</a></code> is used instead.</li>
</ul>
</li>
<li>static and instance method overloads with the same name in the same class aren't allowed, so some convenience methods are missing from <code><a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Halide::Var</a></code></li>
<li>Templated types (notably <code><a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Halide::Buffer</a>&lt;&gt;</code> and <code><a class="el" href="class_halide_1_1_param.html" title="A scalar parameter to a halide pipeline.">Halide::Param</a>&lt;&gt;</code>) aren't provided, for obvious reasons; only the equivalents of <code><a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Halide::Buffer</a>&lt;void&gt;</code> and <code><a class="el" href="class_halide_1_1_param.html" title="A scalar parameter to a halide pipeline.">Halide::Param</a>&lt;void&gt;</code> are supported.</li>
<li>The functions in <code><a class="el" href="namespace_halide_1_1_concise_casts.html">Halide::ConciseCasts</a></code> are present in the toplevel <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> module in Python, rather than a submodule: e.g., use <code>halide.i8_sat()</code>, not <code>halide.ConciseCasts.i8_sat()</code>.</li>
<li>Only things in the <code><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a></code> namespace are supported; classes and methods that involve using the <code><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></code> namespace are not provided.</li>
<li>No mechanism is provided for overriding any runtime functions from Python for JIT-compiled code. (Runtime functions for AOT-compiled code can be overridden by building and linking a custom runtime, but not currently via any runtime API, e.g. <a class="el" href="runtime__internal_8h.html#a796f30bc9cb976181a401d04dddd0c86">halide_set_custom_print()</a> does not exist.)</li>
<li>No mechanism is provided for supporting <code>Func::define_extern</code>.</li>
<li><code>Buffer::for_each_value()</code> isn't supported yet.</li>
<li><code>Func::in</code> becomes <code>Func.in_</code> because <code>in</code> is a Python keyword.</li>
<li><code>Func::async</code> becomes <code>Func.async_</code> because <code>async</code> is a Python keyword.</li>
<li>The <code>not</code> keyword cannot be used to negate boolean <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expressions. Instead, the <code>logical_not</code> function can be used and is equivalent to using <code>operator!</code> in C++.</li>
<li>There is no way to override the logical <code>and</code>/<code>or</code> operators in Python to work with <code>Expr</code>: you must use the bitwise <code>|</code> and <code>&amp;</code> instead. (Note that incorrectly using <code>and</code>/<code>or</code> just short-circuits weirdly, rather than failing with some helpful error; this is an issue that we have not yet found any way to improve, unfortunately.)</li>
<li>Some error messages need to be made more informative.</li>
<li>Some exceptions are the "incorrect" type (compared to C++ expectations).</li>
<li>Many hooks to override runtime functions (e.g. Func::set_error_handler) aren't yet implemented.</li>
<li>The following parts of the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> public API are currently missing entirely from the Python bindings (but are all likely to be supported at some point in the future):<ul>
<li><code>DeviceInterface</code></li>
<li><code>evaluate()</code></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="example-of-simple-usage"></a>
Example of Simple Usage</h1>
<p>Here is a basic example of using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to produce a procedural image.</p>
<div class="fragment"><div class="line"><span class="comment"># By convention, we import halide as &#39;hl&#39; for terseness</span></div>
<div class="line"><span class="keyword">import</span> halide <span class="keyword">as</span> hl</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Some constants</span></div>
<div class="line">edge = 512</div>
<div class="line">k = 20.0 / float(edge)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simple formula</span></div>
<div class="line">x, y, c = hl.Var(<span class="stringliteral">&#39;x&#39;</span>), hl.Var(<span class="stringliteral">&#39;y&#39;</span>), hl.Var(<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line">f = hl.Func(<span class="stringliteral">&#39;f&#39;</span>)</div>
<div class="line">e = hl.sin(x * ((c + 1) / 3.0) * k) * hl.cos(y * ((c + 1) / 3.0) * k)</div>
<div class="line">f[x, y, c] = hl.cast(hl.UInt(8), e * 255.0)</div>
<div class="line">f.vectorize(x, 8).parallel(y)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Realize into a Buffer.</span></div>
<div class="line">buf = f.realize([edge, edge, 3])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Do something with the image. We&#39;ll just save it to a PNG.</span></div>
<div class="line"><span class="keyword">from</span> halide <span class="keyword">import</span> imageio</div>
<div class="line"> </div>
<div class="line">imageio.imwrite(<span class="stringliteral">&quot;/tmp/example.png&quot;</span>, buf)</div>
</div><!-- fragment --><p>It's worth noting in the example above that the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <code>Buffer</code> object supports the Python Buffer Protocol (<a href="https://www.python.org/dev/peps/pep-3118">https://www.python.org/dev/peps/pep-3118</a>) and thus is converted to and from other compatible objects (e.g., NumPy's <code>ndarray</code>), at essentially zero cost, with storage being shared. Thus, we can usually pass it directly to existing Python APIs (like <code>imsave()</code>) that expect 'image-like' objects without any explicit conversion necessary.</p>
<h1><a class="anchor" id="halide-generators-in-python"></a>
Halide Generators In Python</h1>
<p>In <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, a "Generator" is a unit of encapsulation for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code. It is a self-contained piece of code that can:</p>
<ul>
<li>Produce a chunk of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR (in the form of an <code>hl.Pipeline</code>) that is appropriate for compilation (via either JIT or AOT)</li>
<li>Expose itself to the build system in a discoverable way</li>
<li>Fully describe itself for the build system with metadata for (at least) the type and number of inputs and outputs expected</li>
<li>Allow for build-time customization of coder-specified parameters in a way that doesn't require editing of source code</li>
</ul>
<p>Originally, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> only supported writing Generators in C++. In this document, we'll use the term "C++ Generator" to mean "Generator written in C++ using the
classic API", the term "Python Generator" to mean "Generator written in Halide's
Python bindings", and just plain "Generator" when the discussion is relatively neutral with respect to the implementation language/API.</p>
<h2><a class="anchor" id="writing-a-generator-in-python"></a>
Writing a Generator in Python</h2>
<p>A Python Generator is a class that:</p>
<ul>
<li>has the <code>@hl.generator</code> decorator applied to it</li>
<li>declares zero or more member fields that are initialized with values of <code>hl.InputBuffer</code> or <code>hl.InputScalar</code>, which specify the expected input(s) of the resulting <code>Pipeline</code>.</li>
<li>declares one or more member fields that are initialized with values of <code>hl.OutputBuffer</code> or <code>hl.OutputScalar</code>, which specify the expected output(s) of the resulting <code>Pipeline</code>.</li>
<li>declares zero or more member fields that are initialized with values of <code>hl.GeneratorParam</code>, which can be used to pass arbitrary information from the build system to the Generator. A GeneratorParam can carry a value of type <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, or <code>hl.Type</code>.</li>
<li>declares a <code>generate()</code> method that fill in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR needed to define all the Outputs</li>
<li>optionally declares a <code>configure()</code> method to dynamically add Inputs or Outputs to the pipeline, based on (e.g.) the values of <code>GeneratorParam</code> values or other external inputs</li>
</ul>
<p>Let's look at a fairly simple example:</p>
<blockquote class="doxtable">
<p>&zwj;<b>TODO:</b> this example is pretty contrived; is there an equally simple Generator to use here that would demonstrate the basics? </p>
</blockquote>
<div class="fragment"><div class="line"><span class="keyword">import</span> halide <span class="keyword">as</span> hl</div>
<div class="line"> </div>
<div class="line">x = hl.Var(<span class="stringliteral">&#39;x&#39;</span>)</div>
<div class="line">y = hl.Var(<span class="stringliteral">&#39;y&#39;</span>)</div>
<div class="line"> </div>
<div class="line">_operators = {</div>
<div class="line">    <span class="stringliteral">&#39;xor&#39;</span>: <span class="keyword">lambda</span> a, b: a ^ b,</div>
<div class="line">    <span class="stringliteral">&#39;and&#39;</span>: <span class="keyword">lambda</span> a, b: a &amp; b,</div>
<div class="line">    <span class="stringliteral">&#39;or&#39;</span>: <span class="keyword">lambda</span> a, b: a | b</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># Apply a mask value to a 2D image using a logical operator that is selected at compile-time.</span></div>
<div class="line"><span class="preprocessor">@hl.generator(name=&quot;logical_op_generator&quot;)</span></div>
<div class="line"><span class="keyword">class </span>LogicalOpGenerator:</div>
<div class="line">    op = hl.GeneratorParam(<span class="stringliteral">&quot;xor&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    input = hl.InputBuffer(hl.UInt(8), 2)</div>
<div class="line">    mask = hl.InputScalar(hl.UInt(8))</div>
<div class="line"> </div>
<div class="line">    output = hl.OutputBuffer(hl.UInt(8), 2)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>generate(g):</div>
<div class="line">        <span class="comment"># Algorithm</span></div>
<div class="line">        operator = _operators[g.op]</div>
<div class="line">        g.output[x, y] = operator(g.input[x, y], g.mask)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Schedule</span></div>
<div class="line">        v = g.natural_vector_size(hl.UInt(8))</div>
<div class="line">        g.output.vectorize(x, v)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    hl.main()</div>
</div><!-- fragment --><p>If you've worked with <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Generators written in C++, the "shape" of this will likely look familiar. (If not, no worries; you shouldn't need any knowledge of C++ Generators for the following to make sense.)</p>
<p>Let's take the details here one at a time.</p>
<h3><a class="anchor" id="hlgeneratorname"></a>
<code>hl.generator("name")</code></h3>
<p>This decorator adds appropriate "glue" machinery to the class to enforce various invariants. It also serves as the declares a "registered name" for the Generator, which is a unique name that the build system will use to identify the Generator. If you omit the name, it defaults to <code>module.classname</code>; if module is <code>__main__</code> then we omit it and just use the plain classname. Note that the registered name need not match the classname. (Inside <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, we use the convention of <code>CamelCase</code> for class names and <code>snake_case</code> for registered names, but you can use whatever convention you like.)</p>
<h3><a class="anchor" id="hlgeneratorparam"></a>
hl.GeneratorParam</h3>
<p>Each <code>GeneratorParam</code> is an arbitrary key-value pair that can be used to provide configurable options at compile time. You provide the name and a default value. The default value can be overridden by the build machinery, which will replace the value (based on user specified text).</p>
<p>Note that the type of the default value <em>is</em> used to define the expected type of the <code>GeneratorParam</code>, and trying to set it to an incompatible value will throw an exception. The types that are acceptable to use in a <code>GeneratorParam</code> are:</p>
<ul>
<li>Python's <code>bool</code>, <code>int</code>, <code>float</code>, or <code>str</code></li>
<li><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s <code>hl.Type</code></li>
<li>...that's all</li>
</ul>
<p>Note that the value of a <code>GeneratorParam</code> is read-only from the point of view of the Generator; they are set at Generator construction time and attempting to change their value will throw an exception.</p>
<h3><a class="anchor" id="hlinputbuffer-hlinputscalar"></a>
hl.InputBuffer, hl.InputScalar</h3>
<p>These declare the inputs to the <code>hl.Pipeline</code> that the Generator will produce. An <code>hl.InputScalar</code> is, essentially, a "factory" that produces an <code>hl.Param</code> in the existing Python API, while an <code>hl.InputBuffer</code> is a factory for <code>hl.ImageParam</code>.</p>
<p>From the Generator author's perspective, a field initialized with <code>InputScalar</code> <b>is</b> a <code>Param</code> – not kinda-like-one, not a magic wrapper that forwards everything; it is literally just <code>hl.Param</code>. Similarly, an <code>InputBuffer</code> produces <code>ImageParam</code>, and an <code>InputFunc</code> is a wrapper around <code>Func</code>. You won't be able to assign a new value to the member field for Inputs – as with GeneratorParams, they are "read-only" to the Generator – but you will be able to set constraints on them.</p>
<p>Note that in addition to specifying a concrete type and dimensionality for the inputs, these factory classes support the ability to specify either (or both) <code>None</code>, which means the type/dimensionality will be provided by GeneratorParams in the build system.</p>
<h3><a class="anchor" id="hloutputbuffer-hloutputscalar"></a>
hl.OutputBuffer, hl.OutputScalar</h3>
<p>These declare the output(s) of the Pipeline that the Generator will produce. An <code>hl.OutputBuffer</code> is, essentially, a "factory" that produces an <code>hl.Func</code> in the existing Python API. (<code>hl.OutputScalar</code> is just an <code>hl.OutputBuffer</code> that always has zero dimensions.)</p>
<p>From the Generator author's perspective, a field declared with <code>OutputBuffer</code> <b>is</b> a <code>Func</code> – not kinda-like-one, not a magic wrapper that forwards everything; it is literally just <code>hl.Func</code> (with type-and-dimensionality set to match, see recent PR <a href="https://github.com/halide/Halide/pull/6734">https://github.com/halide/Halide/pull/6734</a>) . You won't be able to assign a new value to the member field for Inputs – as with GeneratorParams, they are "read-only" to the Generator – but you will be able to set constraints on them.</p>
<p>Note that in addition to specifying a concrete type and dimensionality for the inputs, these factory classes support the ability to specify either (or both) as <code>None</code>, which means the type/dimensionality will be provided by GeneratorParams in the build system.</p>
<h3><a class="anchor" id="names"></a>
Names</h3>
<p>Note that all the GeneratorParams, Inputs, and Outputs have names that are implicitly filled in based on the field name of their initial assignment; unlike in C++ Generators, there isn't a way to "override" this name (i.e., the name in the IR will always exactly match the Python field name). Names have the same constraints as for C++ Generators (essentially, a C identifier, but without an initial underscore, and without any double underscore anywhere).</p>
<h3><a class="anchor" id="generate-method"></a>
generate() method</h3>
<p>This will be called by the Generator machinery to build the Pipeline. As with C++ Generators, the only required task is to ensure that all Output fields are fully defined, in a way that matches the type-and-dimension constraints specified.</p>
<p>It is required that the <code>generate()</code> method be defined by the Generator.</p>
<p>(Note that, by convention, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Generators use <code>g</code> instead of <code>self</code> in their <code>generate()</code> method to make the expression language terser; this is not in any way required, but is recommended to improve readability.)</p>
<h3><a class="anchor" id="types-for-inputs-and-outputs"></a>
Types for Inputs and Outputs</h3>
<p>For all the Input and Output fields of Generators, you can specify native Python types (instead of <code>hl.Type</code>) for certain cases that are unambiguous. At present, we allow <code>bool</code> as an alias for <code>hl.Bool()</code>, <code>int</code> as an alias for <code>hl.Int(32)</code>, and <code>float</code> as an alias for <code>hl.Float(32)</code>.</p>
<h2><a class="anchor" id="using-a-generator-for-jit-compilation"></a>
Using a Generator for JIT compilation</h2>
<p>You can use the <code>compile_to_callable()</code> method to JIT-compile a Generator into a <code>hl.Callable</code>, which is (essentially) just a dynamically-created function.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> LogicalOpGenerator</div>
<div class="line"><span class="keyword">from</span> halide <span class="keyword">import</span> imageio</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Instantiate a Generator -- we can only set the GeneratorParams</span></div>
<div class="line"><span class="comment"># by passing in a dict to the Generator&#39;s constructor</span></div>
<div class="line">or_op_generator = LogicalOpGenerator({<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;or&quot;</span>})</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Now compile the Generator into a Callable</span></div>
<div class="line">or_filter = or_op_generator.compile_to_callable()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Read in some file for input</span></div>
<div class="line">input_buf = imageio.imread(<span class="stringliteral">&quot;/path/to/some/file.png&quot;</span>)</div>
<div class="line"><span class="keyword">assert</span> input_buf.ndim == 2</div>
<div class="line"><span class="keyword">assert</span> input_buf.dtype == np.uint8</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create a Buffer-compatible object for the output; we&#39;ll use np.array</span></div>
<div class="line">output_buf = np.empty(input_buf.shape, dtype=input_buf.dtype)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Note, Python code throws exception for error conditions rather than returning an int</span></div>
<div class="line">or_filter(input_buf, 0x7f, output_buf)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Note also that we can use named arguments for any/all, in the Python manner:</span></div>
<div class="line">or_filter(mask=0x7f, input=input_buf, output=output_buf)</div>
<div class="line"> </div>
<div class="line">imageio.imwrite(<span class="stringliteral">&quot;/tmp/or.png&quot;</span>, output_buf)</div>
</div><!-- fragment --><p>By default, a Generator will produce code targeted at <code>Target("host")</code> (or the value of the <code>HL_JIT_TARGET</code> environment variable, if set); you can override this behavior selectively by activating a <code>GeneratorContext</code> when the Generator is <em>created</em>:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> LogicalOpGenerator</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Compile with debugging enabled</span></div>
<div class="line">t = hl.Target(<span class="stringliteral">&quot;host-debug&quot;</span>)</div>
<div class="line"><span class="keyword">with</span> hl.GeneratorContext(t):</div>
<div class="line">    or_op_generator = LogicalOpGenerator({<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;or&quot;</span>})</div>
<div class="line">    or_filter = or_op_generator.compile_to_callable()</div>
</div><!-- fragment --><h2><a class="anchor" id="using-a-generator-for-aot-compilation"></a>
Using a Generator for AOT compilation</h2>
<p>If you are using CMake, the simplest thing is to use <code>add_halide_library</code> and <code>add_halide_python_extension_library()</code>:</p>
<div class="fragment"><div class="line"># Build a Halide library as you usually would, but be sure to include `PYTHON_EXTENSION`</div>
<div class="line">add_halide_library(xor_filter</div>
<div class="line">                   FROM logical_op_generator</div>
<div class="line">                   PARAMS op=xor</div>
<div class="line">                   PYTHON_EXTENSION output_path_var</div>
<div class="line">                   [ FEATURES ... ]</div>
<div class="line">                   [ PARAMS ... ])</div>
<div class="line"> </div>
<div class="line"># Now wrap the generated code with a Python extension.</div>
<div class="line"># (Note that module name defaults to match the target name; we only</div>
<div class="line"># need to specify MODULE_NAME if we need a name that may differ)</div>
<div class="line">add_halide_python_extension_library(my_extension</div>
<div class="line">                                    MODULE_NAME my_module</div>
<div class="line">                                    HALIDE_LIBRARIES xor_filter)</div>
</div><!-- fragment --><p>(Note that this rule works for both C++ and Python Generators.)</p>
<p>This compiles the Generator code in <code>logical_op_generator.py</code> with the registered name <code>logical_op_generator</code> to produce the target <code>xor_filter</code>, and then wraps the compiled output with a Python extension. The result will be a shared library of the form <code>&lt;target&gt;.&lt;soabi&gt;.so</code>, where <code>&lt;soabi&gt;</code> describes the specific Python version and platform (e.g., <code>cpython-310-darwin</code> for Python 3.10 on OSX.)</p>
<p>Note that you can combine multiple <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> libraries into a single Python module; this is convenient for packaging, but also because all the libraries in a single extension module share the same <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime (and thus, the same caches, thread pools, etc.).</p>
<div class="fragment"><div class="line">add_halide_library(xor_filter ...)</div>
<div class="line">add_halide_library(and_filter ...)</div>
<div class="line">add_halide_library(or_filter ...)</div>
<div class="line"> </div>
<div class="line">add_halide_python_extension_library(my_extension</div>
<div class="line">                                    MODULE_NAME my_module</div>
<div class="line">                                    HALIDE_LIBRARIES xor_filter and_filter or_filter)</div>
</div><!-- fragment --><p>Note that you must take care to ensure that all of the <code>add_halide_library</code> targets specified use the same <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime; it may be necessary to use <code>add_halide_runtime</code> to define an explicit runtime that is shared by all the targets:</p>
<div class="fragment"><div class="line">add_halide_runtime(my_runtime)</div>
<div class="line"> </div>
<div class="line">add_halide_library(xor_filter USE_RUNTIME my_runtime ...)</div>
<div class="line">add_halide_library(and_filter USE_RUNTIME my_runtime ...)</div>
<div class="line">add_halide_library(or_filter USE_RUNTIME my_runtime ...)</div>
<div class="line"> </div>
<div class="line">add_halide_python_extension_library(my_extension</div>
<div class="line">                                    MODULE_NAME my_module</div>
<div class="line">                                    HALIDE_LIBRARIES xor_filter and_filter or_filter)</div>
</div><!-- fragment --><p>If you're not using CMake, you can "drive" a Generator directly from your build system via command-line flags. The most common, minimal set looks something like this:</p>
<div class="fragment"><div class="line">python3 /path/to/my/generator.py -g &lt;registered-name&gt; \</div>
<div class="line">                                 -o &lt;output-dir&gt; \</div>
<div class="line">                                 target=&lt;halide-target-string&gt; \</div>
<div class="line">                                 [generator-param=value ...]</div>
</div><!-- fragment --><p>The argument to <code>-g</code> is the name supplied to the <code>@hl.generator</code> decorator. The argument to -o is a directory to use for the output files; by default, we'll produce a static library containing the object code, and a C++ header file with a forward declaration. <code>target</code> specifies a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <code>Target</code> string describing the OS, architecture, features, etc. that should be used for compilation. Any other arguments to the command line that don't begin with <code>-</code> are presumed to name <code>GeneratorParam</code> values to set.</p>
<p>There are other flags and options too, of course; use <code>python3 /path/to/my/generator.py -help</code> to see a list with explanations.</p>
<p>(Unfortunately, there isn't (yet) a way to produce a Python Extension just by running a Generator; the logic for <code>add_halide_python_extension_library</code> is currently all in the CMake helper files.)</p>
<h2><a class="anchor" id="calling-generator-produced-code-from-python"></a>
Calling Generator-Produced code from Python</h2>
<p>As long as the shared library is in <code>PYTHONPATH</code>, it can be imported and used directly. For the example above:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> xor_filter</div>
<div class="line"><span class="keyword">from</span> halide <span class="keyword">import</span> imageio</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Read in some file for input</span></div>
<div class="line">input_buf = imageio.imread(<span class="stringliteral">&quot;/path/to/some/file.png&quot;</span>)</div>
<div class="line"><span class="keyword">assert</span> input_buf.ndim == 2</div>
<div class="line"><span class="keyword">assert</span> input_buf.dtype == np.uint8</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create a Buffer-compatible object for the output; we&#39;ll use np.array</span></div>
<div class="line">output_buf = np.empty(input_buf.shape, dtype=input_buf.dtype)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Note, Python code throws exception for error conditions rather than returning an int</span></div>
<div class="line">xor_filter(input_buf, 0xff, output_buf)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Note also that we can use named arguments for any/all, in the Python manner:</span></div>
<div class="line"><span class="comment"># xor_filter(input=input_buf, mask=0xff, output=output_buf)</span></div>
<div class="line"> </div>
<div class="line">imageio.imwrite(<span class="stringliteral">&quot;/tmp/xored.png&quot;</span>, output_buf)</div>
</div><!-- fragment --><p>Above, we're using common Python utilities (<code>numpy</code>) to construct the input/output buffers we want to pass to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.</p>
<p><b>Note</b>: Getting the memory order correct can be a little confusing for numpy. By default, numpy uses "C-style" <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/internals.html">row-major</a> order, which sounds like the right option for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>; however, this nomenclature assumes the matrix-math convention of ordering axes as <code>[rows, cols]</code>, whereas <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> (and imaging code in general) generally assumes <code>[x, y]</code> (i.e., <code>[cols, rows]</code>). Thus, what you usually want in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> is column-major ordering. This means numpy arrays, by default, come with the wrong memory layout for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. But if you construct the numpy arrays yourself (like above), you can pass &lsquo;order='F&rsquo;<code>to make numpy use the Halide-compatible memory layout. If you're passing in an array constructed somewhere else, the easiest thing to do is to </code>.transpose()` it before passing it to your <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code.</p>
<h2><a class="anchor" id="advanced-generator-related-topics"></a>
Advanced Generator-Related Topics</h2>
<h3><a class="anchor" id="generator-aliases"></a>
Generator Aliases</h3>
<p>A Generator alias is a way to associate a Generator with one (or more) specific sets of GeneratorParams; the 'alias' is just another registered name. This offers a convenient alternative to specifying multiple sets of GeneratorParams via the build system. To define alias(es) for a Generator, just add the <code>@hl.alias</code> decorator before <code>@hl.generator</code> decorator:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@hl.alias</span>(</div>
<div class="line">    xor_generator={<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;xor&quot;</span>},</div>
<div class="line">    and_generator={<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;and&quot;</span>},</div>
<div class="line">    or_generator={<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;or&quot;</span>}</div>
<div class="line">)</div>
<div class="line"><span class="preprocessor">@hl.generator(&quot;logical_op_generator&quot;)</span></div>
<div class="line"><span class="keyword">class </span>LogicalOpGenerator:</div>
<div class="line">    ...</div>
</div><!-- fragment --><h3><a class="anchor" id="dynamic-inputs-and-outputs"></a>
Dynamic Inputs and Outputs</h3>
<p>If you need to build <code>Input</code> and/or <code>Output</code> dynamically, you can define a <code>configure()</code> method. It will always be called after all <code>GeneratorParam</code> values are valid, but before <code>generate()</code> is called. Let's take our example and add an option to pass an offset to be added after the logical operator is done:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> halide <span class="keyword">as</span> hl</div>
<div class="line"> </div>
<div class="line">x = hl.Var(<span class="stringliteral">&#39;x&#39;</span>)</div>
<div class="line">y = hl.Var(<span class="stringliteral">&#39;y&#39;</span>)</div>
<div class="line"> </div>
<div class="line">_operators = {</div>
<div class="line">    <span class="stringliteral">&#39;xor&#39;</span>: <span class="keyword">lambda</span> a, b: a ^ b,</div>
<div class="line">    <span class="stringliteral">&#39;and&#39;</span>: <span class="keyword">lambda</span> a, b: a &amp; b,</div>
<div class="line">    <span class="stringliteral">&#39;or&#39;</span>: <span class="keyword">lambda</span> a, b: a | b</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># Apply a mask value to a 2D image using a logical operator that is selected at compile-time.</span></div>
<div class="line"><span class="preprocessor">@hl.generator(name=&quot;logical_op_generator&quot;)</span></div>
<div class="line"><span class="keyword">class </span>LogicalOpGenerator:</div>
<div class="line">    op = hl.GeneratorParam(<span class="stringliteral">&quot;xor&quot;</span>)</div>
<div class="line">    with_offset = hl.GeneratorParam(<span class="keyword">False</span>)</div>
<div class="line"> </div>
<div class="line">    input = hl.InputBuffer(hl.UInt(8), 2)</div>
<div class="line">    mask = hl.InputScalar(hl.UInt(8))</div>
<div class="line"> </div>
<div class="line">    output = hl.OutputBuffer(hl.UInt(8), 2)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>configure(g):</div>
<div class="line">        <span class="comment"># If with_offset is specified, we</span></div>
<div class="line">        <span class="keywordflow">if</span> g.with_offset:</div>
<div class="line">            g.add_input(<span class="stringliteral">&quot;offset&quot;</span>, hl.InputScalar(hl.Int(32)))</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># See note the use of &#39;g&#39; instead of &#39;self&#39; here</span></div>
<div class="line">    <span class="keyword">def </span>generate(g):</div>
<div class="line">        <span class="comment"># Algorithm</span></div>
<div class="line">        operator = _operators[g.op]</div>
<div class="line">        <span class="keywordflow">if</span> hasattr(g, <span class="stringliteral">&quot;offset&quot;</span>):</div>
<div class="line">            g.output[x, y] = operator(g.input[x, y], g.mask) + g.offset</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            g.output[x, y] = operator(g.input[x, y], g.mask)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Schedule</span></div>
<div class="line">        v = g.natural_vector_size(hl.UInt(8))</div>
<div class="line">        g.output.vectorize(x, v)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    hl.main()</div>
</div><!-- fragment --><p>The only thing you can (usefully) do from <code>configure()</code> is to call <code>add_input()</code> or <code>add_output()</code>, which accept only the appropriate <code>Input</code> or <code>Output</code> classes. The resulting value is stored as a member variable with the name specified (if there is already a member with the given name, an exception is thrown).</p>
<h3><a class="anchor" id="calling-a-generator-directly"></a>
Calling a Generator Directly</h3>
<p>Each Generator has a class method (injected by <code>@hl.generator</code>) that allows you to "call" the Generator like an ordinary function; this allows you to directly take the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR produced by the Generator and do anything you want to with it. This can be especially useful when writing library code, as you can 'compose' more complex pipelines this way.</p>
<p>This method is named <code>call()</code> and looks like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@classmethod</span></div>
<div class="line"><span class="keyword">def </span>call(cls, *args, **kwargs):</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>It takes the inputs (specified either by-name or by-position in the usual Python way). It also allows for an optional by-name-only argument, <code>generator_params</code>, which is a simple Python dict that allows for overriding <code>GeneratorParam</code>s. It returns a tuple of the Output values. For the earlier example, usage might be something like:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> LogicalOpFilter</div>
<div class="line"> </div>
<div class="line">x, y = hl.Var(), hl.Var()</div>
<div class="line"> </div>
<div class="line">input_buf = hl.Buffer(hl.UInt(8), [2, 2])</div>
<div class="line">mask_value = 0x7f</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Inputs by-position</span></div>
<div class="line">func_out = LogicalOpFilter.call(input_buf, mask_value)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Inputs by-name</span></div>
<div class="line">func_out = LogicalOpFilter.call(mask=mask_value, input=input_buf)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Above again, but with generator_params</span></div>
<div class="line">func_out = LogicalOpFilter.call(input_buf, mask_value,</div>
<div class="line">                                generator_params={<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;and&quot;</span>})</div>
<div class="line">func_out = LogicalOpFilter.call(generator_params={<span class="stringliteral">&quot;op&quot;</span>: <span class="stringliteral">&quot;and&quot;</span>},</div>
<div class="line">                                input=input_buf, mask=mask_value)</div>
</div><!-- fragment --><h3><a class="anchor" id="the-lifecycle-of-a-generator"></a>
The Lifecycle Of A Generator</h3>
<p>Whether being driven by a build system (for AOT use) or by another piece of Python code (typically for JIT use), the lifecycle of a Generator looks something like this:</p>
<ul>
<li>An instance of the Generator in question is created. It uses the currently-active <code>GeneratorContext</code> (which contains the <code>Target</code> to be used for code generation), which is stored in a thread-local stack.</li>
<li>Some (or all) of the default values of the <code>GeneratorParam</code> members may be replaced based on (e.g.) command-line arguments in the build system</li>
<li>All <code>GeneratorParam</code> members are made immutable.</li>
<li>The <code>configure()</code> method is called, allowing the Generator to use <code>add_input()</code> or <code>add_output()</code> to dynamically add inputs and/or outputs.</li>
<li>If any <code>Input</code> or <code>Output</code> members were defined with unspecified type or dimensions (e.g. <code>some_input = hl.InputBuffer(None, 3)</code>), those types and dimensions are filled in from <code>GeneratorParam</code> values (e.g. <code>some_input.type</code> in this case). If any types or dimensions are left unspecified after this step, an exception will be thrown.</li>
<li>If the Generator is being invoked via its <code>call()</code> method (see below), the default values for <code>Inputs</code> will be replaced by the values from the argument list.</li>
<li>The Generator instance has its <code>generate()</code> method called.</li>
<li>The calling code will extract the values of all <code>Output</code> values and validate that they match the type, dimensions, etc. of the declarations.</li>
<li>The calling code will then either call <code>compile_to_file()</code> and friends (for AOT use), or return the output values to the caller (for JIT use).</li>
<li>Finally, the Generator instance will be discarded, never to be used again.</li>
</ul>
<p>Note that almost all the code doing the hand-wavy bits above is injected by the <code>@hl.generator</code> decorator – the Generator author doesn't need to know or care about the specific details, only that they happen.</p>
<p>All <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Generators are <b>single-use</b> instances – that is, any given Generator instance should be used at most once. If a Generator is to be executed multiple times (e.g. for different <code>GeneratorParam</code> values, or a different <code>Target</code>), a new one must be constructed each time.</p>
<h3><a class="anchor" id="notable-differences-between-c-and-python-generators"></a>
Notable Differences Between C++ and Python Generators</h3>
<p>If you have written C++ Generators in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> in the past, you might notice some features are missing and/or different for Python Generators. Among the differences are:</p>
<ul>
<li>In C++, you can create a Generator, then call <code>set_generatorparam_value()</code> to alter the values of GeneratorParams. In Python, there is no public method to alter a GeneratorParam after the Generator is created; instead, you must pass a dict of GeneratorParam values to the constructor, after which the values are immutable for that Generator instance.</li>
<li>Array Inputs/Outputs: in our experience, they are pretty rarely used, it complicates the implementation in nontrivial ways, and the majority of use cases for them can all be reasonably supported by dynamically adding inputs or outputs (and saving the results in a local array).</li>
<li><code>Input&lt;Func&gt;</code> and <code>Output&lt;Func&gt;</code>: these were deliberately left out in order to simplify Python Generators. It's possible that something similar might be added in the future.</li>
<li>GeneratorParams with LoopLevel types: these aren't useful without <code>Input&lt;Func&gt;</code>/<code>Output&lt;Func&gt;</code>.</li>
<li>GeneratorParams with Enum types: using a plain <code>str</code> type in Python is arguably just as easy, if not easier.</li>
<li><code>get_externs_map()</code>: this allows registering ExternalCode objects to be appended to the Generator's code. In our experience, this feature is very rarely used. We will consider adding this in the future if necessary.</li>
<li>Lazy Binding of Unspecified Input/Output Types: for C++ Generators, if you left an Output's type (or dimensionality) unspecified, you didn't always have to specify a <code>GeneratorParam</code> to make it into a concrete type: if the type was always fully specified by the contents of the <code>generate()</code> method, that was good enough. In Python Generators, by contrast, <b>all</b> types and dimensions must be <b>explicitly</b> specified by either code declaration or by <code>GeneratorParam</code> setting. This simplifies the internal code in nontrivial ways, and also allows for (arguably) more readable code, since there are no longer cases that require the reader to execute the code in their head in order to deduce the output types.</li>
</ul>
<h1><a class="anchor" id="keeping-up-to-date"></a>
Keeping Up To Date</h1>
<p>If you use the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Bindings for Python inside Google, you are <em>strongly</em> encouraged to <a href="https://github.blog/changelog/2018-11-27-watch-releases/">subscribe to announcements for new releases of Halide</a>, as it is likely that enhancements and tweaks to our Python support will be made in future releases.</p>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>The Python bindings use the same <a href="https://github.com/halide/Halide/blob/main/LICENSE.txt">MIT license</a> as <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.</p>
<p>Python bindings provided by Connelly Barnes (2012-2013), Fred Rotbart (2014), Rodrigo Benenson (2015) and the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> open-source community. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
