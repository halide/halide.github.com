<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::CodeGen_LLVM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Halide::Internal::CodeGen_LLVM Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A code generator abstract base class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Halide::Internal::CodeGen_LLVM:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.png" usemap="#Halide::Internal::CodeGen_5FLLVM_map" alt=""/>
  <map id="Halide::Internal::CodeGen_5FLLVM_map" name="Halide::Internal::CodeGen_5FLLVM_map">
<area href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR." alt="Halide::Internal::IRVisitor" shape="rect" coords="0,0,196,24"/>
<area href="class_halide_1_1_internal_1_1_code_gen___posix.html" title="A code generator that emits posix code from a given Halide stmt." alt="Halide::Internal::CodeGen_Posix" shape="rect" coords="0,112,196,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_all_enabled_mask.html">AllEnabledMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> indicating mask to use is all true &ndash; all lanes enabled.  <a href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_all_enabled_mask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_intrinsic.html">Intrinsic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of an intrinsic function overload.  <a href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_intrinsic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_no_mask.html">NoMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> indicating an intrinsic does not take a mask.  <a href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_no_mask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_arg.html">VPArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for generating LLVM vector predication intrinsics ("@llvm.vp.*" and "@llvm.experimental.vp.*")  <a href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_result_type.html">VPResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2504b90dbc9307972e48a6dfc45e0dc6" id="r_a2504b90dbc9307972e48a6dfc45e0dc6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2504b90dbc9307972e48a6dfc45e0dc6">compile</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;<a class="el" href="#a4f28718479886e14dace03ce3a4e96d4">module</a>)</td></tr>
<tr class="memdesc:a2504b90dbc9307972e48a6dfc45e0dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> and compiles it to an llvm <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a>.  <br /></td></tr>
<tr class="separator:a2504b90dbc9307972e48a6dfc45e0dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b610bac31c788b13ccaa47bd503fb15" id="r_a1b610bac31c788b13ccaa47bd503fb15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b610bac31c788b13ccaa47bd503fb15">get_target</a> () const</td></tr>
<tr class="memdesc:a1b610bac31c788b13ccaa47bd503fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target we're generating code for.  <br /></td></tr>
<tr class="separator:a1b610bac31c788b13ccaa47bd503fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb5afade2ec4699febb51055bb8a85b" id="r_abfb5afade2ec4699febb51055bb8a85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfb5afade2ec4699febb51055bb8a85b">set_context</a> (llvm::LLVMContext &amp;<a class="el" href="#a877b0f3d432ba326f51974e5861c20de">context</a>)</td></tr>
<tr class="memdesc:abfb5afade2ec4699febb51055bb8a85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the code generator which LLVM context to use.  <br /></td></tr>
<tr class="separator:abfb5afade2ec4699febb51055bb8a85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf436556e94fd28dee1106129b25f66b" id="r_aaf436556e94fd28dee1106129b25f66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf436556e94fd28dee1106129b25f66b">get_requested_alloca_total</a> () const</td></tr>
<tr class="separator:aaf436556e94fd28dee1106129b25f66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_halide_1_1_internal_1_1_i_r_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_halide_1_1_internal_1_1_i_r_visitor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">Halide::Internal::IRVisitor</a></td></tr>
<tr class="memitem:ab54da35467fd78e42f63a6536c93cf16 inherit pub_methods_class_halide_1_1_internal_1_1_i_r_visitor" id="r_ab54da35467fd78e42f63a6536c93cf16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ab54da35467fd78e42f63a6536c93cf16">IRVisitor</a> ()=default</td></tr>
<tr class="separator:ab54da35467fd78e42f63a6536c93cf16 inherit pub_methods_class_halide_1_1_internal_1_1_i_r_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa29ab9cd5d2dd7797b53e0782a4c9a inherit pub_methods_class_halide_1_1_internal_1_1_i_r_visitor" id="r_a3aa29ab9cd5d2dd7797b53e0782a4c9a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a3aa29ab9cd5d2dd7797b53e0782a4c9a">~IRVisitor</a> ()=default</td></tr>
<tr class="separator:a3aa29ab9cd5d2dd7797b53e0782a4c9a inherit pub_methods_class_halide_1_1_internal_1_1_i_r_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaf6baae83a8ac9c62df39855b2f90bf3" id="r_aaf6baae83a8ac9c62df39855b2f90bf3"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf6baae83a8ac9c62df39855b2f90bf3">new_for_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;<a class="el" href="#a47c0da8b30234e39d27645a522e91a10">target</a>, llvm::LLVMContext &amp;<a class="el" href="#a877b0f3d432ba326f51974e5861c20de">context</a>)</td></tr>
<tr class="memdesc:aaf6baae83a8ac9c62df39855b2f90bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html" title="A code generator abstract base class.">CodeGen_LLVM</a> suitable for the target.  <br /></td></tr>
<tr class="separator:aaf6baae83a8ac9c62df39855b2f90bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1cca67615cd6d7cab8eb0f2524a1f3" id="r_abb1cca67615cd6d7cab8eb0f2524a1f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb1cca67615cd6d7cab8eb0f2524a1f3">initialize_llvm</a> ()</td></tr>
<tr class="memdesc:abb1cca67615cd6d7cab8eb0f2524a1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize internal llvm state for the enabled targets.  <br /></td></tr>
<tr class="separator:abb1cca67615cd6d7cab8eb0f2524a1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b84ea5b04977108acb3b3fc3197c9a" id="r_a83b84ea5b04977108acb3b3fc3197c9a"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83b84ea5b04977108acb3b3fc3197c9a">compile_trampolines</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;<a class="el" href="#a47c0da8b30234e39d27645a522e91a10">target</a>, llvm::LLVMContext &amp;<a class="el" href="#a877b0f3d432ba326f51974e5861c20de">context</a>, const std::string &amp;suffix, const std::vector&lt; std::pair&lt; std::string, <a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a> &gt; &gt; &amp;externs)</td></tr>
<tr class="separator:a83b84ea5b04977108acb3b3fc3197c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a431585f4447c39d5639672baa5b1c5d2" id="r_a431585f4447c39d5639672baa5b1c5d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a431585f4447c39d5639672baa5b1c5d2">DestructorType</a> { <a class="el" href="#a431585f4447c39d5639672baa5b1c5d2a65f0774ca71b47cdb4461248276337b3">Always</a>
, <a class="el" href="#a431585f4447c39d5639672baa5b1c5d2aa8ffd1a2e243519844b054ec9eafe9c4">OnError</a>
, <a class="el" href="#a431585f4447c39d5639672baa5b1c5d2abf9677f74a723a3afef3f9c454652241">OnSuccess</a>
 }</td></tr>
<tr class="memdesc:a431585f4447c39d5639672baa5b1c5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some destructors should always be called.  <a href="#a431585f4447c39d5639672baa5b1c5d2">More...</a><br /></td></tr>
<tr class="separator:a431585f4447c39d5639672baa5b1c5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3f9a6a0b806dcb0517b4955aa0a625" id="r_a3f3f9a6a0b806dcb0517b4955aa0a625"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a> { <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625a4457d440870ad6d42bab9082d9bf9b61">Fixed</a>
, <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625aaeee1a772403b537e94b54141e896773">VScale</a>
 }</td></tr>
<tr class="memdesc:a3f3f9a6a0b806dcb0517b4955aa0a625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to abstract vector code generation as LLVM is now providing multiple options to express even simple vector operations.  <a href="#a3f3f9a6a0b806dcb0517b4955aa0a625">More...</a><br /></td></tr>
<tr class="separator:a3f3f9a6a0b806dcb0517b4955aa0a625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7e186e1aee1d0a313f7a7c89a58909" id="r_a7b7e186e1aee1d0a313f7a7c89a58909"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b7e186e1aee1d0a313f7a7c89a58909">WarningKind</a> { <a class="el" href="#a7b7e186e1aee1d0a313f7a7c89a58909a2070d00a39208a5d118ae721ac330627">EmulatedFloat16</a>
 }</td></tr>
<tr class="memdesc:a7b7e186e1aee1d0a313f7a7c89a58909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warning messages which we want to avoid displaying number of times.  <a href="#a7b7e186e1aee1d0a313f7a7c89a58909">More...</a><br /></td></tr>
<tr class="separator:a7b7e186e1aee1d0a313f7a7c89a58909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc056cd4cc8139292ae7268200101c0" id="r_acfc056cd4cc8139292ae7268200101c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfc056cd4cc8139292ae7268200101c0">MaskVariant</a> = std::variant&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_no_mask.html">NoMask</a>, <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_all_enabled_mask.html">AllEnabledMask</a>, llvm::Value *&gt;</td></tr>
<tr class="memdesc:acfc056cd4cc8139292ae7268200101c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predication mask using the above two types for special cases and an llvm::Value for the general one.  <br /></td></tr>
<tr class="separator:acfc056cd4cc8139292ae7268200101c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab3d1bfcb39456d2f7f1f26086fe060fb" id="r_ab3d1bfcb39456d2f7f1f26086fe060fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3d1bfcb39456d2f7f1f26086fe060fb">CodeGen_LLVM</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="separator:ab3d1bfcb39456d2f7f1f26086fe060fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842edc53337047c5e27411a19e972068" id="r_a842edc53337047c5e27411a19e972068"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842edc53337047c5e27411a19e972068">compile_func</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;func, const std::string &amp;simple_name, const std::string &amp;extern_name)</td></tr>
<tr class="memdesc:a842edc53337047c5e27411a19e972068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a specific halide declaration into the llvm <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a>.  <br /></td></tr>
<tr class="separator:a842edc53337047c5e27411a19e972068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f2a5c9fc207720ddeba3aca40f1ca" id="r_a540f2a5c9fc207720ddeba3aca40f1ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a540f2a5c9fc207720ddeba3aca40f1ca">compile_buffer</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;buffer)</td></tr>
<tr class="separator:a540f2a5c9fc207720ddeba3aca40f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49489320b60f11049eff0233275fa95e" id="r_a49489320b60f11049eff0233275fa95e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49489320b60f11049eff0233275fa95e">begin_func</a> (<a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> linkage, const std::string &amp;simple_name, const std::string &amp;extern_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a49489320b60f11049eff0233275fa95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for compiling <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions to llvm functions.  <br /></td></tr>
<tr class="separator:a49489320b60f11049eff0233275fa95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0ccda984bec742a4f3ee92e0e808c" id="r_a06d0ccda984bec742a4f3ee92e0e808c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d0ccda984bec742a4f3ee92e0e808c">end_func</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a> &gt; &amp;args)</td></tr>
<tr class="separator:a06d0ccda984bec742a4f3ee92e0e808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5228a19eb5823cadb067817664865d7c" id="r_a5228a19eb5823cadb067817664865d7c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5228a19eb5823cadb067817664865d7c">mcpu_target</a> () const =0</td></tr>
<tr class="memdesc:a5228a19eb5823cadb067817664865d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">What should be passed as -mcpu (warning: implies attrs!), -mattrs, and related for compilation.  <br /></td></tr>
<tr class="separator:a5228a19eb5823cadb067817664865d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3d15a06f19c7e251c2e351c23ac432" id="r_a2c3d15a06f19c7e251c2e351c23ac432"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3d15a06f19c7e251c2e351c23ac432">mcpu_tune</a> () const =0</td></tr>
<tr class="separator:a2c3d15a06f19c7e251c2e351c23ac432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33728361cfc0b827fa72f11b8207247" id="r_ae33728361cfc0b827fa72f11b8207247"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33728361cfc0b827fa72f11b8207247">mattrs</a> () const =0</td></tr>
<tr class="separator:ae33728361cfc0b827fa72f11b8207247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6493faac2bb44fd9c5b4a0257a4034" id="r_a9c6493faac2bb44fd9c5b4a0257a4034"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c6493faac2bb44fd9c5b4a0257a4034">mabi</a> () const</td></tr>
<tr class="separator:a9c6493faac2bb44fd9c5b4a0257a4034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d73057374d80eab5f601a7d6de184" id="r_a9b3d73057374d80eab5f601a7d6de184"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3d73057374d80eab5f601a7d6de184">use_soft_float_abi</a> () const =0</td></tr>
<tr class="separator:a9b3d73057374d80eab5f601a7d6de184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c4bd1496b0492ad671c82b3a15bc16" id="r_aa6c4bd1496b0492ad671c82b3a15bc16"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6c4bd1496b0492ad671c82b3a15bc16">use_pic</a> () const</td></tr>
<tr class="separator:aa6c4bd1496b0492ad671c82b3a15bc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555842c7a0f8c36b2911e8b88348e3fa" id="r_a555842c7a0f8c36b2911e8b88348e3fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a555842c7a0f8c36b2911e8b88348e3fa">promote_indices</a> () const</td></tr>
<tr class="memdesc:a555842c7a0f8c36b2911e8b88348e3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should indexing math be promoted to 64-bit on platforms with 64-bit pointers?  <br /></td></tr>
<tr class="separator:a555842c7a0f8c36b2911e8b88348e3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6b29eb2ab4da0c72521e2fe901fe10" id="r_a7d6b29eb2ab4da0c72521e2fe901fe10"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d6b29eb2ab4da0c72521e2fe901fe10">native_vector_bits</a> () const =0</td></tr>
<tr class="memdesc:a7d6b29eb2ab4da0c72521e2fe901fe10"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the natural vector bit-width to use for loads, stores, etc.  <br /></td></tr>
<tr class="separator:a7d6b29eb2ab4da0c72521e2fe901fe10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbf2f0f34c03dc2a5c44a56a76c969f" id="r_a0bbf2f0f34c03dc2a5c44a56a76c969f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bbf2f0f34c03dc2a5c44a56a76c969f">maximum_vector_bits</a> () const</td></tr>
<tr class="memdesc:a0bbf2f0f34c03dc2a5c44a56a76c969f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to decide whether to break a vector up into multiple smaller operations.  <br /></td></tr>
<tr class="separator:a0bbf2f0f34c03dc2a5c44a56a76c969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1274feff0da89ba7c3c73d699e62b488" id="r_a1274feff0da89ba7c3c73d699e62b488"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1274feff0da89ba7c3c73d699e62b488">target_vscale</a> () const</td></tr>
<tr class="memdesc:a1274feff0da89ba7c3c73d699e62b488"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> architectures that have vscale vectors, return the constant vscale to use.  <br /></td></tr>
<tr class="separator:a1274feff0da89ba7c3c73d699e62b488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72048e9e69af328a3157680d7f937a65" id="r_a72048e9e69af328a3157680d7f937a65"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72048e9e69af328a3157680d7f937a65">upgrade_type_for_arithmetic</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;) const</td></tr>
<tr class="memdesc:a72048e9e69af328a3157680d7f937a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type in which arithmetic should be done for the given storage type.  <br /></td></tr>
<tr class="separator:a72048e9e69af328a3157680d7f937a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678a1a20460795f63ba7cc4fe3e01a03" id="r_a678a1a20460795f63ba7cc4fe3e01a03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678a1a20460795f63ba7cc4fe3e01a03">upgrade_type_for_storage</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;) const</td></tr>
<tr class="memdesc:a678a1a20460795f63ba7cc4fe3e01a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type that a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> type should be stored/loaded from memory as.  <br /></td></tr>
<tr class="separator:a678a1a20460795f63ba7cc4fe3e01a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc5c70918fa44012a05d165c293d43b" id="r_aafc5c70918fa44012a05d165c293d43b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafc5c70918fa44012a05d165c293d43b">upgrade_type_for_argument_passing</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;) const</td></tr>
<tr class="memdesc:aafc5c70918fa44012a05d165c293d43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type that a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> type should be passed in and out of functions as.  <br /></td></tr>
<tr class="separator:aafc5c70918fa44012a05d165c293d43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103523cea9fc739ed24f3db6baeb722b" id="r_a103523cea9fc739ed24f3db6baeb722b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a103523cea9fc739ed24f3db6baeb722b">init_context</a> ()</td></tr>
<tr class="memdesc:a103523cea9fc739ed24f3db6baeb722b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab all the context specific internal state.  <br /></td></tr>
<tr class="separator:a103523cea9fc739ed24f3db6baeb722b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a02e24b44e3de6f0af6cc0bc7dbd2a" id="r_ae1a02e24b44e3de6f0af6cc0bc7dbd2a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1a02e24b44e3de6f0af6cc0bc7dbd2a">init_module</a> ()</td></tr>
<tr class="memdesc:ae1a02e24b44e3de6f0af6cc0bc7dbd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html" title="A code generator abstract base class.">CodeGen_LLVM</a> internal state to compile a fresh module.  <br /></td></tr>
<tr class="separator:ae1a02e24b44e3de6f0af6cc0bc7dbd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d46a488247c117bb47647eca7b0530" id="r_ac5d46a488247c117bb47647eca7b0530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5d46a488247c117bb47647eca7b0530">optimize_module</a> ()</td></tr>
<tr class="memdesc:ac5d46a488247c117bb47647eca7b0530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run all of llvm's optimization passes on the module.  <br /></td></tr>
<tr class="separator:ac5d46a488247c117bb47647eca7b0530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e46a91aee2483099528aeb6249c9d17" id="r_a3e46a91aee2483099528aeb6249c9d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e46a91aee2483099528aeb6249c9d17">sym_push</a> (const std::string &amp;name, llvm::Value *<a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a>)</td></tr>
<tr class="memdesc:a3e46a91aee2483099528aeb6249c9d17"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> an entry to the symbol table, hiding previous entries with the same name.  <br /></td></tr>
<tr class="separator:a3e46a91aee2483099528aeb6249c9d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102cc4ef7189121091c5af1fef029c9f" id="r_a102cc4ef7189121091c5af1fef029c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a102cc4ef7189121091c5af1fef029c9f">sym_pop</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a102cc4ef7189121091c5af1fef029c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry for the symbol table, revealing any previous entries with the same name.  <br /></td></tr>
<tr class="separator:a102cc4ef7189121091c5af1fef029c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8a2f1f926591abd965a48685ee3f31" id="r_acb8a2f1f926591abd965a48685ee3f31"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb8a2f1f926591abd965a48685ee3f31">sym_get</a> (const std::string &amp;name, bool must_succeed=true) const</td></tr>
<tr class="memdesc:acb8a2f1f926591abd965a48685ee3f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an entry from the symbol table.  <br /></td></tr>
<tr class="separator:acb8a2f1f926591abd965a48685ee3f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24a38ec5ba1a09efad89f8691f5d62d" id="r_af24a38ec5ba1a09efad89f8691f5d62d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af24a38ec5ba1a09efad89f8691f5d62d">sym_exists</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:af24a38ec5ba1a09efad89f8691f5d62d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an item exists in the symbol table.  <br /></td></tr>
<tr class="separator:af24a38ec5ba1a09efad89f8691f5d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8431c25510b21a55c75ea1b1190597ae" id="r_a8431c25510b21a55c75ea1b1190597ae"><td class="memItemLeft" align="right" valign="top">llvm::FunctionType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8431c25510b21a55c75ea1b1190597ae">signature_to_type</a> (const <a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a> &amp;signature)</td></tr>
<tr class="memdesc:a8431c25510b21a55c75ea1b1190597ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a>, return the equivalent llvm::FunctionType.  <br /></td></tr>
<tr class="separator:a8431c25510b21a55c75ea1b1190597ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51f9d47922eed62e42c56b702b237e2" id="r_ac51f9d47922eed62e42c56b702b237e2"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac51f9d47922eed62e42c56b702b237e2">codegen</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:ac51f9d47922eed62e42c56b702b237e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that evaluates an expression, and return the llvm representation of the result of the expression.  <br /></td></tr>
<tr class="separator:ac51f9d47922eed62e42c56b702b237e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54099205473b83336ba6cd5b2465fa4a" id="r_a54099205473b83336ba6cd5b2465fa4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54099205473b83336ba6cd5b2465fa4a">codegen</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a54099205473b83336ba6cd5b2465fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that runs a statement.  <br /></td></tr>
<tr class="separator:a54099205473b83336ba6cd5b2465fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a34c216f3aa31e65c597220097cd82" id="r_aa8a34c216f3aa31e65c597220097cd82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8a34c216f3aa31e65c597220097cd82">scalarize</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:aa8a34c216f3aa31e65c597220097cd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codegen a vector <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> by codegenning each lane and combining.  <br /></td></tr>
<tr class="separator:aa8a34c216f3aa31e65c597220097cd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa3e1e579505927efc43d610288589" id="r_ac1fa3e1e579505927efc43d610288589"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1fa3e1e579505927efc43d610288589">register_destructor</a> (llvm::Function *destructor_fn, llvm::Value *obj, <a class="el" href="#a431585f4447c39d5639672baa5b1c5d2">DestructorType</a> when)</td></tr>
<tr class="separator:ac1fa3e1e579505927efc43d610288589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fb437fa2c7542aa213947a03dc20c3" id="r_a34fb437fa2c7542aa213947a03dc20c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34fb437fa2c7542aa213947a03dc20c3">trigger_destructor</a> (llvm::Function *destructor_fn, llvm::Value *stack_slot)</td></tr>
<tr class="memdesc:a34fb437fa2c7542aa213947a03dc20c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> a destructor early.  <br /></td></tr>
<tr class="separator:a34fb437fa2c7542aa213947a03dc20c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfea81a166f2b255147c00cd754de519" id="r_adfea81a166f2b255147c00cd754de519"><td class="memItemLeft" align="right" valign="top">llvm::BasicBlock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfea81a166f2b255147c00cd754de519">get_destructor_block</a> ()</td></tr>
<tr class="memdesc:adfea81a166f2b255147c00cd754de519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the block containing the error handling code.  <br /></td></tr>
<tr class="separator:adfea81a166f2b255147c00cd754de519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67868e18426144982ede1ecd5ec79dbe" id="r_a67868e18426144982ede1ecd5ec79dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67868e18426144982ede1ecd5ec79dbe">create_assertion</a> (llvm::Value *condition, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;message, llvm::Value *<a class="el" href="vulkan__resources_8h.html#a7d16b1c68c87cec009d972e79abfba78">error_code</a>=nullptr)</td></tr>
<tr class="memdesc:a67868e18426144982ede1ecd5ec79dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codegen an assertion.  <br /></td></tr>
<tr class="separator:a67868e18426144982ede1ecd5ec79dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad42fb0f33277ab0c10acb8fd7d80b65" id="r_aad42fb0f33277ab0c10acb8fd7d80b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad42fb0f33277ab0c10acb8fd7d80b65">codegen_asserts</a> (const std::vector&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a> * &gt; &amp;asserts)</td></tr>
<tr class="memdesc:aad42fb0f33277ab0c10acb8fd7d80b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codegen a block of asserts with pure conditions.  <br /></td></tr>
<tr class="separator:aad42fb0f33277ab0c10acb8fd7d80b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4e55909a6a1fad9110c9671d8002e2" id="r_a1d4e55909a6a1fad9110c9671d8002e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d4e55909a6a1fad9110c9671d8002e2">return_with_error_code</a> (llvm::Value *<a class="el" href="vulkan__resources_8h.html#a7d16b1c68c87cec009d972e79abfba78">error_code</a>)</td></tr>
<tr class="memdesc:a1d4e55909a6a1fad9110c9671d8002e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the the pipeline with the given error code.  <br /></td></tr>
<tr class="separator:a1d4e55909a6a1fad9110c9671d8002e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8611e28d9e28a8f4ad9b374b379829af" id="r_a8611e28d9e28a8f4ad9b374b379829af"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8611e28d9e28a8f4ad9b374b379829af">create_string_constant</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a8611e28d9e28a8f4ad9b374b379829af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a string constant in the module as a global variable and return a pointer to it.  <br /></td></tr>
<tr class="separator:a8611e28d9e28a8f4ad9b374b379829af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bdf6abc8b32c3e7ebf6e293594655f" id="r_a07bdf6abc8b32c3e7ebf6e293594655f"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07bdf6abc8b32c3e7ebf6e293594655f">create_binary_blob</a> (const std::vector&lt; char &gt; &amp;data, const std::string &amp;name, bool constant=true)</td></tr>
<tr class="memdesc:a07bdf6abc8b32c3e7ebf6e293594655f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a binary blob in the module as a global variable and return a pointer to it.  <br /></td></tr>
<tr class="separator:a07bdf6abc8b32c3e7ebf6e293594655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3dab69ec0a2fb55376e35632c43858" id="r_a4e3dab69ec0a2fb55376e35632c43858"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e3dab69ec0a2fb55376e35632c43858">create_broadcast</a> (llvm::Value *, int lanes)</td></tr>
<tr class="memdesc:a4e3dab69ec0a2fb55376e35632c43858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Widen an llvm scalar into an llvm vector with the given number of lanes.  <br /></td></tr>
<tr class="separator:a4e3dab69ec0a2fb55376e35632c43858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22fbf9ebe09b7fc5720c5000680e504" id="r_aa22fbf9ebe09b7fc5720c5000680e504"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa22fbf9ebe09b7fc5720c5000680e504">codegen_buffer_pointer</a> (const std::string &amp;buffer, <a class="el" href="struct_halide_1_1_type.html">Type</a> type, llvm::Value *index)</td></tr>
<tr class="memdesc:aa22fbf9ebe09b7fc5720c5000680e504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pointer into a named buffer at a given index, of a given type.  <br /></td></tr>
<tr class="separator:aa22fbf9ebe09b7fc5720c5000680e504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25321b123adfe0419f330cc8c621e314" id="r_a25321b123adfe0419f330cc8c621e314"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25321b123adfe0419f330cc8c621e314">codegen_buffer_pointer</a> (const std::string &amp;buffer, <a class="el" href="struct_halide_1_1_type.html">Type</a> type, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> index)</td></tr>
<tr class="separator:a25321b123adfe0419f330cc8c621e314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a28e726b99f1059bddfe75c5ad6ce" id="r_ac74a28e726b99f1059bddfe75c5ad6ce"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac74a28e726b99f1059bddfe75c5ad6ce">codegen_buffer_pointer</a> (llvm::Value *base_address, <a class="el" href="struct_halide_1_1_type.html">Type</a> type, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> index)</td></tr>
<tr class="separator:ac74a28e726b99f1059bddfe75c5ad6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce049528d7c5cb70e7bbde906216c2e" id="r_a3ce049528d7c5cb70e7bbde906216c2e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ce049528d7c5cb70e7bbde906216c2e">codegen_buffer_pointer</a> (llvm::Value *base_address, <a class="el" href="struct_halide_1_1_type.html">Type</a> type, llvm::Value *index)</td></tr>
<tr class="separator:a3ce049528d7c5cb70e7bbde906216c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f70b9db0fb2c148635730704a7846e2" id="r_a9f70b9db0fb2c148635730704a7846e2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f70b9db0fb2c148635730704a7846e2">mangle_llvm_type</a> (llvm::Type *type)</td></tr>
<tr class="memdesc:a9f70b9db0fb2c148635730704a7846e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type string for LLVM type using LLVM IR intrinsic type mangling.  <br /></td></tr>
<tr class="separator:a9f70b9db0fb2c148635730704a7846e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f79b17cb7dc1875476ba83ca5d0015" id="r_ab9f79b17cb7dc1875476ba83ca5d0015"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f79b17cb7dc1875476ba83ca5d0015">make_halide_type_t</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;)</td></tr>
<tr class="memdesc:ab9f79b17cb7dc1875476ba83ca5d0015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> into an llvm::Value representing a constant <a class="el" href="structhalide__type__t.html" title="A runtime tag for a type in the halide type system.">halide_type_t</a>.  <br /></td></tr>
<tr class="separator:ab9f79b17cb7dc1875476ba83ca5d0015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c07d83cbb6f29b7753bd8ad41da6ac" id="r_aa5c07d83cbb6f29b7753bd8ad41da6ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5c07d83cbb6f29b7753bd8ad41da6ac">add_tbaa_metadata</a> (llvm::Instruction *inst, std::string buffer, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;index)</td></tr>
<tr class="memdesc:aa5c07d83cbb6f29b7753bd8ad41da6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a load or store with type-based-alias-analysis metadata so that llvm knows it can reorder loads and stores across different buffers.  <br /></td></tr>
<tr class="separator:aa5c07d83cbb6f29b7753bd8ad41da6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c6992af87f6076d29644ae6885e86b" id="r_a97c6992af87f6076d29644ae6885e86b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c6992af87f6076d29644ae6885e86b">get_allocation_name</a> (const std::string &amp;n)</td></tr>
<tr class="memdesc:a97c6992af87f6076d29644ae6885e86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unique name for the actual block of memory that an allocate node uses.  <br /></td></tr>
<tr class="separator:a97c6992af87f6076d29644ae6885e86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c4f607250525b19bd9e1d2b5bd6515" id="r_ad9c4f607250525b19bd9e1d2b5bd6515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c4f607250525b19bd9e1d2b5bd6515">function_does_not_access_memory</a> (llvm::Function *fn)</td></tr>
<tr class="memdesc:ad9c4f607250525b19bd9e1d2b5bd6515"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> the appropriate function attribute to tell LLVM that the function doesn't access memory.  <br /></td></tr>
<tr class="separator:ad9c4f607250525b19bd9e1d2b5bd6515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6be7d801b1c3ae8899b6afc4c233ff1" id="r_ad6be7d801b1c3ae8899b6afc4c233ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6be7d801b1c3ae8899b6afc4c233ff1">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a> *) override</td></tr>
<tr class="memdesc:ad6be7d801b1c3ae8899b6afc4c233ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code for various IR nodes.  <br /></td></tr>
<tr class="separator:ad6be7d801b1c3ae8899b6afc4c233ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0437b1914fa6876bbe31c919e3651c" id="r_afa0437b1914fa6876bbe31c919e3651c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa0437b1914fa6876bbe31c919e3651c">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html">UIntImm</a> *) override</td></tr>
<tr class="separator:afa0437b1914fa6876bbe31c919e3651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b0665827fbf21713f835301c2662e5" id="r_ad6b0665827fbf21713f835301c2662e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6b0665827fbf21713f835301c2662e5">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a> *) override</td></tr>
<tr class="separator:ad6b0665827fbf21713f835301c2662e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab70d995e94fae105f05720babe3e61f" id="r_aab70d995e94fae105f05720babe3e61f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab70d995e94fae105f05720babe3e61f">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a> *) override</td></tr>
<tr class="separator:aab70d995e94fae105f05720babe3e61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39d72c53c2bf3bf9bf813c0fd4daee6" id="r_ab39d72c53c2bf3bf9bf813c0fd4daee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab39d72c53c2bf3bf9bf813c0fd4daee6">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a> *) override</td></tr>
<tr class="separator:ab39d72c53c2bf3bf9bf813c0fd4daee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdfd1f75dfa3abea6006c25c83631a5" id="r_a3bdfd1f75dfa3abea6006c25c83631a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bdfd1f75dfa3abea6006c25c83631a5">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_reinterpret.html">Reinterpret</a> *) override</td></tr>
<tr class="separator:a3bdfd1f75dfa3abea6006c25c83631a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e487141d83fda347874c102904bc2d7" id="r_a5e487141d83fda347874c102904bc2d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e487141d83fda347874c102904bc2d7">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a> *) override</td></tr>
<tr class="separator:a5e487141d83fda347874c102904bc2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e7abe108d9e092cafbb04cfb8f7712" id="r_af4e7abe108d9e092cafbb04cfb8f7712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4e7abe108d9e092cafbb04cfb8f7712">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a> *) override</td></tr>
<tr class="separator:af4e7abe108d9e092cafbb04cfb8f7712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc6ff2a8e9de4611c47e7a94a4e8e1f" id="r_a3dc6ff2a8e9de4611c47e7a94a4e8e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dc6ff2a8e9de4611c47e7a94a4e8e1f">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a> *) override</td></tr>
<tr class="separator:a3dc6ff2a8e9de4611c47e7a94a4e8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159efa721a3eca0acbfadd8c453bbc86" id="r_a159efa721a3eca0acbfadd8c453bbc86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a159efa721a3eca0acbfadd8c453bbc86">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a> *) override</td></tr>
<tr class="separator:a159efa721a3eca0acbfadd8c453bbc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fd0c7dffaf8adcb0ce26c5b14055f7" id="r_a77fd0c7dffaf8adcb0ce26c5b14055f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77fd0c7dffaf8adcb0ce26c5b14055f7">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a> *) override</td></tr>
<tr class="separator:a77fd0c7dffaf8adcb0ce26c5b14055f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81cd4be6209bbbaf477d452ba3a41af" id="r_ab81cd4be6209bbbaf477d452ba3a41af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81cd4be6209bbbaf477d452ba3a41af">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a> *) override</td></tr>
<tr class="separator:ab81cd4be6209bbbaf477d452ba3a41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c41a23b6ca803904e0e3d25f79ba913" id="r_a3c41a23b6ca803904e0e3d25f79ba913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c41a23b6ca803904e0e3d25f79ba913">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a> *) override</td></tr>
<tr class="separator:a3c41a23b6ca803904e0e3d25f79ba913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5241a4fc6590c660621cdcd3a6b37101" id="r_a5241a4fc6590c660621cdcd3a6b37101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5241a4fc6590c660621cdcd3a6b37101">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a> *) override</td></tr>
<tr class="separator:a5241a4fc6590c660621cdcd3a6b37101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2594e9ec81b3ba791f8d8cc1f582ec" id="r_a7c2594e9ec81b3ba791f8d8cc1f582ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2594e9ec81b3ba791f8d8cc1f582ec">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a> *) override</td></tr>
<tr class="separator:a7c2594e9ec81b3ba791f8d8cc1f582ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa402a5a6b2998cf3ff9a343b507c28a2" id="r_aa402a5a6b2998cf3ff9a343b507c28a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa402a5a6b2998cf3ff9a343b507c28a2">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a> *) override</td></tr>
<tr class="separator:aa402a5a6b2998cf3ff9a343b507c28a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e833a4d35f85c21cc9ac6bbdbe374" id="r_acf9e833a4d35f85c21cc9ac6bbdbe374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9e833a4d35f85c21cc9ac6bbdbe374">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a> *) override</td></tr>
<tr class="separator:acf9e833a4d35f85c21cc9ac6bbdbe374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cebb5d4b80543155cf06d3f68f18cf" id="r_aa0cebb5d4b80543155cf06d3f68f18cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0cebb5d4b80543155cf06d3f68f18cf">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a> *) override</td></tr>
<tr class="separator:aa0cebb5d4b80543155cf06d3f68f18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1294b9a1320d4efe965cf524681aee4" id="r_ab1294b9a1320d4efe965cf524681aee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1294b9a1320d4efe965cf524681aee4">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a> *) override</td></tr>
<tr class="separator:ab1294b9a1320d4efe965cf524681aee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e33f468f9c83e0a845621d42489450" id="r_a59e33f468f9c83e0a845621d42489450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59e33f468f9c83e0a845621d42489450">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a> *) override</td></tr>
<tr class="separator:a59e33f468f9c83e0a845621d42489450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e5dadb48781d6c4f260096247d58fc" id="r_aa5e5dadb48781d6c4f260096247d58fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e5dadb48781d6c4f260096247d58fc">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a> *) override</td></tr>
<tr class="separator:aa5e5dadb48781d6c4f260096247d58fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cde0537b0d95684cd117f7afa57bee3" id="r_a0cde0537b0d95684cd117f7afa57bee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cde0537b0d95684cd117f7afa57bee3">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a> *) override</td></tr>
<tr class="separator:a0cde0537b0d95684cd117f7afa57bee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1cc5d28d68fecc8dc5839f9b335ac1" id="r_a3d1cc5d28d68fecc8dc5839f9b335ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d1cc5d28d68fecc8dc5839f9b335ac1">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a> *) override</td></tr>
<tr class="separator:a3d1cc5d28d68fecc8dc5839f9b335ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab426e2ffbab5e4d24e1db29a563e2f" id="r_a0ab426e2ffbab5e4d24e1db29a563e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ab426e2ffbab5e4d24e1db29a563e2f">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a> *) override</td></tr>
<tr class="separator:a0ab426e2ffbab5e4d24e1db29a563e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb37970fafc7e161950ab98a16d458d" id="r_acfb37970fafc7e161950ab98a16d458d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfb37970fafc7e161950ab98a16d458d">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a> *) override</td></tr>
<tr class="separator:acfb37970fafc7e161950ab98a16d458d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f58d86c4686df1287c117752a7302c" id="r_ab3f58d86c4686df1287c117752a7302c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f58d86c4686df1287c117752a7302c">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a> *) override</td></tr>
<tr class="separator:ab3f58d86c4686df1287c117752a7302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a3df69e81eae2fcb16e293e992c23" id="r_ab78a3df69e81eae2fcb16e293e992c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab78a3df69e81eae2fcb16e293e992c23">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a> *) override</td></tr>
<tr class="separator:ab78a3df69e81eae2fcb16e293e992c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf44187968b3f2d06b32a219d5e91af" id="r_abaf44187968b3f2d06b32a219d5e91af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf44187968b3f2d06b32a219d5e91af">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *) override</td></tr>
<tr class="separator:abaf44187968b3f2d06b32a219d5e91af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1e0751c39ee0982c5abc7cdf94ece" id="r_a01a1e0751c39ee0982c5abc7cdf94ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a1e0751c39ee0982c5abc7cdf94ece">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a> *) override</td></tr>
<tr class="separator:a01a1e0751c39ee0982c5abc7cdf94ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaa6cad821f79dd4cfc9313a9df1ba7" id="r_afaaa6cad821f79dd4cfc9313a9df1ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaaa6cad821f79dd4cfc9313a9df1ba7">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a> *) override</td></tr>
<tr class="separator:afaaa6cad821f79dd4cfc9313a9df1ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db1e694735abbcbffd69ea52b7b3c0b" id="r_a0db1e694735abbcbffd69ea52b7b3c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db1e694735abbcbffd69ea52b7b3c0b">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a> *) override</td></tr>
<tr class="separator:a0db1e694735abbcbffd69ea52b7b3c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf2b65f2a3e188939deee35ad7cbbe1" id="r_acbf2b65f2a3e188939deee35ad7cbbe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbf2b65f2a3e188939deee35ad7cbbe1">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_producer_consumer.html">ProducerConsumer</a> *) override</td></tr>
<tr class="separator:acbf2b65f2a3e188939deee35ad7cbbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5d31e6bd523189474c784cc2845f9d" id="r_a3c5d31e6bd523189474c784cc2845f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c5d31e6bd523189474c784cc2845f9d">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a> *) override</td></tr>
<tr class="separator:a3c5d31e6bd523189474c784cc2845f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0577638683640757e861d9b3e8fde3c" id="r_ac0577638683640757e861d9b3e8fde3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0577638683640757e861d9b3e8fde3c">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a> *) override</td></tr>
<tr class="separator:ac0577638683640757e861d9b3e8fde3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83db52caca7ab618661ca0f9ce196cb" id="r_af83db52caca7ab618661ca0f9ce196cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af83db52caca7ab618661ca0f9ce196cb">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a> *) override</td></tr>
<tr class="separator:af83db52caca7ab618661ca0f9ce196cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37d8e543796575154b0fbd858a50b04" id="r_ae37d8e543796575154b0fbd858a50b04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37d8e543796575154b0fbd858a50b04">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a> *) override</td></tr>
<tr class="separator:ae37d8e543796575154b0fbd858a50b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d62ca359f2c13797040ceb70b16c9" id="r_a9e0d62ca359f2c13797040ceb70b16c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e0d62ca359f2c13797040ceb70b16c9">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a> *) override</td></tr>
<tr class="separator:a9e0d62ca359f2c13797040ceb70b16c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b81f5c4e3a329c1882853c8e7375ec9" id="r_a6b81f5c4e3a329c1882853c8e7375ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b81f5c4e3a329c1882853c8e7375ec9">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_shuffle.html">Shuffle</a> *) override</td></tr>
<tr class="separator:a6b81f5c4e3a329c1882853c8e7375ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357edaf56bde8a99e72c2af5f914b50" id="r_ae357edaf56bde8a99e72c2af5f914b50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae357edaf56bde8a99e72c2af5f914b50">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html">VectorReduce</a> *) override</td></tr>
<tr class="separator:ae357edaf56bde8a99e72c2af5f914b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f63d40641f1ec5b47e159efe8233702" id="r_a6f63d40641f1ec5b47e159efe8233702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f63d40641f1ec5b47e159efe8233702">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_prefetch.html">Prefetch</a> *) override</td></tr>
<tr class="separator:a6f63d40641f1ec5b47e159efe8233702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bb25571f9302f0f012372b6f26dae4" id="r_a63bb25571f9302f0f012372b6f26dae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63bb25571f9302f0f012372b6f26dae4">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_atomic.html">Atomic</a> *) override</td></tr>
<tr class="separator:a63bb25571f9302f0f012372b6f26dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2a9f3073ef0976954acab5709172d2" id="r_a6d2a9f3073ef0976954acab5709172d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d2a9f3073ef0976954acab5709172d2">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a> *) override=0</td></tr>
<tr class="memdesc:a6d2a9f3073ef0976954acab5709172d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code for an allocate node.  <br /></td></tr>
<tr class="separator:a6d2a9f3073ef0976954acab5709172d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45e768152265f200176a81053ed7071" id="r_af45e768152265f200176a81053ed7071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af45e768152265f200176a81053ed7071">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a> *) override=0</td></tr>
<tr class="memdesc:af45e768152265f200176a81053ed7071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code for a free node.  <br /></td></tr>
<tr class="separator:af45e768152265f200176a81053ed7071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7023010280dfaf312ec65b6b51c85b47" id="r_a7023010280dfaf312ec65b6b51c85b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7023010280dfaf312ec65b6b51c85b47">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a> *) override</td></tr>
<tr class="memdesc:a7023010280dfaf312ec65b6b51c85b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">These IR nodes should have been removed during lowering.  <br /></td></tr>
<tr class="separator:a7023010280dfaf312ec65b6b51c85b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c68b59491d5f0d8f0da070981df26" id="r_ae34c68b59491d5f0d8f0da070981df26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34c68b59491d5f0d8f0da070981df26">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a> *) override</td></tr>
<tr class="separator:ae34c68b59491d5f0d8f0da070981df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d5ebe162c71eb494c82ddced408b1" id="r_a188d5ebe162c71eb494c82ddced408b1"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188d5ebe162c71eb494c82ddced408b1">llvm_type_of</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;) const</td></tr>
<tr class="memdesc:a188d5ebe162c71eb494c82ddced408b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to the given halide type in the current context.  <br /></td></tr>
<tr class="separator:a188d5ebe162c71eb494c82ddced408b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf1bd01240d5216be2096f7fc7fbd3f" id="r_aecf1bd01240d5216be2096f7fc7fbd3f"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf1bd01240d5216be2096f7fc7fbd3f">llvm_type_of</a> (llvm::LLVMContext *<a class="el" href="#a877b0f3d432ba326f51974e5861c20de">context</a>, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t, int effective_vscale) const</td></tr>
<tr class="memdesc:aecf1bd01240d5216be2096f7fc7fbd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <br /></td></tr>
<tr class="separator:aecf1bd01240d5216be2096f7fc7fbd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900b3ddc6397480ba5d20c24c8717377" id="r_a900b3ddc6397480ba5d20c24c8717377"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a900b3ddc6397480ba5d20c24c8717377">create_alloca_at_entry</a> (llvm::Type *type, int n, bool zero_initialize=false, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a900b3ddc6397480ba5d20c24c8717377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an alloca at the function entrypoint.  <br /></td></tr>
<tr class="separator:a900b3ddc6397480ba5d20c24c8717377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b36b542f6faf3467ef94ec4b75252a" id="r_ae1b36b542f6faf3467ef94ec4b75252a"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b36b542f6faf3467ef94ec4b75252a">get_user_context</a> () const</td></tr>
<tr class="memdesc:ae1b36b542f6faf3467ef94ec4b75252a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user_context argument.  <br /></td></tr>
<tr class="separator:ae1b36b542f6faf3467ef94ec4b75252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd88de3fefa17c44bfeb69b33d457fb" id="r_afdd88de3fefa17c44bfeb69b33d457fb"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd88de3fefa17c44bfeb69b33d457fb">interleave_vectors</a> (const std::vector&lt; llvm::Value * &gt; &amp;)</td></tr>
<tr class="memdesc:afdd88de3fefa17c44bfeb69b33d457fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the intrinsic call to interleave_vectors.  <br /></td></tr>
<tr class="separator:afdd88de3fefa17c44bfeb69b33d457fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaf4faaf1fb732b1ccd7f13798ea1be" id="r_aaeaf4faaf1fb732b1ccd7f13798ea1be"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaeaf4faaf1fb732b1ccd7f13798ea1be">get_llvm_intrin</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;ret_type, const std::string &amp;name, const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;arg_types, bool scalars_are_vectors=false)</td></tr>
<tr class="memdesc:aaeaf4faaf1fb732b1ccd7f13798ea1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an LLVM intrinsic declaration.  <br /></td></tr>
<tr class="separator:aaeaf4faaf1fb732b1ccd7f13798ea1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aad0e1592128e6804c3e484427bd534" id="r_a2aad0e1592128e6804c3e484427bd534"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aad0e1592128e6804c3e484427bd534">get_llvm_intrin</a> (llvm::Type *ret_type, const std::string &amp;name, const std::vector&lt; llvm::Type * &gt; &amp;arg_types)</td></tr>
<tr class="separator:a2aad0e1592128e6804c3e484427bd534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49ba65507c73d9ae7220029e1bb7c92" id="r_ad49ba65507c73d9ae7220029e1bb7c92"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad49ba65507c73d9ae7220029e1bb7c92">declare_intrin_overload</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;ret_type, const std::string &amp;impl_name, std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; arg_types, bool scalars_are_vectors=false)</td></tr>
<tr class="memdesc:ad49ba65507c73d9ae7220029e1bb7c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare an intrinsic function that participates in overload resolution.  <br /></td></tr>
<tr class="separator:ad49ba65507c73d9ae7220029e1bb7c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa787d195572d3fce6efa21778d907e" id="r_a5fa787d195572d3fce6efa21778d907e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fa787d195572d3fce6efa21778d907e">declare_intrin_overload</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;ret_type, llvm::Function *impl, std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; arg_types)</td></tr>
<tr class="separator:a5fa787d195572d3fce6efa21778d907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd65d081560b01f7a536f73d21198ea8" id="r_afd65d081560b01f7a536f73d21198ea8"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd65d081560b01f7a536f73d21198ea8">call_overloaded_intrin</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;result_type, const std::string &amp;name, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:afd65d081560b01f7a536f73d21198ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> an overloaded intrinsic function.  <br /></td></tr>
<tr class="separator:afd65d081560b01f7a536f73d21198ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add36168d60c735139c806ebf5431a3e4" id="r_add36168d60c735139c806ebf5431a3e4"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add36168d60c735139c806ebf5431a3e4">call_intrin</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t, int intrin_lanes, const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;)</td></tr>
<tr class="memdesc:add36168d60c735139c806ebf5431a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a call to a vector intrinsic or runtime inlined function.  <br /></td></tr>
<tr class="separator:add36168d60c735139c806ebf5431a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ffcc3c824fc0af67c4598ddfcf7bed" id="r_ac0ffcc3c824fc0af67c4598ddfcf7bed"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ffcc3c824fc0af67c4598ddfcf7bed">call_intrin</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t, int intrin_lanes, llvm::Function *intrin, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;)</td></tr>
<tr class="separator:ac0ffcc3c824fc0af67c4598ddfcf7bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2038326d14b19bbe4625b018889edb18" id="r_a2038326d14b19bbe4625b018889edb18"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2038326d14b19bbe4625b018889edb18">call_intrin</a> (const llvm::Type *t, int intrin_lanes, const std::string &amp;name, std::vector&lt; llvm::Value * &gt;, bool scalable_vector_result=false, bool is_reduction=false)</td></tr>
<tr class="separator:a2038326d14b19bbe4625b018889edb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a562ae91292dc37eae90110f78f86a" id="r_af1a562ae91292dc37eae90110f78f86a"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1a562ae91292dc37eae90110f78f86a">call_intrin</a> (const llvm::Type *t, int intrin_lanes, llvm::Function *intrin, std::vector&lt; llvm::Value * &gt;, bool is_reduction=false)</td></tr>
<tr class="separator:af1a562ae91292dc37eae90110f78f86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438abc50f4ba23d66278c97d2e1394b" id="r_ad438abc50f4ba23d66278c97d2e1394b"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad438abc50f4ba23d66278c97d2e1394b">slice_vector</a> (llvm::Value *vec, int start, int extent)</td></tr>
<tr class="memdesc:ad438abc50f4ba23d66278c97d2e1394b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a slice of lanes out of an llvm vector.  <br /></td></tr>
<tr class="separator:ad438abc50f4ba23d66278c97d2e1394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866a80ffd295c6876a8327d99888afe9" id="r_a866a80ffd295c6876a8327d99888afe9"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a866a80ffd295c6876a8327d99888afe9">concat_vectors</a> (const std::vector&lt; llvm::Value * &gt; &amp;)</td></tr>
<tr class="memdesc:a866a80ffd295c6876a8327d99888afe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a bunch of llvm vectors.  <br /></td></tr>
<tr class="separator:a866a80ffd295c6876a8327d99888afe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc33abd5ef0b3f06d768517e517117a6" id="r_acc33abd5ef0b3f06d768517e517117a6"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc33abd5ef0b3f06d768517e517117a6">shuffle_vectors</a> (llvm::Value *a, llvm::Value *b, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:acc33abd5ef0b3f06d768517e517117a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an LLVM shuffle vectors instruction.  <br /></td></tr>
<tr class="separator:acc33abd5ef0b3f06d768517e517117a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45e786fc70bfa450d0793bd96c7feb6" id="r_af45e786fc70bfa450d0793bd96c7feb6"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af45e786fc70bfa450d0793bd96c7feb6">shuffle_vectors</a> (llvm::Value *v, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:af45e786fc70bfa450d0793bd96c7feb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for shuffling a single vector.  <br /></td></tr>
<tr class="separator:af45e786fc70bfa450d0793bd96c7feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0550f2399fd4b99b09359217987511c9" id="r_a0550f2399fd4b99b09359217987511c9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; llvm::Function *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0550f2399fd4b99b09359217987511c9">find_vector_runtime_function</a> (const std::string &amp;name, int lanes)</td></tr>
<tr class="memdesc:a0550f2399fd4b99b09359217987511c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go looking for a vector version of a runtime function.  <br /></td></tr>
<tr class="separator:a0550f2399fd4b99b09359217987511c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16955a29a09bb79ab24c9953d3fb4b29" id="r_a16955a29a09bb79ab24c9953d3fb4b29"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16955a29a09bb79ab24c9953d3fb4b29">supports_atomic_add</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t) const</td></tr>
<tr class="separator:a16955a29a09bb79ab24c9953d3fb4b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab98b8eb6f60946158278712d9128d9b" id="r_aab98b8eb6f60946158278712d9128d9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab98b8eb6f60946158278712d9128d9b">codegen_vector_reduce</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html">VectorReduce</a> *op, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;init)</td></tr>
<tr class="memdesc:aab98b8eb6f60946158278712d9128d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a horizontal reduction that starts with an explicit initial value.  <br /></td></tr>
<tr class="separator:aab98b8eb6f60946158278712d9128d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b159c510f7bf7df8f72cd0716a3ae2" id="r_af9b159c510f7bf7df8f72cd0716a3ae2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b159c510f7bf7df8f72cd0716a3ae2">supports_call_as_float16</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *op) const</td></tr>
<tr class="memdesc:af9b159c510f7bf7df8f72cd0716a3ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can we call this operation with float16 type? This is used to avoid "emulated" equivalent code-gen in case target has FP16 feature.  <br /></td></tr>
<tr class="separator:af9b159c510f7bf7df8f72cd0716a3ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbde979880a7a68b15a53b6e31ed7c71" id="r_abbde979880a7a68b15a53b6e31ed7c71"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbde979880a7a68b15a53b6e31ed7c71">simple_call_intrin</a> (const std::string &amp;intrin, const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::Type *result_type)</td></tr>
<tr class="memdesc:abbde979880a7a68b15a53b6e31ed7c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">call_intrin does far too much to be useful and generally breaks things when one has carefully set things up for a specific architecture.  <br /></td></tr>
<tr class="separator:abbde979880a7a68b15a53b6e31ed7c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592b08166d80aafc4f6018be28ceea8" id="r_a7592b08166d80aafc4f6018be28ceea8"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7592b08166d80aafc4f6018be28ceea8">normalize_fixed_scalable_vector_type</a> (llvm::Type *desired_type, llvm::Value *result)</td></tr>
<tr class="memdesc:a7592b08166d80aafc4f6018be28ceea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that a vector value is either fixed or vscale depending to match desired_type.  <br /></td></tr>
<tr class="separator:a7592b08166d80aafc4f6018be28ceea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad384439fc88aa9e77cd3e08db13756f4" id="r_ad384439fc88aa9e77cd3e08db13756f4"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad384439fc88aa9e77cd3e08db13756f4">convert_fixed_or_scalable_vector_type</a> (llvm::Value *arg, llvm::Type *desired_type)</td></tr>
<tr class="memdesc:ad384439fc88aa9e77cd3e08db13756f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> between two LLVM vectors of potentially different scalable/fixed and size.  <br /></td></tr>
<tr class="separator:ad384439fc88aa9e77cd3e08db13756f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14e8ccbc3bb71669fdfe5e4f024416e" id="r_ab14e8ccbc3bb71669fdfe5e4f024416e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab14e8ccbc3bb71669fdfe5e4f024416e">fixed_to_scalable_vector_type</a> (llvm::Value *fixed)</td></tr>
<tr class="memdesc:ab14e8ccbc3bb71669fdfe5e4f024416e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> an LLVM fixed vector value to the corresponding vscale vector value.  <br /></td></tr>
<tr class="separator:ab14e8ccbc3bb71669fdfe5e4f024416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed469691cf4c94f02759a7e0b43b8f91" id="r_aed469691cf4c94f02759a7e0b43b8f91"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed469691cf4c94f02759a7e0b43b8f91">scalable_to_fixed_vector_type</a> (llvm::Value *scalable)</td></tr>
<tr class="memdesc:aed469691cf4c94f02759a7e0b43b8f91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> an LLVM vscale vector value to the corresponding fixed vector value.  <br /></td></tr>
<tr class="separator:aed469691cf4c94f02759a7e0b43b8f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac070eea2c1c9913134c9fc2e6766d0c6" id="r_ac070eea2c1c9913134c9fc2e6766d0c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac070eea2c1c9913134c9fc2e6766d0c6">get_vector_num_elements</a> (const llvm::Type *t)</td></tr>
<tr class="memdesc:ac070eea2c1c9913134c9fc2e6766d0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of vector elements, taking into account scalable vectors.  <br /></td></tr>
<tr class="separator:ac070eea2c1c9913134c9fc2e6766d0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7b86e371ef5afc01ec3edeaf9d885b" id="r_aff7b86e371ef5afc01ec3edeaf9d885b"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff7b86e371ef5afc01ec3edeaf9d885b">get_vector_type</a> (llvm::Type *, int n, <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a> type_constraint=<a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754">VectorTypeConstraint::None</a>) const</td></tr>
<tr class="separator:aff7b86e371ef5afc01ec3edeaf9d885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000b2c21660c4a28ae4c9a29717fd9ea" id="r_a000b2c21660c4a28ae4c9a29717fd9ea"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a000b2c21660c4a28ae4c9a29717fd9ea">get_splat</a> (int lanes, llvm::Constant *<a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a>, <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a> type_constraint=<a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754">VectorTypeConstraint::None</a>) const</td></tr>
<tr class="separator:a000b2c21660c4a28ae4c9a29717fd9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ad63a73d169c4a64598a09f987cc5e" id="r_af3ad63a73d169c4a64598a09f987cc5e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3ad63a73d169c4a64598a09f987cc5e">match_vector_type_scalable</a> (llvm::Value *<a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a>, <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a> constraint)</td></tr>
<tr class="memdesc:af3ad63a73d169c4a64598a09f987cc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure a value type has the same scalable/fixed vector type as a guide.  <br /></td></tr>
<tr class="separator:af3ad63a73d169c4a64598a09f987cc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c59288d36c086ef2040ca50e38c3d0" id="r_a80c59288d36c086ef2040ca50e38c3d0"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c59288d36c086ef2040ca50e38c3d0">match_vector_type_scalable</a> (llvm::Value *<a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a>, llvm::Type *guide)</td></tr>
<tr class="separator:a80c59288d36c086ef2040ca50e38c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c27113c71ab927042abb3fd4843d65" id="r_a94c27113c71ab927042abb3fd4843d65"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94c27113c71ab927042abb3fd4843d65">match_vector_type_scalable</a> (llvm::Value *<a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a>, llvm::Value *guide)</td></tr>
<tr class="separator:a94c27113c71ab927042abb3fd4843d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c03b2055c1269f84e95b1feba94d1" id="r_a495c03b2055c1269f84e95b1feba94d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495c03b2055c1269f84e95b1feba94d1">try_vector_predication_comparison</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;result_type, <a class="el" href="#acfc056cd4cc8139292ae7268200101c0">MaskVariant</a> mask, llvm::Value *a, llvm::Value *b, const char *cmp_op)</td></tr>
<tr class="memdesc:a495c03b2055c1269f84e95b1feba94d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector predicated comparison intrinsic call if use_llvm_vp_intrinsics is true and result_type is a vector type.  <br /></td></tr>
<tr class="separator:a495c03b2055c1269f84e95b1feba94d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e60171d03d635e3f443f311f45377f" id="r_a32e60171d03d635e3f443f311f45377f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32e60171d03d635e3f443f311f45377f">try_vector_predication_intrinsic</a> (const std::string &amp;name, <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_result_type.html">VPResultType</a> result_type, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> length, <a class="el" href="#acfc056cd4cc8139292ae7268200101c0">MaskVariant</a> mask, std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_arg.html">VPArg</a> &gt; args)</td></tr>
<tr class="memdesc:a32e60171d03d635e3f443f311f45377f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an intrisic call if use_llvm_vp_intrinsics is true and length is greater than 1.  <br /></td></tr>
<tr class="separator:a32e60171d03d635e3f443f311f45377f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a31951805271d85f036762be8ada94" id="r_a60a31951805271d85f036762be8ada94"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a31951805271d85f036762be8ada94">codegen_dense_vector_load</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a> *load, llvm::Value *vpred=nullptr, bool slice_to_native=true)</td></tr>
<tr class="memdesc:a60a31951805271d85f036762be8ada94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basic dense vector load, with an optional predicate and control over whether or not we should slice the load into native vectors.  <br /></td></tr>
<tr class="separator:a60a31951805271d85f036762be8ada94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e03d7ecc708ceb97015b15cfe526ad9" id="r_a2e03d7ecc708ceb97015b15cfe526ad9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e03d7ecc708ceb97015b15cfe526ad9">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_fork.html">Fork</a> *)</td></tr>
<tr class="separator:a2e03d7ecc708ceb97015b15cfe526ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a4420cc8b07c9e3a199639b79802b4" id="r_a81a4420cc8b07c9e3a199639b79802b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81a4420cc8b07c9e3a199639b79802b4">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_acquire.html">Acquire</a> *)</td></tr>
<tr class="separator:a81a4420cc8b07c9e3a199639b79802b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742fd9bc6624a1a3500ea96b7cf4531e" id="r_a742fd9bc6624a1a3500ea96b7cf4531e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a742fd9bc6624a1a3500ea96b7cf4531e">visit</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_hoisted_storage.html">HoistedStorage</a> *)</td></tr>
<tr class="separator:a742fd9bc6624a1a3500ea96b7cf4531e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_halide_1_1_internal_1_1_i_r_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_halide_1_1_internal_1_1_i_r_visitor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">Halide::Internal::IRVisitor</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4f28718479886e14dace03ce3a4e96d4" id="r_a4f28718479886e14dace03ce3a4e96d4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f28718479886e14dace03ce3a4e96d4">module</a></td></tr>
<tr class="separator:a4f28718479886e14dace03ce3a4e96d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910d641bc9fdd7a33feded6ae2b5232" id="r_a5910d641bc9fdd7a33feded6ae2b5232"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5910d641bc9fdd7a33feded6ae2b5232">function</a> = nullptr</td></tr>
<tr class="separator:a5910d641bc9fdd7a33feded6ae2b5232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877b0f3d432ba326f51974e5861c20de" id="r_a877b0f3d432ba326f51974e5861c20de"><td class="memItemLeft" align="right" valign="top">llvm::LLVMContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877b0f3d432ba326f51974e5861c20de">context</a> = nullptr</td></tr>
<tr class="separator:a877b0f3d432ba326f51974e5861c20de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c40d7a78bcbd75d7bf38a7647ac9ac7" id="r_a4c40d7a78bcbd75d7bf38a7647ac9ac7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c40d7a78bcbd75d7bf38a7647ac9ac7">builder</a></td></tr>
<tr class="separator:a4c40d7a78bcbd75d7bf38a7647ac9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0119d82814d12292a89cf3836a00c710" id="r_a0119d82814d12292a89cf3836a00c710"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a> = nullptr</td></tr>
<tr class="separator:a0119d82814d12292a89cf3836a00c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca7476bab4d0bd74a68f05a8fe4ee4f" id="r_a6ca7476bab4d0bd74a68f05a8fe4ee4f"><td class="memItemLeft" align="right" valign="top">llvm::MDNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ca7476bab4d0bd74a68f05a8fe4ee4f">very_likely_branch</a> = nullptr</td></tr>
<tr class="separator:a6ca7476bab4d0bd74a68f05a8fe4ee4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af158c6cf53003f8132ab316d0b883872" id="r_af158c6cf53003f8132ab316d0b883872"><td class="memItemLeft" align="right" valign="top">llvm::MDNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af158c6cf53003f8132ab316d0b883872">default_fp_math_md</a> = nullptr</td></tr>
<tr class="separator:af158c6cf53003f8132ab316d0b883872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdced1fc6b947dbbf463342b9b732a8" id="r_adcdced1fc6b947dbbf463342b9b732a8"><td class="memItemLeft" align="right" valign="top">llvm::MDNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcdced1fc6b947dbbf463342b9b732a8">strict_fp_math_md</a> = nullptr</td></tr>
<tr class="separator:adcdced1fc6b947dbbf463342b9b732a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ed3189a07c7edb84460af09ccdb6c9" id="r_a19ed3189a07c7edb84460af09ccdb6c9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19ed3189a07c7edb84460af09ccdb6c9">current_function_args</a></td></tr>
<tr class="separator:a19ed3189a07c7edb84460af09ccdb6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c0da8b30234e39d27645a522e91a10" id="r_a47c0da8b30234e39d27645a522e91a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Halide::Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47c0da8b30234e39d27645a522e91a10">target</a></td></tr>
<tr class="memdesc:a47c0da8b30234e39d27645a522e91a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target we're generating code for.  <br /></td></tr>
<tr class="separator:a47c0da8b30234e39d27645a522e91a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb643b91f22fe85391c4ec6fbf40bcc0" id="r_afb643b91f22fe85391c4ec6fbf40bcc0"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb643b91f22fe85391c4ec6fbf40bcc0">void_t</a> = nullptr</td></tr>
<tr class="memdesc:afb643b91f22fe85391c4ec6fbf40bcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some useful llvm types.  <br /></td></tr>
<tr class="separator:afb643b91f22fe85391c4ec6fbf40bcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8663cf327697bb374832ef78af23a5ae" id="r_a8663cf327697bb374832ef78af23a5ae"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8663cf327697bb374832ef78af23a5ae">i1_t</a> = nullptr</td></tr>
<tr class="separator:a8663cf327697bb374832ef78af23a5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b13f959c70f7498077f8816fde5763" id="r_a82b13f959c70f7498077f8816fde5763"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b13f959c70f7498077f8816fde5763">i8_t</a> = nullptr</td></tr>
<tr class="separator:a82b13f959c70f7498077f8816fde5763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c507faf4417eaf1b8cafd7e8c9b9ea4" id="r_a4c507faf4417eaf1b8cafd7e8c9b9ea4"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c507faf4417eaf1b8cafd7e8c9b9ea4">i16_t</a> = nullptr</td></tr>
<tr class="separator:a4c507faf4417eaf1b8cafd7e8c9b9ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4599b23ab01f06428ae05dc46a6464d" id="r_ae4599b23ab01f06428ae05dc46a6464d"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4599b23ab01f06428ae05dc46a6464d">i32_t</a> = nullptr</td></tr>
<tr class="separator:ae4599b23ab01f06428ae05dc46a6464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ccd648cd7c6af92b1dcc41226fe2e3" id="r_a18ccd648cd7c6af92b1dcc41226fe2e3"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18ccd648cd7c6af92b1dcc41226fe2e3">i64_t</a> = nullptr</td></tr>
<tr class="separator:a18ccd648cd7c6af92b1dcc41226fe2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc523eba27ab6ec6d647f0a8039c0ea0" id="r_afc523eba27ab6ec6d647f0a8039c0ea0"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc523eba27ab6ec6d647f0a8039c0ea0">f16_t</a> = nullptr</td></tr>
<tr class="separator:afc523eba27ab6ec6d647f0a8039c0ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9371d250123944ce7cbd6917d1bcdc57" id="r_a9371d250123944ce7cbd6917d1bcdc57"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9371d250123944ce7cbd6917d1bcdc57">f32_t</a> = nullptr</td></tr>
<tr class="separator:a9371d250123944ce7cbd6917d1bcdc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d481506f1c6cd852726df7e9cd4adfc" id="r_a0d481506f1c6cd852726df7e9cd4adfc"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d481506f1c6cd852726df7e9cd4adfc">f64_t</a> = nullptr</td></tr>
<tr class="separator:a0d481506f1c6cd852726df7e9cd4adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7821ab39642a75898c76c16c7b0a4cbd" id="r_a7821ab39642a75898c76c16c7b0a4cbd"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7821ab39642a75898c76c16c7b0a4cbd">halide_buffer_t_type</a> = nullptr</td></tr>
<tr class="separator:a7821ab39642a75898c76c16c7b0a4cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2c423935f8eb7114a07f716d68ab90" id="r_a3f2c423935f8eb7114a07f716d68ab90"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f2c423935f8eb7114a07f716d68ab90">type_t_type</a></td></tr>
<tr class="separator:a3f2c423935f8eb7114a07f716d68ab90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82208322de749e9ef4dc2744946afbe4" id="r_a82208322de749e9ef4dc2744946afbe4"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82208322de749e9ef4dc2744946afbe4">dimension_t_type</a></td></tr>
<tr class="separator:a82208322de749e9ef4dc2744946afbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056c5571524a7926b91716647a4e3d8b" id="r_a056c5571524a7926b91716647a4e3d8b"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a056c5571524a7926b91716647a4e3d8b">metadata_t_type</a> = nullptr</td></tr>
<tr class="separator:a056c5571524a7926b91716647a4e3d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0dc00d0309cc9a38280f3a80a28ac" id="r_a07a0dc00d0309cc9a38280f3a80a28ac"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07a0dc00d0309cc9a38280f3a80a28ac">argument_t_type</a> = nullptr</td></tr>
<tr class="separator:a07a0dc00d0309cc9a38280f3a80a28ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c00c39835429be838307d97942648d2" id="r_a4c00c39835429be838307d97942648d2"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c00c39835429be838307d97942648d2">scalar_value_t_type</a> = nullptr</td></tr>
<tr class="separator:a4c00c39835429be838307d97942648d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13530696bc30f7f0541f7506d44b51b8" id="r_a13530696bc30f7f0541f7506d44b51b8"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13530696bc30f7f0541f7506d44b51b8">device_interface_t_type</a> = nullptr</td></tr>
<tr class="separator:a13530696bc30f7f0541f7506d44b51b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabe32280d026b804e121c015a300b07" id="r_aeabe32280d026b804e121c015a300b07"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeabe32280d026b804e121c015a300b07">pseudostack_slot_t_type</a> = nullptr</td></tr>
<tr class="separator:aeabe32280d026b804e121c015a300b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3e86740275b085e03e8e97f839da5" id="r_a15a3e86740275b085e03e8e97f839da5"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15a3e86740275b085e03e8e97f839da5">semaphore_t_type</a></td></tr>
<tr class="separator:a15a3e86740275b085e03e8e97f839da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7454f0492a21a982e77026f277ae0f6" id="r_ae7454f0492a21a982e77026f277ae0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7454f0492a21a982e77026f277ae0f6">wild_u1x_</a></td></tr>
<tr class="memdesc:ae7454f0492a21a982e77026f277ae0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some wildcard variables used for peephole optimizations in subclasses.  <br /></td></tr>
<tr class="separator:ae7454f0492a21a982e77026f277ae0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e61618d6413924d1a40557a91c80d" id="r_a391e61618d6413924d1a40557a91c80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391e61618d6413924d1a40557a91c80d">wild_i8x_</a></td></tr>
<tr class="separator:a391e61618d6413924d1a40557a91c80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eafcdfb329717fd4e8213d26cd8a71e" id="r_a7eafcdfb329717fd4e8213d26cd8a71e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eafcdfb329717fd4e8213d26cd8a71e">wild_u8x_</a></td></tr>
<tr class="separator:a7eafcdfb329717fd4e8213d26cd8a71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d767e754a9570f8cd9ea3249a532912" id="r_a8d767e754a9570f8cd9ea3249a532912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d767e754a9570f8cd9ea3249a532912">wild_i16x_</a></td></tr>
<tr class="separator:a8d767e754a9570f8cd9ea3249a532912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8585ddda6b88bb4b5e3ac19a986df0e" id="r_ae8585ddda6b88bb4b5e3ac19a986df0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8585ddda6b88bb4b5e3ac19a986df0e">wild_u16x_</a></td></tr>
<tr class="separator:ae8585ddda6b88bb4b5e3ac19a986df0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dc46061602bf06a8e215320c940ba6" id="r_af4dc46061602bf06a8e215320c940ba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4dc46061602bf06a8e215320c940ba6">wild_i32x_</a></td></tr>
<tr class="separator:af4dc46061602bf06a8e215320c940ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac4670e5958f81a1a29f0c88138f22" id="r_aebac4670e5958f81a1a29f0c88138f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebac4670e5958f81a1a29f0c88138f22">wild_u32x_</a></td></tr>
<tr class="separator:aebac4670e5958f81a1a29f0c88138f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda0db60a1b3e7ac34f163e12645c529" id="r_aeda0db60a1b3e7ac34f163e12645c529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeda0db60a1b3e7ac34f163e12645c529">wild_i64x_</a></td></tr>
<tr class="separator:aeda0db60a1b3e7ac34f163e12645c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff785d97f2c1f668f175a84124cca54" id="r_a8ff785d97f2c1f668f175a84124cca54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ff785d97f2c1f668f175a84124cca54">wild_u64x_</a></td></tr>
<tr class="separator:a8ff785d97f2c1f668f175a84124cca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62772a48a5b8bb039db2920b6d8fb7b2" id="r_a62772a48a5b8bb039db2920b6d8fb7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62772a48a5b8bb039db2920b6d8fb7b2">wild_f32x_</a></td></tr>
<tr class="separator:a62772a48a5b8bb039db2920b6d8fb7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d085fffcb0ef0c1aef52868b563f4" id="r_a614d085fffcb0ef0c1aef52868b563f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614d085fffcb0ef0c1aef52868b563f4">wild_f64x_</a></td></tr>
<tr class="separator:a614d085fffcb0ef0c1aef52868b563f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfbe42f3e2108b471d0070dba2a7564" id="r_a5bfbe42f3e2108b471d0070dba2a7564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bfbe42f3e2108b471d0070dba2a7564">wild_u1_</a></td></tr>
<tr class="separator:a5bfbe42f3e2108b471d0070dba2a7564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46a1adf1c37c0bce2e46fa9cea0304f" id="r_ac46a1adf1c37c0bce2e46fa9cea0304f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac46a1adf1c37c0bce2e46fa9cea0304f">wild_i8_</a></td></tr>
<tr class="separator:ac46a1adf1c37c0bce2e46fa9cea0304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f8ac1961b48ad78e63ffc4636c6097" id="r_ac2f8ac1961b48ad78e63ffc4636c6097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f8ac1961b48ad78e63ffc4636c6097">wild_u8_</a></td></tr>
<tr class="separator:ac2f8ac1961b48ad78e63ffc4636c6097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53740b31129aeca292ade376dcd048f" id="r_ac53740b31129aeca292ade376dcd048f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac53740b31129aeca292ade376dcd048f">wild_i16_</a></td></tr>
<tr class="separator:ac53740b31129aeca292ade376dcd048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66765a15c861a3b5f635a109f0f0df40" id="r_a66765a15c861a3b5f635a109f0f0df40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66765a15c861a3b5f635a109f0f0df40">wild_u16_</a></td></tr>
<tr class="separator:a66765a15c861a3b5f635a109f0f0df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb0d18f1cfc48e29a104c3d5c41e5bd" id="r_a4fb0d18f1cfc48e29a104c3d5c41e5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fb0d18f1cfc48e29a104c3d5c41e5bd">wild_i32_</a></td></tr>
<tr class="separator:a4fb0d18f1cfc48e29a104c3d5c41e5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969e74c7a485470024374de00c563c4b" id="r_a969e74c7a485470024374de00c563c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a969e74c7a485470024374de00c563c4b">wild_u32_</a></td></tr>
<tr class="separator:a969e74c7a485470024374de00c563c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c92a609e494727af687dae03afe24f0" id="r_a5c92a609e494727af687dae03afe24f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c92a609e494727af687dae03afe24f0">wild_i64_</a></td></tr>
<tr class="separator:a5c92a609e494727af687dae03afe24f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b81caf2b65dcf5e522503c1f4af37e" id="r_ae2b81caf2b65dcf5e522503c1f4af37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2b81caf2b65dcf5e522503c1f4af37e">wild_u64_</a></td></tr>
<tr class="separator:ae2b81caf2b65dcf5e522503c1f4af37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17954f48a82e3eaf8eda197b2a0e54e" id="r_ae17954f48a82e3eaf8eda197b2a0e54e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17954f48a82e3eaf8eda197b2a0e54e">wild_f32_</a></td></tr>
<tr class="separator:ae17954f48a82e3eaf8eda197b2a0e54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5178c674d2b2cf0d4b9a6dd4a30461" id="r_a1d5178c674d2b2cf0d4b9a6dd4a30461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d5178c674d2b2cf0d4b9a6dd4a30461">wild_f64_</a></td></tr>
<tr class="separator:a1d5178c674d2b2cf0d4b9a6dd4a30461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d7156c51bb2a5a9dd6ed587d5ecb81" id="r_ae5d7156c51bb2a5a9dd6ed587d5ecb81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5d7156c51bb2a5a9dd6ed587d5ecb81">requested_alloca_total</a> = 0</td></tr>
<tr class="memdesc:ae5d7156c51bb2a5a9dd6ed587d5ecb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (very) conservative guess at the size of all alloca() storage requested (including alignment padding).  <br /></td></tr>
<tr class="separator:ae5d7156c51bb2a5a9dd6ed587d5ecb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2c2af56b0eefd293bb6c8d65a6a8cd" id="r_a9f2c2af56b0eefd293bb6c8d65a6a8cd"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_intrinsic.html">Intrinsic</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f2c2af56b0eefd293bb6c8d65a6a8cd">intrinsics</a></td></tr>
<tr class="memdesc:a9f2c2af56b0eefd293bb6c8d65a6a8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of intrinsic functions to the various overloads implementing it.  <br /></td></tr>
<tr class="separator:a9f2c2af56b0eefd293bb6c8d65a6a8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad637c306190b4decda583ac1e283433d" id="r_ad637c306190b4decda583ac1e283433d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad637c306190b4decda583ac1e283433d">inside_atomic_mutex_node</a> = false</td></tr>
<tr class="memdesc:ad637c306190b4decda583ac1e283433d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we inside an atomic node that uses mutex locks? This is used for detecting deadlocks from nested atomics &amp; illegal vectorization.  <br /></td></tr>
<tr class="separator:ad637c306190b4decda583ac1e283433d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de455cd8309fd52824446ae9d515aec" id="r_a0de455cd8309fd52824446ae9d515aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de455cd8309fd52824446ae9d515aec">emit_atomic_stores</a> = false</td></tr>
<tr class="memdesc:a0de455cd8309fd52824446ae9d515aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit atomic store instructions?  <br /></td></tr>
<tr class="separator:a0de455cd8309fd52824446ae9d515aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9672fcad3720ef452e297556573bd6" id="r_a4c9672fcad3720ef452e297556573bd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c9672fcad3720ef452e297556573bd6">use_llvm_vp_intrinsics</a> = false</td></tr>
<tr class="memdesc:a4c9672fcad3720ef452e297556573bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls use of vector predicated intrinsics for vector operations.  <br /></td></tr>
<tr class="separator:a4c9672fcad3720ef452e297556573bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829073c893d90d987c9d16ac59db5069" id="r_a829073c893d90d987c9d16ac59db5069"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="#a7b7e186e1aee1d0a313f7a7c89a58909">WarningKind</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a829073c893d90d987c9d16ac59db5069">onetime_warnings</a></td></tr>
<tr class="separator:a829073c893d90d987c9d16ac59db5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A code generator abstract base class. </p>
<p>Actual code generators (e.g. CodeGen_X86) inherit from this. This class is responsible for taking a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> and producing llvm bitcode, machine code in an object file, or machine code accessible through a function pointer. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00059">59</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acfc056cd4cc8139292ae7268200101c0" name="acfc056cd4cc8139292ae7268200101c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc056cd4cc8139292ae7268200101c0">&#9670;&#160;</a></span>MaskVariant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acfc056cd4cc8139292ae7268200101c0">Halide::Internal::CodeGen_LLVM::MaskVariant</a> = std::variant&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_no_mask.html">NoMask</a>, <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_all_enabled_mask.html">AllEnabledMask</a>, llvm::Value *&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predication mask using the above two types for special cases and an llvm::Value for the general one. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00619">619</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a431585f4447c39d5639672baa5b1c5d2" name="a431585f4447c39d5639672baa5b1c5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431585f4447c39d5639672baa5b1c5d2">&#9670;&#160;</a></span>DestructorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a431585f4447c39d5639672baa5b1c5d2">Halide::Internal::CodeGen_LLVM::DestructorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some destructors should always be called. </p>
<p>Others should only be called if the pipeline is exiting with an error code. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a431585f4447c39d5639672baa5b1c5d2a65f0774ca71b47cdb4461248276337b3" name="a431585f4447c39d5639672baa5b1c5d2a65f0774ca71b47cdb4461248276337b3"></a>Always&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a431585f4447c39d5639672baa5b1c5d2aa8ffd1a2e243519844b054ec9eafe9c4" name="a431585f4447c39d5639672baa5b1c5d2aa8ffd1a2e243519844b054ec9eafe9c4"></a>OnError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a431585f4447c39d5639672baa5b1c5d2abf9677f74a723a3afef3f9c454652241" name="a431585f4447c39d5639672baa5b1c5d2abf9677f74a723a3afef3f9c454652241"></a>OnSuccess&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00248">248</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a3f3f9a6a0b806dcb0517b4955aa0a625" name="a3f3f9a6a0b806dcb0517b4955aa0a625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3f9a6a0b806dcb0517b4955aa0a625">&#9670;&#160;</a></span>VectorTypeConstraint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">Halide::Internal::CodeGen_LLVM::VectorTypeConstraint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interface to abstract vector code generation as LLVM is now providing multiple options to express even simple vector operations. </p>
<p>Specifically traditional fixed length vectors, vscale based variable length vectors, and the vector predicate based approach where an explict length is passed with each instruction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754" name="a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3f3f9a6a0b806dcb0517b4955aa0a625a4457d440870ad6d42bab9082d9bf9b61" name="a3f3f9a6a0b806dcb0517b4955aa0a625a4457d440870ad6d42bab9082d9bf9b61"></a>Fixed&#160;</td><td class="fielddoc"><p>Use default for current target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3f3f9a6a0b806dcb0517b4955aa0a625aaeee1a772403b537e94b54141e896773" name="a3f3f9a6a0b806dcb0517b4955aa0a625aaeee1a772403b537e94b54141e896773"></a>VScale&#160;</td><td class="fielddoc"><p>Force use of fixed size vectors. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00572">572</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a7b7e186e1aee1d0a313f7a7c89a58909" name="a7b7e186e1aee1d0a313f7a7c89a58909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7e186e1aee1d0a313f7a7c89a58909">&#9670;&#160;</a></span>WarningKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a7b7e186e1aee1d0a313f7a7c89a58909">Halide::Internal::CodeGen_LLVM::WarningKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Warning messages which we want to avoid displaying number of times. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b7e186e1aee1d0a313f7a7c89a58909a2070d00a39208a5d118ae721ac330627" name="a7b7e186e1aee1d0a313f7a7c89a58909a2070d00a39208a5d118ae721ac330627"></a>EmulatedFloat16&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00656">656</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3d1bfcb39456d2f7f1f26086fe060fb" name="ab3d1bfcb39456d2f7f1f26086fe060fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d1bfcb39456d2f7f1f26086fe060fb">&#9670;&#160;</a></span>CodeGen_LLVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::CodeGen_LLVM::CodeGen_LLVM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf6baae83a8ac9c62df39855b2f90bf3" name="aaf6baae83a8ac9c62df39855b2f90bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6baae83a8ac9c62df39855b2f90bf3">&#9670;&#160;</a></span>new_for_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a> &gt; Halide::Internal::CodeGen_LLVM::new_for_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance of <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html" title="A code generator abstract base class.">CodeGen_LLVM</a> suitable for the target. </p>

</div>
</div>
<a id="a2504b90dbc9307972e48a6dfc45e0dc6" name="a2504b90dbc9307972e48a6dfc45e0dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2504b90dbc9307972e48a6dfc45e0dc6">&#9670;&#160;</a></span>compile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; llvm::Module &gt; Halide::Internal::CodeGen_LLVM::compile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>module</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> and compiles it to an llvm <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a>. </p>

</div>
</div>
<a id="a1b610bac31c788b13ccaa47bd503fb15" name="a1b610bac31c788b13ccaa47bd503fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b610bac31c788b13ccaa47bd503fb15">&#9670;&#160;</a></span>get_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp; Halide::Internal::CodeGen_LLVM::get_target </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The target we're generating code for. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00068">68</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

<p class="reference">References <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00175">target</a>.</p>

</div>
</div>
<a id="abfb5afade2ec4699febb51055bb8a85b" name="abfb5afade2ec4699febb51055bb8a85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb5afade2ec4699febb51055bb8a85b">&#9670;&#160;</a></span>set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::set_context </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the code generator which LLVM context to use. </p>

</div>
</div>
<a id="abb1cca67615cd6d7cab8eb0f2524a1f3" name="abb1cca67615cd6d7cab8eb0f2524a1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1cca67615cd6d7cab8eb0f2524a1f3">&#9670;&#160;</a></span>initialize_llvm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Halide::Internal::CodeGen_LLVM::initialize_llvm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize internal llvm state for the enabled targets. </p>

</div>
</div>
<a id="a83b84ea5b04977108acb3b3fc3197c9a" name="a83b84ea5b04977108acb3b3fc3197c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b84ea5b04977108acb3b3fc3197c9a">&#9670;&#160;</a></span>compile_trampolines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; llvm::Module &gt; Halide::Internal::CodeGen_LLVM::compile_trampolines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, <a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>externs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf436556e94fd28dee1106129b25f66b" name="aaf436556e94fd28dee1106129b25f66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf436556e94fd28dee1106129b25f66b">&#9670;&#160;</a></span>get_requested_alloca_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> Halide::Internal::CodeGen_LLVM::get_requested_alloca_total </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00084">84</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

<p class="reference">References <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00429">requested_alloca_total</a>.</p>

</div>
</div>
<a id="a842edc53337047c5e27411a19e972068" name="a842edc53337047c5e27411a19e972068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842edc53337047c5e27411a19e972068">&#9670;&#160;</a></span>compile_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::compile_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>simple_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extern_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile a specific halide declaration into the llvm <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a>. </p>

</div>
</div>
<a id="a540f2a5c9fc207720ddeba3aca40f1ca" name="a540f2a5c9fc207720ddeba3aca40f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f2a5c9fc207720ddeba3aca40f1ca">&#9670;&#160;</a></span>compile_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::compile_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49489320b60f11049eff0233275fa95e" name="a49489320b60f11049eff0233275fa95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49489320b60f11049eff0233275fa95e">&#9670;&#160;</a></span>begin_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::begin_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a></td>          <td class="paramname"><span class="paramname"><em>linkage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>simple_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extern_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for compiling <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions to llvm functions. </p>
<p>begin_func performs all the work necessary to begin generating code for a function with a given argument list with the IRBuilder. A call to begin_func should be a followed by a call to end_func with the same arguments, to generate the appropriate cleanup code. </p>

</div>
</div>
<a id="a06d0ccda984bec742a4f3ee92e0e808c" name="a06d0ccda984bec742a4f3ee92e0e808c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d0ccda984bec742a4f3ee92e0e808c">&#9670;&#160;</a></span>end_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::end_func </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5228a19eb5823cadb067817664865d7c" name="a5228a19eb5823cadb067817664865d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5228a19eb5823cadb067817664865d7c">&#9670;&#160;</a></span>mcpu_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Halide::Internal::CodeGen_LLVM::mcpu_target </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What should be passed as -mcpu (warning: implies attrs!), -mattrs, and related for compilation. </p>
<p>The architecture-specific code generator should define these.</p>
<p><code><a class="el" href="#a5228a19eb5823cadb067817664865d7c" title="What should be passed as -mcpu (warning: implies attrs!), -mattrs, and related for compilation.">mcpu_target()</a></code> - target this specific CPU, in the sense of the allowed ISA sets <em>and</em> the CPU-specific tuning/assembly instruction scheduling.</p>
<p><code><a class="el" href="#a2c3d15a06f19c7e251c2e351c23ac432">mcpu_tune()</a></code> - expect that we will be running on this specific CPU, so perform CPU-specific tuning/assembly instruction scheduling, <em>but</em> DON'T sacrifice the portability, support running on other CPUs, only make use of the ISAs that are enabled by <code><a class="el" href="#a5228a19eb5823cadb067817664865d7c" title="What should be passed as -mcpu (warning: implies attrs!), -mattrs, and related for compilation.">mcpu_target()</a></code>+<code><a class="el" href="#ae33728361cfc0b827fa72f11b8207247">mattrs()</a></code>. </p>

</div>
</div>
<a id="a2c3d15a06f19c7e251c2e351c23ac432" name="a2c3d15a06f19c7e251c2e351c23ac432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d15a06f19c7e251c2e351c23ac432">&#9670;&#160;</a></span>mcpu_tune()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Halide::Internal::CodeGen_LLVM::mcpu_tune </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae33728361cfc0b827fa72f11b8207247" name="ae33728361cfc0b827fa72f11b8207247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33728361cfc0b827fa72f11b8207247">&#9670;&#160;</a></span>mattrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Halide::Internal::CodeGen_LLVM::mattrs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c6493faac2bb44fd9c5b4a0257a4034" name="a9c6493faac2bb44fd9c5b4a0257a4034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6493faac2bb44fd9c5b4a0257a4034">&#9670;&#160;</a></span>mabi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Halide::Internal::CodeGen_LLVM::mabi </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b3d73057374d80eab5f601a7d6de184" name="a9b3d73057374d80eab5f601a7d6de184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3d73057374d80eab5f601a7d6de184">&#9670;&#160;</a></span>use_soft_float_abi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Halide::Internal::CodeGen_LLVM::use_soft_float_abi </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6c4bd1496b0492ad671c82b3a15bc16" name="aa6c4bd1496b0492ad671c82b3a15bc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c4bd1496b0492ad671c82b3a15bc16">&#9670;&#160;</a></span>use_pic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Halide::Internal::CodeGen_LLVM::use_pic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a555842c7a0f8c36b2911e8b88348e3fa" name="a555842c7a0f8c36b2911e8b88348e3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555842c7a0f8c36b2911e8b88348e3fa">&#9670;&#160;</a></span>promote_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Halide::Internal::CodeGen_LLVM::promote_indices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should indexing math be promoted to 64-bit on platforms with 64-bit pointers? </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00132">132</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a7d6b29eb2ab4da0c72521e2fe901fe10" name="a7d6b29eb2ab4da0c72521e2fe901fe10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6b29eb2ab4da0c72521e2fe901fe10">&#9670;&#160;</a></span>native_vector_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Halide::Internal::CodeGen_LLVM::native_vector_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the natural vector bit-width to use for loads, stores, etc. </p>

<p class="reference">Referenced by <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00141">maximum_vector_bits()</a>.</p>

</div>
</div>
<a id="a0bbf2f0f34c03dc2a5c44a56a76c969f" name="a0bbf2f0f34c03dc2a5c44a56a76c969f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbf2f0f34c03dc2a5c44a56a76c969f">&#9670;&#160;</a></span>maximum_vector_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Halide::Internal::CodeGen_LLVM::maximum_vector_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to decide whether to break a vector up into multiple smaller operations. </p>
<p>This is the largest size the architecture supports. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00141">141</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

<p class="reference">References <a class="el" href="#a7d6b29eb2ab4da0c72521e2fe901fe10">native_vector_bits()</a>.</p>

</div>
</div>
<a id="a1274feff0da89ba7c3c73d699e62b488" name="a1274feff0da89ba7c3c73d699e62b488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1274feff0da89ba7c3c73d699e62b488">&#9670;&#160;</a></span>target_vscale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Halide::Internal::CodeGen_LLVM::target_vscale </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> architectures that have vscale vectors, return the constant vscale to use. </p>
<p>Default of 0 means do not use vscale vectors. Generally will depend on the target flags and vector_bits settings. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00148">148</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a72048e9e69af328a3157680d7f937a65" name="a72048e9e69af328a3157680d7f937a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72048e9e69af328a3157680d7f937a65">&#9670;&#160;</a></span>upgrade_type_for_arithmetic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::CodeGen_LLVM::upgrade_type_for_arithmetic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type in which arithmetic should be done for the given storage type. </p>

</div>
</div>
<a id="a678a1a20460795f63ba7cc4fe3e01a03" name="a678a1a20460795f63ba7cc4fe3e01a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678a1a20460795f63ba7cc4fe3e01a03">&#9670;&#160;</a></span>upgrade_type_for_storage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::CodeGen_LLVM::upgrade_type_for_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type that a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> type should be stored/loaded from memory as. </p>

</div>
</div>
<a id="aafc5c70918fa44012a05d165c293d43b" name="aafc5c70918fa44012a05d165c293d43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc5c70918fa44012a05d165c293d43b">&#9670;&#160;</a></span>upgrade_type_for_argument_passing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::CodeGen_LLVM::upgrade_type_for_argument_passing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type that a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> type should be passed in and out of functions as. </p>

</div>
</div>
<a id="a103523cea9fc739ed24f3db6baeb722b" name="a103523cea9fc739ed24f3db6baeb722b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103523cea9fc739ed24f3db6baeb722b">&#9670;&#160;</a></span>init_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::init_context </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grab all the context specific internal state. </p>

</div>
</div>
<a id="ae1a02e24b44e3de6f0af6cc0bc7dbd2a" name="ae1a02e24b44e3de6f0af6cc0bc7dbd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a02e24b44e3de6f0af6cc0bc7dbd2a">&#9670;&#160;</a></span>init_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::init_module </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html" title="A code generator abstract base class.">CodeGen_LLVM</a> internal state to compile a fresh module. </p>
<p>This allows reuse of one <a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html" title="A code generator abstract base class.">CodeGen_LLVM</a> object to compiled multiple related modules (e.g. multiple device kernels). </p>

</div>
</div>
<a id="ac5d46a488247c117bb47647eca7b0530" name="ac5d46a488247c117bb47647eca7b0530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d46a488247c117bb47647eca7b0530">&#9670;&#160;</a></span>optimize_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::optimize_module </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run all of llvm's optimization passes on the module. </p>

</div>
</div>
<a id="a3e46a91aee2483099528aeb6249c9d17" name="a3e46a91aee2483099528aeb6249c9d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e46a91aee2483099528aeb6249c9d17">&#9670;&#160;</a></span>sym_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::sym_push </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> an entry to the symbol table, hiding previous entries with the same name. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> this when new values come into scope. </p>

</div>
</div>
<a id="a102cc4ef7189121091c5af1fef029c9f" name="a102cc4ef7189121091c5af1fef029c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102cc4ef7189121091c5af1fef029c9f">&#9670;&#160;</a></span>sym_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::sym_pop </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an entry for the symbol table, revealing any previous entries with the same name. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> this when values go out of scope. </p>

</div>
</div>
<a id="acb8a2f1f926591abd965a48685ee3f31" name="acb8a2f1f926591abd965a48685ee3f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8a2f1f926591abd965a48685ee3f31">&#9670;&#160;</a></span>sym_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::sym_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_succeed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch an entry from the symbol table. </p>
<p>If the symbol is not found, it either errors out (if the second arg is true), or returns nullptr. </p>

</div>
</div>
<a id="af24a38ec5ba1a09efad89f8691f5d62d" name="af24a38ec5ba1a09efad89f8691f5d62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24a38ec5ba1a09efad89f8691f5d62d">&#9670;&#160;</a></span>sym_exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::CodeGen_LLVM::sym_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an item exists in the symbol table. </p>

</div>
</div>
<a id="a8431c25510b21a55c75ea1b1190597ae" name="a8431c25510b21a55c75ea1b1190597ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8431c25510b21a55c75ea1b1190597ae">&#9670;&#160;</a></span>signature_to_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::FunctionType * Halide::Internal::CodeGen_LLVM::signature_to_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>signature</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a>, return the equivalent llvm::FunctionType. </p>

</div>
</div>
<a id="ac51f9d47922eed62e42c56b702b237e2" name="ac51f9d47922eed62e42c56b702b237e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51f9d47922eed62e42c56b702b237e2">&#9670;&#160;</a></span>codegen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::codegen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit code that evaluates an expression, and return the llvm representation of the result of the expression. </p>

</div>
</div>
<a id="a54099205473b83336ba6cd5b2465fa4a" name="a54099205473b83336ba6cd5b2465fa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54099205473b83336ba6cd5b2465fa4a">&#9670;&#160;</a></span>codegen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::codegen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit code that runs a statement. </p>

</div>
</div>
<a id="aa8a34c216f3aa31e65c597220097cd82" name="aa8a34c216f3aa31e65c597220097cd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a34c216f3aa31e65c597220097cd82">&#9670;&#160;</a></span>scalarize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::scalarize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Codegen a vector <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> by codegenning each lane and combining. </p>

</div>
</div>
<a id="ac1fa3e1e579505927efc43d610288589" name="ac1fa3e1e579505927efc43d610288589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fa3e1e579505927efc43d610288589">&#9670;&#160;</a></span>register_destructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::register_destructor </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>destructor_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a431585f4447c39d5639672baa5b1c5d2">DestructorType</a></td>          <td class="paramname"><span class="paramname"><em>when</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34fb437fa2c7542aa213947a03dc20c3" name="a34fb437fa2c7542aa213947a03dc20c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fb437fa2c7542aa213947a03dc20c3">&#9670;&#160;</a></span>trigger_destructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::trigger_destructor </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>destructor_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>stack_slot</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> a destructor early. </p>
<p>Pass in the value returned by register destructor. </p>

</div>
</div>
<a id="adfea81a166f2b255147c00cd754de519" name="adfea81a166f2b255147c00cd754de519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfea81a166f2b255147c00cd754de519">&#9670;&#160;</a></span>get_destructor_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::BasicBlock * Halide::Internal::CodeGen_LLVM::get_destructor_block </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the block containing the error handling code. </p>
<p>Creates it if it doesn't already exist for this function. </p>

</div>
</div>
<a id="a67868e18426144982ede1ecd5ec79dbe" name="a67868e18426144982ede1ecd5ec79dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67868e18426144982ede1ecd5ec79dbe">&#9670;&#160;</a></span>create_assertion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::create_assertion </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>error_code</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Codegen an assertion. </p>
<p>If false, returns the error code (if not null), or evaluates and returns the message, which must be an Int(32) expression. </p>

</div>
</div>
<a id="aad42fb0f33277ab0c10acb8fd7d80b65" name="aad42fb0f33277ab0c10acb8fd7d80b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad42fb0f33277ab0c10acb8fd7d80b65">&#9670;&#160;</a></span>codegen_asserts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::codegen_asserts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>asserts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Codegen a block of asserts with pure conditions. </p>

</div>
</div>
<a id="a1d4e55909a6a1fad9110c9671d8002e2" name="a1d4e55909a6a1fad9110c9671d8002e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4e55909a6a1fad9110c9671d8002e2">&#9670;&#160;</a></span>return_with_error_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::return_with_error_code </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>error_code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the the pipeline with the given error code. </p>
<p>Will run the destructor block. </p>

</div>
</div>
<a id="a8611e28d9e28a8f4ad9b374b379829af" name="a8611e28d9e28a8f4ad9b374b379829af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8611e28d9e28a8f4ad9b374b379829af">&#9670;&#160;</a></span>create_string_constant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * Halide::Internal::CodeGen_LLVM::create_string_constant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put a string constant in the module as a global variable and return a pointer to it. </p>

</div>
</div>
<a id="a07bdf6abc8b32c3e7ebf6e293594655f" name="a07bdf6abc8b32c3e7ebf6e293594655f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bdf6abc8b32c3e7ebf6e293594655f">&#9670;&#160;</a></span>create_binary_blob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * Halide::Internal::CodeGen_LLVM::create_binary_blob </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>constant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put a binary blob in the module as a global variable and return a pointer to it. </p>

</div>
</div>
<a id="a4e3dab69ec0a2fb55376e35632c43858" name="a4e3dab69ec0a2fb55376e35632c43858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3dab69ec0a2fb55376e35632c43858">&#9670;&#160;</a></span>create_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::create_broadcast </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Widen an llvm scalar into an llvm vector with the given number of lanes. </p>

</div>
</div>
<a id="aa22fbf9ebe09b7fc5720c5000680e504" name="aa22fbf9ebe09b7fc5720c5000680e504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22fbf9ebe09b7fc5720c5000680e504">&#9670;&#160;</a></span>codegen_buffer_pointer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::codegen_buffer_pointer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pointer into a named buffer at a given index, of a given type. </p>
<p>The index counts according to the scalar type of the type passed in. </p>

</div>
</div>
<a id="a25321b123adfe0419f330cc8c621e314" name="a25321b123adfe0419f330cc8c621e314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25321b123adfe0419f330cc8c621e314">&#9670;&#160;</a></span>codegen_buffer_pointer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::codegen_buffer_pointer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac74a28e726b99f1059bddfe75c5ad6ce" name="ac74a28e726b99f1059bddfe75c5ad6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74a28e726b99f1059bddfe75c5ad6ce">&#9670;&#160;</a></span>codegen_buffer_pointer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::codegen_buffer_pointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>base_address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce049528d7c5cb70e7bbde906216c2e" name="a3ce049528d7c5cb70e7bbde906216c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce049528d7c5cb70e7bbde906216c2e">&#9670;&#160;</a></span>codegen_buffer_pointer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::codegen_buffer_pointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>base_address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f70b9db0fb2c148635730704a7846e2" name="a9f70b9db0fb2c148635730704a7846e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f70b9db0fb2c148635730704a7846e2">&#9670;&#160;</a></span>mangle_llvm_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::CodeGen_LLVM::mangle_llvm_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return type string for LLVM type using LLVM IR intrinsic type mangling. </p>
<p>E.g. ".i32 or ".f32" for scalars, ".p0" for pointers,
".nxv4i32" for a scalable vector of four 32-bit integers,
or ".v4f32" for a fixed vector of four 32-bit floats. The dot is included in the result. </p>

</div>
</div>
<a id="ab9f79b17cb7dc1875476ba83ca5d0015" name="ab9f79b17cb7dc1875476ba83ca5d0015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f79b17cb7dc1875476ba83ca5d0015">&#9670;&#160;</a></span>make_halide_type_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::make_halide_type_t </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> into an llvm::Value representing a constant <a class="el" href="structhalide__type__t.html" title="A runtime tag for a type in the halide type system.">halide_type_t</a>. </p>

</div>
</div>
<a id="aa5c07d83cbb6f29b7753bd8ad41da6ac" name="aa5c07d83cbb6f29b7753bd8ad41da6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c07d83cbb6f29b7753bd8ad41da6ac">&#9670;&#160;</a></span>add_tbaa_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::add_tbaa_metadata </td>
          <td>(</td>
          <td class="paramtype">llvm::Instruction *</td>          <td class="paramname"><span class="paramname"><em>inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark a load or store with type-based-alias-analysis metadata so that llvm knows it can reorder loads and stores across different buffers. </p>

</div>
</div>
<a id="a97c6992af87f6076d29644ae6885e86b" name="a97c6992af87f6076d29644ae6885e86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c6992af87f6076d29644ae6885e86b">&#9670;&#160;</a></span>get_allocation_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Halide::Internal::CodeGen_LLVM::get_allocation_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a unique name for the actual block of memory that an allocate node uses. </p>
<p>Used so that alias analysis understands when multiple <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> nodes shared the same memory. </p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a88e12eb33136e87eb8e499ecc2bf8be8">Halide::Internal::CodeGen_Posix</a>.</p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00324">324</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ad9c4f607250525b19bd9e1d2b5bd6515" name="ad9c4f607250525b19bd9e1d2b5bd6515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c4f607250525b19bd9e1d2b5bd6515">&#9670;&#160;</a></span>function_does_not_access_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::function_does_not_access_memory </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> the appropriate function attribute to tell LLVM that the function doesn't access memory. </p>

</div>
</div>
<a id="ad6be7d801b1c3ae8899b6afc4c233ff1" name="ad6be7d801b1c3ae8899b6afc4c233ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6be7d801b1c3ae8899b6afc4c233ff1">&#9670;&#160;</a></span>visit() <span class="overload">[1/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate code for various IR nodes. </p>
<p>These can be overridden by architecture-specific code to perform peephole optimizations. The result of each is stored in <a class="el" href="#a0119d82814d12292a89cf3836a00c710">value</a> </p>

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a93f91cea5a783c0319c73fb7e6246167">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ad6be7d801b1c3ae8899b6afc4c233ff1">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="afa0437b1914fa6876bbe31c919e3651c" name="afa0437b1914fa6876bbe31c919e3651c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0437b1914fa6876bbe31c919e3651c">&#9670;&#160;</a></span>visit() <span class="overload">[2/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html">UIntImm</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a706a1e8fa36baf8629429a065134d55a">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#afa0437b1914fa6876bbe31c919e3651c">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ad6b0665827fbf21713f835301c2662e5" name="ad6b0665827fbf21713f835301c2662e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b0665827fbf21713f835301c2662e5">&#9670;&#160;</a></span>visit() <span class="overload">[3/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a7485f3d7c5d57a253baa9853ca80bcac">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ad6b0665827fbf21713f835301c2662e5">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="aab70d995e94fae105f05720babe3e61f" name="aab70d995e94fae105f05720babe3e61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab70d995e94fae105f05720babe3e61f">&#9670;&#160;</a></span>visit() <span class="overload">[4/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a59d4fbe82778b579db8548064d784134">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#aab70d995e94fae105f05720babe3e61f">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ab39d72c53c2bf3bf9bf813c0fd4daee6" name="ab39d72c53c2bf3bf9bf813c0fd4daee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39d72c53c2bf3bf9bf813c0fd4daee6">&#9670;&#160;</a></span>visit() <span class="overload">[5/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#af89f42849faa3fc737b8acfee95cacc7">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ab39d72c53c2bf3bf9bf813c0fd4daee6">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a3bdfd1f75dfa3abea6006c25c83631a5" name="a3bdfd1f75dfa3abea6006c25c83631a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdfd1f75dfa3abea6006c25c83631a5">&#9670;&#160;</a></span>visit() <span class="overload">[6/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_reinterpret.html">Reinterpret</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ac8406406e0435cfbefbdd17129aa8570">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a3bdfd1f75dfa3abea6006c25c83631a5">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a5e487141d83fda347874c102904bc2d7" name="a5e487141d83fda347874c102904bc2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e487141d83fda347874c102904bc2d7">&#9670;&#160;</a></span>visit() <span class="overload">[7/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ab043c56a00839d20a5c734c84a5c9c8f">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a5e487141d83fda347874c102904bc2d7">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="af4e7abe108d9e092cafbb04cfb8f7712" name="af4e7abe108d9e092cafbb04cfb8f7712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e7abe108d9e092cafbb04cfb8f7712">&#9670;&#160;</a></span>visit() <span class="overload">[8/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#abb0a6b6d244182ba97684afd1915d8a8">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#af4e7abe108d9e092cafbb04cfb8f7712">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a3dc6ff2a8e9de4611c47e7a94a4e8e1f" name="a3dc6ff2a8e9de4611c47e7a94a4e8e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc6ff2a8e9de4611c47e7a94a4e8e1f">&#9670;&#160;</a></span>visit() <span class="overload">[9/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a2e7eb1e3f5d3579a5596e63932bfcd1b">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a3dc6ff2a8e9de4611c47e7a94a4e8e1f">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a159efa721a3eca0acbfadd8c453bbc86" name="a159efa721a3eca0acbfadd8c453bbc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159efa721a3eca0acbfadd8c453bbc86">&#9670;&#160;</a></span>visit() <span class="overload">[10/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a0cba90cc11b924a157e1ac597e863487">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a159efa721a3eca0acbfadd8c453bbc86">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a77fd0c7dffaf8adcb0ce26c5b14055f7" name="a77fd0c7dffaf8adcb0ce26c5b14055f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fd0c7dffaf8adcb0ce26c5b14055f7">&#9670;&#160;</a></span>visit() <span class="overload">[11/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a1f4190ff4f8227f79b5651eb893acb43">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a77fd0c7dffaf8adcb0ce26c5b14055f7">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ab81cd4be6209bbbaf477d452ba3a41af" name="ab81cd4be6209bbbaf477d452ba3a41af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81cd4be6209bbbaf477d452ba3a41af">&#9670;&#160;</a></span>visit() <span class="overload">[12/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a815bf772979f4920017d78e8b67f2db8">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ab81cd4be6209bbbaf477d452ba3a41af">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a3c41a23b6ca803904e0e3d25f79ba913" name="a3c41a23b6ca803904e0e3d25f79ba913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c41a23b6ca803904e0e3d25f79ba913">&#9670;&#160;</a></span>visit() <span class="overload">[13/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#aaf0bb1168612d9b2af5769112f9d4800">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a3c41a23b6ca803904e0e3d25f79ba913">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a5241a4fc6590c660621cdcd3a6b37101" name="a5241a4fc6590c660621cdcd3a6b37101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5241a4fc6590c660621cdcd3a6b37101">&#9670;&#160;</a></span>visit() <span class="overload">[14/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a15d7937037589fc3f0b2e04d5541b7f8">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a5241a4fc6590c660621cdcd3a6b37101">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a7c2594e9ec81b3ba791f8d8cc1f582ec" name="a7c2594e9ec81b3ba791f8d8cc1f582ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2594e9ec81b3ba791f8d8cc1f582ec">&#9670;&#160;</a></span>visit() <span class="overload">[15/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a9c2ed8e6d068c5d17798277c9dce2cb6">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a7c2594e9ec81b3ba791f8d8cc1f582ec">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="aa402a5a6b2998cf3ff9a343b507c28a2" name="aa402a5a6b2998cf3ff9a343b507c28a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa402a5a6b2998cf3ff9a343b507c28a2">&#9670;&#160;</a></span>visit() <span class="overload">[16/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a03a86e3dc10f4c5fc6e18295a114b179">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#aa402a5a6b2998cf3ff9a343b507c28a2">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="acf9e833a4d35f85c21cc9ac6bbdbe374" name="acf9e833a4d35f85c21cc9ac6bbdbe374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9e833a4d35f85c21cc9ac6bbdbe374">&#9670;&#160;</a></span>visit() <span class="overload">[17/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#af828ec4e79259412da832262c52ee77e">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#acf9e833a4d35f85c21cc9ac6bbdbe374">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="aa0cebb5d4b80543155cf06d3f68f18cf" name="aa0cebb5d4b80543155cf06d3f68f18cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cebb5d4b80543155cf06d3f68f18cf">&#9670;&#160;</a></span>visit() <span class="overload">[18/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a356d79edb2ce1f65333bc2680793464c">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#aa0cebb5d4b80543155cf06d3f68f18cf">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ab1294b9a1320d4efe965cf524681aee4" name="ab1294b9a1320d4efe965cf524681aee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1294b9a1320d4efe965cf524681aee4">&#9670;&#160;</a></span>visit() <span class="overload">[19/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a79c90ad85366c4c5573fa3177f0677cf">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ab1294b9a1320d4efe965cf524681aee4">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a59e33f468f9c83e0a845621d42489450" name="a59e33f468f9c83e0a845621d42489450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e33f468f9c83e0a845621d42489450">&#9670;&#160;</a></span>visit() <span class="overload">[20/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a53200324df64181decac6753788a7596">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a59e33f468f9c83e0a845621d42489450">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="aa5e5dadb48781d6c4f260096247d58fc" name="aa5e5dadb48781d6c4f260096247d58fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e5dadb48781d6c4f260096247d58fc">&#9670;&#160;</a></span>visit() <span class="overload">[21/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#adc4dedabca91f06f8cd79ccad59a0085">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#aa5e5dadb48781d6c4f260096247d58fc">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a0cde0537b0d95684cd117f7afa57bee3" name="a0cde0537b0d95684cd117f7afa57bee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cde0537b0d95684cd117f7afa57bee3">&#9670;&#160;</a></span>visit() <span class="overload">[22/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a94abb37814ff3a700a594a3050fbc1b3">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a0cde0537b0d95684cd117f7afa57bee3">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a3d1cc5d28d68fecc8dc5839f9b335ac1" name="a3d1cc5d28d68fecc8dc5839f9b335ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1cc5d28d68fecc8dc5839f9b335ac1">&#9670;&#160;</a></span>visit() <span class="overload">[23/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#afad8ce0a4d91e42a68d08645ca42fc7a">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a3d1cc5d28d68fecc8dc5839f9b335ac1">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a0ab426e2ffbab5e4d24e1db29a563e2f" name="a0ab426e2ffbab5e4d24e1db29a563e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab426e2ffbab5e4d24e1db29a563e2f">&#9670;&#160;</a></span>visit() <span class="overload">[24/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a1ab1fa46e0a573decba7767ff549fb4c">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a0ab426e2ffbab5e4d24e1db29a563e2f">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="acfb37970fafc7e161950ab98a16d458d" name="acfb37970fafc7e161950ab98a16d458d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb37970fafc7e161950ab98a16d458d">&#9670;&#160;</a></span>visit() <span class="overload">[25/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a1acfa0f1cc4243a10d3caf3f9c5479f0">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#acfb37970fafc7e161950ab98a16d458d">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ab3f58d86c4686df1287c117752a7302c" name="ab3f58d86c4686df1287c117752a7302c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f58d86c4686df1287c117752a7302c">&#9670;&#160;</a></span>visit() <span class="overload">[26/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a8dc4b0bc6f6145753be0b2e603ab6156">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ab3f58d86c4686df1287c117752a7302c">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ab78a3df69e81eae2fcb16e293e992c23" name="ab78a3df69e81eae2fcb16e293e992c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78a3df69e81eae2fcb16e293e992c23">&#9670;&#160;</a></span>visit() <span class="overload">[27/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a9e055e3aa387d4ce5a45fd097ccd1c45">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ab78a3df69e81eae2fcb16e293e992c23">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="abaf44187968b3f2d06b32a219d5e91af" name="abaf44187968b3f2d06b32a219d5e91af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf44187968b3f2d06b32a219d5e91af">&#9670;&#160;</a></span>visit() <span class="overload">[28/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a9e4e66050ac47ad1219f72ed966589df">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#abaf44187968b3f2d06b32a219d5e91af">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a01a1e0751c39ee0982c5abc7cdf94ece" name="a01a1e0751c39ee0982c5abc7cdf94ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a1e0751c39ee0982c5abc7cdf94ece">&#9670;&#160;</a></span>visit() <span class="overload">[29/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#afcb726e59fd040c8a3759e775b430c23">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a01a1e0751c39ee0982c5abc7cdf94ece">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="afaaa6cad821f79dd4cfc9313a9df1ba7" name="afaaa6cad821f79dd4cfc9313a9df1ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaaa6cad821f79dd4cfc9313a9df1ba7">&#9670;&#160;</a></span>visit() <span class="overload">[30/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ae787f737dd34906d18ad739f67d66d23">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#afaaa6cad821f79dd4cfc9313a9df1ba7">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a0db1e694735abbcbffd69ea52b7b3c0b" name="a0db1e694735abbcbffd69ea52b7b3c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db1e694735abbcbffd69ea52b7b3c0b">&#9670;&#160;</a></span>visit() <span class="overload">[31/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ad3e6d5d63ab4841ec3d4903c7e7a4c34">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a0db1e694735abbcbffd69ea52b7b3c0b">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="acbf2b65f2a3e188939deee35ad7cbbe1" name="acbf2b65f2a3e188939deee35ad7cbbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf2b65f2a3e188939deee35ad7cbbe1">&#9670;&#160;</a></span>visit() <span class="overload">[32/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_producer_consumer.html">ProducerConsumer</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a44e92f696042c322f1dc6d60dc82d5ae">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#acbf2b65f2a3e188939deee35ad7cbbe1">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a3c5d31e6bd523189474c784cc2845f9d" name="a3c5d31e6bd523189474c784cc2845f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5d31e6bd523189474c784cc2845f9d">&#9670;&#160;</a></span>visit() <span class="overload">[33/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a66041a2278c8a881e7917238d0bed065">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a3c5d31e6bd523189474c784cc2845f9d">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ac0577638683640757e861d9b3e8fde3c" name="ac0577638683640757e861d9b3e8fde3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0577638683640757e861d9b3e8fde3c">&#9670;&#160;</a></span>visit() <span class="overload">[34/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#af0e1a3b165a5d84e2482a6bde1a21f76">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ac0577638683640757e861d9b3e8fde3c">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="af83db52caca7ab618661ca0f9ce196cb" name="af83db52caca7ab618661ca0f9ce196cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83db52caca7ab618661ca0f9ce196cb">&#9670;&#160;</a></span>visit() <span class="overload">[35/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a670cb7d2873abda271ab1bdb35b97a17">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#af83db52caca7ab618661ca0f9ce196cb">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ae37d8e543796575154b0fbd858a50b04" name="ae37d8e543796575154b0fbd858a50b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37d8e543796575154b0fbd858a50b04">&#9670;&#160;</a></span>visit() <span class="overload">[36/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a60111e17b4a20d687331555bd9a93421">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ae37d8e543796575154b0fbd858a50b04">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a9e0d62ca359f2c13797040ceb70b16c9" name="a9e0d62ca359f2c13797040ceb70b16c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0d62ca359f2c13797040ceb70b16c9">&#9670;&#160;</a></span>visit() <span class="overload">[37/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#accb8d772e0c943e2f2e99b4808cb73ef">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a9e0d62ca359f2c13797040ceb70b16c9">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a6b81f5c4e3a329c1882853c8e7375ec9" name="a6b81f5c4e3a329c1882853c8e7375ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b81f5c4e3a329c1882853c8e7375ec9">&#9670;&#160;</a></span>visit() <span class="overload">[38/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_shuffle.html">Shuffle</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ac6f4c0977cc05e692cb964ea55293e58">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a6b81f5c4e3a329c1882853c8e7375ec9">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ae357edaf56bde8a99e72c2af5f914b50" name="ae357edaf56bde8a99e72c2af5f914b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357edaf56bde8a99e72c2af5f914b50">&#9670;&#160;</a></span>visit() <span class="overload">[39/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html">VectorReduce</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a4cb320bd50652611ad4e26abd0811d94">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ae357edaf56bde8a99e72c2af5f914b50">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a6f63d40641f1ec5b47e159efe8233702" name="a6f63d40641f1ec5b47e159efe8233702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f63d40641f1ec5b47e159efe8233702">&#9670;&#160;</a></span>visit() <span class="overload">[40/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_prefetch.html">Prefetch</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a66d43ff91a52aa89bb8f9896f20c2c5c">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a6f63d40641f1ec5b47e159efe8233702">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a63bb25571f9302f0f012372b6f26dae4" name="a63bb25571f9302f0f012372b6f26dae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bb25571f9302f0f012372b6f26dae4">&#9670;&#160;</a></span>visit() <span class="overload">[41/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_atomic.html">Atomic</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a8ae28ed61752aa323cf8012db1097c64">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a63bb25571f9302f0f012372b6f26dae4">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a6d2a9f3073ef0976954acab5709172d2" name="a6d2a9f3073ef0976954acab5709172d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2a9f3073ef0976954acab5709172d2">&#9670;&#160;</a></span>visit() <span class="overload">[42/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate code for an allocate node. </p>
<p>It has no default implementation - it must be handled in an architecture-specific way. </p>

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a59e7c9bfa37bbe6c0ca6a4d87dc41267">Halide::Internal::IRVisitor</a>.</p>

<p>Implemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a7297d8a0efe1a67253aed9a48b31544a">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="af45e768152265f200176a81053ed7071" name="af45e768152265f200176a81053ed7071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45e768152265f200176a81053ed7071">&#9670;&#160;</a></span>visit() <span class="overload">[43/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate code for a free node. </p>
<p>It has no default implementation and must be handled in an architecture-specific way. </p>

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a915308e2c9768a67136cc9a6ab5a0421">Halide::Internal::IRVisitor</a>.</p>

<p>Implemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a8fe8aad546099b808903741f3ff6888c">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a7023010280dfaf312ec65b6b51c85b47" name="a7023010280dfaf312ec65b6b51c85b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7023010280dfaf312ec65b6b51c85b47">&#9670;&#160;</a></span>visit() <span class="overload">[44/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These IR nodes should have been removed during lowering. </p>
<p><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html" title="A code generator abstract base class.">CodeGen_LLVM</a> will error out if they are present </p>

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#af49b5db3e65a013ee095de5a43f62c59">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a7023010280dfaf312ec65b6b51c85b47">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="ae34c68b59491d5f0d8f0da070981df26" name="ae34c68b59491d5f0d8f0da070981df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c68b59491d5f0d8f0da070981df26">&#9670;&#160;</a></span>visit() <span class="overload">[45/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#ab737f4dcda27c0fb52e79f10f59e425c">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#ae34c68b59491d5f0d8f0da070981df26">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a188d5ebe162c71eb494c82ddced408b1" name="a188d5ebe162c71eb494c82ddced408b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188d5ebe162c71eb494c82ddced408b1">&#9670;&#160;</a></span>llvm_type_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type * Halide::Internal::CodeGen_LLVM::llvm_type_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the llvm type equivalent to the given halide type in the current context. </p>

</div>
</div>
<a id="aecf1bd01240d5216be2096f7fc7fbd3f" name="aecf1bd01240d5216be2096f7fc7fbd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf1bd01240d5216be2096f7fc7fbd3f">&#9670;&#160;</a></span>llvm_type_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::llvm_type_of </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>effective_vscale</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>
<p>If effective_vscale is nonzero and the type is a vector type with lanes a multiple of effective_vscale, a scalable vector type is generated with total lanes divided by effective_vscale. That is a scalable vector intended to be used with a fixed vscale of effective_vscale. </p>

</div>
</div>
<a id="a900b3ddc6397480ba5d20c24c8717377" name="a900b3ddc6397480ba5d20c24c8717377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900b3ddc6397480ba5d20c24c8717377">&#9670;&#160;</a></span>create_alloca_at_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::create_alloca_at_entry </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>zero_initialize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an alloca at the function entrypoint. </p>
<p>Will be cleaned on function exit. </p>

</div>
</div>
<a id="ae1b36b542f6faf3467ef94ec4b75252a" name="ae1b36b542f6faf3467ef94ec4b75252a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b36b542f6faf3467ef94ec4b75252a">&#9670;&#160;</a></span>get_user_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::get_user_context </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The user_context argument. </p>
<p>May be a constant null if the function is being compiled without a user context. </p>

</div>
</div>
<a id="afdd88de3fefa17c44bfeb69b33d457fb" name="afdd88de3fefa17c44bfeb69b33d457fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd88de3fefa17c44bfeb69b33d457fb">&#9670;&#160;</a></span>interleave_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value * Halide::Internal::CodeGen_LLVM::interleave_vectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the intrinsic call to interleave_vectors. </p>
<p>This implementation allows for interleaving an arbitrary number of vectors. </p>

</div>
</div>
<a id="aaeaf4faaf1fb732b1ccd7f13798ea1be" name="aaeaf4faaf1fb732b1ccd7f13798ea1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeaf4faaf1fb732b1ccd7f13798ea1be">&#9670;&#160;</a></span>get_llvm_intrin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * Halide::Internal::CodeGen_LLVM::get_llvm_intrin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ret_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg_types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalars_are_vectors</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an LLVM intrinsic declaration. </p>
<p>If it doesn't exist, it will be created. </p>

</div>
</div>
<a id="a2aad0e1592128e6804c3e484427bd534" name="a2aad0e1592128e6804c3e484427bd534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad0e1592128e6804c3e484427bd534">&#9670;&#160;</a></span>get_llvm_intrin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * Halide::Internal::CodeGen_LLVM::get_llvm_intrin </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>ret_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg_types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad49ba65507c73d9ae7220029e1bb7c92" name="ad49ba65507c73d9ae7220029e1bb7c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49ba65507c73d9ae7220029e1bb7c92">&#9670;&#160;</a></span>declare_intrin_overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * Halide::Internal::CodeGen_LLVM::declare_intrin_overload </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ret_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>impl_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>arg_types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalars_are_vectors</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare an intrinsic function that participates in overload resolution. </p>

</div>
</div>
<a id="a5fa787d195572d3fce6efa21778d907e" name="a5fa787d195572d3fce6efa21778d907e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa787d195572d3fce6efa21778d907e">&#9670;&#160;</a></span>declare_intrin_overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::CodeGen_LLVM::declare_intrin_overload </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ret_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>impl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>arg_types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd65d081560b01f7a536f73d21198ea8" name="afd65d081560b01f7a536f73d21198ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd65d081560b01f7a536f73d21198ea8">&#9670;&#160;</a></span>call_overloaded_intrin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::call_overloaded_intrin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> an overloaded intrinsic function. </p>
<p>Returns nullptr if no suitable overload is found. </p>

</div>
</div>
<a id="add36168d60c735139c806ebf5431a3e4" name="add36168d60c735139c806ebf5431a3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add36168d60c735139c806ebf5431a3e4">&#9670;&#160;</a></span>call_intrin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::call_intrin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intrin_lanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a call to a vector intrinsic or runtime inlined function. </p>
<p>The arguments are sliced up into vectors of the width given by 'intrin_lanes', the intrinsic is called on each piece, then the results (if any) are concatenated back together into the original type 't'. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the version that takes an llvm::Type *, the type may be void, so the vector width of the arguments must be specified explicitly as 'called_lanes'. </p>

</div>
</div>
<a id="ac0ffcc3c824fc0af67c4598ddfcf7bed" name="ac0ffcc3c824fc0af67c4598ddfcf7bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ffcc3c824fc0af67c4598ddfcf7bed">&#9670;&#160;</a></span>call_intrin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::call_intrin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intrin_lanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>intrin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2038326d14b19bbe4625b018889edb18" name="a2038326d14b19bbe4625b018889edb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2038326d14b19bbe4625b018889edb18">&#9670;&#160;</a></span>call_intrin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::call_intrin </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intrin_lanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalable_vector_result</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_reduction</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1a562ae91292dc37eae90110f78f86a" name="af1a562ae91292dc37eae90110f78f86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a562ae91292dc37eae90110f78f86a">&#9670;&#160;</a></span>call_intrin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::call_intrin </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intrin_lanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>intrin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_reduction</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad438abc50f4ba23d66278c97d2e1394b" name="ad438abc50f4ba23d66278c97d2e1394b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438abc50f4ba23d66278c97d2e1394b">&#9670;&#160;</a></span>slice_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value * Halide::Internal::CodeGen_LLVM::slice_vector </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a slice of lanes out of an llvm vector. </p>
<p>Pads with undefs if you ask for more lanes than the vector has. </p>

</div>
</div>
<a id="a866a80ffd295c6876a8327d99888afe9" name="a866a80ffd295c6876a8327d99888afe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866a80ffd295c6876a8327d99888afe9">&#9670;&#160;</a></span>concat_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value * Halide::Internal::CodeGen_LLVM::concat_vectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate a bunch of llvm vectors. </p>
<p>Must be of the same type. </p>

</div>
</div>
<a id="acc33abd5ef0b3f06d768517e517117a6" name="acc33abd5ef0b3f06d768517e517117a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc33abd5ef0b3f06d768517e517117a6">&#9670;&#160;</a></span>shuffle_vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value * Halide::Internal::CodeGen_LLVM::shuffle_vectors </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an LLVM shuffle vectors instruction. </p>
<p>Takes a combination of fixed or scalable vectors as input, so long as the effective lengths match, but always returns a fixed vector. </p>

</div>
</div>
<a id="af45e786fc70bfa450d0793bd96c7feb6" name="af45e786fc70bfa450d0793bd96c7feb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45e786fc70bfa450d0793bd96c7feb6">&#9670;&#160;</a></span>shuffle_vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::shuffle_vectors </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shorthand for shuffling a single vector. </p>

</div>
</div>
<a id="a0550f2399fd4b99b09359217987511c9" name="a0550f2399fd4b99b09359217987511c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0550f2399fd4b99b09359217987511c9">&#9670;&#160;</a></span>find_vector_runtime_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; llvm::Function *, int &gt; Halide::Internal::CodeGen_LLVM::find_vector_runtime_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go looking for a vector version of a runtime function. </p>
<p>Will return the best match. Matches in the following order:</p>
<p>1) The requested vector width.</p>
<p>2) The width which is the smallest power of two greater than or equal to the vector width.</p>
<p>3) All the factors of 2) greater than one, in decreasing order.</p>
<p>4) The smallest power of two not yet tried.</p>
<p>So for a 5-wide vector, it tries: 5, 8, 4, 2, 16.</p>
<p>If there's no match, returns (nullptr, 0). </p>

</div>
</div>
<a id="a16955a29a09bb79ab24c9953d3fb4b29" name="a16955a29a09bb79ab24c9953d3fb4b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16955a29a09bb79ab24c9953d3fb4b29">&#9670;&#160;</a></span>supports_atomic_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Halide::Internal::CodeGen_LLVM::supports_atomic_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab98b8eb6f60946158278712d9128d9b" name="aab98b8eb6f60946158278712d9128d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab98b8eb6f60946158278712d9128d9b">&#9670;&#160;</a></span>codegen_vector_reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::CodeGen_LLVM::codegen_vector_reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html">VectorReduce</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile a horizontal reduction that starts with an explicit initial value. </p>
<p>There are lots of complex ways to peephole optimize this pattern, especially with the proliferation of dot-product instructions, and they can usefully share logic across backends. </p>

</div>
</div>
<a id="af9b159c510f7bf7df8f72cd0716a3ae2" name="af9b159c510f7bf7df8f72cd0716a3ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b159c510f7bf7df8f72cd0716a3ae2">&#9670;&#160;</a></span>supports_call_as_float16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Halide::Internal::CodeGen_LLVM::supports_call_as_float16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can we call this operation with float16 type? This is used to avoid "emulated" equivalent code-gen in case target has FP16 feature. </p>

</div>
</div>
<a id="abbde979880a7a68b15a53b6e31ed7c71" name="abbde979880a7a68b15a53b6e31ed7c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbde979880a7a68b15a53b6e31ed7c71">&#9670;&#160;</a></span>simple_call_intrin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::simple_call_intrin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>intrin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>result_type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>call_intrin does far too much to be useful and generally breaks things when one has carefully set things up for a specific architecture. </p>
<p>This just does the bare minimum. call_intrin should be refactored and could call this, possibly with renaming of the methods. </p>

</div>
</div>
<a id="a7592b08166d80aafc4f6018be28ceea8" name="a7592b08166d80aafc4f6018be28ceea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7592b08166d80aafc4f6018be28ceea8">&#9670;&#160;</a></span>normalize_fixed_scalable_vector_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::normalize_fixed_scalable_vector_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>desired_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that a vector value is either fixed or vscale depending to match desired_type. </p>

</div>
</div>
<a id="ad384439fc88aa9e77cd3e08db13756f4" name="ad384439fc88aa9e77cd3e08db13756f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad384439fc88aa9e77cd3e08db13756f4">&#9670;&#160;</a></span>convert_fixed_or_scalable_vector_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::convert_fixed_or_scalable_vector_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>desired_type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> between two LLVM vectors of potentially different scalable/fixed and size. </p>
<p>Used to handle converting to/from fixed vectors that are smaller than the minimum size scalable vector. </p>

</div>
</div>
<a id="ab14e8ccbc3bb71669fdfe5e4f024416e" name="ab14e8ccbc3bb71669fdfe5e4f024416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14e8ccbc3bb71669fdfe5e4f024416e">&#9670;&#160;</a></span>fixed_to_scalable_vector_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::fixed_to_scalable_vector_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>fixed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> an LLVM fixed vector value to the corresponding vscale vector value. </p>

</div>
</div>
<a id="aed469691cf4c94f02759a7e0b43b8f91" name="aed469691cf4c94f02759a7e0b43b8f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed469691cf4c94f02759a7e0b43b8f91">&#9670;&#160;</a></span>scalable_to_fixed_vector_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::scalable_to_fixed_vector_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>scalable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> an LLVM vscale vector value to the corresponding fixed vector value. </p>

</div>
</div>
<a id="ac070eea2c1c9913134c9fc2e6766d0c6" name="ac070eea2c1c9913134c9fc2e6766d0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac070eea2c1c9913134c9fc2e6766d0c6">&#9670;&#160;</a></span>get_vector_num_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::CodeGen_LLVM::get_vector_num_elements </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of vector elements, taking into account scalable vectors. </p>
<p>Returns 1 for scalars. </p>

</div>
</div>
<a id="aff7b86e371ef5afc01ec3edeaf9d885b" name="aff7b86e371ef5afc01ec3edeaf9d885b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7b86e371ef5afc01ec3edeaf9d885b">&#9670;&#160;</a></span>get_vector_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::get_vector_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a></td>          <td class="paramname"><span class="paramname"><em>type_constraint</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754">VectorTypeConstraint::None</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a000b2c21660c4a28ae4c9a29717fd9ea" name="a000b2c21660c4a28ae4c9a29717fd9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000b2c21660c4a28ae4c9a29717fd9ea">&#9670;&#160;</a></span>get_splat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * Halide::Internal::CodeGen_LLVM::get_splat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Constant *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a></td>          <td class="paramname"><span class="paramname"><em>type_constraint</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625a6adf97f83acf6453d4a6a4b1070f3754">VectorTypeConstraint::None</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3ad63a73d169c4a64598a09f987cc5e" name="af3ad63a73d169c4a64598a09f987cc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ad63a73d169c4a64598a09f987cc5e">&#9670;&#160;</a></span>match_vector_type_scalable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::match_vector_type_scalable </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3f3f9a6a0b806dcb0517b4955aa0a625">VectorTypeConstraint</a></td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure a value type has the same scalable/fixed vector type as a guide. </p>

</div>
</div>
<a id="a80c59288d36c086ef2040ca50e38c3d0" name="a80c59288d36c086ef2040ca50e38c3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c59288d36c086ef2040ca50e38c3d0">&#9670;&#160;</a></span>match_vector_type_scalable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::match_vector_type_scalable </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>guide</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94c27113c71ab927042abb3fd4843d65" name="a94c27113c71ab927042abb3fd4843d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c27113c71ab927042abb3fd4843d65">&#9670;&#160;</a></span>match_vector_type_scalable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::match_vector_type_scalable </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>guide</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a495c03b2055c1269f84e95b1feba94d1" name="a495c03b2055c1269f84e95b1feba94d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495c03b2055c1269f84e95b1feba94d1">&#9670;&#160;</a></span>try_vector_predication_comparison()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::CodeGen_LLVM::try_vector_predication_comparison </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acfc056cd4cc8139292ae7268200101c0">MaskVariant</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmp_op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a vector predicated comparison intrinsic call if use_llvm_vp_intrinsics is true and result_type is a vector type. </p>
<p>If generated, assigns result of vp intrinsic to value and returns true if it an instuction is generated, otherwise returns false. </p>

</div>
</div>
<a id="a32e60171d03d635e3f443f311f45377f" name="a32e60171d03d635e3f443f311f45377f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e60171d03d635e3f443f311f45377f">&#9670;&#160;</a></span>try_vector_predication_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::CodeGen_LLVM::try_vector_predication_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_result_type.html">VPResultType</a></td>          <td class="paramname"><span class="paramname"><em>result_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acfc056cd4cc8139292ae7268200101c0">MaskVariant</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_v_p_arg.html">VPArg</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an intrisic call if use_llvm_vp_intrinsics is true and length is greater than 1. </p>
<p>If generated, assigns result of vp intrinsic to value and returns true if it an instuction is generated, otherwise returns false. </p>

</div>
</div>
<a id="a60a31951805271d85f036762be8ada94" name="a60a31951805271d85f036762be8ada94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a31951805271d85f036762be8ada94">&#9670;&#160;</a></span>codegen_dense_vector_load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * Halide::Internal::CodeGen_LLVM::codegen_dense_vector_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a> *</td>          <td class="paramname"><span class="paramname"><em>load</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>vpred</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>slice_to_native</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a basic dense vector load, with an optional predicate and control over whether or not we should slice the load into native vectors. </p>
<p>Used by CodeGen_ARM to help with vld2/3/4 emission. </p>

</div>
</div>
<a id="a2e03d7ecc708ceb97015b15cfe526ad9" name="a2e03d7ecc708ceb97015b15cfe526ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e03d7ecc708ceb97015b15cfe526ad9">&#9670;&#160;</a></span>visit() <span class="overload">[46/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::IRVisitor::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_fork.html">Fork</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a2e03d7ecc708ceb97015b15cfe526ad9">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a2e03d7ecc708ceb97015b15cfe526ad9">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a81a4420cc8b07c9e3a199639b79802b4" name="a81a4420cc8b07c9e3a199639b79802b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a4420cc8b07c9e3a199639b79802b4">&#9670;&#160;</a></span>visit() <span class="overload">[47/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::IRVisitor::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_acquire.html">Acquire</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a81a4420cc8b07c9e3a199639b79802b4">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a81a4420cc8b07c9e3a199639b79802b4">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<a id="a742fd9bc6624a1a3500ea96b7cf4531e" name="a742fd9bc6624a1a3500ea96b7cf4531e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742fd9bc6624a1a3500ea96b7cf4531e">&#9670;&#160;</a></span>visit() <span class="overload">[48/48]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Halide::Internal::IRVisitor::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_hoisted_storage.html">HoistedStorage</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html#a742fd9bc6624a1a3500ea96b7cf4531e">Halide::Internal::IRVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html#a742fd9bc6624a1a3500ea96b7cf4531e">Halide::Internal::CodeGen_Posix</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4f28718479886e14dace03ce3a4e96d4" name="a4f28718479886e14dace03ce3a4e96d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f28718479886e14dace03ce3a4e96d4">&#9670;&#160;</a></span>module</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::CodeGen_LLVM::module</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00164">164</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a5910d641bc9fdd7a33feded6ae2b5232" name="a5910d641bc9fdd7a33feded6ae2b5232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5910d641bc9fdd7a33feded6ae2b5232">&#9670;&#160;</a></span>function</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function* Halide::Internal::CodeGen_LLVM::function = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00165">165</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a877b0f3d432ba326f51974e5861c20de" name="a877b0f3d432ba326f51974e5861c20de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877b0f3d432ba326f51974e5861c20de">&#9670;&#160;</a></span>context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::LLVMContext* Halide::Internal::CodeGen_LLVM::context = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00166">166</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a4c40d7a78bcbd75d7bf38a7647ac9ac7" name="a4c40d7a78bcbd75d7bf38a7647ac9ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c40d7a78bcbd75d7bf38a7647ac9ac7">&#9670;&#160;</a></span>builder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt;llvm::ConstantFolder, llvm::IRBuilderDefaultInserter&gt; &gt; Halide::Internal::CodeGen_LLVM::builder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00167">167</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a0119d82814d12292a89cf3836a00c710" name="a0119d82814d12292a89cf3836a00c710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0119d82814d12292a89cf3836a00c710">&#9670;&#160;</a></span>value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* Halide::Internal::CodeGen_LLVM::value = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00168">168</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a6ca7476bab4d0bd74a68f05a8fe4ee4f" name="a6ca7476bab4d0bd74a68f05a8fe4ee4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca7476bab4d0bd74a68f05a8fe4ee4f">&#9670;&#160;</a></span>very_likely_branch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::MDNode* Halide::Internal::CodeGen_LLVM::very_likely_branch = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00169">169</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="af158c6cf53003f8132ab316d0b883872" name="af158c6cf53003f8132ab316d0b883872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af158c6cf53003f8132ab316d0b883872">&#9670;&#160;</a></span>default_fp_math_md</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::MDNode* Halide::Internal::CodeGen_LLVM::default_fp_math_md = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00170">170</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="adcdced1fc6b947dbbf463342b9b732a8" name="adcdced1fc6b947dbbf463342b9b732a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdced1fc6b947dbbf463342b9b732a8">&#9670;&#160;</a></span>strict_fp_math_md</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::MDNode* Halide::Internal::CodeGen_LLVM::strict_fp_math_md = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00171">171</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a19ed3189a07c7edb84460af09ccdb6c9" name="a19ed3189a07c7edb84460af09ccdb6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ed3189a07c7edb84460af09ccdb6c9">&#9670;&#160;</a></span>current_function_args</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a>&gt; Halide::Internal::CodeGen_LLVM::current_function_args</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00172">172</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a47c0da8b30234e39d27645a522e91a10" name="a47c0da8b30234e39d27645a522e91a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c0da8b30234e39d27645a522e91a10">&#9670;&#160;</a></span>target</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Halide::Target</a> Halide::Internal::CodeGen_LLVM::target</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The target we're generating code for. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00175">175</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00068">get_target()</a>.</p>

</div>
</div>
<a id="afb643b91f22fe85391c4ec6fbf40bcc0" name="afb643b91f22fe85391c4ec6fbf40bcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb643b91f22fe85391c4ec6fbf40bcc0">&#9670;&#160;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* Halide::Internal::CodeGen_LLVM::void_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some useful llvm types. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a8663cf327697bb374832ef78af23a5ae" name="a8663cf327697bb374832ef78af23a5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8663cf327697bb374832ef78af23a5ae">&#9670;&#160;</a></span>i1_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::i1_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a82b13f959c70f7498077f8816fde5763" name="a82b13f959c70f7498077f8816fde5763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b13f959c70f7498077f8816fde5763">&#9670;&#160;</a></span>i8_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::i8_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a4c507faf4417eaf1b8cafd7e8c9b9ea4" name="a4c507faf4417eaf1b8cafd7e8c9b9ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c507faf4417eaf1b8cafd7e8c9b9ea4">&#9670;&#160;</a></span>i16_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::i16_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ae4599b23ab01f06428ae05dc46a6464d" name="ae4599b23ab01f06428ae05dc46a6464d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4599b23ab01f06428ae05dc46a6464d">&#9670;&#160;</a></span>i32_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::i32_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a18ccd648cd7c6af92b1dcc41226fe2e3" name="a18ccd648cd7c6af92b1dcc41226fe2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ccd648cd7c6af92b1dcc41226fe2e3">&#9670;&#160;</a></span>i64_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::i64_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="afc523eba27ab6ec6d647f0a8039c0ea0" name="afc523eba27ab6ec6d647f0a8039c0ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc523eba27ab6ec6d647f0a8039c0ea0">&#9670;&#160;</a></span>f16_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::f16_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a9371d250123944ce7cbd6917d1bcdc57" name="a9371d250123944ce7cbd6917d1bcdc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9371d250123944ce7cbd6917d1bcdc57">&#9670;&#160;</a></span>f32_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::f32_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a0d481506f1c6cd852726df7e9cd4adfc" name="a0d481506f1c6cd852726df7e9cd4adfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d481506f1c6cd852726df7e9cd4adfc">&#9670;&#160;</a></span>f64_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::CodeGen_LLVM::f64_t = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00210">210</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a7821ab39642a75898c76c16c7b0a4cbd" name="a7821ab39642a75898c76c16c7b0a4cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7821ab39642a75898c76c16c7b0a4cbd">&#9670;&#160;</a></span>halide_buffer_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType* Halide::Internal::CodeGen_LLVM::halide_buffer_t_type = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00211">211</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a3f2c423935f8eb7114a07f716d68ab90" name="a3f2c423935f8eb7114a07f716d68ab90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2c423935f8eb7114a07f716d68ab90">&#9670;&#160;</a></span>type_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::type_t_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00212">212</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a82208322de749e9ef4dc2744946afbe4" name="a82208322de749e9ef4dc2744946afbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82208322de749e9ef4dc2744946afbe4">&#9670;&#160;</a></span>dimension_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::dimension_t_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00213">213</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a056c5571524a7926b91716647a4e3d8b" name="a056c5571524a7926b91716647a4e3d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056c5571524a7926b91716647a4e3d8b">&#9670;&#160;</a></span>metadata_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::metadata_t_type = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00214">214</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a07a0dc00d0309cc9a38280f3a80a28ac" name="a07a0dc00d0309cc9a38280f3a80a28ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0dc00d0309cc9a38280f3a80a28ac">&#9670;&#160;</a></span>argument_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::argument_t_type = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00215">215</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a4c00c39835429be838307d97942648d2" name="a4c00c39835429be838307d97942648d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c00c39835429be838307d97942648d2">&#9670;&#160;</a></span>scalar_value_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::scalar_value_t_type = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00216">216</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a13530696bc30f7f0541f7506d44b51b8" name="a13530696bc30f7f0541f7506d44b51b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13530696bc30f7f0541f7506d44b51b8">&#9670;&#160;</a></span>device_interface_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::device_interface_t_type = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00217">217</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="aeabe32280d026b804e121c015a300b07" name="aeabe32280d026b804e121c015a300b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabe32280d026b804e121c015a300b07">&#9670;&#160;</a></span>pseudostack_slot_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::pseudostack_slot_t_type = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00218">218</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a15a3e86740275b085e03e8e97f839da5" name="a15a3e86740275b085e03e8e97f839da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a3e86740275b085e03e8e97f839da5">&#9670;&#160;</a></span>semaphore_t_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::CodeGen_LLVM::semaphore_t_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00219">219</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ae7454f0492a21a982e77026f277ae0f6" name="ae7454f0492a21a982e77026f277ae0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7454f0492a21a982e77026f277ae0f6">&#9670;&#160;</a></span>wild_u1x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u1x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some wildcard variables used for peephole optimizations in subclasses. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00226">226</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a391e61618d6413924d1a40557a91c80d" name="a391e61618d6413924d1a40557a91c80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391e61618d6413924d1a40557a91c80d">&#9670;&#160;</a></span>wild_i8x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i8x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00226">226</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a7eafcdfb329717fd4e8213d26cd8a71e" name="a7eafcdfb329717fd4e8213d26cd8a71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eafcdfb329717fd4e8213d26cd8a71e">&#9670;&#160;</a></span>wild_u8x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u8x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00226">226</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a8d767e754a9570f8cd9ea3249a532912" name="a8d767e754a9570f8cd9ea3249a532912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d767e754a9570f8cd9ea3249a532912">&#9670;&#160;</a></span>wild_i16x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i16x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00226">226</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ae8585ddda6b88bb4b5e3ac19a986df0e" name="ae8585ddda6b88bb4b5e3ac19a986df0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8585ddda6b88bb4b5e3ac19a986df0e">&#9670;&#160;</a></span>wild_u16x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u16x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00226">226</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="af4dc46061602bf06a8e215320c940ba6" name="af4dc46061602bf06a8e215320c940ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dc46061602bf06a8e215320c940ba6">&#9670;&#160;</a></span>wild_i32x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i32x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00227">227</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="aebac4670e5958f81a1a29f0c88138f22" name="aebac4670e5958f81a1a29f0c88138f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac4670e5958f81a1a29f0c88138f22">&#9670;&#160;</a></span>wild_u32x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u32x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00227">227</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="aeda0db60a1b3e7ac34f163e12645c529" name="aeda0db60a1b3e7ac34f163e12645c529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda0db60a1b3e7ac34f163e12645c529">&#9670;&#160;</a></span>wild_i64x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i64x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00227">227</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a8ff785d97f2c1f668f175a84124cca54" name="a8ff785d97f2c1f668f175a84124cca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff785d97f2c1f668f175a84124cca54">&#9670;&#160;</a></span>wild_u64x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u64x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00227">227</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a62772a48a5b8bb039db2920b6d8fb7b2" name="a62772a48a5b8bb039db2920b6d8fb7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62772a48a5b8bb039db2920b6d8fb7b2">&#9670;&#160;</a></span>wild_f32x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_f32x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00228">228</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a614d085fffcb0ef0c1aef52868b563f4" name="a614d085fffcb0ef0c1aef52868b563f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614d085fffcb0ef0c1aef52868b563f4">&#9670;&#160;</a></span>wild_f64x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_f64x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00228">228</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a5bfbe42f3e2108b471d0070dba2a7564" name="a5bfbe42f3e2108b471d0070dba2a7564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfbe42f3e2108b471d0070dba2a7564">&#9670;&#160;</a></span>wild_u1_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u1_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00231">231</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ac46a1adf1c37c0bce2e46fa9cea0304f" name="ac46a1adf1c37c0bce2e46fa9cea0304f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46a1adf1c37c0bce2e46fa9cea0304f">&#9670;&#160;</a></span>wild_i8_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i8_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00231">231</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ac2f8ac1961b48ad78e63ffc4636c6097" name="ac2f8ac1961b48ad78e63ffc4636c6097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f8ac1961b48ad78e63ffc4636c6097">&#9670;&#160;</a></span>wild_u8_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u8_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00231">231</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ac53740b31129aeca292ade376dcd048f" name="ac53740b31129aeca292ade376dcd048f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53740b31129aeca292ade376dcd048f">&#9670;&#160;</a></span>wild_i16_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i16_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00231">231</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a66765a15c861a3b5f635a109f0f0df40" name="a66765a15c861a3b5f635a109f0f0df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66765a15c861a3b5f635a109f0f0df40">&#9670;&#160;</a></span>wild_u16_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u16_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00231">231</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a4fb0d18f1cfc48e29a104c3d5c41e5bd" name="a4fb0d18f1cfc48e29a104c3d5c41e5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb0d18f1cfc48e29a104c3d5c41e5bd">&#9670;&#160;</a></span>wild_i32_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i32_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00232">232</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a969e74c7a485470024374de00c563c4b" name="a969e74c7a485470024374de00c563c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969e74c7a485470024374de00c563c4b">&#9670;&#160;</a></span>wild_u32_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u32_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00232">232</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a5c92a609e494727af687dae03afe24f0" name="a5c92a609e494727af687dae03afe24f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c92a609e494727af687dae03afe24f0">&#9670;&#160;</a></span>wild_i64_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_i64_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00232">232</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ae2b81caf2b65dcf5e522503c1f4af37e" name="ae2b81caf2b65dcf5e522503c1f4af37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b81caf2b65dcf5e522503c1f4af37e">&#9670;&#160;</a></span>wild_u64_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_u64_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00232">232</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ae17954f48a82e3eaf8eda197b2a0e54e" name="ae17954f48a82e3eaf8eda197b2a0e54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17954f48a82e3eaf8eda197b2a0e54e">&#9670;&#160;</a></span>wild_f32_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_f32_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00233">233</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a1d5178c674d2b2cf0d4b9a6dd4a30461" name="a1d5178c674d2b2cf0d4b9a6dd4a30461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5178c674d2b2cf0d4b9a6dd4a30461">&#9670;&#160;</a></span>wild_f64_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::CodeGen_LLVM::wild_f64_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00233">233</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ae5d7156c51bb2a5a9dd6ed587d5ecb81" name="ae5d7156c51bb2a5a9dd6ed587d5ecb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d7156c51bb2a5a9dd6ed587d5ecb81">&#9670;&#160;</a></span>requested_alloca_total</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> Halide::Internal::CodeGen_LLVM::requested_alloca_total = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A (very) conservative guess at the size of all alloca() storage requested (including alignment padding). </p>
<p>It's currently meant only to be used as a very coarse way to ensure there is enough stack space when testing on the WebAssembly backend.</p>
<p>It is <em>not</em> meant to be a useful proxy for "stack space needed", for a number of reasons:</p><ul>
<li>allocas with non-overlapping lifetimes will share space</li>
<li>on some backends, LLVM may promote register-sized allocas into registers</li>
<li>while this accounts for alloca() calls we know about, it doesn't attempt to account for stack spills, function call overhead, etc. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00429">429</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00084">get_requested_alloca_total()</a>.</p>

</div>
</div>
<a id="a9f2c2af56b0eefd293bb6c8d65a6a8cd" name="a9f2c2af56b0eefd293bb6c8d65a6a8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2c2af56b0eefd293bb6c8d65a6a8cd">&#9670;&#160;</a></span>intrinsics</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___l_l_v_m_1_1_intrinsic.html">Intrinsic</a>&gt; &gt; Halide::Internal::CodeGen_LLVM::intrinsics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapping of intrinsic functions to the various overloads implementing it. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00453">453</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="ad637c306190b4decda583ac1e283433d" name="ad637c306190b4decda583ac1e283433d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad637c306190b4decda583ac1e283433d">&#9670;&#160;</a></span>inside_atomic_mutex_node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::CodeGen_LLVM::inside_atomic_mutex_node = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we inside an atomic node that uses mutex locks? This is used for detecting deadlocks from nested atomics &amp; illegal vectorization. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00529">529</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a0de455cd8309fd52824446ae9d515aec" name="a0de455cd8309fd52824446ae9d515aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de455cd8309fd52824446ae9d515aec">&#9670;&#160;</a></span>emit_atomic_stores</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::CodeGen_LLVM::emit_atomic_stores = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit atomic store instructions? </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00532">532</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a4c9672fcad3720ef452e297556573bd6" name="a4c9672fcad3720ef452e297556573bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9672fcad3720ef452e297556573bd6">&#9670;&#160;</a></span>use_llvm_vp_intrinsics</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::CodeGen_LLVM::use_llvm_vp_intrinsics = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls use of vector predicated intrinsics for vector operations. </p>
<p>Will be set by certain backends (e.g. RISC V) to control codegen. </p>

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00647">647</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<a id="a829073c893d90d987c9d16ac59db5069" name="a829073c893d90d987c9d16ac59db5069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829073c893d90d987c9d16ac59db5069">&#9670;&#160;</a></span>onetime_warnings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="#a7b7e186e1aee1d0a313f7a7c89a58909">WarningKind</a>, std::string&gt; Halide::Internal::CodeGen_LLVM::onetime_warnings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00659">659</a> of file <a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_code_gen___l_l_v_m_8h_source.html">CodeGen_LLVM.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
