<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: tutorial/lesson_09_update_definitions.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tutorial_2lesson_09_update_definitions_8cpp-example.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">tutorial/lesson_09_update_definitions.cpp</div></div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Halide tutorial lesson 9: Multi-pass Funcs, update definitions, and reductions</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On linux, you can compile and run it like so:</span></div>
<div class="line"><span class="comment">// g++ lesson_09*.cpp -g -std=c++17 -I &lt;path/to/Halide.h&gt; -I &lt;path/to/tools/halide_image_io.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide `libpng-config --cflags --ldflags` -ljpeg -lpthread -ldl -fopenmp -o lesson_09</span></div>
<div class="line"><span class="comment">// LD_LIBRARY_PATH=&lt;path/to/libHalide.so&gt; ./lesson_09</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On os x (will only work if you actually have g++, not Apple&#39;s pretend g++ which is actually clang):</span></div>
<div class="line"><span class="comment">// g++ lesson_09*.cpp -g -std=c++17 -I &lt;path/to/Halide.h&gt; -I &lt;path/to/tools/halide_image_io.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide `libpng-config --cflags --ldflags` -ljpeg -fopenmp -o lesson_09</span></div>
<div class="line"><span class="comment">// DYLD_LIBRARY_PATH=&lt;path/to/libHalide.dylib&gt; ./lesson_09</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you have the entire Halide source tree, you can also build it by</span></div>
<div class="line"><span class="comment">// running:</span></div>
<div class="line"><span class="comment">//    make tutorial_lesson_09_update_definitions</span></div>
<div class="line"><span class="comment">// in a shell with the current directory at the top of the halide</span></div>
<div class="line"><span class="comment">// source tree.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Halide.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// We&#39;re going to be using x86 SSE intrinsics later on in this lesson.</span></div>
<div class="line"><span class="preprocessor">#ifdef __SSE2__</span></div>
<div class="line"><span class="preprocessor">#include &lt;emmintrin.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// We&#39;ll also need a clock to do performance testing at the end.</span></div>
<div class="line"><span class="preprocessor">#include &quot;clock.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_halide.html">Halide</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Support code for loading pngs.</span></div>
<div class="line"><span class="preprocessor">#include &quot;halide_image_io.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>Halide::Tools;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="comment">// Declare some Vars to use below.</span></div>
<div class="line">    <a id="_a0" name="_a0"></a><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Load a grayscale image to use as an input.</span></div>
<div class="line">    <a id="_a1" name="_a1"></a><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;uint8_t&gt;</a> input = load_image(<span class="stringliteral">&quot;images/gray.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You can define a Func in multiple passes. Let&#39;s see a toy</span></div>
<div class="line">    <span class="comment">// example first.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The first definition must be one like we have seen already</span></div>
<div class="line">        <span class="comment">// - a mapping from Vars to an Expr:</span></div>
<div class="line">        <a id="_a2" name="_a2"></a><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f;</div>
<div class="line">        f(x, y) = x + y;</div>
<div class="line">        <span class="comment">// We call this first definition the &quot;pure&quot; definition.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// But the later definitions can include computed expressions on</span></div>
<div class="line">        <span class="comment">// both sides. The simplest example is modifying a single point:</span></div>
<div class="line">        f(3, 7) = 42;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We call these extra definitions &quot;update&quot; definitions, or</span></div>
<div class="line">        <span class="comment">// &quot;reduction&quot; definitions. A reduction definition is an</span></div>
<div class="line">        <span class="comment">// update definition that recursively refers back to the</span></div>
<div class="line">        <span class="comment">// function&#39;s current value at the same site:</span></div>
<div class="line">        f(x, y) = f(x, y) + 17;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we confine our update to a single row, we can</span></div>
<div class="line">        <span class="comment">// recursively refer to values in the same column:</span></div>
<div class="line">        f(x, 3) = f(x, 0) * f(x, 10);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Similarly, if we confine our update to a single column, we</span></div>
<div class="line">        <span class="comment">// can recursively refer to other values in the same row.</span></div>
<div class="line">        f(0, y) = f(0, y) / f(3, y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The general rule is: Each Var used in an update definition</span></div>
<div class="line">        <span class="comment">// must appear unadorned in the same position as in the pure</span></div>
<div class="line">        <span class="comment">// definition in all references to the function on the left-</span></div>
<div class="line">        <span class="comment">// and right-hand sides. So the following definitions are</span></div>
<div class="line">        <span class="comment">// legal updates:</span></div>
<div class="line">        f(x, 17) = x + 8;</div>
<div class="line">        f(0, y) = y * 8;</div>
<div class="line">        f(x, x + 1) = x + 8;</div>
<div class="line">        f(y / 2, y) = f(0, y) * 17;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// But these ones would cause an error:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(x, 0) = f(x + 1, 0);</span></div>
<div class="line">        <span class="comment">// First argument to f on the right-hand-side must be &#39;x&#39;, not &#39;x + 1&#39;.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(y, y + 1) = y + 8;</span></div>
<div class="line">        <span class="comment">// Second argument to f on the left-hand-side must be &#39;y&#39;, not &#39;y + 1&#39;.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(y, x) = y - x;</span></div>
<div class="line">        <span class="comment">// Arguments to f on the left-hand-side are in the wrong places.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(3, 4) = x + y;</span></div>
<div class="line">        <span class="comment">// Free variables appear on the right-hand-side but not the left-hand-side.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll realize this one just to make sure it compiles. The</span></div>
<div class="line">        <span class="comment">// second-to-last definition forces us to realize over a</span></div>
<div class="line">        <span class="comment">// domain that is taller than it is wide.</span></div>
<div class="line">        f.<a id="a3" name="a3"></a><a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({100, 101});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For each realization of f, each step runs in its entirety</span></div>
<div class="line">        <span class="comment">// before the next one begins. Let&#39;s trace the loads and</span></div>
<div class="line">        <span class="comment">// stores for a simpler example:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> g(<span class="stringliteral">&quot;g&quot;</span>);</div>
<div class="line">        g(x, y) = x + y;    <span class="comment">// Pure definition</span></div>
<div class="line">        g(2, 1) = 42;       <span class="comment">// First update definition</span></div>
<div class="line">        g(x, 0) = g(x, 1);  <span class="comment">// Second update definition</span></div>
<div class="line"> </div>
<div class="line">        g.<a id="a4" name="a4"></a><a class="code hl_function" href="class_halide_1_1_func.html#a0e9226c8b5e603fc788e33882898aa4f">trace_loads</a>();</div>
<div class="line">        g.<a id="a5" name="a5"></a><a class="code hl_function" href="class_halide_1_1_func.html#a0e34adc5c6dc2549d4ef28e56e3fac6d">trace_stores</a>();</div>
<div class="line"> </div>
<div class="line">        g.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_update.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reading the log, we see that each pass is applied in</span></div>
<div class="line">        <span class="comment">// turn. The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> result[4][4];</div>
<div class="line">        <span class="comment">// Pure definition</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = x + y;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// First update definition</span></div>
<div class="line">        result[1][2] = 42;</div>
<div class="line">        <span class="comment">// Second update definition</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">            result[0][x] = result[1][x];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Putting update passes inside loops.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Starting with this pure definition:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f;</div>
<div class="line">        f(x, y) = (x + y) / 100.0f;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Say we want an update that squares the first fifty rows. We</span></div>
<div class="line">        <span class="comment">// could do this by adding 50 update definitions:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(x, 0) = f(x, 0) * f(x, 0);</span></div>
<div class="line">        <span class="comment">// f(x, 1) = f(x, 1) * f(x, 1);</span></div>
<div class="line">        <span class="comment">// f(x, 2) = f(x, 2) * f(x, 2);</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        <span class="comment">// f(x, 49) = f(x, 49) * f(x, 49);</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Or equivalently using a compile-time loop in our C++:</span></div>
<div class="line">        <span class="comment">// for (int i = 0; i &lt; 50; i++) {</span></div>
<div class="line">        <span class="comment">//   f(x, i) = f(x, i) * f(x, i);</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// But it&#39;s more manageable and more flexible to put the loop</span></div>
<div class="line">        <span class="comment">// in the generated code. We do this by defining a &quot;reduction</span></div>
<div class="line">        <span class="comment">// domain&quot; and using it inside an update definition:</span></div>
<div class="line">        <a id="_a6" name="_a6"></a><a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, 50);</div>
<div class="line">        f(x, r) = f(x, r) * f(x, r);</div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;float&gt;</a> halide_result = f.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({100, 100});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_update_rdom.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">float</span> c_result[100][100];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 100; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {</div>
<div class="line">                c_result[y][x] = (x + y) / 100.0f;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 50; r++) {</div>
<div class="line">                <span class="comment">// The loop over the reduction domain occurs inside of</span></div>
<div class="line">                <span class="comment">// the loop over any pure variables used in the update</span></div>
<div class="line">                <span class="comment">// step:</span></div>
<div class="line">                c_result[r][x] = c_result[r][x] * c_result[r][x];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 100; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (fabs(halide_result(x, y) - c_result[y][x]) &gt; 0.01f) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %f instead of %f\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now we&#39;ll examine a real-world use for an update definition:</span></div>
<div class="line">    <span class="comment">// computing a histogram.</span></div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Some operations on images can&#39;t be cleanly expressed as a pure</span></div>
<div class="line">        <span class="comment">// function from the output coordinates to the value stored</span></div>
<div class="line">        <span class="comment">// there. The classic example is computing a histogram. The</span></div>
<div class="line">        <span class="comment">// natural way to do it is to iterate over the input image,</span></div>
<div class="line">        <span class="comment">// updating histogram buckets. Here&#39;s how you do that in Halide:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> histogram(<span class="stringliteral">&quot;histogram&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Histogram buckets start as zero.</span></div>
<div class="line">        histogram(x) = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define a multi-dimensional reduction domain over the input image:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, input.width(), 0, input.height());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For every point in the reduction domain, increment the</span></div>
<div class="line">        <span class="comment">// histogram bucket corresponding to the intensity of the</span></div>
<div class="line">        <span class="comment">// input image at that point.</span></div>
<div class="line">        histogram(input(r.<a id="a7" name="a7"></a><a class="code hl_variable" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614">x</a>, r.<a id="a8" name="a8"></a><a class="code hl_variable" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff">y</a>)) += 1;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = histogram.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({256});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[256];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 256; x++) {</div>
<div class="line">            c_result[x] = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_y = 0; r_y &lt; input.height(); r_y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_x = 0; r_x &lt; input.width(); r_x++) {</div>
<div class="line">                c_result[input(r_x, r_y)] += 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the answers agree:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 256; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (c_result[x] != halide_result(x)) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Scheduling update steps</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The pure variables in an update step and can be</span></div>
<div class="line">        <span class="comment">// parallelized, vectorized, split, etc as usual.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Vectorizing, splitting, or parallelize the variables that</span></div>
<div class="line">        <span class="comment">// are part of the reduction domain is trickier. We&#39;ll cover</span></div>
<div class="line">        <span class="comment">// that in a later lesson.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Consider the definition:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f;</div>
<div class="line">        f(x, y) = x * y;</div>
<div class="line">        <span class="comment">// Set row zero to each row 8</span></div>
<div class="line">        f(x, 0) = f(x, 8);</div>
<div class="line">        <span class="comment">// Set column zero equal to column 8 plus 2</span></div>
<div class="line">        f(0, y) = f(8, y) + 2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The pure variables in each stage can be scheduled</span></div>
<div class="line">        <span class="comment">// independently. To control the pure definition, we schedule</span></div>
<div class="line">        <span class="comment">// as we have done in the past. The following code vectorizes</span></div>
<div class="line">        <span class="comment">// and parallelizes the pure definition only.</span></div>
<div class="line">        f.<a id="a9" name="a9"></a><a class="code hl_function" href="class_halide_1_1_func.html#aefc273557b19c8c02c948f7e8ca56ffd">vectorize</a>(x, 4).<a id="a10" name="a10"></a><a class="code hl_function" href="class_halide_1_1_func.html#ae78db35f74950c9e9c586f6ad7a3e7e0">parallel</a>(y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We use Func::update(int) to get a handle to an update step</span></div>
<div class="line">        <span class="comment">// for the purposes of scheduling. The following line</span></div>
<div class="line">        <span class="comment">// vectorizes the first update step across x. We can&#39;t do</span></div>
<div class="line">        <span class="comment">// anything with y for this update step, because it doesn&#39;t</span></div>
<div class="line">        <span class="comment">// use y.</span></div>
<div class="line">        f.<a id="a11" name="a11"></a><a class="code hl_function" href="class_halide_1_1_func.html#a34b8c4bece8042e500f838b72ed2b718">update</a>(0).<a id="a12" name="a12"></a><a class="code hl_function" href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">vectorize</a>(x, 4);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now we parallelize the second update step in chunks of size</span></div>
<div class="line">        <span class="comment">// 4.</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_var.html">Var</a> yo, yi;</div>
<div class="line">        f.<a class="code hl_function" href="class_halide_1_1_func.html#a34b8c4bece8042e500f838b72ed2b718">update</a>(1).<a id="a13" name="a13"></a>split(y, yo, yi, 4).parallel(yo);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = f.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({16, 16});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_update_schedule.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Here&#39;s the equivalent (serial) C:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[16][16];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Pure step. Vectorized in x and parallelized in y.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 16; y++) {  <span class="comment">// Should be a parallel for loop</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 4; x_vec++) {</div>
<div class="line">                <span class="keywordtype">int</span> x[] = {x_vec * 4, x_vec * 4 + 1, x_vec * 4 + 2, x_vec * 4 + 3};</div>
<div class="line">                c_result[y][x[0]] = x[0] * y;</div>
<div class="line">                c_result[y][x[1]] = x[1] * y;</div>
<div class="line">                c_result[y][x[2]] = x[2] * y;</div>
<div class="line">                c_result[y][x[3]] = x[3] * y;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First update. Vectorized in x.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 4; x_vec++) {</div>
<div class="line">            <span class="keywordtype">int</span> x[] = {x_vec * 4, x_vec * 4 + 1, x_vec * 4 + 2, x_vec * 4 + 3};</div>
<div class="line">            c_result[0][x[0]] = c_result[8][x[0]];</div>
<div class="line">            c_result[0][x[1]] = c_result[8][x[1]];</div>
<div class="line">            c_result[0][x[2]] = c_result[8][x[2]];</div>
<div class="line">            c_result[0][x[3]] = c_result[8][x[3]];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Second update. Parallelized in chunks of size 4 in y.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; 4; yo++) {  <span class="comment">// Should be a parallel for loop</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 4; yi++) {</div>
<div class="line">                <span class="keywordtype">int</span> y = yo * 4 + yi;</div>
<div class="line">                c_result[y][0] = c_result[y][8] + 2;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the C and Halide results match:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 16; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 16; x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// That covers how to schedule the variables within a Func that</span></div>
<div class="line">    <span class="comment">// uses update steps, but what about producer-consumer</span></div>
<div class="line">    <span class="comment">// relationships that involve compute_at and store_at? Let&#39;s</span></div>
<div class="line">    <span class="comment">// examine a reduction as a producer, in a producer-consumer pair.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Because an update does multiple passes over a stored array,</span></div>
<div class="line">        <span class="comment">// it&#39;s not meaningful to inline them. So the default schedule</span></div>
<div class="line">        <span class="comment">// for them does the closest thing possible. It computes them</span></div>
<div class="line">        <span class="comment">// in the innermost loop of their consumer. Consider this</span></div>
<div class="line">        <span class="comment">// trivial example:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer, consumer;</div>
<div class="line">        producer(x) = x * 2;</div>
<div class="line">        producer(x) += 10;</div>
<div class="line">        consumer(x) = 2 * producer(x);</div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = consumer.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_inline_reduction.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            producer_storage[0] = x * 2;</div>
<div class="line">            <span class="comment">// Update step for producer</span></div>
<div class="line">            producer_storage[0] = producer_storage[0] + 10;</div>
<div class="line">            <span class="comment">// Pure step for consumer</span></div>
<div class="line">            c_result[x] = 2 * producer_storage[0];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For all other compute_at/store_at options, the reduction</span></div>
<div class="line">        <span class="comment">// gets placed where you would expect, somewhere in the loop</span></div>
<div class="line">        <span class="comment">// nest of the consumer.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now let&#39;s consider a reduction as a consumer in a</span></div>
<div class="line">    <span class="comment">// producer-consumer pair. This is a little more involved.</span></div>
<div class="line">    <span class="comment">// Case 1: The consumer references the producer in the pure step only.</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer, consumer;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The producer is pure.</span></div>
<div class="line">        producer(x) = x * 17;</div>
<div class="line">        consumer(x) = 2 * producer(x);</div>
<div class="line">        consumer(x) += 50;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The valid schedules for the producer in this case are</span></div>
<div class="line">        <span class="comment">// the default schedule - inlined, and also:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// 1) producer.compute_at(x), which places the computation of</span></div>
<div class="line">        <span class="comment">// the producer inside the loop over x in the pure step of the</span></div>
<div class="line">        <span class="comment">// consumer.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// 2) producer.compute_root(), which computes all of the</span></div>
<div class="line">        <span class="comment">// producer ahead of time.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// 3) producer.store_root().compute_at(x), which allocates</span></div>
<div class="line">        <span class="comment">// space for the consumer outside the loop over x, but fills</span></div>
<div class="line">        <span class="comment">// it in as needed inside the loop.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Let&#39;s use option 1.</span></div>
<div class="line"> </div>
<div class="line">        producer.<a id="a14" name="a14"></a><a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(consumer, x);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = consumer.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_pure.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] = 2 * producer_storage[0];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            c_result[x] += 50;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// All of the pure step is evaluated before any of the</span></div>
<div class="line">        <span class="comment">// update step, so there are two separate loops over x.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 2: The consumer references the producer in the update step only</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer, consumer;</div>
<div class="line">        producer(x) = x * 17;</div>
<div class="line">        consumer(x) = 100 - x * 10;</div>
<div class="line">        consumer(x) += producer(x);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Again we compute the producer per x coordinate of the</span></div>
<div class="line">        <span class="comment">// consumer. This places producer code inside the update</span></div>
<div class="line">        <span class="comment">// step of the consumer, because that&#39;s the only step that</span></div>
<div class="line">        <span class="comment">// uses the producer.</span></div>
<div class="line">        producer.<a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(consumer, x);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note however, that we didn&#39;t say:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// producer.compute_at(consumer.update(0), x).</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Scheduling is done with respect to Vars of a Func, and</span></div>
<div class="line">        <span class="comment">// the Vars of a Func are shared across the pure and</span></div>
<div class="line">        <span class="comment">// update steps.</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = consumer.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_update.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            c_result[x] = 100 - x * 10;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] += producer_storage[0];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 3: The consumer references the producer in</span></div>
<div class="line">        <span class="comment">// multiple steps that share common variables</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer, consumer;</div>
<div class="line">        producer(x) = x * 17;</div>
<div class="line">        consumer(x) = 170 - producer(x);</div>
<div class="line">        consumer(x) += producer(x) / 2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Again we compute the producer per x coordinate of the</span></div>
<div class="line">        <span class="comment">// consumer. This places producer code inside both the</span></div>
<div class="line">        <span class="comment">// pure and the update step of the consumer. So there end</span></div>
<div class="line">        <span class="comment">// up being two separate realizations of the producer, and</span></div>
<div class="line">        <span class="comment">// redundant work occurs.</span></div>
<div class="line">        producer.<a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(consumer, x);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = consumer.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_pure_and_update.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] = 170 - producer_storage[0];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Another copy of the pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] += producer_storage[0] / 2;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 4: The consumer references the producer in</span></div>
<div class="line">        <span class="comment">// multiple steps that do not share common variables</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer, consumer;</div>
<div class="line">        producer(x, y) = (x * y) / 10 + 8;</div>
<div class="line">        consumer(x, y) = x + y;</div>
<div class="line">        consumer(x, 0) += producer(x, x);</div>
<div class="line">        consumer(0, y) += producer(y, 9 - y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// In this case neither producer.compute_at(consumer, x)</span></div>
<div class="line">        <span class="comment">// nor producer.compute_at(consumer, y) will work, because</span></div>
<div class="line">        <span class="comment">// either one fails to cover one of the uses of the</span></div>
<div class="line">        <span class="comment">// producer. So we&#39;d have to inline producer, or use</span></div>
<div class="line">        <span class="comment">// producer.compute_root().</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Let&#39;s say we really really want producer to be</span></div>
<div class="line">        <span class="comment">// compute_at the inner loops of both consumer update</span></div>
<div class="line">        <span class="comment">// steps. Halide doesn&#39;t allow multiple different</span></div>
<div class="line">        <span class="comment">// schedules for a single Func, but we can work around it</span></div>
<div class="line">        <span class="comment">// by making two wrappers around producer, and scheduling</span></div>
<div class="line">        <span class="comment">// those instead:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Attempt 2:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer_1, producer_2, consumer_2;</div>
<div class="line">        producer_1(x, y) = producer(x, y);</div>
<div class="line">        producer_2(x, y) = producer(x, y);</div>
<div class="line"> </div>
<div class="line">        consumer_2(x, y) = x + y;</div>
<div class="line">        consumer_2(x, 0) += producer_1(x, x);</div>
<div class="line">        consumer_2(0, y) += producer_2(y, 9 - y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The wrapper functions give us two separate handles on</span></div>
<div class="line">        <span class="comment">// the producer, so we can schedule them differently.</span></div>
<div class="line">        producer_1.<a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(consumer_2, x);</div>
<div class="line">        producer_2.<a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(consumer_2, y);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = consumer_2.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10, 10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_multiple_updates.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10][10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">                c_result[y][x] = x + y;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// First update step for consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordtype">int</span> producer_1_storage[1];</div>
<div class="line">            producer_1_storage[0] = (x * x) / 10 + 8;</div>
<div class="line">            c_result[0][x] += producer_1_storage[0];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Second update step for consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {</div>
<div class="line">            <span class="keywordtype">int</span> producer_2_storage[1];</div>
<div class="line">            producer_2_storage[0] = (y * (9 - y)) / 10 + 8;</div>
<div class="line">            c_result[y][0] += producer_2_storage[0];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 5: Scheduling a producer under a reduction domain</span></div>
<div class="line">        <span class="comment">// variable of the consumer.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We are not just restricted to scheduling producers at</span></div>
<div class="line">        <span class="comment">// the loops over the pure variables of the consumer. If a</span></div>
<div class="line">        <span class="comment">// producer is only used within a loop over a reduction</span></div>
<div class="line">        <span class="comment">// domain (RDom) variable, we can also schedule the</span></div>
<div class="line">        <span class="comment">// producer there.</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> producer, consumer;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, 5);</div>
<div class="line">        producer(x) = x % 8;</div>
<div class="line">        consumer(x) = x + 10;</div>
<div class="line">        consumer(x) += r + producer(x + r);</div>
<div class="line"> </div>
<div class="line">        producer.<a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(consumer, r);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result = consumer.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_rvar.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            c_result[x] = x + 10;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// The loop over the reduction domain is always the inner loop.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 5; r++) {</div>
<div class="line">                <span class="comment">// We&#39;ve schedule the storage and computation of</span></div>
<div class="line">                <span class="comment">// the producer here. We just need a single value.</span></div>
<div class="line">                <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">                <span class="comment">// Pure step of the producer.</span></div>
<div class="line">                producer_storage[0] = (x + r) % 8;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Now use it in the update step of the consumer.</span></div>
<div class="line">                c_result[x] += r + producer_storage[0];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A real-world example of a reduction inside a producer-consumer chain.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The default schedule for a reduction is a good one for</span></div>
<div class="line">        <span class="comment">// convolution-like operations. For example, the following</span></div>
<div class="line">        <span class="comment">// computes a 5x5 box-blur of our grayscale test image with a</span></div>
<div class="line">        <span class="comment">// clamp-to-edge boundary condition:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First add the boundary condition.</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> clamped = BoundaryConditions::repeat_edge(input);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define a 5x5 box that starts at (-2, -2)</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(-2, 5, -2, 5);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the 5x5 sum around each pixel.</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> local_sum;</div>
<div class="line">        local_sum(x, y) = 0;  <span class="comment">// Compute the sum as a 32-bit integer</span></div>
<div class="line">        local_sum(x, y) += clamped(x + r.<a class="code hl_variable" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614">x</a>, y + r.<a class="code hl_variable" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff">y</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Divide the sum by 25 to make it an average</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> blurry;</div>
<div class="line">        blurry(x, y) = cast&lt;uint8_t&gt;(local_sum(x, y) / 25);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;uint8_t&gt;</a> halide_result = blurry.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({input.width(), input.height()});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The default schedule will inline &#39;clamped&#39; into the update</span></div>
<div class="line">        <span class="comment">// step of &#39;local_sum&#39;, because clamped only has a pure</span></div>
<div class="line">        <span class="comment">// definition, and so its default schedule is fully-inlined.</span></div>
<div class="line">        <span class="comment">// We will then compute local_sum per x coordinate of blurry,</span></div>
<div class="line">        <span class="comment">// because the default schedule for reductions is</span></div>
<div class="line">        <span class="comment">// compute-innermost. Here&#39;s the equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;uint8_t&gt;</a> c_result(input.width(), input.height());</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.height(); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.width(); x++) {</div>
<div class="line">                <span class="keywordtype">int</span> local_sum[1];</div>
<div class="line">                <span class="comment">// Pure step of local_sum</span></div>
<div class="line">                local_sum[0] = 0;</div>
<div class="line">                <span class="comment">// Update step of local_sum</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_y = -2; r_y &lt;= 2; r_y++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_x = -2; r_x &lt;= 2; r_x++) {</div>
<div class="line">                        <span class="comment">// The clamping has been inlined into the update step.</span></div>
<div class="line">                        <span class="keywordtype">int</span> clamped_x = std::min(std::max(x + r_x, 0), input.width() - 1);</div>
<div class="line">                        <span class="keywordtype">int</span> clamped_y = std::min(std::max(y + r_y, 0), input.height() - 1);</div>
<div class="line">                        local_sum[0] += input(clamped_x, clamped_y);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// Pure step of blurry</span></div>
<div class="line">                c_result(x, y) = (<a id="a15" name="a15"></a><a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>)(local_sum[0] / 25);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.height(); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.width(); x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result(x, y)) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result(x, y));</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Reduction helpers.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// There are several reduction helper functions provided in</span></div>
<div class="line">        <span class="comment">// Halide.h, which compute small reductions and schedule them</span></div>
<div class="line">        <span class="comment">// innermost into their consumer. The most useful one is</span></div>
<div class="line">        <span class="comment">// &quot;sum&quot;.</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f1;</div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, 100);</div>
<div class="line">        f1(x) = sum(r + x) * 7;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sum creates a small anonymous Func to do the reduction. It&#39;s equivalent to:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f2;</div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> anon;</div>
<div class="line">        anon(x) = 0;</div>
<div class="line">        anon(x) += r + x;</div>
<div class="line">        f2(x) = anon(x) * 7;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// So even though f1 references a reduction domain, it is a</span></div>
<div class="line">        <span class="comment">// pure function. The reduction domain has been swallowed to</span></div>
<div class="line">        <span class="comment">// define the inner anonymous reduction.</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result_1 = f1.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> halide_result_2 = f2.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordtype">int</span> anon[1];</div>
<div class="line">            anon[0] = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 100; r++) {</div>
<div class="line">                anon[0] += r + x;</div>
<div class="line">            }</div>
<div class="line">            c_result[x] = anon[0] * 7;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check they all match.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result_1(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result_1(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result_1(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result_2(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result_2(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result_2(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A complex example that uses reduction helpers.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Other reduction helpers include &quot;product&quot;, &quot;minimum&quot;,</span></div>
<div class="line">        <span class="comment">// &quot;maximum&quot;, &quot;argmin&quot;, and &quot;argmax&quot;. Using argmin and argmax</span></div>
<div class="line">        <span class="comment">// requires understanding tuples, which come in a later</span></div>
<div class="line">        <span class="comment">// lesson. Let&#39;s use minimum and maximum to compute the local</span></div>
<div class="line">        <span class="comment">// spread of our grayscale image.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First, add a boundary condition to the input.</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> clamped;</div>
<div class="line">        <a id="_a16" name="_a16"></a><a class="code hl_struct" href="struct_halide_1_1_expr.html">Expr</a> x_clamped = clamp(x, 0, input.width() - 1);</div>
<div class="line">        <a class="code hl_struct" href="struct_halide_1_1_expr.html">Expr</a> y_clamped = clamp(y, 0, input.height() - 1);</div>
<div class="line">        clamped(x, y) = input(x_clamped, y_clamped);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> box(-2, 5, -2, 5);</div>
<div class="line">        <span class="comment">// Compute the local maximum minus the local minimum:</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_func.html">Func</a> spread;</div>
<div class="line">        spread(x, y) = (maximum(clamped(x + box.<a class="code hl_variable" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614">x</a>, y + box.<a class="code hl_variable" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff">y</a>)) -</div>
<div class="line">                        minimum(clamped(x + box.<a class="code hl_variable" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614">x</a>, y + box.<a class="code hl_variable" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff">y</a>)));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the result in strips of 32 scanlines</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_var.html">Var</a> yo, yi;</div>
<div class="line">        spread.<a id="a17" name="a17"></a><a class="code hl_function" href="class_halide_1_1_func.html#a4f9feebea3c3da655f623422971f869c">split</a>(y, yo, yi, 32).<a class="code hl_function" href="class_halide_1_1_func.html#ae78db35f74950c9e9c586f6ad7a3e7e0">parallel</a>(yo);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Vectorize across x within the strips. This implicitly</span></div>
<div class="line">        <span class="comment">// vectorizes stuff that is computed within the loop over x in</span></div>
<div class="line">        <span class="comment">// spread, which includes our minimum and maximum helpers, so</span></div>
<div class="line">        <span class="comment">// they get vectorized too.</span></div>
<div class="line">        spread.<a class="code hl_function" href="class_halide_1_1_func.html#aefc273557b19c8c02c948f7e8ca56ffd">vectorize</a>(x, 16);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll apply the boundary condition by padding each scanline</span></div>
<div class="line">        <span class="comment">// as we need it in a circular buffer (see lesson 08).</span></div>
<div class="line">        clamped.<a id="a18" name="a18"></a><a class="code hl_function" href="class_halide_1_1_func.html#aa5d784c5fe960c2c0e4c89961b8b71ef">store_at</a>(spread, yo).<a class="code hl_function" href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(spread, yi);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;uint8_t&gt;</a> halide_result = spread.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>({input.width(), input.height()});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The C equivalent is almost too horrible to contemplate (and</span></div>
<div class="line"><span class="comment">// took me a long time to debug). This time I want to time</span></div>
<div class="line"><span class="comment">// both the Halide version and the C version, so I&#39;ll use sse</span></div>
<div class="line"><span class="comment">// intrinsics for the vectorization, and openmp to do the</span></div>
<div class="line"><span class="comment">// parallel for loop (you&#39;ll need to compile with -fopenmp or</span></div>
<div class="line"><span class="comment">// similar to get correct timing).</span></div>
<div class="line"><span class="preprocessor">#ifdef __SSE2__</span></div>
<div class="line">        <span class="comment">// Don&#39;t include the time required to allocate the output buffer.</span></div>
<div class="line">        <a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;uint8_t&gt;</a> c_result(input.width(), input.height());</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef _OPENMP</span></div>
<div class="line">        <span class="keywordtype">double</span> t1 = current_time();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Run this one hundred times so we can average the timing results.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iters = 0; iters &lt; 100; iters++) {</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; (input.height() + 31) / 32; yo++) {</div>
<div class="line">                <span class="keywordtype">int</span> y_base = std::min(yo * 32, input.height() - 32);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Compute clamped in a circular buffer of size 8</span></div>
<div class="line">                <span class="comment">// (smallest power of two greater than 5). Each thread</span></div>
<div class="line">                <span class="comment">// needs its own allocation, so it must occur here.</span></div>
<div class="line"> </div>
<div class="line">                <span class="keywordtype">int</span> clamped_width = input.width() + 4;</div>
<div class="line">                <a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_storage = (<a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)<a id="a19" name="a19"></a><a class="code hl_function" href="runtime__internal_8h.html#a52abbdf8792edbd1e34d4ca8d061f840">malloc</a>(clamped_width * 8);</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 32; yi++) {</div>
<div class="line">                    <span class="keywordtype">int</span> y = y_base + yi;</div>
<div class="line"> </div>
<div class="line">                    <a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *output_row = &amp;c_result(0, y);</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Compute clamped for this scanline, skipping rows</span></div>
<div class="line">                    <span class="comment">// already computed within this slice.</span></div>
<div class="line">                    <span class="keywordtype">int</span> min_y_clamped = (yi == 0) ? (y - 2) : (y + 2);</div>
<div class="line">                    <span class="keywordtype">int</span> max_y_clamped = (y + 2);</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cy = min_y_clamped; cy &lt;= max_y_clamped; cy++) {</div>
<div class="line">                        <span class="comment">// Figure out which row of the circular buffer</span></div>
<div class="line">                        <span class="comment">// we&#39;re filling in using bitmasking:</span></div>
<div class="line">                        <a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_row =</div>
<div class="line">                            clamped_storage + (cy &amp; 7) * clamped_width;</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Figure out which row of the input we&#39;re reading</span></div>
<div class="line">                        <span class="comment">// from by clamping the y coordinate:</span></div>
<div class="line">                        <span class="keywordtype">int</span> clamped_y = std::min(std::max(cy, 0), input.height() - 1);</div>
<div class="line">                        <a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *input_row = &amp;input(0, clamped_y);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Fill it in with the padding.</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = -2; x &lt; input.width() + 2; x++) {</div>
<div class="line">                            <span class="keywordtype">int</span> clamped_x = std::min(std::max(x, 0), input.width() - 1);</div>
<div class="line">                            *clamped_row++ = input_row[clamped_x];</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Now iterate over vectors of x for the pure step of the output.</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; (input.width() + 15) / 16; x_vec++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x_base = std::min(x_vec * 16, input.width() - 16);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Allocate storage for the minimum and maximum</span></div>
<div class="line">                        <span class="comment">// helpers. One vector is enough.</span></div>
<div class="line">                        __m128i minimum_storage, maximum_storage;</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The pure step for the maximum is a vector of zeros</span></div>
<div class="line">                        maximum_storage = _mm_setzero_si128();</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The update step for maximum</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> max_y = y - 2; max_y &lt;= y + 2; max_y++) {</div>
<div class="line">                            <a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_row =</div>
<div class="line">                                clamped_storage + (max_y &amp; 7) * clamped_width;</div>
<div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> max_x = x_base - 2; max_x &lt;= x_base + 2; max_x++) {</div>
<div class="line">                                __m128i v = _mm_loadu_si128(</div>
<div class="line">                                    (__m128i <span class="keyword">const</span> *)(clamped_row + max_x + 2));</div>
<div class="line">                                maximum_storage = _mm_max_epu8(maximum_storage, v);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The pure step for the minimum is a vector of</span></div>
<div class="line">                        <span class="comment">// ones. Create it by comparing something to</span></div>
<div class="line">                        <span class="comment">// itself.</span></div>
<div class="line">                        minimum_storage = _mm_cmpeq_epi32(_mm_setzero_si128(),</div>
<div class="line">                                                          _mm_setzero_si128());</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The update step for minimum.</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> min_y = y - 2; min_y &lt;= y + 2; min_y++) {</div>
<div class="line">                            <a class="code hl_typedef" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_row =</div>
<div class="line">                                clamped_storage + (min_y &amp; 7) * clamped_width;</div>
<div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> min_x = x_base - 2; min_x &lt;= x_base + 2; min_x++) {</div>
<div class="line">                                __m128i v = _mm_loadu_si128(</div>
<div class="line">                                    (__m128i <span class="keyword">const</span> *)(clamped_row + min_x + 2));</div>
<div class="line">                                minimum_storage = _mm_min_epu8(minimum_storage, v);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Now compute the spread.</span></div>
<div class="line">                        __m128i spread = _mm_sub_epi8(maximum_storage, minimum_storage);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Store it.</span></div>
<div class="line">                        _mm_storeu_si128((__m128i *)(output_row + x_base), spread);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <a id="a20" name="a20"></a><a class="code hl_function" href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>(clamped_storage);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Skip the timing comparison if we don&#39;t have openmp</span></div>
<div class="line"><span class="comment">// enabled. Otherwise it&#39;s unfair to C.</span></div>
<div class="line"><span class="preprocessor">#ifdef _OPENMP</span></div>
<div class="line">        <span class="keywordtype">double</span> t2 = current_time();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now run the Halide version again without the</span></div>
<div class="line">        <span class="comment">// jit-compilation overhead. Also run it one hundred times.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iters = 0; iters &lt; 100; iters++) {</div>
<div class="line">            spread.<a class="code hl_function" href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">realize</a>(halide_result);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> t3 = current_time();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Report the timings. On my machine they both take about 3ms</span></div>
<div class="line">        <span class="comment">// for the 4-megapixel input (fast!), which makes sense,</span></div>
<div class="line">        <span class="comment">// because they&#39;re using the same vectorization and</span></div>
<div class="line">        <span class="comment">// parallelization strategy. However I find the Halide easier</span></div>
<div class="line">        <span class="comment">// to read, write, debug, modify, and port.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Halide spread took %f ms. C equivalent took %f ms\n&quot;</span>,</div>
<div class="line">               (t3 - t2) / 100, (t2 - t1) / 100);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// _OPENMP</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.height(); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.width(); x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result(x, y)) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result(x, y));</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// __SSE2__</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_halide_1_1_buffer_html"><div class="ttname"><a href="class_halide_1_1_buffer.html">Halide::Buffer</a></div><div class="ttdoc">A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00021">RDom.h:21</a></div></div>
<div class="ttc" id="aclass_halide_1_1_func_html"><div class="ttname"><a href="class_halide_1_1_func.html">Halide::Func</a></div><div class="ttdoc">A halide function.</div><div class="ttdef"><b>Definition</b> <a href="_func_8h_source.html#l00700">Func.h:700</a></div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_a0e34adc5c6dc2549d4ef28e56e3fac6d"><div class="ttname"><a href="class_halide_1_1_func.html#a0e34adc5c6dc2549d4ef28e56e3fac6d">Halide::Func::trace_stores</a></div><div class="ttdeci">Func &amp; trace_stores()</div><div class="ttdoc">Trace all stores to the buffer backing this Func by emitting calls to halide_trace.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_a0e9226c8b5e603fc788e33882898aa4f"><div class="ttname"><a href="class_halide_1_1_func.html#a0e9226c8b5e603fc788e33882898aa4f">Halide::Func::trace_loads</a></div><div class="ttdeci">Func &amp; trace_loads()</div><div class="ttdoc">Trace all loads from this Func by emitting calls to halide_trace.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_a34b8c4bece8042e500f838b72ed2b718"><div class="ttname"><a href="class_halide_1_1_func.html#a34b8c4bece8042e500f838b72ed2b718">Halide::Func::update</a></div><div class="ttdeci">Stage update(int idx=0)</div><div class="ttdoc">Get a handle on an update step for the purposes of scheduling it.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_a4f9feebea3c3da655f623422971f869c"><div class="ttname"><a href="class_halide_1_1_func.html#a4f9feebea3c3da655f623422971f869c">Halide::Func::split</a></div><div class="ttdeci">Func &amp; split(const VarOrRVar &amp;old, const VarOrRVar &amp;outer, const VarOrRVar &amp;inner, const Expr &amp;factor, TailStrategy tail=TailStrategy::Auto)</div><div class="ttdoc">Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_aa5d784c5fe960c2c0e4c89961b8b71ef"><div class="ttname"><a href="class_halide_1_1_func.html#aa5d784c5fe960c2c0e4c89961b8b71ef">Halide::Func::store_at</a></div><div class="ttdeci">Func &amp; store_at(const Func &amp;f, const Var &amp;var)</div><div class="ttdoc">Allocate storage for this function within f's loop over var.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_aabca4df7c939e2a47246a21b34f20070"><div class="ttname"><a href="class_halide_1_1_func.html#aabca4df7c939e2a47246a21b34f20070">Halide::Func::realize</a></div><div class="ttdeci">Realization realize(std::vector&lt; int32_t &gt; sizes={}, const Target &amp;target=Target())</div><div class="ttdoc">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_ae78db35f74950c9e9c586f6ad7a3e7e0"><div class="ttname"><a href="class_halide_1_1_func.html#ae78db35f74950c9e9c586f6ad7a3e7e0">Halide::Func::parallel</a></div><div class="ttdeci">Func &amp; parallel(const VarOrRVar &amp;var)</div><div class="ttdoc">Mark a dimension to be traversed in parallel.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_aefc273557b19c8c02c948f7e8ca56ffd"><div class="ttname"><a href="class_halide_1_1_func.html#aefc273557b19c8c02c948f7e8ca56ffd">Halide::Func::vectorize</a></div><div class="ttdeci">Func &amp; vectorize(const VarOrRVar &amp;var)</div><div class="ttdoc">Mark a dimension to be computed all-at-once as a single vector.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_af4aca8ca6331e64a6fdfd98fccf1757a"><div class="ttname"><a href="class_halide_1_1_func.html#af4aca8ca6331e64a6fdfd98fccf1757a">Halide::Func::compute_at</a></div><div class="ttdeci">Func &amp; compute_at(const Func &amp;f, const Var &amp;var)</div><div class="ttdoc">Compute this function as needed for each unique value of the given var for the given calling function...</div></div>
<div class="ttc" id="aclass_halide_1_1_r_dom_html"><div class="ttname"><a href="class_halide_1_1_r_dom.html">Halide::RDom</a></div><div class="ttdoc">A multi-dimensional domain over which to iterate.</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00193">RDom.h:193</a></div></div>
<div class="ttc" id="aclass_halide_1_1_r_dom_html_a9c41992ecccbe2eea2430a65a1dc7614"><div class="ttname"><a href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614">Halide::RDom::x</a></div><div class="ttdeci">RVar x</div><div class="ttdoc">Direct access to the first four dimensions of the reduction domain.</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00339">RDom.h:339</a></div></div>
<div class="ttc" id="aclass_halide_1_1_r_dom_html_ab9ec82ccc25c587c18ea174a9c7a46ff"><div class="ttname"><a href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff">Halide::RDom::y</a></div><div class="ttdeci">RVar y</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00339">RDom.h:339</a></div></div>
<div class="ttc" id="aclass_halide_1_1_stage_html_a2cddae992bed87a0ee529d6ec4946356"><div class="ttname"><a href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">Halide::Stage::vectorize</a></div><div class="ttdeci">Stage &amp; vectorize(const VarOrRVar &amp;var)</div></div>
<div class="ttc" id="aclass_halide_1_1_var_html"><div class="ttname"><a href="class_halide_1_1_var.html">Halide::Var</a></div><div class="ttdoc">A Halide variable, to be used when defining functions.</div><div class="ttdef"><b>Definition</b> <a href="_var_8h_source.html#l00019">Var.h:19</a></div></div>
<div class="ttc" id="anamespace_halide_html"><div class="ttname"><a href="namespace_halide.html">Halide</a></div><div class="ttdoc">This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...</div><div class="ttdef"><b>Definition</b> <a href="_abstract_generator_8h_source.html#l00019">AbstractGenerator.h:19</a></div></div>
<div class="ttc" id="aruntime__internal_8h_html_a52abbdf8792edbd1e34d4ca8d061f840"><div class="ttname"><a href="runtime__internal_8h.html#a52abbdf8792edbd1e34d4ca8d061f840">malloc</a></div><div class="ttdeci">void * malloc(size_t)</div></div>
<div class="ttc" id="aruntime__internal_8h_html_a5f44f30d12f5ed554d1bdb9825df6137"><div class="ttname"><a href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a></div><div class="ttdeci">unsigned __INT8_TYPE__ uint8_t</div><div class="ttdef"><b>Definition</b> <a href="runtime__internal_8h_source.html#l00029">runtime_internal.h:29</a></div></div>
<div class="ttc" id="aruntime__internal_8h_html_af07d89f5ceaea0c7c8252cc41fd75f37"><div class="ttname"><a href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a></div><div class="ttdeci">void free(void *)</div></div>
<div class="ttc" id="astruct_halide_1_1_expr_html"><div class="ttname"><a href="struct_halide_1_1_expr.html">Halide::Expr</a></div><div class="ttdoc">A fragment of Halide syntax.</div><div class="ttdef"><b>Definition</b> <a href="_expr_8h_source.html#l00258">Expr.h:258</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
