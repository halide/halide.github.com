<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Func Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_halide_1_1_func.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_func-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Halide::Func Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A halide function.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09702aeadda51baa8ff9f338a3ecd22d" id="r_a09702aeadda51baa8ff9f338a3ecd22d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09702aeadda51baa8ff9f338a3ecd22d">Func</a> (const std::string &amp;<a class="el" href="#ac119151e46e02b367a60a2af6ff02420">name</a>)</td></tr>
<tr class="memdesc:a09702aeadda51baa8ff9f338a3ecd22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with the given name.  <br /></td></tr>
<tr class="separator:a09702aeadda51baa8ff9f338a3ecd22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b82d6c5e413bc6a47a7d03fce912c6" id="r_a38b82d6c5e413bc6a47a7d03fce912c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b82d6c5e413bc6a47a7d03fce912c6">Func</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;required_type, int required_dims, const std::string &amp;<a class="el" href="#ac119151e46e02b367a60a2af6ff02420">name</a>)</td></tr>
<tr class="memdesc:a38b82d6c5e413bc6a47a7d03fce912c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with the given name.  <br /></td></tr>
<tr class="separator:a38b82d6c5e413bc6a47a7d03fce912c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adceabcfb1b423f34be95d2bc406ec3" id="r_a3adceabcfb1b423f34be95d2bc406ec3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3adceabcfb1b423f34be95d2bc406ec3">Func</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;required_types, int required_dims, const std::string &amp;<a class="el" href="#ac119151e46e02b367a60a2af6ff02420">name</a>)</td></tr>
<tr class="memdesc:a3adceabcfb1b423f34be95d2bc406ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with the given name.  <br /></td></tr>
<tr class="separator:a3adceabcfb1b423f34be95d2bc406ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd9ae99dad26dddffa078199375a6ba" id="r_a1dd9ae99dad26dddffa078199375a6ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dd9ae99dad26dddffa078199375a6ba">Func</a> ()</td></tr>
<tr class="memdesc:a1dd9ae99dad26dddffa078199375a6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with an automatically-generated unique name.  <br /></td></tr>
<tr class="separator:a1dd9ae99dad26dddffa078199375a6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a459f37a7d7031c7b6e2ab8a0ccee5" id="r_a52a459f37a7d7031c7b6e2ab8a0ccee5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a459f37a7d7031c7b6e2ab8a0ccee5">Func</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a52a459f37a7d7031c7b6e2ab8a0ccee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new function with an automatically-generated unique name, and define it to return the given expression (which may not contain free variables).  <br /></td></tr>
<tr class="separator:a52a459f37a7d7031c7b6e2ab8a0ccee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76f9e3e90a3b6dc95ef1a5821422ec4" id="r_ad76f9e3e90a3b6dc95ef1a5821422ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad76f9e3e90a3b6dc95ef1a5821422ec4">Func</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> f)</td></tr>
<tr class="memdesc:ad76f9e3e90a3b6dc95ef1a5821422ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to wrap an existing, already-define Function object.  <br /></td></tr>
<tr class="separator:ad76f9e3e90a3b6dc95ef1a5821422ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8432d8bcbcf649d9e201d49c1e4816" id="r_a8d8432d8bcbcf649d9e201d49c1e4816"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims&gt; </td></tr>
<tr class="memitem:a8d8432d8bcbcf649d9e201d49c1e4816"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d8432d8bcbcf649d9e201d49c1e4816">Func</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, Dims &gt; &amp;im)</td></tr>
<tr class="memdesc:a8d8432d8bcbcf649d9e201d49c1e4816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to wrap a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a>.  <br /></td></tr>
<tr class="separator:a8d8432d8bcbcf649d9e201d49c1e4816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabca4df7c939e2a47246a21b34f20070" id="r_aabca4df7c939e2a47246a21b34f20070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabca4df7c939e2a47246a21b34f20070">realize</a> (std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; sizes={}, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:aabca4df7c939e2a47246a21b34f20070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.  <br /></td></tr>
<tr class="separator:aabca4df7c939e2a47246a21b34f20070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66150432e0dc72cc1c7a4d766950cf27" id="r_a66150432e0dc72cc1c7a4d766950cf27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66150432e0dc72cc1c7a4d766950cf27">realize</a> (<a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *context, std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; sizes={}, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:a66150432e0dc72cc1c7a4d766950cf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but takes a custom user-provided context to be passed to runtime functions.  <br /></td></tr>
<tr class="separator:a66150432e0dc72cc1c7a4d766950cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c673f87eda38ef811ee0b8265ffbcae" id="r_a9c673f87eda38ef811ee0b8265ffbcae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c673f87eda38ef811ee0b8265ffbcae">realize</a> (<a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a> <a class="el" href="#a66202288811f0d1ef8810d0baab207f4">outputs</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:a9c673f87eda38ef811ee0b8265ffbcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <br /></td></tr>
<tr class="separator:a9c673f87eda38ef811ee0b8265ffbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae83195ae0e24f9c2a9eefde0e79c9e0" id="r_aae83195ae0e24f9c2a9eefde0e79c9e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae83195ae0e24f9c2a9eefde0e79c9e0">realize</a> (<a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *context, <a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a> <a class="el" href="#a66202288811f0d1ef8810d0baab207f4">outputs</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:aae83195ae0e24f9c2a9eefde0e79c9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but takes a custom user-provided context to be passed to runtime functions.  <br /></td></tr>
<tr class="separator:aae83195ae0e24f9c2a9eefde0e79c9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93112ca4b121c1a65d39b01b680e2759" id="r_a93112ca4b121c1a65d39b01b680e2759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93112ca4b121c1a65d39b01b680e2759">infer_input_bounds</a> (const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; &amp;sizes, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>())</td></tr>
<tr class="memdesc:a93112ca4b121c1a65d39b01b680e2759"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced.  <br /></td></tr>
<tr class="separator:a93112ca4b121c1a65d39b01b680e2759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243880dfcbdd71c9dbef095353a35c51" id="r_a243880dfcbdd71c9dbef095353a35c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a243880dfcbdd71c9dbef095353a35c51">infer_input_bounds</a> (<a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a> <a class="el" href="#a66202288811f0d1ef8810d0baab207f4">outputs</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>())</td></tr>
<tr class="separator:a243880dfcbdd71c9dbef095353a35c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef70a5e279ca295e33eaf681bb6a69d0" id="r_aef70a5e279ca295e33eaf681bb6a69d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef70a5e279ca295e33eaf681bb6a69d0">infer_input_bounds</a> (<a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *context, const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; &amp;sizes, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>())</td></tr>
<tr class="memdesc:aef70a5e279ca295e33eaf681bb6a69d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Versions of infer_input_bounds that take a custom user context to pass to runtime functions.  <br /></td></tr>
<tr class="separator:aef70a5e279ca295e33eaf681bb6a69d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ddeb323185cd478dcd21518da9fe22" id="r_a43ddeb323185cd478dcd21518da9fe22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43ddeb323185cd478dcd21518da9fe22">infer_input_bounds</a> (<a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *context, <a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a> <a class="el" href="#a66202288811f0d1ef8810d0baab207f4">outputs</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>())</td></tr>
<tr class="separator:a43ddeb323185cd478dcd21518da9fe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ea68da121228c9bb2acc52438fb76c" id="r_a74ea68da121228c9bb2acc52438fb76c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ea68da121228c9bb2acc52438fb76c">compile_to_bitcode</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a74ea68da121228c9bb2acc52438fb76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function.  <br /></td></tr>
<tr class="separator:a74ea68da121228c9bb2acc52438fb76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213712e8681babec663adbb9ab87bf2e" id="r_a213712e8681babec663adbb9ab87bf2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a213712e8681babec663adbb9ab87bf2e">compile_to_bitcode</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="separator:a213712e8681babec663adbb9ab87bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04ba34de18200c71ed948ed9a96dfe8" id="r_ac04ba34de18200c71ed948ed9a96dfe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac04ba34de18200c71ed948ed9a96dfe8">compile_to_llvm_assembly</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:ac04ba34de18200c71ed948ed9a96dfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to llvm assembly, with the given filename (which should probably end in .ll), type signature, and C function name (which defaults to the same name as this halide function.  <br /></td></tr>
<tr class="separator:ac04ba34de18200c71ed948ed9a96dfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa348865f8302ff247d2ecd95b263ffb4" id="r_aa348865f8302ff247d2ecd95b263ffb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa348865f8302ff247d2ecd95b263ffb4">compile_to_llvm_assembly</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="separator:aa348865f8302ff247d2ecd95b263ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe88a7fb3127dc67953ee9418cd9c68" id="r_adbe88a7fb3127dc67953ee9418cd9c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbe88a7fb3127dc67953ee9418cd9c68">compile_to_object</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:adbe88a7fb3127dc67953ee9418cd9c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function.  <br /></td></tr>
<tr class="separator:adbe88a7fb3127dc67953ee9418cd9c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ff9bb09b0e6615ebd170f50f1382fa" id="r_ae7ff9bb09b0e6615ebd170f50f1382fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ff9bb09b0e6615ebd170f50f1382fa">compile_to_object</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="separator:ae7ff9bb09b0e6615ebd170f50f1382fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485c44376069489589f8e071b6d28e25" id="r_a485c44376069489589f8e071b6d28e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485c44376069489589f8e071b6d28e25">compile_to_header</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name=&quot;&quot;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a485c44376069489589f8e071b6d28e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a header file with the given filename for this function.  <br /></td></tr>
<tr class="separator:a485c44376069489589f8e071b6d28e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1766b6f9c06cfc149ba3832b07d0f116" id="r_a1766b6f9c06cfc149ba3832b07d0f116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1766b6f9c06cfc149ba3832b07d0f116">compile_to_assembly</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a1766b6f9c06cfc149ba3832b07d0f116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to text assembly equivalent to the object file generated by compile_to_object.  <br /></td></tr>
<tr class="separator:a1766b6f9c06cfc149ba3832b07d0f116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace30c21625c4f42456a9aee8466eb883" id="r_ace30c21625c4f42456a9aee8466eb883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace30c21625c4f42456a9aee8466eb883">compile_to_assembly</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="separator:ace30c21625c4f42456a9aee8466eb883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b6acd470fed73a6804afa8353d018e" id="r_a31b6acd470fed73a6804afa8353d018e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b6acd470fed73a6804afa8353d018e">compile_to_c</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name=&quot;&quot;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a31b6acd470fed73a6804afa8353d018e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to C source code.  <br /></td></tr>
<tr class="separator:a31b6acd470fed73a6804afa8353d018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064d3085694782432e175d541c3051b" id="r_a3064d3085694782432e175d541c3051b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3064d3085694782432e175d541c3051b">compile_to_lowered_stmt</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a3064d3085694782432e175d541c3051b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code.  <br /></td></tr>
<tr class="separator:a3064d3085694782432e175d541c3051b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59de8d0455b4f5d15cb05dcfcbc464f7" id="r_a59de8d0455b4f5d15cb05dcfcbc464f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59de8d0455b4f5d15cb05dcfcbc464f7">compile_to_conceptual_stmt</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a59de8d0455b4f5d15cb05dcfcbc464f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out a conceptual representation of lowered code, before any parallel loop get factored out into separate functions, or GPU loops are offloaded to kernel code.r Useful for analyzing and debugging scheduling.  <br /></td></tr>
<tr class="separator:a59de8d0455b4f5d15cb05dcfcbc464f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f839d9e13cae4b87a540aa618589ae" id="r_a03f839d9e13cae4b87a540aa618589ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f839d9e13cae4b87a540aa618589ae">print_loop_nest</a> ()</td></tr>
<tr class="memdesc:a03f839d9e13cae4b87a540aa618589ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out the loop nests specified by the schedule for this Function.  <br /></td></tr>
<tr class="separator:a03f839d9e13cae4b87a540aa618589ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8873bbbbaf3cba1cf8976a24acab310" id="r_ab8873bbbbaf3cba1cf8976a24acab310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8873bbbbaf3cba1cf8976a24acab310">compile_to_file</a> (const std::string &amp;filename_prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const std::string &amp;fn_name=&quot;&quot;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:ab8873bbbbaf3cba1cf8976a24acab310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <br /></td></tr>
<tr class="separator:ab8873bbbbaf3cba1cf8976a24acab310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21dcadd6fd36f4fc4ee7e1325621b27" id="r_af21dcadd6fd36f4fc4ee7e1325621b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af21dcadd6fd36f4fc4ee7e1325621b27">compile_to_static_library</a> (const std::string &amp;filename_prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const std::string &amp;fn_name=&quot;&quot;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:af21dcadd6fd36f4fc4ee7e1325621b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to static-library file and header pair, with the given arguments.  <br /></td></tr>
<tr class="separator:af21dcadd6fd36f4fc4ee7e1325621b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22a7daea850a6f2723fe8184029d7f8" id="r_ac22a7daea850a6f2723fe8184029d7f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22a7daea850a6f2723fe8184029d7f8">compile_to_multitarget_static_library</a> (const std::string &amp;filename_prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt; &amp;targets)</td></tr>
<tr class="memdesc:ac22a7daea850a6f2723fe8184029d7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to static-library file and header pair once for each target; each resulting function will be considered (in order) via <a class="el" href="_halide_runtime_8h.html#aeb3de9758e5af340b55d91e929ea52be" title="This function is called internally by Halide in some situations to determine if the current execution...">halide_can_use_target_features()</a> at runtime, with the first appropriate match being selected for subsequent use.  <br /></td></tr>
<tr class="separator:ac22a7daea850a6f2723fe8184029d7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3a9cbbcfc3219386937ac24c4c9735" id="r_a0a3a9cbbcfc3219386937ac24c4c9735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a3a9cbbcfc3219386937ac24c4c9735">compile_to_multitarget_object_files</a> (const std::string &amp;filename_prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt; &amp;targets, const std::vector&lt; std::string &gt; &amp;suffixes)</td></tr>
<tr class="memdesc:a0a3a9cbbcfc3219386937ac24c4c9735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="#ac22a7daea850a6f2723fe8184029d7f8" title="Compile to static-library file and header pair once for each target; each resulting function will be ...">compile_to_multitarget_static_library()</a>, except that the object files are all output as object files (rather than bundled into a static library).  <br /></td></tr>
<tr class="separator:a0a3a9cbbcfc3219386937ac24c4c9735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96978001c2e4071be87d6f3e49f0db31" id="r_a96978001c2e4071be87d6f3e49f0db31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96978001c2e4071be87d6f3e49f0db31">compile_to_module</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const std::string &amp;fn_name=&quot;&quot;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a96978001c2e4071be87d6f3e49f0db31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an internal representation of lowered code as a self contained <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> suitable for further compilation.  <br /></td></tr>
<tr class="separator:a96978001c2e4071be87d6f3e49f0db31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17f5091968639d630d29f640aff21dd" id="r_aa17f5091968639d630d29f640aff21dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa17f5091968639d630d29f640aff21dd">compile_to</a> (const std::map&lt; <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2af">OutputFileType</a>, std::string &gt; &amp;output_files, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:aa17f5091968639d630d29f640aff21dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile and generate multiple target files with single call.  <br /></td></tr>
<tr class="separator:aa17f5091968639d630d29f640aff21dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0c8541bc9a63d08c4b3d1accbab4e6" id="r_a1c0c8541bc9a63d08c4b3d1accbab4e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c0c8541bc9a63d08c4b3d1accbab4e6">compile_jit</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>())</td></tr>
<tr class="memdesc:a1c0c8541bc9a63d08c4b3d1accbab4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly jit compile the function to machine code.  <br /></td></tr>
<tr class="separator:a1c0c8541bc9a63d08c4b3d1accbab4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e08cea3909e06105732570ebcb45896" id="r_a6e08cea3909e06105732570ebcb45896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_j_i_t_handlers.html">JITHandlers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e08cea3909e06105732570ebcb45896">jit_handlers</a> ()</td></tr>
<tr class="memdesc:a6e08cea3909e06105732570ebcb45896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a struct containing the currently set custom functions used by JIT.  <br /></td></tr>
<tr class="separator:a6e08cea3909e06105732570ebcb45896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffec02c0c16ecce4cac7b3d646f6a2c" id="r_a7ffec02c0c16ecce4cac7b3d646f6a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_callable.html">Callable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ffec02c0c16ecce4cac7b3d646f6a2c">compile_to_callable</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>())</td></tr>
<tr class="memdesc:a7ffec02c0c16ecce4cac7b3d646f6a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly jit compile the function to machine code and return a callable struct that behaves like a function pointer.  <br /></td></tr>
<tr class="separator:a7ffec02c0c16ecce4cac7b3d646f6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f5c7a7e7be2da5203eb78b192399d5" id="r_aa5f5c7a7e7be2da5203eb78b192399d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5f5c7a7e7be2da5203eb78b192399d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5f5c7a7e7be2da5203eb78b192399d5">add_custom_lowering_pass</a> (T *pass)</td></tr>
<tr class="memdesc:aa5f5c7a7e7be2da5203eb78b192399d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom pass to be used during lowering.  <br /></td></tr>
<tr class="separator:aa5f5c7a7e7be2da5203eb78b192399d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5d2ac731fc872d129f2f301f484f56" id="r_aba5d2ac731fc872d129f2f301f484f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5d2ac731fc872d129f2f301f484f56">add_custom_lowering_pass</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">Internal::IRMutator</a> *pass, std::function&lt; void()&gt; deleter)</td></tr>
<tr class="memdesc:aba5d2ac731fc872d129f2f301f484f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom pass to be used during lowering, with the function that will be called to delete it also passed in.  <br /></td></tr>
<tr class="separator:aba5d2ac731fc872d129f2f301f484f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe676a57879fa842c2fa08edbf6f9746" id="r_abe676a57879fa842c2fa08edbf6f9746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe676a57879fa842c2fa08edbf6f9746">clear_custom_lowering_passes</a> ()</td></tr>
<tr class="memdesc:abe676a57879fa842c2fa08edbf6f9746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all previously-set custom lowering passes.  <br /></td></tr>
<tr class="separator:abe676a57879fa842c2fa08edbf6f9746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f4c01bd44680d90a4ae6c43cc42968" id="r_ad1f4c01bd44680d90a4ae6c43cc42968"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_custom_lowering_pass.html">CustomLoweringPass</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f4c01bd44680d90a4ae6c43cc42968">custom_lowering_passes</a> ()</td></tr>
<tr class="memdesc:ad1f4c01bd44680d90a4ae6c43cc42968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the custom lowering passes.  <br /></td></tr>
<tr class="separator:ad1f4c01bd44680d90a4ae6c43cc42968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af001fb038dcce6dc07166f8072485abd" id="r_af001fb038dcce6dc07166f8072485abd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af001fb038dcce6dc07166f8072485abd">debug_to_file</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:af001fb038dcce6dc07166f8072485abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this function is compiled, include code that dumps its values to a file after it is realized, for the purpose of debugging.  <br /></td></tr>
<tr class="separator:af001fb038dcce6dc07166f8072485abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac119151e46e02b367a60a2af6ff02420" id="r_ac119151e46e02b367a60a2af6ff02420"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac119151e46e02b367a60a2af6ff02420">name</a> () const</td></tr>
<tr class="memdesc:ac119151e46e02b367a60a2af6ff02420"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this function, either given during construction, or automatically generated.  <br /></td></tr>
<tr class="separator:ac119151e46e02b367a60a2af6ff02420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa2fe6d902d1c426ad209ec6a986ace" id="r_a6fa2fe6d902d1c426ad209ec6a986ace"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a> () const</td></tr>
<tr class="memdesc:a6fa2fe6d902d1c426ad209ec6a986ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pure arguments.  <br /></td></tr>
<tr class="separator:a6fa2fe6d902d1c426ad209ec6a986ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90926a2fe1bd3b6db924e8bdd53b5ed4" id="r_a90926a2fe1bd3b6db924e8bdd53b5ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">value</a> () const</td></tr>
<tr class="memdesc:a90926a2fe1bd3b6db924e8bdd53b5ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The right-hand-side value of the pure definition of this function.  <br /></td></tr>
<tr class="separator:a90926a2fe1bd3b6db924e8bdd53b5ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae128ce6543038092523c2848b150bfc1" id="r_ae128ce6543038092523c2848b150bfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae128ce6543038092523c2848b150bfc1">values</a> () const</td></tr>
<tr class="memdesc:ae128ce6543038092523c2848b150bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values returned by this function.  <br /></td></tr>
<tr class="separator:ae128ce6543038092523c2848b150bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ae7c756f051da46e75cd63e325a47" id="r_a3a6ae7c756f051da46e75cd63e325a47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a6ae7c756f051da46e75cd63e325a47">defined</a> () const</td></tr>
<tr class="memdesc:a3a6ae7c756f051da46e75cd63e325a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function have at least a pure definition.  <br /></td></tr>
<tr class="separator:a3a6ae7c756f051da46e75cd63e325a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658952efccaf4cd532652eb3bef5ba51" id="r_a658952efccaf4cd532652eb3bef5ba51"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658952efccaf4cd532652eb3bef5ba51">update_args</a> (int idx=0) const</td></tr>
<tr class="memdesc:a658952efccaf4cd532652eb3bef5ba51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the left-hand-side of the update definition.  <br /></td></tr>
<tr class="separator:a658952efccaf4cd532652eb3bef5ba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc992a5e7a33090b1fc11b7c60ff97f" id="r_a9fc992a5e7a33090b1fc11b7c60ff97f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fc992a5e7a33090b1fc11b7c60ff97f">update_value</a> (int idx=0) const</td></tr>
<tr class="memdesc:a9fc992a5e7a33090b1fc11b7c60ff97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right-hand-side of an update definition.  <br /></td></tr>
<tr class="separator:a9fc992a5e7a33090b1fc11b7c60ff97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705c75484752d64d66abac9b1ebf5b13" id="r_a705c75484752d64d66abac9b1ebf5b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705c75484752d64d66abac9b1ebf5b13">update_values</a> (int idx=0) const</td></tr>
<tr class="memdesc:a705c75484752d64d66abac9b1ebf5b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right-hand-side of an update definition for functions that returns multiple values.  <br /></td></tr>
<tr class="separator:a705c75484752d64d66abac9b1ebf5b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13c0acfd2499ef245947595e9d092d7" id="r_ad13c0acfd2499ef245947595e9d092d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad13c0acfd2499ef245947595e9d092d7">rvars</a> (int idx=0) const</td></tr>
<tr class="memdesc:ad13c0acfd2499ef245947595e9d092d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RVars of the reduction domain for an update definition, if there is one.  <br /></td></tr>
<tr class="separator:ad13c0acfd2499ef245947595e9d092d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0049f405a62cd2bf0205f92b3ac99e" id="r_a1b0049f405a62cd2bf0205f92b3ac99e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b0049f405a62cd2bf0205f92b3ac99e">has_update_definition</a> () const</td></tr>
<tr class="memdesc:a1b0049f405a62cd2bf0205f92b3ac99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function have at least one update definition?  <br /></td></tr>
<tr class="separator:a1b0049f405a62cd2bf0205f92b3ac99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78585432af7129ce0e767f070aa3b2a6" id="r_a78585432af7129ce0e767f070aa3b2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78585432af7129ce0e767f070aa3b2a6">num_update_definitions</a> () const</td></tr>
<tr class="memdesc:a78585432af7129ce0e767f070aa3b2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many update definitions does this function have?  <br /></td></tr>
<tr class="separator:a78585432af7129ce0e767f070aa3b2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a38e09eb4696b1d37b640c639f6299" id="r_a06a38e09eb4696b1d37b640c639f6299"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06a38e09eb4696b1d37b640c639f6299">is_extern</a> () const</td></tr>
<tr class="memdesc:a06a38e09eb4696b1d37b640c639f6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this function an external stage? That is, was it defined using define_extern?  <br /></td></tr>
<tr class="separator:a06a38e09eb4696b1d37b640c639f6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8432d789980de9e281e0e54b70307f7" id="r_ab8432d789980de9e281e0e54b70307f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8432d789980de9e281e0e54b70307f7">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, <a class="el" href="struct_halide_1_1_type.html">Type</a> t, int dimensionality, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> mangling=<a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a>)</td></tr>
<tr class="memdesc:ab8432d789980de9e281e0e54b70307f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extern definition for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:ab8432d789980de9e281e0e54b70307f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9764c21ad6794e74d9aa4c069741e45" id="r_af9764c21ad6794e74d9aa4c069741e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9764c21ad6794e74d9aa4c069741e45">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;<a class="el" href="#a5dcf6c24fd1de40b52d3709933e4e009">types</a>, int dimensionality, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> mangling)</td></tr>
<tr class="separator:af9764c21ad6794e74d9aa4c069741e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9965443aea3975bfe1b8f5787f47025b" id="r_a9965443aea3975bfe1b8f5787f47025b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9965443aea3975bfe1b8f5787f47025b">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;<a class="el" href="#a5dcf6c24fd1de40b52d3709933e4e009">types</a>, int dimensionality, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> mangling=<a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a>)</td></tr>
<tr class="separator:a9965443aea3975bfe1b8f5787f47025b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2685cc1459971deebca75fa6de2ee9" id="r_aec2685cc1459971deebca75fa6de2ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec2685cc1459971deebca75fa6de2ee9">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, <a class="el" href="struct_halide_1_1_type.html">Type</a> t, const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;arguments, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> mangling=<a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a>)</td></tr>
<tr class="separator:aec2685cc1459971deebca75fa6de2ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df7a80d0dfa5f24c61f1346e4365bf6" id="r_a8df7a80d0dfa5f24c61f1346e4365bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8df7a80d0dfa5f24c61f1346e4365bf6">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;<a class="el" href="#a5dcf6c24fd1de40b52d3709933e4e009">types</a>, const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;arguments, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> mangling=<a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a>)</td></tr>
<tr class="separator:a8df7a80d0dfa5f24c61f1346e4365bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2103b97e0f563aba56aaabd2f82e1d03" id="r_a2103b97e0f563aba56aaabd2f82e1d03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">type</a> () const</td></tr>
<tr class="memdesc:a2103b97e0f563aba56aaabd2f82e1d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type(s) of the outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a2103b97e0f563aba56aaabd2f82e1d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcf6c24fd1de40b52d3709933e4e009" id="r_a5dcf6c24fd1de40b52d3709933e4e009"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dcf6c24fd1de40b52d3709933e4e009">types</a> () const</td></tr>
<tr class="separator:a5dcf6c24fd1de40b52d3709933e4e009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66202288811f0d1ef8810d0baab207f4" id="r_a66202288811f0d1ef8810d0baab207f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66202288811f0d1ef8810d0baab207f4">outputs</a> () const</td></tr>
<tr class="memdesc:a66202288811f0d1ef8810d0baab207f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a66202288811f0d1ef8810d0baab207f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33375e0e54f39e647c6988d283ef8f2" id="r_ae33375e0e54f39e647c6988d283ef8f2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33375e0e54f39e647c6988d283ef8f2">extern_function_name</a> () const</td></tr>
<tr class="memdesc:ae33375e0e54f39e647c6988d283ef8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the extern function called for an extern definition.  <br /></td></tr>
<tr class="separator:ae33375e0e54f39e647c6988d283ef8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ef02d97a2c77c7061f73b7768880e6" id="r_a55ef02d97a2c77c7061f73b7768880e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55ef02d97a2c77c7061f73b7768880e6">dimensions</a> () const</td></tr>
<tr class="memdesc:a55ef02d97a2c77c7061f73b7768880e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality (number of arguments) of this function.  <br /></td></tr>
<tr class="separator:a55ef02d97a2c77c7061f73b7768880e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68de832a30ac471a89ae2247012fb42" id="r_af68de832a30ac471a89ae2247012fb42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af68de832a30ac471a89ae2247012fb42">operator()</a> (std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;) const</td></tr>
<tr class="memdesc:af68de832a30ac471a89ae2247012fb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <br /></td></tr>
<tr class="separator:af68de832a30ac471a89ae2247012fb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b76c068f619d618e0bcf2b5d1b7994" id="r_ad3b76c068f619d618e0bcf2b5d1b7994"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad3b76c068f619d618e0bcf2b5d1b7994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="class_halide_1_1_var.html">Var</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3b76c068f619d618e0bcf2b5d1b7994">operator()</a> (Args &amp;&amp;...<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>) const</td></tr>
<tr class="separator:ad3b76c068f619d618e0bcf2b5d1b7994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0769211233b39808c5b4c76d843e611a" id="r_a0769211233b39808c5b4c76d843e611a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0769211233b39808c5b4c76d843e611a">operator()</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;) const</td></tr>
<tr class="memdesc:a0769211233b39808c5b4c76d843e611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of an update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <br /></td></tr>
<tr class="separator:a0769211233b39808c5b4c76d843e611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8080fd1a2425585c3c2382aa8fa683" id="r_a2a8080fd1a2425585c3c2382aa8fa683"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2a8080fd1a2425585c3c2382aa8fa683"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a8080fd1a2425585c3c2382aa8fa683">operator()</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x, Args &amp;&amp;...<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>) const</td></tr>
<tr class="separator:a2a8080fd1a2425585c3c2382aa8fa683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0957a1f444256a88279d5d922bf1c52" id="r_af0957a1f444256a88279d5d922bf1c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0957a1f444256a88279d5d922bf1c52">in</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f)</td></tr>
<tr class="memdesc:af0957a1f444256a88279d5d922bf1c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new identity <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that wraps this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:af0957a1f444256a88279d5d922bf1c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6279995e3a5b078ee60c680d1decb2b" id="r_aa6279995e3a5b078ee60c680d1decb2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6279995e3a5b078ee60c680d1decb2b">in</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;fs)</td></tr>
<tr class="memdesc:aa6279995e3a5b078ee60c680d1decb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return an identity wrapper shared by all the Funcs in 'fs'.  <br /></td></tr>
<tr class="separator:aa6279995e3a5b078ee60c680d1decb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d619f2d0111ea5bf640781d1324d050" id="r_a9d619f2d0111ea5bf640781d1324d050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d619f2d0111ea5bf640781d1324d050">in</a> ()</td></tr>
<tr class="memdesc:a9d619f2d0111ea5bf640781d1324d050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a global identity wrapper, which wraps all calls to this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by any other <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a9d619f2d0111ea5bf640781d1324d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c1059311b4211ab60d4b38963b1e8d" id="r_ad1c1059311b4211ab60d4b38963b1e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1c1059311b4211ab60d4b38963b1e8d">clone_in</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f)</td></tr>
<tr class="memdesc:ad1c1059311b4211ab60d4b38963b1e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="#af0957a1f444256a88279d5d922bf1c52">Func::in</a>; however, instead of replacing the call to this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with an identity <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that refers to it, this replaces the call with a clone of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:ad1c1059311b4211ab60d4b38963b1e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b37c0c468df27d16c3b6190bd9475" id="r_a954b37c0c468df27d16c3b6190bd9475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a954b37c0c468df27d16c3b6190bd9475">clone_in</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;fs)</td></tr>
<tr class="separator:a954b37c0c468df27d16c3b6190bd9475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74b2c71950c16b88f4d7883b55fd366" id="r_ae74b2c71950c16b88f4d7883b55fd366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae74b2c71950c16b88f4d7883b55fd366">copy_to_device</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> d=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:ae74b2c71950c16b88f4d7883b55fd366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare that this function should be implemented by a call to halide_buffer_copy with the given target device API.  <br /></td></tr>
<tr class="separator:ae74b2c71950c16b88f4d7883b55fd366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e9130ba2e3289b7cfe307f06351f92" id="r_a41e9130ba2e3289b7cfe307f06351f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41e9130ba2e3289b7cfe307f06351f92">copy_to_host</a> ()</td></tr>
<tr class="memdesc:a41e9130ba2e3289b7cfe307f06351f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare that this function should be implemented by a call to halide_buffer_copy with a NULL target device API.  <br /></td></tr>
<tr class="separator:a41e9130ba2e3289b7cfe307f06351f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9feebea3c3da655f623422971f869c" id="r_a4f9feebea3c3da655f623422971f869c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f9feebea3c3da655f623422971f869c">split</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a4f9feebea3c3da655f623422971f869c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1.  <br /></td></tr>
<tr class="separator:a4f9feebea3c3da655f623422971f869c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af094cac26cfad9cf0b550d6329c503f5" id="r_af094cac26cfad9cf0b550d6329c503f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af094cac26cfad9cf0b550d6329c503f5">fuse</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;fused)</td></tr>
<tr class="memdesc:af094cac26cfad9cf0b550d6329c503f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two dimensions into a single fused dimension.  <br /></td></tr>
<tr class="separator:af094cac26cfad9cf0b550d6329c503f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bb370513cf7f0c45d9f2f4f53e694f" id="r_a46bb370513cf7f0c45d9f2f4f53e694f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46bb370513cf7f0c45d9f2f4f53e694f">serial</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="memdesc:a46bb370513cf7f0c45d9f2f4f53e694f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be traversed serially.  <br /></td></tr>
<tr class="separator:a46bb370513cf7f0c45d9f2f4f53e694f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78db35f74950c9e9c586f6ad7a3e7e0" id="r_ae78db35f74950c9e9c586f6ad7a3e7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae78db35f74950c9e9c586f6ad7a3e7e0">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="memdesc:ae78db35f74950c9e9c586f6ad7a3e7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be traversed in parallel.  <br /></td></tr>
<tr class="separator:ae78db35f74950c9e9c586f6ad7a3e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af075813ccb2d266dd7c1d9c8552e2feb" id="r_af075813ccb2d266dd7c1d9c8552e2feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af075813ccb2d266dd7c1d9c8552e2feb">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;task_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:af075813ccb2d266dd7c1d9c8552e2feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given task_size, and the parallelize the outer dimension.  <br /></td></tr>
<tr class="separator:af075813ccb2d266dd7c1d9c8552e2feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc273557b19c8c02c948f7e8ca56ffd" id="r_aefc273557b19c8c02c948f7e8ca56ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc273557b19c8c02c948f7e8ca56ffd">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="memdesc:aefc273557b19c8c02c948f7e8ca56ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be computed all-at-once as a single vector.  <br /></td></tr>
<tr class="separator:aefc273557b19c8c02c948f7e8ca56ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c93c10aecaeab1d98d0f65461536bf4" id="r_a9c93c10aecaeab1d98d0f65461536bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c93c10aecaeab1d98d0f65461536bf4">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="memdesc:a9c93c10aecaeab1d98d0f65461536bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be completely unrolled.  <br /></td></tr>
<tr class="separator:a9c93c10aecaeab1d98d0f65461536bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad9bed80565d85f2cc6d09c607fdfb" id="r_a13ad9bed80565d85f2cc6d09c607fdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13ad9bed80565d85f2cc6d09c607fdfb">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a13ad9bed80565d85f2cc6d09c607fdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then vectorize the inner dimension.  <br /></td></tr>
<tr class="separator:a13ad9bed80565d85f2cc6d09c607fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cd7a5c03324c4d876626307939ef80" id="r_a05cd7a5c03324c4d876626307939ef80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05cd7a5c03324c4d876626307939ef80">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a05cd7a5c03324c4d876626307939ef80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then unroll the inner dimension.  <br /></td></tr>
<tr class="separator:a05cd7a5c03324c4d876626307939ef80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daf72571f0086e550eefb984ae18415" id="r_a0daf72571f0086e550eefb984ae18415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0daf72571f0086e550eefb984ae18415">partition</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="namespace_halide.html#af5048e52b474e6d6733ffa66f800b881">Partition</a> partition_policy)</td></tr>
<tr class="memdesc:a0daf72571f0086e550eefb984ae18415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy.  <br /></td></tr>
<tr class="separator:a0daf72571f0086e550eefb984ae18415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e658dd0591a5dfa7c0a5f10cc015441" id="r_a7e658dd0591a5dfa7c0a5f10cc015441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e658dd0591a5dfa7c0a5f10cc015441">never_partition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7e658dd0591a5dfa7c0a5f10cc015441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy to Never for a vector of Vars and RVars.  <br /></td></tr>
<tr class="separator:a7e658dd0591a5dfa7c0a5f10cc015441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0f7473b1ed9623ef2566d63a9ac975" id="r_adf0f7473b1ed9623ef2566d63a9ac975"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adf0f7473b1ed9623ef2566d63a9ac975"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf0f7473b1ed9623ef2566d63a9ac975">never_partition</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, Args &amp;&amp;...<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>)</td></tr>
<tr class="memdesc:adf0f7473b1ed9623ef2566d63a9ac975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy to Never for some number of Vars and RVars.  <br /></td></tr>
<tr class="separator:adf0f7473b1ed9623ef2566d63a9ac975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f033bff4f8e6215f8c7f3ff80fa61ad" id="r_a0f033bff4f8e6215f8c7f3ff80fa61ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f033bff4f8e6215f8c7f3ff80fa61ad">never_partition_all</a> ()</td></tr>
<tr class="memdesc:a0f033bff4f8e6215f8c7f3ff80fa61ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy to Never for all Vars and <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> of the initial definition of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a0f033bff4f8e6215f8c7f3ff80fa61ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4932df8bc02e8f205d485b9ef609d0b" id="r_ab4932df8bc02e8f205d485b9ef609d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4932df8bc02e8f205d485b9ef609d0b">always_partition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ab4932df8bc02e8f205d485b9ef609d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy to Always for a vector of Vars and RVars.  <br /></td></tr>
<tr class="separator:ab4932df8bc02e8f205d485b9ef609d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1262e391aaebca7ee7536e5e6d0e765" id="r_af1262e391aaebca7ee7536e5e6d0e765"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af1262e391aaebca7ee7536e5e6d0e765"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1262e391aaebca7ee7536e5e6d0e765">always_partition</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, Args &amp;&amp;...<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>)</td></tr>
<tr class="memdesc:af1262e391aaebca7ee7536e5e6d0e765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy to Always for some number of Vars and RVars.  <br /></td></tr>
<tr class="separator:af1262e391aaebca7ee7536e5e6d0e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7150dba01f063399eb130c968eaafbb" id="r_af7150dba01f063399eb130c968eaafbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7150dba01f063399eb130c968eaafbb">always_partition_all</a> ()</td></tr>
<tr class="memdesc:af7150dba01f063399eb130c968eaafbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop partition policy to Always for all Vars and <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> of the initial definition of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:af7150dba01f063399eb130c968eaafbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2825e04367798cb1d2b58cf13a7b2" id="r_af0a2825e04367798cb1d2b58cf13a7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a2825e04367798cb1d2b58cf13a7b2">bound</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr class="memdesc:af0a2825e04367798cb1d2b58cf13a7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically declare that the range over which a function should be evaluated is given by the second and third arguments.  <br /></td></tr>
<tr class="separator:af0a2825e04367798cb1d2b58cf13a7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed454dcacda07083b13a4f697ee02f2" id="r_a2ed454dcacda07083b13a4f697ee02f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ed454dcacda07083b13a4f697ee02f2">set_estimate</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;extent)</td></tr>
<tr class="memdesc:a2ed454dcacda07083b13a4f697ee02f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically declare the range over which the function will be evaluated in the general case.  <br /></td></tr>
<tr class="separator:a2ed454dcacda07083b13a4f697ee02f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cadbe9d4510716b10d07cac7956f16c" id="r_a9cadbe9d4510716b10d07cac7956f16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cadbe9d4510716b10d07cac7956f16c">set_estimates</a> (const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;estimates)</td></tr>
<tr class="memdesc:a9cadbe9d4510716b10d07cac7956f16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (min, extent) estimates for all dimensions in the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at once; this is equivalent to calling <code>set_estimate(args()[n], min, extent)</code> repeatedly, but slightly terser.  <br /></td></tr>
<tr class="separator:a9cadbe9d4510716b10d07cac7956f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5b9179f8f69789f4b2db823e4c6129" id="r_a4a5b9179f8f69789f4b2db823e4c6129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a5b9179f8f69789f4b2db823e4c6129">align_bounds</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> modulus, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> remainder=0)</td></tr>
<tr class="memdesc:a4a5b9179f8f69789f4b2db823e4c6129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the region computed so that the min coordinates is congruent to 'remainder' modulo 'modulus', and the extent is a multiple of 'modulus'.  <br /></td></tr>
<tr class="separator:a4a5b9179f8f69789f4b2db823e4c6129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b24acb865c4ca47b5e03d57cf8fc9" id="r_a927b24acb865c4ca47b5e03d57cf8fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a927b24acb865c4ca47b5e03d57cf8fc9">align_extent</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> modulus)</td></tr>
<tr class="memdesc:a927b24acb865c4ca47b5e03d57cf8fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the region computed so that the extent is a multiple of 'modulus'.  <br /></td></tr>
<tr class="separator:a927b24acb865c4ca47b5e03d57cf8fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e8400651242c62ab709cefeda1062c" id="r_a03e8400651242c62ab709cefeda1062c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03e8400651242c62ab709cefeda1062c">bound_extent</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr class="memdesc:a03e8400651242c62ab709cefeda1062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the extent of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s realization, but not its min.  <br /></td></tr>
<tr class="separator:a03e8400651242c62ab709cefeda1062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5413c606618e7c4257a1129666922fb5" id="r_a5413c606618e7c4257a1129666922fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5413c606618e7c4257a1129666922fb5">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a5413c606618e7c4257a1129666922fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards.  <br /></td></tr>
<tr class="separator:a5413c606618e7c4257a1129666922fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be85a5c88dec96e8b8ee8aa94816ff9" id="r_a7be85a5c88dec96e8b8ee8aa94816ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be85a5c88dec96e8b8ee8aa94816ff9">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a7be85a5c88dec96e8b8ee8aa94816ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shorter form of tile, which reuses the old variable names as the new outer dimensions.  <br /></td></tr>
<tr class="separator:a7be85a5c88dec96e8b8ee8aa94816ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60df741c4533d2beeda778d43de57553" id="r_a60df741c4533d2beeda778d43de57553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60df741c4533d2beeda778d43de57553">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;tails)</td></tr>
<tr class="memdesc:a60df741c4533d2beeda778d43de57553"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more general form of tile, which defines tiles of any dimensionality.  <br /></td></tr>
<tr class="separator:a60df741c4533d2beeda778d43de57553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ba4f7b004b9efcb61bc7b23dd151f5" id="r_a16ba4f7b004b9efcb61bc7b23dd151f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16ba4f7b004b9efcb61bc7b23dd151f5">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a16ba4f7b004b9efcb61bc7b23dd151f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generalized tile, with a single tail strategy to apply to all vars.  <br /></td></tr>
<tr class="separator:a16ba4f7b004b9efcb61bc7b23dd151f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7091adc43ef2945f2b564eb73e23343" id="r_ac7091adc43ef2945f2b564eb73e23343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7091adc43ef2945f2b564eb73e23343">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:ac7091adc43ef2945f2b564eb73e23343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized tiling, reusing the previous names as the outer names.  <br /></td></tr>
<tr class="separator:ac7091adc43ef2945f2b564eb73e23343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295dda0c50965d5b29fa9fc48a9edbf4" id="r_a295dda0c50965d5b29fa9fc48a9edbf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a295dda0c50965d5b29fa9fc48a9edbf4">reorder</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a295dda0c50965d5b29fa9fc48a9edbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder variables to have the given nesting order, from innermost out.  <br /></td></tr>
<tr class="separator:a295dda0c50965d5b29fa9fc48a9edbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a2bc9d4bb4dfab342f3f412f8e2927" id="r_a77a2bc9d4bb4dfab342f3f412f8e2927"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a77a2bc9d4bb4dfab342f3f412f8e2927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77a2bc9d4bb4dfab342f3f412f8e2927">reorder</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, Args &amp;&amp;...<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>)</td></tr>
<tr class="separator:a77a2bc9d4bb4dfab342f3f412f8e2927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae059d387e9df97751c0c74bd28c91708" id="r_ae059d387e9df97751c0c74bd28c91708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae059d387e9df97751c0c74bd28c91708">rename</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old_name, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;new_name)</td></tr>
<tr class="memdesc:ae059d387e9df97751c0c74bd28c91708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a dimension.  <br /></td></tr>
<tr class="separator:ae059d387e9df97751c0c74bd28c91708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712365570e7695d9b157ba2e4b089343" id="r_a712365570e7695d9b157ba2e4b089343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a712365570e7695d9b157ba2e4b089343">allow_race_conditions</a> ()</td></tr>
<tr class="memdesc:a712365570e7695d9b157ba2e4b089343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that race conditions are permitted for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, which enables parallelizing over RVars even when <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> cannot prove that it is safe to do so.  <br /></td></tr>
<tr class="separator:a712365570e7695d9b157ba2e4b089343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a03efea97147fa0ab55cc86106f17a" id="r_a97a03efea97147fa0ab55cc86106f17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97a03efea97147fa0ab55cc86106f17a">atomic</a> (bool override_associativity_test=false)</td></tr>
<tr class="memdesc:a97a03efea97147fa0ab55cc86106f17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue atomic updates for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a97a03efea97147fa0ab55cc86106f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84f672454064d16ab214cbae90c464" id="r_a7e84f672454064d16ab214cbae90c464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e84f672454064d16ab214cbae90c464">specialize</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;condition)</td></tr>
<tr class="memdesc:a7e84f672454064d16ab214cbae90c464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a7e84f672454064d16ab214cbae90c464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b75965d72a3f1cd98e4f13cfe28aaf" id="r_a11b75965d72a3f1cd98e4f13cfe28aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b75965d72a3f1cd98e4f13cfe28aaf">specialize_fail</a> (const std::string &amp;message)</td></tr>
<tr class="memdesc:a11b75965d72a3f1cd98e4f13cfe28aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a specialization to a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that always terminates execution with a call to <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8" title="Halide calls this function on runtime errors (for example bounds checking failures).">halide_error()</a>.  <br /></td></tr>
<tr class="separator:a11b75965d72a3f1cd98e4f13cfe28aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab190a2b563e3cdfdf7b52a4a7e9a7962" id="r_ab190a2b563e3cdfdf7b52a4a7e9a7962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab190a2b563e3cdfdf7b52a4a7e9a7962">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:ab190a2b563e3cdfdf7b52a4a7e9a7962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> that the following dimensions correspond to GPU thread indices.  <br /></td></tr>
<tr class="separator:ab190a2b563e3cdfdf7b52a4a7e9a7962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3715a7bf2ae98559ed7e4c2959b97b3a" id="r_a3715a7bf2ae98559ed7e4c2959b97b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3715a7bf2ae98559ed7e4c2959b97b3a">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a3715a7bf2ae98559ed7e4c2959b97b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b1fa5f7c8744bf77f6bc46ecf3fada" id="r_ae7b1fa5f7c8744bf77f6bc46ecf3fada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b1fa5f7c8744bf77f6bc46ecf3fada">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ae7b1fa5f7c8744bf77f6bc46ecf3fada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f795873445836af0c7643d4c99a2ee2" id="r_a2f795873445836af0c7643d4c99a2ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f795873445836af0c7643d4c99a2ee2">gpu_lanes</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:a2f795873445836af0c7643d4c99a2ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given dimension corresponds to the lanes in a GPU warp.  <br /></td></tr>
<tr class="separator:a2f795873445836af0c7643d4c99a2ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83e9ccd0de6fd575006ab04c220ece2" id="r_af83e9ccd0de6fd575006ab04c220ece2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af83e9ccd0de6fd575006ab04c220ece2">gpu_single_thread</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:af83e9ccd0de6fd575006ab04c220ece2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to run this stage using a single gpu thread and block.  <br /></td></tr>
<tr class="separator:af83e9ccd0de6fd575006ab04c220ece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b8d8ad9e4f4b25a23bab71d77de165" id="r_a02b8d8ad9e4f4b25a23bab71d77de165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02b8d8ad9e4f4b25a23bab71d77de165">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:a02b8d8ad9e4f4b25a23bab71d77de165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> that the following dimensions correspond to GPU block indices.  <br /></td></tr>
<tr class="separator:a02b8d8ad9e4f4b25a23bab71d77de165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a246ffb10d6bf598bacec308c58387" id="r_a36a246ffb10d6bf598bacec308c58387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a246ffb10d6bf598bacec308c58387">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a36a246ffb10d6bf598bacec308c58387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e63197448302757cf990fcc0e0cb682" id="r_a2e63197448302757cf990fcc0e0cb682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e63197448302757cf990fcc0e0cb682">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a2e63197448302757cf990fcc0e0cb682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022f7853d7313f6a5128ce8c24ed05ce" id="r_a022f7853d7313f6a5128ce8c24ed05ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a022f7853d7313f6a5128ce8c24ed05ce">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:a022f7853d7313f6a5128ce8c24ed05ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> that the following dimensions correspond to GPU block indices and thread indices.  <br /></td></tr>
<tr class="separator:a022f7853d7313f6a5128ce8c24ed05ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599a3fb276bce469fe19dcad526908b1" id="r_a599a3fb276bce469fe19dcad526908b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a599a3fb276bce469fe19dcad526908b1">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a599a3fb276bce469fe19dcad526908b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc7cea9bf01c8db41a5901a659c146d" id="r_aebc7cea9bf01c8db41a5901a659c146d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebc7cea9bf01c8db41a5901a659c146d">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aebc7cea9bf01c8db41a5901a659c146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce7c7be7f2a6f4ab1dc806c6124850" id="r_afdce7c7be7f2a6f4ab1dc806c6124850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdce7c7be7f2a6f4ab1dc806c6124850">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="memdesc:afdce7c7be7f2a6f4ab1dc806c6124850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices.  <br /></td></tr>
<tr class="separator:afdce7c7be7f2a6f4ab1dc806c6124850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e7ce74cb609e959c1222b4b6637fd" id="r_a448e7ce74cb609e959c1222b4b6637fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448e7ce74cb609e959c1222b4b6637fd">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a448e7ce74cb609e959c1222b4b6637fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fbc9b1d1bda331d5e2a53c9e1d339c" id="r_ac9fbc9b1d1bda331d5e2a53c9e1d339c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9fbc9b1d1bda331d5e2a53c9e1d339c">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ac9fbc9b1d1bda331d5e2a53c9e1d339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081082518ba27137531a2cba4d552351" id="r_a081082518ba27137531a2cba4d552351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081082518ba27137531a2cba4d552351">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a081082518ba27137531a2cba4d552351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fd2e3cb76e2d6a8fb650f13f51d8e0" id="r_a62fd2e3cb76e2d6a8fb650f13f51d8e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62fd2e3cb76e2d6a8fb650f13f51d8e0">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bz, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a62fd2e3cb76e2d6a8fb650f13f51d8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7881893e0a1db5ac9429c46334ecaf" id="r_a8d7881893e0a1db5ac9429c46334ecaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7881893e0a1db5ac9429c46334ecaf">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a8d7881893e0a1db5ac9429c46334ecaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5834ded586e70e65b93850d7cafed54" id="r_ac5834ded586e70e65b93850d7cafed54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5834ded586e70e65b93850d7cafed54">hexagon</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x=<a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>())</td></tr>
<tr class="memdesc:ac5834ded586e70e65b93850d7cafed54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule for execution on Hexagon.  <br /></td></tr>
<tr class="separator:ac5834ded586e70e65b93850d7cafed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb11c7c6f5ce93beed415260430ce55" id="r_accb11c7c6f5ce93beed415260430ce55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="memdesc:accb11c7c6f5ce93beed415260430ce55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch data written to or read from a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> by a subsequent loop iteration, at an optionally specified iteration offset.  <br /></td></tr>
<tr class="separator:accb11c7c6f5ce93beed415260430ce55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1102f220f97b8e7e80bdd113567b53c9" id="r_a1102f220f97b8e7e80bdd113567b53c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1102f220f97b8e7e80bdd113567b53c9">prefetch</a> (const <a class="el" href="class_halide_1_1_parameter.html">Parameter</a> &amp;param, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a1102f220f97b8e7e80bdd113567b53c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af212c2cce113c096f2ddc96a10ee66d1" id="r_af212c2cce113c096f2ddc96a10ee66d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af212c2cce113c096f2ddc96a10ee66d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af212c2cce113c096f2ddc96a10ee66d1">prefetch</a> (const T &amp;image, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:af212c2cce113c096f2ddc96a10ee66d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91507761237f8f477fb190bcba1c779" id="r_ae91507761237f8f477fb190bcba1c779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae91507761237f8f477fb190bcba1c779">reorder_storage</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:ae91507761237f8f477fb190bcba1c779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how the storage for the function is laid out.  <br /></td></tr>
<tr class="separator:ae91507761237f8f477fb190bcba1c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad4486909529683fd2d47b3d8b8d9cf" id="r_a4ad4486909529683fd2d47b3d8b8d9cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ad4486909529683fd2d47b3d8b8d9cf">reorder_storage</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;y)</td></tr>
<tr class="separator:a4ad4486909529683fd2d47b3d8b8d9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cd53894a9e7385b3a80c9ec159346b" id="r_a66cd53894a9e7385b3a80c9ec159346b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a66cd53894a9e7385b3a80c9ec159346b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="class_halide_1_1_var.html">Var</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66cd53894a9e7385b3a80c9ec159346b">reorder_storage</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;y, Args &amp;&amp;...<a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args</a>)</td></tr>
<tr class="separator:a66cd53894a9e7385b3a80c9ec159346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9c4e071b44874bdfa1e0b6eea507de" id="r_a3b9c4e071b44874bdfa1e0b6eea507de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9c4e071b44874bdfa1e0b6eea507de">align_storage</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;dim, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;alignment)</td></tr>
<tr class="memdesc:a3b9c4e071b44874bdfa1e0b6eea507de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the storage extent of a particular dimension of realizations of this function up to be a multiple of the specified alignment.  <br /></td></tr>
<tr class="separator:a3b9c4e071b44874bdfa1e0b6eea507de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8900f676c8ba7a07181b96977f00d74" id="r_aa8900f676c8ba7a07181b96977f00d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8900f676c8ba7a07181b96977f00d74">fold_storage</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;dim, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;extent, bool fold_forward=true)</td></tr>
<tr class="memdesc:aa8900f676c8ba7a07181b96977f00d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store realizations of this function in a circular buffer of a given extent.  <br /></td></tr>
<tr class="separator:aa8900f676c8ba7a07181b96977f00d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4aca8ca6331e64a6fdfd98fccf1757a" id="r_af4aca8ca6331e64a6fdfd98fccf1757a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var)</td></tr>
<tr class="memdesc:af4aca8ca6331e64a6fdfd98fccf1757a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute this function as needed for each unique value of the given var for the given calling function f.  <br /></td></tr>
<tr class="separator:af4aca8ca6331e64a6fdfd98fccf1757a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ab65cc3d4f1b0d0e1813d9eab4a526" id="r_a14ab65cc3d4f1b0d0e1813d9eab4a526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ab65cc3d4f1b0d0e1813d9eab4a526">compute_at</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;var)</td></tr>
<tr class="memdesc:a14ab65cc3d4f1b0d0e1813d9eab4a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a function to be computed within the iteration over some dimension of an update domain.  <br /></td></tr>
<tr class="separator:a14ab65cc3d4f1b0d0e1813d9eab4a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf98ea895de7cb30f564b52e4670ba64" id="r_aaf98ea895de7cb30f564b52e4670ba64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf98ea895de7cb30f564b52e4670ba64">compute_at</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level)</td></tr>
<tr class="memdesc:aaf98ea895de7cb30f564b52e4670ba64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a function to be computed within the iteration over a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <br /></td></tr>
<tr class="separator:aaf98ea895de7cb30f564b52e4670ba64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1204939742d77c847c0928e865d318" id="r_a8f1204939742d77c847c0928e865d318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f1204939742d77c847c0928e865d318">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;align)</td></tr>
<tr class="memdesc:a8f1204939742d77c847c0928e865d318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the iteration over the initial definition of this function to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <br /></td></tr>
<tr class="separator:a8f1204939742d77c847c0928e865d318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1a60b53a44e9cda48647da7509ae91" id="r_a8a1a60b53a44e9cda48647da7509ae91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a1a60b53a44e9cda48647da7509ae91">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:a8a1a60b53a44e9cda48647da7509ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b42699e504977b50f9a8196da81a3" id="r_a1c5b42699e504977b50f9a8196da81a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c5b42699e504977b50f9a8196da81a3">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;align)</td></tr>
<tr class="separator:a1c5b42699e504977b50f9a8196da81a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0512b7c3f16f16662dc49bba53775" id="r_a69f0512b7c3f16f16662dc49bba53775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f0512b7c3f16f16662dc49bba53775">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:a69f0512b7c3f16f16662dc49bba53775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5d6e8023b42e81d577a7c9c0c8df0" id="r_a67f5d6e8023b42e81d577a7c9c0c8df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67f5d6e8023b42e81d577a7c9c0c8df0">compute_root</a> ()</td></tr>
<tr class="memdesc:a67f5d6e8023b42e81d577a7c9c0c8df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all of this function once ahead of time.  <br /></td></tr>
<tr class="separator:a67f5d6e8023b42e81d577a7c9c0c8df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2880397c0b550288d17e6f4e08cf27" id="r_a0c2880397c0b550288d17e6f4e08cf27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c2880397c0b550288d17e6f4e08cf27">memoize</a> (const <a class="el" href="class_halide_1_1_eviction_key.html">EvictionKey</a> &amp;eviction_key=<a class="el" href="class_halide_1_1_eviction_key.html">EvictionKey</a>())</td></tr>
<tr class="memdesc:a0c2880397c0b550288d17e6f4e08cf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the halide_memoization_cache_... interface to store a computed version of this function across invocations of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a0c2880397c0b550288d17e6f4e08cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2442a24f054511ab4e181465196012d8" id="r_a2442a24f054511ab4e181465196012d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2442a24f054511ab4e181465196012d8">async</a> ()</td></tr>
<tr class="memdesc:a2442a24f054511ab4e181465196012d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> asynchronously in a separate thread.  <br /></td></tr>
<tr class="separator:a2442a24f054511ab4e181465196012d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826751d5d61453465b2320474f8ef852" id="r_a826751d5d61453465b2320474f8ef852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826751d5d61453465b2320474f8ef852">ring_buffer</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr class="memdesc:a826751d5d61453465b2320474f8ef852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the storage of the function by an extra dimension to enable ring buffering.  <br /></td></tr>
<tr class="separator:a826751d5d61453465b2320474f8ef852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf605eef64da4a4b3bb17a1483181dc6" id="r_adf605eef64da4a4b3bb17a1483181dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf605eef64da4a4b3bb17a1483181dc6">bound_storage</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;dim, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="#af0a2825e04367798cb1d2b58cf13a7b2">bound</a>)</td></tr>
<tr class="memdesc:adf605eef64da4a4b3bb17a1483181dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the extent of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s storage, but not extent of its compute.  <br /></td></tr>
<tr class="separator:adf605eef64da4a4b3bb17a1483181dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d784c5fe960c2c0e4c89961b8b71ef" id="r_aa5d784c5fe960c2c0e4c89961b8b71ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5d784c5fe960c2c0e4c89961b8b71ef">store_at</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var)</td></tr>
<tr class="memdesc:aa5d784c5fe960c2c0e4c89961b8b71ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for this function within f's loop over var.  <br /></td></tr>
<tr class="separator:aa5d784c5fe960c2c0e4c89961b8b71ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca1a5c2f0bc941129f2125b13d753b8" id="r_abca1a5c2f0bc941129f2125b13d753b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abca1a5c2f0bc941129f2125b13d753b8">store_at</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;var)</td></tr>
<tr class="memdesc:abca1a5c2f0bc941129f2125b13d753b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain.  <br /></td></tr>
<tr class="separator:abca1a5c2f0bc941129f2125b13d753b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b04c0b2d479b7cd2714a6b905564926" id="r_a8b04c0b2d479b7cd2714a6b905564926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b04c0b2d479b7cd2714a6b905564926">store_at</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level)</td></tr>
<tr class="memdesc:a8b04c0b2d479b7cd2714a6b905564926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage at a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <br /></td></tr>
<tr class="separator:a8b04c0b2d479b7cd2714a6b905564926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93658c5f706df4dced8b276400885c9" id="r_ac93658c5f706df4dced8b276400885c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac93658c5f706df4dced8b276400885c9">store_root</a> ()</td></tr>
<tr class="memdesc:ac93658c5f706df4dced8b276400885c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="#aa5d784c5fe960c2c0e4c89961b8b71ef">Func::store_at</a>, but schedules storage outside the outermost loop.  <br /></td></tr>
<tr class="separator:ac93658c5f706df4dced8b276400885c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad425d2e003947d41a69ad6c8077c2567" id="r_ad425d2e003947d41a69ad6c8077c2567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad425d2e003947d41a69ad6c8077c2567">hoist_storage</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;var)</td></tr>
<tr class="memdesc:ad425d2e003947d41a69ad6c8077c2567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist storage for this function within f's loop over var.  <br /></td></tr>
<tr class="separator:ad425d2e003947d41a69ad6c8077c2567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e67f7ad66ec91022f81e26d5875a05" id="r_af5e67f7ad66ec91022f81e26d5875a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e67f7ad66ec91022f81e26d5875a05">hoist_storage</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;var)</td></tr>
<tr class="memdesc:af5e67f7ad66ec91022f81e26d5875a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the version of hoist_storage that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain.  <br /></td></tr>
<tr class="separator:af5e67f7ad66ec91022f81e26d5875a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8900d497f117025455bc81c77f979f2" id="r_ae8900d497f117025455bc81c77f979f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8900d497f117025455bc81c77f979f2">hoist_storage</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level)</td></tr>
<tr class="memdesc:ae8900d497f117025455bc81c77f979f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the version of hoist_storage that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage at a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <br /></td></tr>
<tr class="separator:ae8900d497f117025455bc81c77f979f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9506f5d7199888be026f849b952a355" id="r_aa9506f5d7199888be026f849b952a355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9506f5d7199888be026f849b952a355">hoist_storage_root</a> ()</td></tr>
<tr class="memdesc:aa9506f5d7199888be026f849b952a355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="#aa9506f5d7199888be026f849b952a355">Func::hoist_storage_root</a>, but schedules storage outside the outermost loop.  <br /></td></tr>
<tr class="separator:aa9506f5d7199888be026f849b952a355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6136616192c9453749c6b501557ca08" id="r_ad6136616192c9453749c6b501557ca08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6136616192c9453749c6b501557ca08">compute_inline</a> ()</td></tr>
<tr class="memdesc:ad6136616192c9453749c6b501557ca08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressively inline all uses of this function.  <br /></td></tr>
<tr class="separator:ad6136616192c9453749c6b501557ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b8c4bece8042e500f838b72ed2b718" id="r_a34b8c4bece8042e500f838b72ed2b718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b8c4bece8042e500f838b72ed2b718">update</a> (int idx=0)</td></tr>
<tr class="memdesc:a34b8c4bece8042e500f838b72ed2b718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on an update step for the purposes of scheduling it.  <br /></td></tr>
<tr class="separator:a34b8c4bece8042e500f838b72ed2b718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b30d5ddaa9d8eeb50122ddb03d80c3" id="r_a20b30d5ddaa9d8eeb50122ddb03d80c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b30d5ddaa9d8eeb50122ddb03d80c3">store_in</a> (<a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a> memory_type)</td></tr>
<tr class="memdesc:a20b30d5ddaa9d8eeb50122ddb03d80c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of memory this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> should be stored in.  <br /></td></tr>
<tr class="separator:a20b30d5ddaa9d8eeb50122ddb03d80c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9226c8b5e603fc788e33882898aa4f" id="r_a0e9226c8b5e603fc788e33882898aa4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e9226c8b5e603fc788e33882898aa4f">trace_loads</a> ()</td></tr>
<tr class="memdesc:a0e9226c8b5e603fc788e33882898aa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace all loads from this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace.  <br /></td></tr>
<tr class="separator:a0e9226c8b5e603fc788e33882898aa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e34adc5c6dc2549d4ef28e56e3fac6d" id="r_a0e34adc5c6dc2549d4ef28e56e3fac6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e34adc5c6dc2549d4ef28e56e3fac6d">trace_stores</a> ()</td></tr>
<tr class="memdesc:a0e34adc5c6dc2549d4ef28e56e3fac6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace all stores to the buffer backing this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace.  <br /></td></tr>
<tr class="separator:a0e34adc5c6dc2549d4ef28e56e3fac6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aca2015bde5fc377ca1e4612f7c0c97" id="r_a6aca2015bde5fc377ca1e4612f7c0c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aca2015bde5fc377ca1e4612f7c0c97">trace_realizations</a> ()</td></tr>
<tr class="memdesc:a6aca2015bde5fc377ca1e4612f7c0c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace all realizations of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace.  <br /></td></tr>
<tr class="separator:a6aca2015bde5fc377ca1e4612f7c0c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba743330df92f4f979cb0cfd7f6c934a" id="r_aba743330df92f4f979cb0cfd7f6c934a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba743330df92f4f979cb0cfd7f6c934a">add_trace_tag</a> (const std::string &amp;trace_tag)</td></tr>
<tr class="memdesc:aba743330df92f4f979cb0cfd7f6c934a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a string of arbitrary text that will be passed thru to trace inspection code if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is realized in trace mode.  <br /></td></tr>
<tr class="separator:aba743330df92f4f979cb0cfd7f6c934a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe98bb08abd1d03ecee62a2d2e0f754" id="r_aebe98bb08abd1d03ecee62a2d2e0f754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe98bb08abd1d03ecee62a2d2e0f754">no_profiling</a> ()</td></tr>
<tr class="memdesc:aebe98bb08abd1d03ecee62a2d2e0f754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this function as a function that should not be profiled when using the target feature Profile or ProfileByTimer.  <br /></td></tr>
<tr class="separator:aebe98bb08abd1d03ecee62a2d2e0f754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e0eb9703d560b2d08965747e26bae7" id="r_a19e0eb9703d560b2d08965747e26bae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e0eb9703d560b2d08965747e26bae7">function</a> () const</td></tr>
<tr class="memdesc:a19e0eb9703d560b2d08965747e26bae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the internal halide function that this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> represents.  <br /></td></tr>
<tr class="separator:a19e0eb9703d560b2d08965747e26bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f623d418efe24a783d8609d2718ea06" id="r_a3f623d418efe24a783d8609d2718ea06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f623d418efe24a783d8609d2718ea06">operator Stage</a> () const</td></tr>
<tr class="memdesc:a3f623d418efe24a783d8609d2718ea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can cast a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to its pure stage for the purposes of scheduling it.  <br /></td></tr>
<tr class="separator:a3f623d418efe24a783d8609d2718ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8a7b45374c9820810ef6a4a9d6740c" id="r_a9f8a7b45374c9820810ef6a4a9d6740c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f8a7b45374c9820810ef6a4a9d6740c">output_buffer</a> () const</td></tr>
<tr class="memdesc:a9f8a7b45374c9820810ef6a4a9d6740c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the output buffer for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a9f8a7b45374c9820810ef6a4a9d6740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fe7a7b21b04d42a6aca24132b4b470" id="r_af0fe7a7b21b04d42a6aca24132b4b470"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0fe7a7b21b04d42a6aca24132b4b470">output_buffers</a> () const</td></tr>
<tr class="separator:af0fe7a7b21b04d42a6aca24132b4b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823545aae17330fb3d630bffc1720709" id="r_a823545aae17330fb3d630bffc1720709"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a823545aae17330fb3d630bffc1720709">operator ExternFuncArgument</a> () const</td></tr>
<tr class="memdesc:a823545aae17330fb3d630bffc1720709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> as an argument to an external stage.  <br /></td></tr>
<tr class="separator:a823545aae17330fb3d630bffc1720709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa203357492e584a49694d02372d2c557" id="r_aa203357492e584a49694d02372d2c557"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa203357492e584a49694d02372d2c557">infer_arguments</a> () const</td></tr>
<tr class="memdesc:aa203357492e584a49694d02372d2c557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the arguments to the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, sorted into a canonical order: all buffers (sorted alphabetically by name), followed by all non-buffers (sorted alphabetically by name).  <br /></td></tr>
<tr class="separator:aa203357492e584a49694d02372d2c557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74510055cf3aa69aafca6e1dbb8aa74" id="r_af74510055cf3aa69aafca6e1dbb8aa74"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74510055cf3aa69aafca6e1dbb8aa74">get_schedule</a> () const</td></tr>
<tr class="memdesc:af74510055cf3aa69aafca6e1dbb8aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current StageSchedule associated with this initial <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a> of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:af74510055cf3aa69aafca6e1dbb8aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A halide function. </p>
<p>This class represents one stage in a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and is the unit by which we schedule things. By default they are aggressively inlined, so you are encouraged to make lots of little functions, rather than storing things in Exprs. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_01_basics_8cpp-example.html#_a0">tutorial/lesson_01_basics.cpp</a>, <a class="el" href="tutorial_2lesson_02_input_image_8cpp-example.html#_a1">tutorial/lesson_02_input_image.cpp</a>, <a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#_a0">tutorial/lesson_03_debugging_1.cpp</a>, <a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#_a1">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#_a1">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#_a0">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#_a2">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#_a1">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#_a2">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#_a0">tutorial/lesson_10_aot_compilation_generate.cpp</a>, <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#_a0">tutorial/lesson_11_cross_compilation.cpp</a>, <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a2">tutorial/lesson_12_using_the_gpu.cpp</a>, <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#_a0">tutorial/lesson_13_tuples.cpp</a>, <a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#_a5">tutorial/lesson_14_types.cpp</a>, and <a class="el" href="tutorial_2lesson_15_generators_8cpp-example.html#_a5">tutorial/lesson_15_generators.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00700">700</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09702aeadda51baa8ff9f338a3ecd22d" name="a09702aeadda51baa8ff9f338a3ecd22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09702aeadda51baa8ff9f338a3ecd22d">&#9670;&#160;</a></span>Func() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a new undefined function with the given name. </p>

</div>
</div>
<a id="a38b82d6c5e413bc6a47a7d03fce912c6" name="a38b82d6c5e413bc6a47a7d03fce912c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b82d6c5e413bc6a47a7d03fce912c6">&#9670;&#160;</a></span>Func() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>required_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>required_dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a new undefined function with the given name. </p>
<p>The function will be constrained to represent Exprs of required_type. If required_dims is not AnyDims, the function will be constrained to exactly that many dimensions. </p>

</div>
</div>
<a id="a3adceabcfb1b423f34be95d2bc406ec3" name="a3adceabcfb1b423f34be95d2bc406ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adceabcfb1b423f34be95d2bc406ec3">&#9670;&#160;</a></span>Func() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>required_types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>required_dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a new undefined function with the given name. </p>
<p>If required_types is not empty, the function will be constrained to represent Tuples of the same arity and types. (If required_types is empty, there is no constraint.) If required_dims is not AnyDims, the function will be constrained to exactly that many dimensions. </p>

</div>
</div>
<a id="a1dd9ae99dad26dddffa078199375a6ba" name="a1dd9ae99dad26dddffa078199375a6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd9ae99dad26dddffa078199375a6ba">&#9670;&#160;</a></span>Func() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::Func </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a new undefined function with an automatically-generated unique name. </p>

</div>
</div>
<a id="a52a459f37a7d7031c7b6e2ab8a0ccee5" name="a52a459f37a7d7031c7b6e2ab8a0ccee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a459f37a7d7031c7b6e2ab8a0ccee5">&#9670;&#160;</a></span>Func() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a new function with an automatically-generated unique name, and define it to return the given expression (which may not contain free variables). </p>

</div>
</div>
<a id="ad76f9e3e90a3b6dc95ef1a5821422ec4" name="ad76f9e3e90a3b6dc95ef1a5821422ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76f9e3e90a3b6dc95ef1a5821422ec4">&#9670;&#160;</a></span>Func() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to wrap an existing, already-define Function object. </p>

</div>
</div>
<a id="a8d8432d8bcbcf649d9e201d49c1e4816" name="a8d8432d8bcbcf649d9e201d49c1e4816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8432d8bcbcf649d9e201d49c1e4816">&#9670;&#160;</a></span>Func() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, Dims &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>im</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to wrap a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00759">759</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aabca4df7c939e2a47246a21b34f20070" name="aabca4df7c939e2a47246a21b34f20070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabca4df7c939e2a47246a21b34f20070">&#9670;&#160;</a></span>realize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Func::realize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="struct_halide_1_1_target.html">Target</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate this function over some rectangular domain and return the resulting buffer or buffers. </p>
<p>Performs compilation if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has not previously been realized and compile_jit has not been called. If the final stage of the pipeline is on the GPU, data is copied back to the host before being returned. The returned <a class="el" href="class_halide_1_1_realization.html" title="A Realization is a vector of references to existing Buffer objects.">Realization</a> should probably be instantly converted to a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> class of the appropriate type. That is, do this:</p>
<div class="fragment"><div class="line">f(x) = <a class="code hl_function" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;float&gt;</a> im = f.realize(...);</div>
<div class="ttc" id="aclass_halide_1_1_buffer_html"><div class="ttname"><a href="class_halide_1_1_buffer.html">Halide::Buffer</a></div><div class="ttdoc">A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00021">RDom.h:21</a></div></div>
<div class="ttc" id="anamespace_halide_html_a5e1fca22f79625765096133e39caee5e"><div class="ttname"><a href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">Halide::sin</a></div><div class="ttdeci">Expr sin(Expr x)</div><div class="ttdoc">Return the sine of a floating-point expression.</div></div>
</div><!-- fragment --><p>If your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has multiple values, because you defined it using a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, then casting the result of a realize call to a buffer or image will produce a run-time error. Instead you should do the following:</p>
<div class="fragment"><div class="line">f(x) = <a class="code hl_class" href="class_halide_1_1_tuple.html">Tuple</a>(x, <a class="code hl_function" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x));</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_realization.html">Realization</a> r = f.realize(...);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int&gt;</a> im0 = r[0];</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;float&gt;</a> im1 = r[1];</div>
<div class="ttc" id="aclass_halide_1_1_realization_html"><div class="ttname"><a href="class_halide_1_1_realization.html">Halide::Realization</a></div><div class="ttdoc">A Realization is a vector of references to existing Buffer objects.</div><div class="ttdef"><b>Definition</b> <a href="_realization_8h_source.html#l00019">Realization.h:19</a></div></div>
<div class="ttc" id="aclass_halide_1_1_tuple_html"><div class="ttname"><a href="class_halide_1_1_tuple.html">Halide::Tuple</a></div><div class="ttdoc">Create a small array of Exprs for defining and calling functions with multiple outputs.</div><div class="ttdef"><b>Definition</b> <a href="_tuple_8h_source.html#l00018">Tuple.h:18</a></div></div>
</div><!-- fragment --><p>In <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> formal arguments of a computation are specified using Param&lt;T&gt; and <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> objects in the expressions defining the computation. Note that this method is not thread-safe, in that Param&lt;T&gt; and <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> are globals shared by all threads; to call jitted code in a thread-safe manner, use <a class="el" href="#a7ffec02c0c16ecce4cac7b3d646f6a2c" title="Eagerly jit compile the function to machine code and return a callable struct that behaves like a fun...">compile_to_callable()</a> instead.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_param.html">Param&lt;int32&gt;</a> p(42);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_image_param.html">ImageParam</a> img(<a class="code hl_function" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), 1);</div>
<div class="line">f(x) = img(x) + p;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer</a>&lt;<a class="code hl_typedef" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>) arg_img(10, 10);</div>
<div class="line">&lt;fill <a class="code hl_function" href="#a9d619f2d0111ea5bf640781d1324d050">in</a> arg_img...&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_halide_1_1_target.html">Target</a> t = <a class="code hl_function" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>();</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int32_t&gt;</a> result = f.realize({10, 10}, t);</div>
<div class="ttc" id="aclass_halide_1_1_func_html_a9d619f2d0111ea5bf640781d1324d050"><div class="ttname"><a href="#a9d619f2d0111ea5bf640781d1324d050">Halide::Func::in</a></div><div class="ttdeci">Func in()</div><div class="ttdoc">Create and return a global identity wrapper, which wraps all calls to this Func by any other Func.</div></div>
<div class="ttc" id="aclass_halide_1_1_image_param_html"><div class="ttname"><a href="class_halide_1_1_image_param.html">Halide::ImageParam</a></div><div class="ttdoc">An Image parameter to a halide pipeline.</div><div class="ttdef"><b>Definition</b> <a href="_image_param_8h_source.html#l00023">ImageParam.h:23</a></div></div>
<div class="ttc" id="aclass_halide_1_1_param_html"><div class="ttname"><a href="class_halide_1_1_param.html">Halide::Param</a></div><div class="ttdoc">A scalar parameter to a halide pipeline.</div><div class="ttdef"><b>Definition</b> <a href="_param_8h_source.html#l00022">Param.h:22</a></div></div>
<div class="ttc" id="anamespace_halide_html_a70a0c034814a65d55bb848fe9c96653b"><div class="ttname"><a href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Halide::Int</a></div><div class="ttdeci">Type Int(int bits, int lanes=1)</div><div class="ttdoc">Constructing a signed integer type.</div><div class="ttdef"><b>Definition</b> <a href="_type_8h_source.html#l00541">Type.h:541</a></div></div>
<div class="ttc" id="anamespace_halide_html_a9d2cf046902155db63e83374f23a47b5"><div class="ttname"><a href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">Halide::get_jit_target_from_environment</a></div><div class="ttdeci">Target get_jit_target_from_environment()</div><div class="ttdoc">Return the target that Halide will use for jit-compilation.</div></div>
<div class="ttc" id="aruntime__internal_8h_html_a5de3601dbc6acc46bb8a0d9bc84dff5b"><div class="ttname"><a href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></div><div class="ttdeci">signed __INT32_TYPE__ int32_t</div><div class="ttdef"><b>Definition</b> <a href="runtime__internal_8h_source.html#l00024">runtime_internal.h:24</a></div></div>
<div class="ttc" id="astruct_halide_1_1_target_html"><div class="ttname"><a href="struct_halide_1_1_target.html">Halide::Target</a></div><div class="ttdoc">A struct representing a target machine and os to generate code for.</div><div class="ttdef"><b>Definition</b> <a href="_target_8h_source.html#l00019">Target.h:19</a></div></div>
</div><!-- fragment --><p>Alternatively, an initializer list can be used directly in the realize call to pass this information:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_param.html">Param&lt;int32&gt;</a> p(42);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_image_param.html">ImageParam</a> img(<a class="code hl_function" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), 1);</div>
<div class="line">f(x) = img(x) + p;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer</a>&lt;<a class="code hl_typedef" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>) arg_img(10, 10);</div>
<div class="line">&lt;fill <a class="code hl_function" href="#a9d619f2d0111ea5bf640781d1324d050">in</a> arg_img...&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_halide_1_1_target.html">Target</a> t = <a class="code hl_function" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>();</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_buffer.html">Buffer&lt;int32_t&gt;</a> result = f.realize({10, 10}, t, { { p, 17 }, { img, arg_img } });</div>
</div><!-- fragment --><p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> cannot be realized into a buffer of the given size due to scheduling constraints on scattering update definitions, it will be realized into a larger buffer of the minimum size possible, and a cropped view at the requested size will be returned. It is thus not safe to assume the returned buffers are contiguous in memory. This behavior can be disabled with the NoBoundsQuery target flag, in which case an error about writing out of bounds on the output buffer will trigger instead. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_01_basics_8cpp-example.html#a4">tutorial/lesson_01_basics.cpp</a>, <a class="el" href="tutorial_2lesson_02_input_image_8cpp-example.html#a6">tutorial/lesson_02_input_image.cpp</a>, <a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#a3">tutorial/lesson_03_debugging_1.cpp</a>, <a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a4">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a4">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#a4">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#a3">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a3">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a3">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a19">tutorial/lesson_12_using_the_gpu.cpp</a>, and <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a4">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02648">Halide::evaluate()</a>, <a class="el" href="_func_8h_source.html#l02667">Halide::evaluate()</a>, <a class="el" href="_func_8h_source.html#l02702">Halide::evaluate_may_gpu()</a>, <a class="el" href="_func_8h_source.html#l02718">Halide::evaluate_may_gpu()</a>, <a class="el" href="_generator_8h_source.html#l01335">Halide::Internal::StubOutputBufferBase::realize()</a>, and <a class="el" href="_generator_8h_source.html#l01340">Halide::Internal::StubOutputBufferBase::realize()</a>.</p>

</div>
</div>
<a id="a66150432e0dc72cc1c7a4d766950cf27" name="a66150432e0dc72cc1c7a4d766950cf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66150432e0dc72cc1c7a4d766950cf27">&#9670;&#160;</a></span>realize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Func::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="struct_halide_1_1_target.html">Target</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but takes a custom user-provided context to be passed to runtime functions. </p>
<p>This can be used to pass state to runtime overrides in a thread-safe manner. A nullptr context is legal, and is equivalent to calling the variant of realize that does not take a context. </p>

</div>
</div>
<a id="a9c673f87eda38ef811ee0b8265ffbcae" name="a9c673f87eda38ef811ee0b8265ffbcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c673f87eda38ef811ee0b8265ffbcae">&#9670;&#160;</a></span>realize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a></td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="struct_halide_1_1_target.html">Target</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. This form of realize does <em>not</em> automatically copy data back from the GPU. </p>

</div>
</div>
<a id="aae83195ae0e24f9c2a9eefde0e79c9e0" name="aae83195ae0e24f9c2a9eefde0e79c9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae83195ae0e24f9c2a9eefde0e79c9e0">&#9670;&#160;</a></span>realize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a></td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="struct_halide_1_1_target.html">Target</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but takes a custom user-provided context to be passed to runtime functions. </p>
<p>This can be used to pass state to runtime overrides in a thread-safe manner. A nullptr context is legal, and is equivalent to calling the variant of realize that does not take a context. </p>

</div>
</div>
<a id="a93112ca4b121c1a65d39b01b680e2759" name="a93112ca4b121c1a65d39b01b680e2759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93112ca4b121c1a65d39b01b680e2759">&#9670;&#160;</a></span>infer_input_bounds() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a id="a243880dfcbdd71c9dbef095353a35c51" name="a243880dfcbdd71c9dbef095353a35c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243880dfcbdd71c9dbef095353a35c51">&#9670;&#160;</a></span>infer_input_bounds() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a></td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef70a5e279ca295e33eaf681bb6a69d0" name="aef70a5e279ca295e33eaf681bb6a69d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef70a5e279ca295e33eaf681bb6a69d0">&#9670;&#160;</a></span>infer_input_bounds() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Versions of infer_input_bounds that take a custom user context to pass to runtime functions. </p>

</div>
</div>
<a id="a43ddeb323185cd478dcd21518da9fe22" name="a43ddeb323185cd478dcd21518da9fe22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ddeb323185cd478dcd21518da9fe22">&#9670;&#160;</a></span>infer_input_bounds() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_j_i_t_user_context.html">JITUserContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_pipeline_1_1_realization_arg.html">Pipeline::RealizationArg</a></td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74ea68da121228c9bb2acc52438fb76c" name="a74ea68da121228c9bb2acc52438fb76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ea68da121228c9bb2acc52438fb76c">&#9670;&#160;</a></span>compile_to_bitcode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_bitcode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function. </p>

</div>
</div>
<a id="a213712e8681babec663adbb9ab87bf2e" name="a213712e8681babec663adbb9ab87bf2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213712e8681babec663adbb9ab87bf2e">&#9670;&#160;</a></span>compile_to_bitcode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_bitcode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04ba34de18200c71ed948ed9a96dfe8" name="ac04ba34de18200c71ed948ed9a96dfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04ba34de18200c71ed948ed9a96dfe8">&#9670;&#160;</a></span>compile_to_llvm_assembly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_llvm_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to llvm assembly, with the given filename (which should probably end in .ll), type signature, and C function name (which defaults to the same name as this halide function. </p>

</div>
</div>
<a id="aa348865f8302ff247d2ecd95b263ffb4" name="aa348865f8302ff247d2ecd95b263ffb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa348865f8302ff247d2ecd95b263ffb4">&#9670;&#160;</a></span>compile_to_llvm_assembly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_llvm_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbe88a7fb3127dc67953ee9418cd9c68" name="adbe88a7fb3127dc67953ee9418cd9c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe88a7fb3127dc67953ee9418cd9c68">&#9670;&#160;</a></span>compile_to_object() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function. </p>
<p>You probably don't want to use this directly; call compile_to_static_library or compile_to_file instead. </p>

</div>
</div>
<a id="ae7ff9bb09b0e6615ebd170f50f1382fa" name="ae7ff9bb09b0e6615ebd170f50f1382fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ff9bb09b0e6615ebd170f50f1382fa">&#9670;&#160;</a></span>compile_to_object() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a485c44376069489589f8e071b6d28e25" name="a485c44376069489589f8e071b6d28e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485c44376069489589f8e071b6d28e25">&#9670;&#160;</a></span>compile_to_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_header </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a header file with the given filename for this function. </p>
<p>The header will define a function with the type signature given by the second argument, and a name given by the third. The name defaults to the same name as this halide function. You don't actually have to have defined this function yet to call this. You probably don't want to use this directly; call compile_to_static_library or compile_to_file instead. </p>

</div>
</div>
<a id="a1766b6f9c06cfc149ba3832b07d0f116" name="a1766b6f9c06cfc149ba3832b07d0f116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1766b6f9c06cfc149ba3832b07d0f116">&#9670;&#160;</a></span>compile_to_assembly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to text assembly equivalent to the object file generated by compile_to_object. </p>
<p>This is useful for checking what <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> is producing without having to disassemble anything, or if you need to feed the assembly into some custom toolchain to produce an object file (e.g. iOS) </p>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>.</p>

</div>
</div>
<a id="ace30c21625c4f42456a9aee8466eb883" name="ace30c21625c4f42456a9aee8466eb883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace30c21625c4f42456a9aee8466eb883">&#9670;&#160;</a></span>compile_to_assembly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31b6acd470fed73a6804afa8353d018e" name="a31b6acd470fed73a6804afa8353d018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b6acd470fed73a6804afa8353d018e">&#9670;&#160;</a></span>compile_to_c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_c </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to C source code. </p>
<p>This is useful for providing fallback code paths that will compile on many platforms. Vectorization will fail, and parallelization will produce serial code. </p>

</div>
</div>
<a id="a3064d3085694782432e175d541c3051b" name="a3064d3085694782432e175d541c3051b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064d3085694782432e175d541c3051b">&#9670;&#160;</a></span>compile_to_lowered_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_lowered_stmt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out an internal representation of lowered code. </p>
<p>Useful for analyzing and debugging scheduling. Can emit html or plain text. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#a4">tutorial/lesson_03_debugging_1.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a59de8d0455b4f5d15cb05dcfcbc464f7" name="a59de8d0455b4f5d15cb05dcfcbc464f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59de8d0455b4f5d15cb05dcfcbc464f7">&#9670;&#160;</a></span>compile_to_conceptual_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_conceptual_stmt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out a conceptual representation of lowered code, before any parallel loop get factored out into separate functions, or GPU loops are offloaded to kernel code.r Useful for analyzing and debugging scheduling. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a id="a03f839d9e13cae4b87a540aa618589ae" name="a03f839d9e13cae4b87a540aa618589ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f839d9e13cae4b87a540aa618589ae">&#9670;&#160;</a></span>print_loop_nest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::print_loop_nest </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out the loop nests specified by the schedule for this Function. </p>
<p>Helpful for understanding what a schedule is doing. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a5">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a4">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab8873bbbbaf3cba1cf8976a24acab310" name="ab8873bbbbaf3cba1cf8976a24acab310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8873bbbbaf3cba1cf8976a24acab310">&#9670;&#160;</a></span>compile_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename_prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>The name defaults to the same name as this halide function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a6">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af21dcadd6fd36f4fc4ee7e1325621b27" name="af21dcadd6fd36f4fc4ee7e1325621b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21dcadd6fd36f4fc4ee7e1325621b27">&#9670;&#160;</a></span>compile_to_static_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_static_library </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename_prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to static-library file and header pair, with the given arguments. </p>
<p>The name defaults to the same name as this halide function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#a6">tutorial/lesson_10_aot_compilation_generate.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac22a7daea850a6f2723fe8184029d7f8" name="ac22a7daea850a6f2723fe8184029d7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22a7daea850a6f2723fe8184029d7f8">&#9670;&#160;</a></span>compile_to_multitarget_static_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_multitarget_static_library </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename_prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to static-library file and header pair once for each target; each resulting function will be considered (in order) via <a class="el" href="_halide_runtime_8h.html#aeb3de9758e5af340b55d91e929ea52be" title="This function is called internally by Halide in some situations to determine if the current execution...">halide_can_use_target_features()</a> at runtime, with the first appropriate match being selected for subsequent use. </p>
<p>This is typically useful for specializations that may vary unpredictably by machine (e.g., SSE4.1/AVX/AVX2 on x86 desktop machines). All targets must have identical arch-os-bits. </p>

</div>
</div>
<a id="a0a3a9cbbcfc3219386937ac24c4c9735" name="a0a3a9cbbcfc3219386937ac24c4c9735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3a9cbbcfc3219386937ac24c4c9735">&#9670;&#160;</a></span>compile_to_multitarget_object_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to_multitarget_object_files </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename_prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffixes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="#ac22a7daea850a6f2723fe8184029d7f8" title="Compile to static-library file and header pair once for each target; each resulting function will be ...">compile_to_multitarget_static_library()</a>, except that the object files are all output as object files (rather than bundled into a static library). </p>
<p><code>suffixes</code> is an optional list of strings to use for as the suffix for each object file. If nonempty, it must be the same length as <code>targets</code>. (If empty, <a class="el" href="struct_halide_1_1_target.html#a84c96de31933be72ffa506c609e842bc" title="Convert the Target into a string form that can be reconstituted by merge_string(),...">Target::to_string()</a> will be used for each suffix.)</p>
<p>Note that if <code>targets.size()</code> &gt; 1, the wrapper code (to select the subtarget) will be generated with the filename <code>${filename_prefix}_wrapper.o</code></p>
<p>Note that if <code>targets.size()</code> &gt; 1 and <code>no_runtime</code> is not specified, the runtime will be generated with the filename <code>${filename_prefix}_runtime.o</code> </p>

</div>
</div>
<a id="a96978001c2e4071be87d6f3e49f0db31" name="a96978001c2e4071be87d6f3e49f0db31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96978001c2e4071be87d6f3e49f0db31">&#9670;&#160;</a></span>compile_to_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_module.html">Module</a> Halide::Func::compile_to_module </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store an internal representation of lowered code as a self contained <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> suitable for further compilation. </p>

</div>
</div>
<a id="aa17f5091968639d630d29f640aff21dd" name="aa17f5091968639d630d29f640aff21dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17f5091968639d630d29f640aff21dd">&#9670;&#160;</a></span>compile_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_to </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2af">OutputFileType</a>, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_files</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile and generate multiple target files with single call. </p>
<p>Deduces target files based on filenames specified in output_files map. </p>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00158">Halide::SimdOpCheckTest::compile_and_check()</a>.</p>

</div>
</div>
<a id="a1c0c8541bc9a63d08c4b3d1accbab4e6" name="a1c0c8541bc9a63d08c4b3d1accbab4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0c8541bc9a63d08c4b3d1accbab4e6">&#9670;&#160;</a></span>compile_jit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::compile_jit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eagerly jit compile the function to machine code. </p>
<p>This normally happens on the first call to realize. If you're running your halide pipeline inside time-sensitive code and wish to avoid including the time taken to compile a pipeline, then you can call this ahead of time. Default is to use the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> returned from <a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5" title="Return the target that Halide will use for jit-compilation.">Halide::get_jit_target_from_environment()</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a13">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6e08cea3909e06105732570ebcb45896" name="a6e08cea3909e06105732570ebcb45896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e08cea3909e06105732570ebcb45896">&#9670;&#160;</a></span>jit_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_j_i_t_handlers.html">JITHandlers</a> &amp; Halide::Func::jit_handlers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a struct containing the currently set custom functions used by JIT. </p>
<p>This can be mutated. Changes will take effect the next time this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is realized. </p>

</div>
</div>
<a id="a7ffec02c0c16ecce4cac7b3d646f6a2c" name="a7ffec02c0c16ecce4cac7b3d646f6a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffec02c0c16ecce4cac7b3d646f6a2c">&#9670;&#160;</a></span>compile_to_callable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_callable.html">Callable</a> Halide::Func::compile_to_callable </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eagerly jit compile the function to machine code and return a callable struct that behaves like a function pointer. </p>
<p>The calling convention will exactly match that of an AOT-compiled version of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with the same <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> list. </p>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>.</p>

</div>
</div>
<a id="aa5f5c7a7e7be2da5203eb78b192399d5" name="aa5f5c7a7e7be2da5203eb78b192399d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f5c7a7e7be2da5203eb78b192399d5">&#9670;&#160;</a></span>add_custom_lowering_pass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::add_custom_lowering_pass </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pass</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a custom pass to be used during lowering. </p>
<p>It is run after all other lowering passes. Can be used to verify properties of the lowered Stmt, instrument it with extra code, or otherwise modify it. The <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> takes ownership of the pass, and will call delete on it when the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> goes out of scope. So don't pass a stack object, or share pass instances between multiple Funcs. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01059">1059</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l01059">add_custom_lowering_pass()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01059">add_custom_lowering_pass()</a>.</p>

</div>
</div>
<a id="aba5d2ac731fc872d129f2f301f484f56" name="aba5d2ac731fc872d129f2f301f484f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5d2ac731fc872d129f2f301f484f56">&#9670;&#160;</a></span>add_custom_lowering_pass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::add_custom_lowering_pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">Internal::IRMutator</a> *</td>          <td class="paramname"><span class="paramname"><em>pass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>deleter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a custom pass to be used during lowering, with the function that will be called to delete it also passed in. </p>
<p>Set it to nullptr if you wish to retain ownership of the object. </p>

</div>
</div>
<a id="abe676a57879fa842c2fa08edbf6f9746" name="abe676a57879fa842c2fa08edbf6f9746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe676a57879fa842c2fa08edbf6f9746">&#9670;&#160;</a></span>clear_custom_lowering_passes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::clear_custom_lowering_passes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all previously-set custom lowering passes. </p>

</div>
</div>
<a id="ad1f4c01bd44680d90a4ae6c43cc42968" name="ad1f4c01bd44680d90a4ae6c43cc42968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4c01bd44680d90a4ae6c43cc42968">&#9670;&#160;</a></span>custom_lowering_passes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_custom_lowering_pass.html">CustomLoweringPass</a> &gt; &amp; Halide::Func::custom_lowering_passes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the custom lowering passes. </p>

</div>
</div>
<a id="af001fb038dcce6dc07166f8072485abd" name="af001fb038dcce6dc07166f8072485abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af001fb038dcce6dc07166f8072485abd">&#9670;&#160;</a></span>debug_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::debug_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When this function is compiled, include code that dumps its values to a file after it is realized, for the purpose of debugging. </p>
<p>If filename ends in ".tif" or ".tiff" (case insensitive) the file is in TIFF format and can be read by standard tools. Oherwise, the file format is as follows:</p>
<p>All data is in the byte-order of the target platform. First, a 20 byte-header containing four 32-bit ints, giving the extents of the first four dimensions. Dimensions beyond four are folded into the fourth. Then, a fifth 32-bit int giving the data type of the function. The typecodes are given by: float = 0, double = 1, uint8_t = 2, int8_t = 3, uint16_t = 4, int16_t = 5, uint32_t = 6, int32_t = 7, uint64_t = 8, int64_t = 9. The data follows the header, as a densely packed array of the given size and the given type. If given the extension .tmp, this file format can be natively read by the program ImageStack. </p>

</div>
</div>
<a id="ac119151e46e02b367a60a2af6ff02420" name="ac119151e46e02b367a60a2af6ff02420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac119151e46e02b367a60a2af6ff02420">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Func::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The name of this function, either given during construction, or automatically generated. </p>

</div>
</div>
<a id="a6fa2fe6d902d1c426ad209ec6a986ace" name="a6fa2fe6d902d1c426ad209ec6a986ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa2fe6d902d1c426ad209ec6a986ace">&#9670;&#160;</a></span>args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; Halide::Func::args </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pure arguments. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01498">always_partition()</a>, <a class="el" href="_func_8h_source.html#l01481">never_partition()</a>, <a class="el" href="_func_8h_source.html#l01239">operator()()</a>, <a class="el" href="_func_8h_source.html#l01256">operator()()</a>, <a class="el" href="_func_8h_source.html#l01602">reorder()</a>, and <a class="el" href="_func_8h_source.html#l02078">reorder_storage()</a>.</p>

</div>
</div>
<a id="a90926a2fe1bd3b6db924e8bdd53b5ed4" name="a90926a2fe1bd3b6db924e8bdd53b5ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Func::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The right-hand-side value of the pure definition of this function. </p>
<p>Causes an error if there's no pure definition, or if the function is defined to return multiple values. </p>

</div>
</div>
<a id="ae128ce6543038092523c2848b150bfc1" name="ae128ce6543038092523c2848b150bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae128ce6543038092523c2848b150bfc1">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::Func::values </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The values returned by this function. </p>
<p>An error if the function has not been been defined. Returns a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> with one element for functions defined to return a single value. </p>

</div>
</div>
<a id="a3a6ae7c756f051da46e75cd63e325a47" name="a3a6ae7c756f051da46e75cd63e325a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6ae7c756f051da46e75cd63e325a47">&#9670;&#160;</a></span>defined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Func::defined </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this function have at least a pure definition. </p>

</div>
</div>
<a id="a658952efccaf4cd532652eb3bef5ba51" name="a658952efccaf4cd532652eb3bef5ba51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658952efccaf4cd532652eb3bef5ba51">&#9670;&#160;</a></span>update_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp; Halide::Func::update_args </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the left-hand-side of the update definition. </p>
<p>An empty vector if there's no update definition. If there are multiple update definitions for this function, use the argument to select which one you want. </p>

</div>
</div>
<a id="a9fc992a5e7a33090b1fc11b7c60ff97f" name="a9fc992a5e7a33090b1fc11b7c60ff97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc992a5e7a33090b1fc11b7c60ff97f">&#9670;&#160;</a></span>update_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Func::update_value </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the right-hand-side of an update definition. </p>
<p>An error if there's no update definition. If there are multiple update definitions for this function, use the argument to select which one you want. </p>

</div>
</div>
<a id="a705c75484752d64d66abac9b1ebf5b13" name="a705c75484752d64d66abac9b1ebf5b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705c75484752d64d66abac9b1ebf5b13">&#9670;&#160;</a></span>update_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::Func::update_values </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the right-hand-side of an update definition for functions that returns multiple values. </p>
<p>An error if there's no update definition. Returns a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> with one element for functions that return a single value. </p>

</div>
</div>
<a id="ad13c0acfd2499ef245947595e9d092d7" name="ad13c0acfd2499ef245947595e9d092d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13c0acfd2499ef245947595e9d092d7">&#9670;&#160;</a></span>rvars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &gt; Halide::Func::rvars </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RVars of the reduction domain for an update definition, if there is one. </p>

</div>
</div>
<a id="a1b0049f405a62cd2bf0205f92b3ac99e" name="a1b0049f405a62cd2bf0205f92b3ac99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0049f405a62cd2bf0205f92b3ac99e">&#9670;&#160;</a></span>has_update_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Func::has_update_definition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this function have at least one update definition? </p>

</div>
</div>
<a id="a78585432af7129ce0e767f070aa3b2a6" name="a78585432af7129ce0e767f070aa3b2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78585432af7129ce0e767f070aa3b2a6">&#9670;&#160;</a></span>num_update_definitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Func::num_update_definitions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many update definitions does this function have? </p>

</div>
</div>
<a id="a06a38e09eb4696b1d37b640c639f6299" name="a06a38e09eb4696b1d37b640c639f6299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a38e09eb4696b1d37b640c639f6299">&#9670;&#160;</a></span>is_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Func::is_extern </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this function an external stage? That is, was it defined using define_extern? </p>

</div>
</div>
<a id="ab8432d789980de9e281e0e54b70307f7" name="ab8432d789980de9e281e0e54b70307f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8432d789980de9e281e0e54b70307f7">&#9670;&#160;</a></span>define_extern() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::define_extern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimensionality</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a></td>          <td class="paramname"><span class="paramname"><em>mangling</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an extern definition for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>This lets you define a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that represents an external pipeline stage. You can, for example, use it to wrap a call to an extern library such as fftw. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01154">1154</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l01154">define_extern()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a2e581c9e4b9559106c4f2b5b89b1f7c6">Halide::Internal::make_argument_list()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01164">define_extern()</a>, <a class="el" href="_func_8h_source.html#l01172">define_extern()</a>, <a class="el" href="_func_8h_source.html#l01182">define_extern()</a>, and <a class="el" href="_func_8h_source.html#l01154">define_extern()</a>.</p>

</div>
</div>
<a id="af9764c21ad6794e74d9aa4c069741e45" name="af9764c21ad6794e74d9aa4c069741e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9764c21ad6794e74d9aa4c069741e45">&#9670;&#160;</a></span>define_extern() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::define_extern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimensionality</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a></td>          <td class="paramname"><span class="paramname"><em>mangling</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01164">1164</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l01154">define_extern()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a2e581c9e4b9559106c4f2b5b89b1f7c6">Halide::Internal::make_argument_list()</a>, and <a class="el" href="#a5dcf6c24fd1de40b52d3709933e4e009">types()</a>.</p>

</div>
</div>
<a id="a9965443aea3975bfe1b8f5787f47025b" name="a9965443aea3975bfe1b8f5787f47025b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9965443aea3975bfe1b8f5787f47025b">&#9670;&#160;</a></span>define_extern() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::define_extern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimensionality</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a></td>          <td class="paramname"><span class="paramname"><em>mangling</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01172">1172</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l01154">define_extern()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a2e581c9e4b9559106c4f2b5b89b1f7c6">Halide::Internal::make_argument_list()</a>, and <a class="el" href="#a5dcf6c24fd1de40b52d3709933e4e009">types()</a>.</p>

</div>
</div>
<a id="aec2685cc1459971deebca75fa6de2ee9" name="aec2685cc1459971deebca75fa6de2ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2685cc1459971deebca75fa6de2ee9">&#9670;&#160;</a></span>define_extern() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::define_extern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a></td>          <td class="paramname"><span class="paramname"><em>mangling</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01182">1182</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l01154">define_extern()</a>.</p>

</div>
</div>
<a id="a8df7a80d0dfa5f24c61f1346e4365bf6" name="a8df7a80d0dfa5f24c61f1346e4365bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df7a80d0dfa5f24c61f1346e4365bf6">&#9670;&#160;</a></span>define_extern() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::define_extern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a></td>          <td class="paramname"><span class="paramname"><em>mangling</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">NameMangling::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2103b97e0f563aba56aaabd2f82e1d03" name="a2103b97e0f563aba56aaabd2f82e1d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2103b97e0f563aba56aaabd2f82e1d03">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp; Halide::Func::type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type(s) of the outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>It is not legal to call <a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03" title="Get the type(s) of the outputs of this Func.">type()</a> unless the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has non-Tuple elements.</p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> isn't yet defined, and was not specified with required types, a runtime error will occur.</p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> isn't yet defined, but <em>was</em> specified with required types, the requirements will be returned. </p>

</div>
</div>
<a id="a5dcf6c24fd1de40b52d3709933e4e009" name="a5dcf6c24fd1de40b52d3709933e4e009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcf6c24fd1de40b52d3709933e4e009">&#9670;&#160;</a></span>types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp; Halide::Func::types </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a6">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01164">define_extern()</a>, and <a class="el" href="_func_8h_source.html#l01172">define_extern()</a>.</p>

</div>
</div>
<a id="a66202288811f0d1ef8810d0baab207f4" name="a66202288811f0d1ef8810d0baab207f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66202288811f0d1ef8810d0baab207f4">&#9670;&#160;</a></span>outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Func::outputs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Corresponds to the size of the <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> was defined to return. If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> isn't yet defined, but was specified with required types, the number of outputs specified in the requirements will be returned. </p>

</div>
</div>
<a id="ae33375e0e54f39e647c6988d283ef8f2" name="ae33375e0e54f39e647c6988d283ef8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33375e0e54f39e647c6988d283ef8f2">&#9670;&#160;</a></span>extern_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Func::extern_function_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the extern function called for an extern definition. </p>

</div>
</div>
<a id="a55ef02d97a2c77c7061f73b7768880e6" name="a55ef02d97a2c77c7061f73b7768880e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ef02d97a2c77c7061f73b7768880e6">&#9670;&#160;</a></span>dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Func::dimensions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The dimensionality (number of arguments) of this function. </p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> isn't yet defined, but was specified with required dimensionality, the dimensionality specified in the requirements will be returned. </p>

</div>
</div>
<a id="af68de832a30ac471a89ae2247012fb42" name="af68de832a30ac471a89ae2247012fb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68de832a30ac471a89ae2247012fb42">&#9670;&#160;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01239">operator()()</a>.</p>

</div>
</div>
<a id="ad3b76c068f619d618e0bcf2b5d1b7994" name="ad3b76c068f619d618e0bcf2b5d1b7994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b76c068f619d618e0bcf2b5d1b7994">&#9670;&#160;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="class_halide_1_1_var.html">Var</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01239">1239</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args()</a>, and <a class="el" href="#af68de832a30ac471a89ae2247012fb42">operator()()</a>.</p>

</div>
</div>
<a id="a0769211233b39808c5b4c76d843e611a" name="a0769211233b39808c5b4c76d843e611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0769211233b39808c5b4c76d843e611a">&#9670;&#160;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of an update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a id="a2a8080fd1a2425585c3c2382aa8fa683" name="a2a8080fd1a2425585c3c2382aa8fa683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8080fd1a2425585c3c2382aa8fa683">&#9670;&#160;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01256">1256</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args()</a>.</p>

</div>
</div>
<a id="af0957a1f444256a88279d5d922bf1c52" name="af0957a1f444256a88279d5d922bf1c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0957a1f444256a88279d5d922bf1c52">&#9670;&#160;</a></span>in() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new identity <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that wraps this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>During compilation, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> replaces all calls to this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> done by 'f' with calls to the wrapper. If this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is already wrapped for use in 'f', will return the existing wrapper.</p>
<p>For example, g.in(f) would rewrite a pipeline like this: </p><div class="fragment"><div class="line">g(x, y) = ...</div>
<div class="line">f(x, y) = ... g(x, y) ...</div>
</div><!-- fragment --><p> into a pipeline like this: </p><div class="fragment"><div class="line">g(x, y) = ...</div>
<div class="line">g_wrap(x, y) = g(x, y)</div>
<div class="line">f(x, y) = ... g_wrap(x, y)</div>
</div><!-- fragment --><p>This has a variety of uses. You can use it to schedule this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> differently in the different places it is used: </p><div class="fragment"><div class="line">g(x, y) = ...</div>
<div class="line">f1(x, y) = ... g(x, y) ...</div>
<div class="line">f2(x, y) = ... g(x, y) ...</div>
<div class="line">g.in(f1).compute_at(f1, y).vectorize(x, 8);</div>
<div class="line">g.in(f2).compute_at(f2, x).unroll(x);</div>
</div><!-- fragment --><p>You can also use it to stage loads from this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> via some intermediate buffer (perhaps on the stack as in test/performance/block_transpose.cpp, or in shared GPU memory as in test/performance/wrap.cpp). In this we compute the wrapper at tiles of the consuming Funcs like so: </p><div class="fragment"><div class="line">g.compute_root()...</div>
<div class="line">g.in(f).compute_at(f, tiles)...</div>
</div><!-- fragment --><p><a class="el" href="#a9d619f2d0111ea5bf640781d1324d050" title="Create and return a global identity wrapper, which wraps all calls to this Func by any other Func.">Func::in()</a> can also be used to compute pieces of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> into a smaller scratch buffer (perhaps on the GPU) and then copy them into a larger output buffer one tile at a time. See apps/interpolate/interpolate.cpp for an example of this. In this case we compute the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at tiles of its own wrapper: </p><div class="fragment"><div class="line">f.in(g).compute_root().gpu_tile(...)...</div>
<div class="line">f.compute_at(f.in(g), tiles)...</div>
</div><!-- fragment --><p>A similar use of <a class="el" href="#a9d619f2d0111ea5bf640781d1324d050" title="Create and return a global identity wrapper, which wraps all calls to this Func by any other Func.">Func::in()</a> wrapping Funcs with multiple update stages in a pure wrapper. The following code: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">f(x, y) += 5;</div>
<div class="line">g(x, y) = f(x, y);</div>
<div class="line">f.compute_root();</div>
</div><!-- fragment --><p>Is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    f(x, y) = x + y;</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    f(x, y) += 5</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    g(x, y) = f(x, y)</div>
</div><!-- fragment --><p> using <a class="el" href="#a9d619f2d0111ea5bf640781d1324d050" title="Create and return a global identity wrapper, which wraps all calls to this Func by any other Func.">Func::in()</a>, we can write: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">f(x, y) += 5;</div>
<div class="line">g(x, y) = f(x, y);</div>
<div class="line">f.in(g).compute_root();</div>
</div><!-- fragment --><p> which instead produces: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    f(x, y) = x + y;</div>
<div class="line">    f(x, y) += 5</div>
<div class="line">    f_wrap(x, y) = f(x, y)</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    g(x, y) = f_wrap(x, y)</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="anderson2021_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, <a class="el" href="_generator_8h_source.html#l01754">Halide::Internal::GeneratorInput_Buffer&lt; T2 &gt;::in()</a>, <a class="el" href="_generator_8h_source.html#l01759">Halide::Internal::GeneratorInput_Buffer&lt; T2 &gt;::in()</a>, <a class="el" href="_generator_8h_source.html#l01764">Halide::Internal::GeneratorInput_Buffer&lt; T2 &gt;::in()</a>, <a class="el" href="_generator_8h_source.html#l01915">Halide::Internal::GeneratorInput_Func&lt; T &gt;::in()</a>, <a class="el" href="_generator_8h_source.html#l01920">Halide::Internal::GeneratorInput_Func&lt; T &gt;::in()</a>, and <a class="el" href="_generator_8h_source.html#l01925">Halide::Internal::GeneratorInput_Func&lt; T &gt;::in()</a>.</p>

</div>
</div>
<a id="aa6279995e3a5b078ee60c680d1decb2b" name="aa6279995e3a5b078ee60c680d1decb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6279995e3a5b078ee60c680d1decb2b">&#9670;&#160;</a></span>in() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::in </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return an identity wrapper shared by all the Funcs in 'fs'. </p>
<p>If any of the Funcs in 'fs' already have a custom wrapper, this will throw an error. </p>

</div>
</div>
<a id="a9d619f2d0111ea5bf640781d1324d050" name="a9d619f2d0111ea5bf640781d1324d050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d619f2d0111ea5bf640781d1324d050">&#9670;&#160;</a></span>in() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::in </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a global identity wrapper, which wraps all calls to this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by any other <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>If a global wrapper already exists, returns it. The global identity wrapper is only used by callers for which no custom wrapper has been specified. </p>

</div>
</div>
<a id="ad1c1059311b4211ab60d4b38963b1e8d" name="ad1c1059311b4211ab60d4b38963b1e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c1059311b4211ab60d4b38963b1e8d">&#9670;&#160;</a></span>clone_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::clone_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="#af0957a1f444256a88279d5d922bf1c52">Func::in</a>; however, instead of replacing the call to this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with an identity <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that refers to it, this replaces the call with a clone of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>For example, f.clone_in(g) would rewrite a pipeline like this: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">g(x, y) = f(x, y) + 2;</div>
<div class="line">h(x, y) = f(x, y) - 3;</div>
</div><!-- fragment --><p> into a pipeline like this: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">f_clone(x, y) = x + y;</div>
<div class="line">g(x, y) = f_clone(x, y) + 2;</div>
<div class="line">h(x, y) = f(x, y) - 3;</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>.</p>

</div>
</div>
<a id="a954b37c0c468df27d16c3b6190bd9475" name="a954b37c0c468df27d16c3b6190bd9475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954b37c0c468df27d16c3b6190bd9475">&#9670;&#160;</a></span>clone_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::clone_in </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae74b2c71950c16b88f4d7883b55fd366" name="ae74b2c71950c16b88f4d7883b55fd366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74b2c71950c16b88f4d7883b55fd366">&#9670;&#160;</a></span>copy_to_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::copy_to_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare that this function should be implemented by a call to halide_buffer_copy with the given target device API. </p>
<p>Asserts that the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has a pure definition which is a simple call to a single input, and no update definitions. The wrapper Funcs returned by <a class="el" href="#a9d619f2d0111ea5bf640781d1324d050" title="Create and return a global identity wrapper, which wraps all calls to this Func by any other Func.">in()</a> are suitable candidates. Consumes all pure variables, and rewrites the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to have an extern definition that calls halide_buffer_copy. </p>

</div>
</div>
<a id="a41e9130ba2e3289b7cfe307f06351f92" name="a41e9130ba2e3289b7cfe307f06351f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e9130ba2e3289b7cfe307f06351f92">&#9670;&#160;</a></span>copy_to_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Func::copy_to_host </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare that this function should be implemented by a call to halide_buffer_copy with a NULL target device API. </p>
<p>Equivalent to copy_to_device(DeviceAPI::Host). Asserts that the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has a pure definition which is a simple call to a single input, and no update definitions. The wrapper Funcs returned by <a class="el" href="#a9d619f2d0111ea5bf640781d1324d050" title="Create and return a global identity wrapper, which wraps all calls to this Func by any other Func.">in()</a> are suitable candidates. Consumes all pure variables, and rewrites the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to have an extern definition that calls halide_buffer_copy.</p>
<p>Note that if the source <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is already valid in host memory, this compiles to code that does the minimum number of calls to memcpy. </p>

</div>
</div>
<a id="a4f9feebea3c3da655f623422971f869c" name="a4f9feebea3c3da655f623422971f869c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9feebea3c3da655f623422971f869c">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1. </p>
<p>The inner and outer subdimensions can then be dealt with using the other scheduling calls. It's ok to reuse the old variable name as either the inner or outer variable. The final argument specifies how the tail should be handled if the split factor does not provably divide the extent. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a7">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a9">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a17">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a8">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="af094cac26cfad9cf0b550d6329c503f5" name="af094cac26cfad9cf0b550d6329c503f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af094cac26cfad9cf0b550d6329c503f5">&#9670;&#160;</a></span>fuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fused</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join two dimensions into a single fused dimension. </p>
<p>The fused dimension covers the product of the extents of the inner and outer dimensions given. The loop type (e.g. parallel, vectorized) of the resulting fused dimension is inherited from the first argument. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a8">tutorial/lesson_05_scheduling_1.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a46bb370513cf7f0c45d9f2f4f53e694f" name="a46bb370513cf7f0c45d9f2f4f53e694f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bb370513cf7f0c45d9f2f4f53e694f">&#9670;&#160;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be traversed serially. </p>
<p>This is the default. </p>

<p class="reference">Referenced by <a class="el" href="anderson2021_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="ae78db35f74950c9e9c586f6ad7a3e7e0" name="ae78db35f74950c9e9c586f6ad7a3e7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78db35f74950c9e9c586f6ad7a3e7e0">&#9670;&#160;</a></span>parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be traversed in parallel. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a5">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a12">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a10">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a10">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#a5">tutorial/lesson_10_aot_compilation_generate.cpp</a>, <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a5">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a9">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="af075813ccb2d266dd7c1d9c8552e2feb" name="af075813ccb2d266dd7c1d9c8552e2feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af075813ccb2d266dd7c1d9c8552e2feb">&#9670;&#160;</a></span>parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>task_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension by the given task_size, and the parallelize the outer dimension. </p>
<p>This creates parallel tasks that have size task_size. After this call, var refers to the outer dimension of the split. The inner dimension has a new anonymous name. If you wish to mutate it, or schedule with respect to it, do the split manually. </p>

</div>
</div>
<a id="aefc273557b19c8c02c948f7e8ca56ffd" name="aefc273557b19c8c02c948f7e8ca56ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc273557b19c8c02c948f7e8ca56ffd">&#9670;&#160;</a></span>vectorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be computed all-at-once as a single vector. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of vectorize you want the two argument form. The variable to be vectorized should be the innermost one. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a9">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a11">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a9">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#a4">tutorial/lesson_10_aot_compilation_generate.cpp</a>, <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a4">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a11">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a9c93c10aecaeab1d98d0f65461536bf4" name="a9c93c10aecaeab1d98d0f65461536bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c93c10aecaeab1d98d0f65461536bf4">&#9670;&#160;</a></span>unroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be completely unrolled. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of unroll you want the two-argument form. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a10">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a7">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="anderson2021_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a13ad9bed80565d85f2cc6d09c607fdfb" name="a13ad9bed80565d85f2cc6d09c607fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad9bed80565d85f2cc6d09c607fdfb">&#9670;&#160;</a></span>vectorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension by the given factor, then vectorize the inner dimension. </p>
<p>This is how you vectorize a loop of unknown size. The variable to be vectorized should be the innermost one. After this call, var refers to the outer dimension of the split. 'factor' must be an integer. </p>

</div>
</div>
<a id="a05cd7a5c03324c4d876626307939ef80" name="a05cd7a5c03324c4d876626307939ef80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cd7a5c03324c4d876626307939ef80">&#9670;&#160;</a></span>unroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension by the given factor, then unroll the inner dimension. </p>
<p>This is how you unroll a loop of unknown size by some constant factor. After this call, var refers to the outer dimension of the split. 'factor' must be an integer. </p>

</div>
</div>
<a id="a0daf72571f0086e550eefb984ae18415" name="a0daf72571f0086e550eefb984ae18415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daf72571f0086e550eefb984ae18415">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#af5048e52b474e6d6733ffa66f800b881">Partition</a></td>          <td class="paramname"><span class="paramname"><em>partition_policy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the loop partition policy. </p>
<p>Loop partitioning can be useful to optimize boundary conditions (such as clamp_edge). Loop partitioning splits a for loop into three for loops: a prologue, a steady-state, and an epilogue. The default policy is Auto. </p>

</div>
</div>
<a id="a7e658dd0591a5dfa7c0a5f10cc015441" name="a7e658dd0591a5dfa7c0a5f10cc015441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e658dd0591a5dfa7c0a5f10cc015441">&#9670;&#160;</a></span>never_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::never_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the loop partition policy to Never for a vector of Vars and RVars. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01481">never_partition()</a>.</p>

</div>
</div>
<a id="adf0f7473b1ed9623ef2566d63a9ac975" name="adf0f7473b1ed9623ef2566d63a9ac975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0f7473b1ed9623ef2566d63a9ac975">&#9670;&#160;</a></span>never_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a> Halide::Func::never_partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the loop partition policy to Never for some number of Vars and RVars. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01481">1481</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args()</a>, and <a class="el" href="#a7e658dd0591a5dfa7c0a5f10cc015441">never_partition()</a>.</p>

</div>
</div>
<a id="a0f033bff4f8e6215f8c7f3ff80fa61ad" name="a0f033bff4f8e6215f8c7f3ff80fa61ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f033bff4f8e6215f8c7f3ff80fa61ad">&#9670;&#160;</a></span>never_partition_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::never_partition_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the loop partition policy to Never for all Vars and <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> of the initial definition of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>It must be called separately on any update definitions. </p>

</div>
</div>
<a id="ab4932df8bc02e8f205d485b9ef609d0b" name="ab4932df8bc02e8f205d485b9ef609d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4932df8bc02e8f205d485b9ef609d0b">&#9670;&#160;</a></span>always_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::always_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the loop partition policy to Always for a vector of Vars and RVars. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01498">always_partition()</a>.</p>

</div>
</div>
<a id="af1262e391aaebca7ee7536e5e6d0e765" name="af1262e391aaebca7ee7536e5e6d0e765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1262e391aaebca7ee7536e5e6d0e765">&#9670;&#160;</a></span>always_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a> Halide::Func::always_partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the loop partition policy to Always for some number of Vars and RVars. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01498">1498</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#ab4932df8bc02e8f205d485b9ef609d0b">always_partition()</a>, and <a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args()</a>.</p>

</div>
</div>
<a id="af7150dba01f063399eb130c968eaafbb" name="af7150dba01f063399eb130c968eaafbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7150dba01f063399eb130c968eaafbb">&#9670;&#160;</a></span>always_partition_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::always_partition_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the loop partition policy to Always for all Vars and <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> of the initial definition of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>It must be called separately on any update definitions. </p>

</div>
</div>
<a id="af0a2825e04367798cb1d2b58cf13a7b2" name="af0a2825e04367798cb1d2b58cf13a7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a2825e04367798cb1d2b58cf13a7b2">&#9670;&#160;</a></span>bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>extent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically declare that the range over which a function should be evaluated is given by the second and third arguments. </p>
<p>This can let <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> perform some optimizations. E.g. if you know there are going to be 4 color channels, you can completely vectorize the color channel dimension without the overhead of splitting it up. If bounds inference decides that it requires more of this function than the bounds you have stated, a runtime error will occur when you try to run your pipeline. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a6">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>.</p>

</div>
</div>
<a id="a2ed454dcacda07083b13a4f697ee02f2" name="a2ed454dcacda07083b13a4f697ee02f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed454dcacda07083b13a4f697ee02f2">&#9670;&#160;</a></span>set_estimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::set_estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically declare the range over which the function will be evaluated in the general case. </p>
<p>This provides a basis for the auto scheduler to make trade-offs and scheduling decisions. The auto generated schedules might break when the sizes of the dimensions are very different from the estimates specified. These estimates are used only by the auto scheduler if the function is a pipeline output. </p>

</div>
</div>
<a id="a9cadbe9d4510716b10d07cac7956f16c" name="a9cadbe9d4510716b10d07cac7956f16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cadbe9d4510716b10d07cac7956f16c">&#9670;&#160;</a></span>set_estimates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::set_estimates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>estimates</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set (min, extent) estimates for all dimensions in the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at once; this is equivalent to calling <code>set_estimate(args()[n], min, extent)</code> repeatedly, but slightly terser. </p>
<p>The size of the estimates vector must match the dimensionality of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>

</div>
</div>
<a id="a4a5b9179f8f69789f4b2db823e4c6129" name="a4a5b9179f8f69789f4b2db823e4c6129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5b9179f8f69789f4b2db823e4c6129">&#9670;&#160;</a></span>align_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::align_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>modulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>remainder</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the region computed so that the min coordinates is congruent to 'remainder' modulo 'modulus', and the extent is a multiple of 'modulus'. </p>
<p>For example, f.align_bounds(x, 2) forces the min and extent realized to be even, and calling f.align_bounds(x, 2, 1) forces the min to be odd and the extent to be even. The region computed always contains the region that would have been computed without this directive, so no assertions are injected. </p>

</div>
</div>
<a id="a927b24acb865c4ca47b5e03d57cf8fc9" name="a927b24acb865c4ca47b5e03d57cf8fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927b24acb865c4ca47b5e03d57cf8fc9">&#9670;&#160;</a></span>align_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::align_extent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>modulus</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the region computed so that the extent is a multiple of 'modulus'. </p>
<p>For example, f.align_extent(x, 2) forces the extent realized to be even. The region computed always contains the region that would have been computed without this directive, so no assertions are injected. (This is essentially equivalent to <a class="el" href="#a4a5b9179f8f69789f4b2db823e4c6129" title="Expand the region computed so that the min coordinates is congruent to &#39;remainder&#39; modulo &#39;modulus&#39;,...">align_bounds()</a>, but always leaving the min untouched.) </p>

</div>
</div>
<a id="a03e8400651242c62ab709cefeda1062c" name="a03e8400651242c62ab709cefeda1062c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e8400651242c62ab709cefeda1062c">&#9670;&#160;</a></span>bound_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::bound_extent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>extent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the extent of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s realization, but not its min. </p>
<p>This means the dimension can be unrolled or vectorized even when its min is not fixed (for example because it is compute_at tiles of another <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>). This can also be useful for forcing a function's allocation to be a fixed size, which often means it can go on the stack. </p>

</div>
</div>
<a id="a5413c606618e7c4257a1129666922fb5" name="a5413c606618e7c4257a1129666922fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5413c606618e7c4257a1129666922fb5">&#9670;&#160;</a></span>tile() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards. </p>
<p>This gives a tiled traversal. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a11">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a8">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7be85a5c88dec96e8b8ee8aa94816ff9" name="a7be85a5c88dec96e8b8ee8aa94816ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be85a5c88dec96e8b8ee8aa94816ff9">&#9670;&#160;</a></span>tile() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A shorter form of tile, which reuses the old variable names as the new outer dimensions. </p>

</div>
</div>
<a id="a60df741c4533d2beeda778d43de57553" name="a60df741c4533d2beeda778d43de57553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60df741c4533d2beeda778d43de57553">&#9670;&#160;</a></span>tile() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more general form of tile, which defines tiles of any dimensionality. </p>

</div>
</div>
<a id="a16ba4f7b004b9efcb61bc7b23dd151f5" name="a16ba4f7b004b9efcb61bc7b23dd151f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ba4f7b004b9efcb61bc7b23dd151f5">&#9670;&#160;</a></span>tile() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The generalized tile, with a single tail strategy to apply to all vars. </p>

</div>
</div>
<a id="ac7091adc43ef2945f2b564eb73e23343" name="ac7091adc43ef2945f2b564eb73e23343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7091adc43ef2945f2b564eb73e23343">&#9670;&#160;</a></span>tile() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalized tiling, reusing the previous names as the outer names. </p>

</div>
</div>
<a id="a295dda0c50965d5b29fa9fc48a9edbf4" name="a295dda0c50965d5b29fa9fc48a9edbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295dda0c50965d5b29fa9fc48a9edbf4">&#9670;&#160;</a></span>reorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder variables to have the given nesting order, from innermost out. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a6">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a5">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l01602">reorder()</a>.</p>

</div>
</div>
<a id="a77a2bc9d4bb4dfab342f3f412f8e2927" name="a77a2bc9d4bb4dfab342f3f412f8e2927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a2bc9d4bb4dfab342f3f412f8e2927">&#9670;&#160;</a></span>reorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a> Halide::Func::reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l01602">1602</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args()</a>, and <a class="el" href="#a295dda0c50965d5b29fa9fc48a9edbf4">reorder()</a>.</p>

</div>
</div>
<a id="ae059d387e9df97751c0c74bd28c91708" name="ae059d387e9df97751c0c74bd28c91708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae059d387e9df97751c0c74bd28c91708">&#9670;&#160;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>old_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>new_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a dimension. </p>
<p>Equivalent to split with a inner size of one. </p>

</div>
</div>
<a id="a712365570e7695d9b157ba2e4b089343" name="a712365570e7695d9b157ba2e4b089343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712365570e7695d9b157ba2e4b089343">&#9670;&#160;</a></span>allow_race_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::allow_race_conditions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify that race conditions are permitted for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, which enables parallelizing over RVars even when <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> cannot prove that it is safe to do so. </p>
<p>Use this with great caution, and only if you can prove to yourself that this is safe, as it may result in a non-deterministic routine that returns different values at different times or on different machines. </p>

</div>
</div>
<a id="a97a03efea97147fa0ab55cc86106f17a" name="a97a03efea97147fa0ab55cc86106f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a03efea97147fa0ab55cc86106f17a">&#9670;&#160;</a></span>atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::atomic </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>override_associativity_test</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue atomic updates for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>This allows parallelization on associative RVars. The function throws a compile error when <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> fails to prove associativity. Use override_associativity_test to disable the associativity test if you believe the function is associative or the order of reduction variable execution does not matter. <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> compiles this into hardware atomic operations whenever possible, and falls back to a mutex lock per storage element if it is impossible to atomically update. There are three possible outcomes of the compiled code: atomic add, compare-and-swap loop, and mutex lock. For example:</p>
<p>hist(x) = 0; hist(im(r)) += 1; hist.compute_root(); hist.update().<a class="el" href="#a97a03efea97147fa0ab55cc86106f17a" title="Issue atomic updates for this Func.">atomic()</a>.<a class="el" href="#ae78db35f74950c9e9c586f6ad7a3e7e0" title="Mark a dimension to be traversed in parallel.">parallel()</a>;</p>
<p>will be compiled to atomic add operations.</p>
<p>hist(x) = 0; hist(im(r)) = min(hist(im(r)) + 1, 100); hist.compute_root(); hist.update().<a class="el" href="#a97a03efea97147fa0ab55cc86106f17a" title="Issue atomic updates for this Func.">atomic()</a>.<a class="el" href="#ae78db35f74950c9e9c586f6ad7a3e7e0" title="Mark a dimension to be traversed in parallel.">parallel()</a>;</p>
<p>will be compiled to compare-and-swap loops.</p>
<p>arg_max() = {0, im(0)}; <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> old_index = arg_max()[0]; <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> old_max = arg_max()[1]; <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> new_index = select(old_max &lt; im(r), r, old_index); <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> new_max = max(im(r), old_max); arg_max() = {new_index, new_max}; arg_max.compute_root(); arg_max.update().<a class="el" href="#a97a03efea97147fa0ab55cc86106f17a" title="Issue atomic updates for this Func.">atomic()</a>.<a class="el" href="#ae78db35f74950c9e9c586f6ad7a3e7e0" title="Mark a dimension to be traversed in parallel.">parallel()</a>;</p>
<p>will be compiled to updates guarded by a mutex lock, since it is impossible to atomically update two different locations.</p>
<p>Currently the atomic operation is supported by x86, CUDA, and OpenCL backends. Compiling to other backends results in a compile error. If an operation is compiled into a mutex lock, and is vectorized or is compiled to CUDA or OpenCL, it also results in a compile error, since per-element mutex lock on vectorized operation leads to a deadlock. Vectorization of predicated RVars (through rdom.where()) on CPU is also unsupported yet (see <a href="https://github.com/halide/Halide/issues/4298">https://github.com/halide/Halide/issues/4298</a>). 8-bit and 16-bit atomics on GPU are also not supported. </p>

</div>
</div>
<a id="a7e84f672454064d16ab214cbae90c464" name="a7e84f672454064d16ab214cbae90c464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e84f672454064d16ab214cbae90c464">&#9670;&#160;</a></span>specialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> Halide::Func::specialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>condition</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialize a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>This creates a special-case version of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> where the given condition is true. The most effective conditions are those of the form param == value, and boolean Params. Consider a simple example: </p><div class="fragment"><div class="line">f(x) = x + <a class="code hl_function" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(cond, 0, 1);</div>
<div class="line">f.compute_root();</div>
<div class="ttc" id="anamespace_halide_html_a9d6371892ae38e7eb681fd3f23945b06"><div class="ttname"><a href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">Halide::select</a></div><div class="ttdeci">Expr select(Expr condition, Expr true_value, Expr false_value)</div><div class="ttdoc">Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...</div></div>
</div><!-- fragment --><p> This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">  f[x] = x + (cond ? 0 : 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Adding the scheduling directive: </p><div class="fragment"><div class="line">f.specialize(cond)</div>
</div><!-- fragment --><p> makes it equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cond) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">    f[x] = x;</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">    f[x] = x + 1;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that the inner loops have been simplified. In the first path <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> knows that cond is true, and in the second path <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> knows that it is false.</p>
<p>The specialized version gets its own schedule, which inherits every directive made about the parent <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s schedule so far except for its specializations. This method returns a handle to the new schedule. If you wish to retrieve the specialized sub-schedule again later, you can call this method with the same condition. Consider the following example of scheduling the specialized version:</p>
<div class="fragment"><div class="line">f(x) = x;</div>
<div class="line">f.compute_root();</div>
<div class="line">f.specialize(width &gt; 1).unroll(x, 2);</div>
</div><!-- fragment --><p> Assuming for simplicity that width is even, this is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (width &gt; 1) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width/2; x++) {</div>
<div class="line">    f[2*x] = 2*x;</div>
<div class="line">    f[2*x + 1] = 2*x + 1;</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width/2; x++) {</div>
<div class="line">    f[x] = x;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> For this case, it may be better to schedule the un-specialized case instead: </p><div class="fragment"><div class="line">f(x) = x;</div>
<div class="line">f.compute_root();</div>
<div class="line">f.specialize(width == 1); <span class="comment">// Creates a copy of the schedule so far.</span></div>
<div class="line">f.unroll(x, 2); <span class="comment">// Only applies to the unspecialized case.</span></div>
</div><!-- fragment --><p> This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (width == 1) {</div>
<div class="line">  f[0] = 0;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width/2; x++) {</div>
<div class="line">    f[2*x] = 2*x;</div>
<div class="line">    f[2*x + 1] = 2*x + 1;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> This can be a good way to write a pipeline that splits, vectorizes, or tiles, but can still handle small inputs.</p>
<p>If a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has several specializations, the first matching one will be used, so the order in which you define specializations is significant. For example:</p>
<div class="fragment"><div class="line">f(x) = x + <a class="code hl_function" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(cond1, a, b) - <a class="code hl_function" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(cond2, c, d);</div>
<div class="line">f.specialize(cond1);</div>
<div class="line">f.specialize(cond2);</div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cond1) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">    f[x] = x + a - (cond2 ? c : d);</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cond2) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">    f[x] = x + b - c;</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">    f[x] = x + b - d;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Specializations may in turn be specialized, which creates a nested if statement in the generated code.</p>
<div class="fragment"><div class="line">f(x) = x + <a class="code hl_function" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(cond1, a, b) - <a class="code hl_function" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(cond2, c, d);</div>
<div class="line">f.specialize(cond1).specialize(cond2);</div>
</div><!-- fragment --><p> This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cond1) {</div>
<div class="line">  <span class="keywordflow">if</span> (cond2) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">      f[x] = x + a - c;</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">      f[x] = x + a - d;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">    f[x] = x + b - (cond2 ? c : d);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> To create a 4-way if statement that simplifies away all of the ternary operators above, you could say: </p><div class="fragment"><div class="line">f.specialize(cond1).specialize(cond2);</div>
<div class="line">f.specialize(cond2);</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">f.specialize(cond1 &amp;&amp; cond2);</div>
<div class="line">f.specialize(cond1);</div>
<div class="line">f.specialize(cond2);</div>
</div><!-- fragment --><p>Any prior <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> which is compute_at some variable of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gets separately included in all paths of the generated if statement. The <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> in the compute_at call to must exist in all paths, but it may have been generated via a different path of splits, fuses, and renames. This can be used somewhat creatively. Consider the following code: </p><div class="fragment"><div class="line">g(x, y) = 8*x;</div>
<div class="line">f(x, y) = g(x, y) + 1;</div>
<div class="line">f.compute_root().specialize(cond);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> g_loop;</div>
<div class="line">f.specialize(cond).rename(y, g_loop);</div>
<div class="line">f.rename(x, g_loop);</div>
<div class="line">g.compute_at(f, g_loop);</div>
<div class="ttc" id="aclass_halide_1_1_var_html"><div class="ttname"><a href="class_halide_1_1_var.html">Halide::Var</a></div><div class="ttdoc">A Halide variable, to be used when defining functions.</div><div class="ttdef"><b>Definition</b> <a href="_var_8h_source.html#l00019">Var.h:19</a></div></div>
</div><!-- fragment --><p> When cond is true, this is equivalent to g.compute_at(f,y). When it is false, this is equivalent to g.compute_at(f,x). </p>

</div>
</div>
<a id="a11b75965d72a3f1cd98e4f13cfe28aaf" name="a11b75965d72a3f1cd98e4f13cfe28aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b75965d72a3f1cd98e4f13cfe28aaf">&#9670;&#160;</a></span>specialize_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::specialize_fail </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a specialization to a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that always terminates execution with a call to <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8" title="Halide calls this function on runtime errors (for example bounds checking failures).">halide_error()</a>. </p>
<p>By itself, this is of limited use, but can be useful to terminate chains of <a class="el" href="#a7e84f672454064d16ab214cbae90c464" title="Specialize a Func.">specialize()</a> calls where no "default" case is expected (thus avoiding unnecessary code generation).</p>
<p>For instance, say we want to optimize a pipeline to process images in planar and interleaved format; we might typically do something like: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_image_param.html">ImageParam</a> im(<a class="code hl_function" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(8), 3);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f = do_something_with(im);</div>
<div class="line">f.<a class="code hl_function" href="#a7e84f672454064d16ab214cbae90c464">specialize</a>(im.dim(0).stride() == 1).<a class="code hl_function" href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">vectorize</a>(x, 8);  <span class="comment">// planar</span></div>
<div class="line">f.<a class="code hl_function" href="#a7e84f672454064d16ab214cbae90c464">specialize</a>(im.dim(2).stride() == 1).<a class="code hl_function" href="class_halide_1_1_stage.html#a8d9046162bdca77e4e721416ed96a72c">reorder</a>(c, x, y).<a class="code hl_function" href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">vectorize</a>(c);  <span class="comment">// interleaved</span></div>
<div class="ttc" id="aclass_halide_1_1_func_html"><div class="ttname"><a href="class_halide_1_1_func.html">Halide::Func</a></div><div class="ttdoc">A halide function.</div><div class="ttdef"><b>Definition</b> <a href="_func_8h_source.html#l00700">Func.h:700</a></div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_a7e84f672454064d16ab214cbae90c464"><div class="ttname"><a href="#a7e84f672454064d16ab214cbae90c464">Halide::Func::specialize</a></div><div class="ttdeci">Stage specialize(const Expr &amp;condition)</div><div class="ttdoc">Specialize a Func.</div></div>
<div class="ttc" id="aclass_halide_1_1_stage_html_a2cddae992bed87a0ee529d6ec4946356"><div class="ttname"><a href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">Halide::Stage::vectorize</a></div><div class="ttdeci">Stage &amp; vectorize(const VarOrRVar &amp;var)</div></div>
<div class="ttc" id="aclass_halide_1_1_stage_html_a8d9046162bdca77e4e721416ed96a72c"><div class="ttname"><a href="class_halide_1_1_stage.html#a8d9046162bdca77e4e721416ed96a72c">Halide::Stage::reorder</a></div><div class="ttdeci">Stage &amp; reorder(const std::vector&lt; VarOrRVar &gt; &amp;vars)</div></div>
<div class="ttc" id="anamespace_halide_html_a0eb5f455b5c4bce0c54575bc67bf9599"><div class="ttname"><a href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">Halide::UInt</a></div><div class="ttdeci">Type UInt(int bits, int lanes=1)</div><div class="ttdoc">Constructing an unsigned integer type.</div><div class="ttdef"><b>Definition</b> <a href="_type_8h_source.html#l00546">Type.h:546</a></div></div>
</div><!-- fragment --><p> This code will vectorize along rows for the planar case, and across pixel components for the interleaved case... but there is an implicit "else" for the unhandled cases, which generates unoptimized code. If we never anticipate passing any other sort of images to this, we code streamline our code by adding <a class="el" href="#a11b75965d72a3f1cd98e4f13cfe28aaf" title="Add a specialization to a Func that always terminates execution with a call to halide_error().">specialize_fail()</a>: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_image_param.html">ImageParam</a> im(<a class="code hl_function" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(8), 3);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f = do_something(im);</div>
<div class="line">f.<a class="code hl_function" href="#a7e84f672454064d16ab214cbae90c464">specialize</a>(im.dim(0).stride() == 1).<a class="code hl_function" href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">vectorize</a>(x, 8);  <span class="comment">// planar</span></div>
<div class="line">f.<a class="code hl_function" href="#a7e84f672454064d16ab214cbae90c464">specialize</a>(im.dim(2).stride() == 1).<a class="code hl_function" href="class_halide_1_1_stage.html#a8d9046162bdca77e4e721416ed96a72c">reorder</a>(c, x, y).<a class="code hl_function" href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">vectorize</a>(c);  <span class="comment">// interleaved</span></div>
<div class="line">f.<a class="code hl_function" href="#a11b75965d72a3f1cd98e4f13cfe28aaf">specialize_fail</a>(<span class="stringliteral">&quot;Unhandled image format&quot;</span>);</div>
<div class="ttc" id="aclass_halide_1_1_func_html_a11b75965d72a3f1cd98e4f13cfe28aaf"><div class="ttname"><a href="#a11b75965d72a3f1cd98e4f13cfe28aaf">Halide::Func::specialize_fail</a></div><div class="ttdeci">void specialize_fail(const std::string &amp;message)</div><div class="ttdoc">Add a specialization to a Func that always terminates execution with a call to halide_error().</div></div>
</div><!-- fragment --><p> Conceptually, this produces codes like: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (im.dim(0).stride() == 1) {</div>
<div class="line">   do_something_planar();</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (im.dim(2).stride() == 1) {</div>
<div class="line">   do_something_interleaved();</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">   <a class="code hl_function" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a>(<span class="stringliteral">&quot;Unhandled image format&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="a_halide_runtime_8h_html_aea28d04de54b94f0dd6ada140b7734d8"><div class="ttname"><a href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a></div><div class="ttdeci">void halide_error(void *user_context, const char *)</div><div class="ttdoc">Halide calls this function on runtime errors (for example bounds checking failures).</div></div>
</div><!-- fragment --><p>Note that calling <a class="el" href="#a11b75965d72a3f1cd98e4f13cfe28aaf" title="Add a specialization to a Func that always terminates execution with a call to halide_error().">specialize_fail()</a> terminates the specialization chain for a given <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>; you cannot create new specializations for the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> afterwards (though you can retrieve handles to previous specializations). </p>

</div>
</div>
<a id="ab190a2b563e3cdfdf7b52a4a7e9a7962" name="ab190a2b563e3cdfdf7b52a4a7e9a7962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab190a2b563e3cdfdf7b52a4a7e9a7962">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> that the following dimensions correspond to GPU thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to GPU threads. If the selected target is not an appropriate GPU, this just marks those dimensions as parallel. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a16">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3715a7bf2ae98559ed7e4c2959b97b3a" name="a3715a7bf2ae98559ed7e4c2959b97b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3715a7bf2ae98559ed7e4c2959b97b3a">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7b1fa5f7c8744bf77f6bc46ecf3fada" name="ae7b1fa5f7c8744bf77f6bc46ecf3fada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b1fa5f7c8744bf77f6bc46ecf3fada">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f795873445836af0c7643d4c99a2ee2" name="a2f795873445836af0c7643d4c99a2ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f795873445836af0c7643d4c99a2ee2">&#9670;&#160;</a></span>gpu_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The given dimension corresponds to the lanes in a GPU warp. </p>
<p>GPU warp lanes are distinguished from GPU threads by the fact that all warp lanes run together in lockstep, which permits lightweight communication of data from one lane to another. </p>

</div>
</div>
<a id="af83e9ccd0de6fd575006ab04c220ece2" name="af83e9ccd0de6fd575006ab04c220ece2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83e9ccd0de6fd575006ab04c220ece2">&#9670;&#160;</a></span>gpu_single_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_single_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to run this stage using a single gpu thread and block. </p>
<p>This is not an efficient use of your GPU, but it can be useful to avoid copy-back for intermediate update stages that touch a very small part of your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02684">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a id="a02b8d8ad9e4f4b25a23bab71d77de165" name="a02b8d8ad9e4f4b25a23bab71d77de165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b8d8ad9e4f4b25a23bab71d77de165">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> that the following dimensions correspond to GPU block indices. </p>
<p>This is useful for scheduling stages that will run serially within each GPU block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a15">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a36a246ffb10d6bf598bacec308c58387" name="a36a246ffb10d6bf598bacec308c58387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a246ffb10d6bf598bacec308c58387">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e63197448302757cf990fcc0e0cb682" name="a2e63197448302757cf990fcc0e0cb682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e63197448302757cf990fcc0e0cb682">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a022f7853d7313f6a5128ce8c24ed05ce" name="a022f7853d7313f6a5128ce8c24ed05ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022f7853d7313f6a5128ce8c24ed05ce">&#9670;&#160;</a></span>gpu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> that the following dimensions correspond to GPU block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a id="a599a3fb276bce469fe19dcad526908b1" name="a599a3fb276bce469fe19dcad526908b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599a3fb276bce469fe19dcad526908b1">&#9670;&#160;</a></span>gpu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc7cea9bf01c8db41a5901a659c146d" name="aebc7cea9bf01c8db41a5901a659c146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc7cea9bf01c8db41a5901a659c146d">&#9670;&#160;</a></span>gpu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdce7c7be7f2a6f4ab1dc806c6124850" name="afdce7c7be7f2a6f4ab1dc806c6124850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce7c7be7f2a6f4ab1dc806c6124850">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a17">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a448e7ce74cb609e959c1222b4b6637fd" name="a448e7ce74cb609e959c1222b4b6637fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448e7ce74cb609e959c1222b4b6637fd">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9fbc9b1d1bda331d5e2a53c9e1d339c" name="ac9fbc9b1d1bda331d5e2a53c9e1d339c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fbc9b1d1bda331d5e2a53c9e1d339c">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>by</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a081082518ba27137531a2cba4d552351" name="a081082518ba27137531a2cba4d552351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081082518ba27137531a2cba4d552351">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62fd2e3cb76e2d6a8fb650f13f51d8e0" name="a62fd2e3cb76e2d6a8fb650f13f51d8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fd2e3cb76e2d6a8fb650f13f51d8e0">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>by</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7881893e0a1db5ac9429c46334ecaf" name="a8d7881893e0a1db5ac9429c46334ecaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7881893e0a1db5ac9429c46334ecaf">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5834ded586e70e65b93850d7cafed54" name="ac5834ded586e70e65b93850d7cafed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5834ded586e70e65b93850d7cafed54">&#9670;&#160;</a></span>hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::hexagon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule for execution on Hexagon. </p>
<p>When a loop is marked with Hexagon, that loop is executed on a Hexagon DSP. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02684">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a id="accb11c7c6f5ce93beed415260430ce55" name="accb11c7c6f5ce93beed415260430ce55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb11c7c6f5ce93beed415260430ce55">&#9670;&#160;</a></span>prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch data written to or read from a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> by a subsequent loop iteration, at an optionally specified iteration offset. </p>
<p>You may specify specification of different vars for the location of the <a class="el" href="#accb11c7c6f5ce93beed415260430ce55" title="Prefetch data written to or read from a Func or an ImageParam by a subsequent loop iteration,...">prefetch()</a> instruction vs. the location that is being prefetched:</p>
<ul>
<li>the first var specified, 'at', indicates the loop in which the prefetch will be placed</li>
<li>the second var specified, 'from', determines the var used to find the bounds to prefetch (in conjunction with 'offset')</li>
</ul>
<p>If 'at' and 'from' are distinct vars, then 'from' must be at a nesting level outside 'at.' Note that the value for 'offset' applies only to 'from', not 'at'.</p>
<p>The final argument specifies how prefetch of region outside bounds should be handled.</p>
<p>For example, consider this pipeline: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y, z;</div>
<div class="line">f(x, y) = x + y;</div>
<div class="line">g(x, y) = 2 * f(x, y);</div>
<div class="line">h(x, y) = 3 * f(x, y);</div>
</div><!-- fragment --><p>The following schedule: </p><div class="fragment"><div class="line">f.<a class="code hl_function" href="#a67f5d6e8023b42e81d577a7c9c0c8df0">compute_root</a>();</div>
<div class="line">g.<a class="code hl_function" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a>(f, x, x, 2, <a class="code hl_enumvalue" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b">PrefetchBoundStrategy::NonFaulting</a>);</div>
<div class="line">h.<a class="code hl_function" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a>(f, x, y, 2, <a class="code hl_enumvalue" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b">PrefetchBoundStrategy::NonFaulting</a>);</div>
<div class="ttc" id="aclass_halide_1_1_func_html_a67f5d6e8023b42e81d577a7c9c0c8df0"><div class="ttname"><a href="#a67f5d6e8023b42e81d577a7c9c0c8df0">Halide::Func::compute_root</a></div><div class="ttdeci">Func &amp; compute_root()</div><div class="ttdoc">Compute all of this function once ahead of time.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_accb11c7c6f5ce93beed415260430ce55"><div class="ttname"><a href="#accb11c7c6f5ce93beed415260430ce55">Halide::Func::prefetch</a></div><div class="ttdeci">Func &amp; prefetch(const Func &amp;f, const VarOrRVar &amp;at, const VarOrRVar &amp;from, Expr offset=1, PrefetchBoundStrategy strategy=PrefetchBoundStrategy::GuardWithIf)</div><div class="ttdoc">Prefetch data written to or read from a Func or an ImageParam by a subsequent loop iteration,...</div></div>
<div class="ttc" id="anamespace_halide_html_a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b"><div class="ttname"><a href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b">Halide::PrefetchBoundStrategy::NonFaulting</a></div><div class="ttdeci">@ NonFaulting</div><div class="ttdoc">Leave the prefetched exprs as-is (no if-guards around the prefetch and no intersecting with the origi...</div></div>
</div><!-- fragment --><p>will inject prefetch call at the innermost loop of 'g' and 'h' and generate the following loop nest: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y = ...</div>
<div class="line">  <span class="keywordflow">for</span> x = ...</div>
<div class="line">    f(x, y) = x + y</div>
<div class="line"><span class="keywordflow">for</span> y = ..</div>
<div class="line">  <span class="keywordflow">for</span> x = ...</div>
<div class="line">    <a class="code hl_function" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a>(&amp;f[x + 2, y], 1, 16);</div>
<div class="line">    g(x, y) = 2 * f(x, y)</div>
<div class="line"><span class="keywordflow">for</span> y = ..</div>
<div class="line">  <span class="keywordflow">for</span> x = ...</div>
<div class="line">    <a class="code hl_function" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a>(&amp;f[x, y + 2], 1, 16);</div>
<div class="line">    h(x, y) = 3 * f(x, y)</div>
</div><!-- fragment --><p>Note that the 'from' nesting level need not be adjacent to 'at': </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y, z, w;</div>
<div class="line">f(x, y, z, w) = x + y + z + w;</div>
<div class="line">g(x, y, z, w) = 2 * f(x, y, z, w);</div>
</div><!-- fragment --><p>The following schedule: </p><div class="fragment"><div class="line">f.<a class="code hl_function" href="#a67f5d6e8023b42e81d577a7c9c0c8df0">compute_root</a>();</div>
<div class="line">g.<a class="code hl_function" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a>(f, y, w, 2, <a class="code hl_enumvalue" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b">PrefetchBoundStrategy::NonFaulting</a>);</div>
</div><!-- fragment --><p>will produce code that prefetches a tile of data: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> w = ...</div>
<div class="line">  <span class="keywordflow">for</span> z = ...</div>
<div class="line">    <span class="keywordflow">for</span> y = ...</div>
<div class="line">      <span class="keywordflow">for</span> x = ...</div>
<div class="line">    f(x, y, z, w) = x + y + z + w</div>
<div class="line"><span class="keywordflow">for</span> w = ...</div>
<div class="line">  <span class="keywordflow">for</span> z = ...</div>
<div class="line">    <span class="keywordflow">for</span> y = ...</div>
<div class="line">      <span class="keywordflow">for</span> x0 = ...</div>
<div class="line">         <a class="code hl_function" href="#accb11c7c6f5ce93beed415260430ce55">prefetch</a>(&amp;f[x0, y, z, w + 2], 1, 16);</div>
<div class="line">      <span class="keywordflow">for</span> x = ...</div>
<div class="line">        g(x, y, z, w) = 2 * f(x, y, z, w)</div>
</div><!-- fragment --><p>Note that calling <a class="el" href="#accb11c7c6f5ce93beed415260430ce55" title="Prefetch data written to or read from a Func or an ImageParam by a subsequent loop iteration,...">prefetch()</a> with the same var for both 'at' and 'from' is equivalent to calling <a class="el" href="#accb11c7c6f5ce93beed415260430ce55" title="Prefetch data written to or read from a Func or an ImageParam by a subsequent loop iteration,...">prefetch()</a> with that var. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02052">prefetch()</a>.</p>

</div>
</div>
<a id="a1102f220f97b8e7e80bdd113567b53c9" name="a1102f220f97b8e7e80bdd113567b53c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1102f220f97b8e7e80bdd113567b53c9">&#9670;&#160;</a></span>prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_parameter.html">Parameter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af212c2cce113c096f2ddc96a10ee66d1" name="af212c2cce113c096f2ddc96a10ee66d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af212c2cce113c096f2ddc96a10ee66d1">&#9670;&#160;</a></span>prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>image</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02052">2052</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#accb11c7c6f5ce93beed415260430ce55">prefetch()</a>.</p>

</div>
</div>
<a id="ae91507761237f8f477fb190bcba1c779" name="ae91507761237f8f477fb190bcba1c779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91507761237f8f477fb190bcba1c779">&#9670;&#160;</a></span>reorder_storage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify how the storage for the function is laid out. </p>
<p>These calls let you specify the nesting order of the dimensions. For example, foo.reorder_storage(y, x) tells <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to use column-major storage for any realizations of foo, without changing how you refer to foo in the code. You may want to do this if you intend to vectorize across y. When representing color images, foo.reorder_storage(c, x, y) specifies packed storage (red, green, and blue values adjacent in memory), and foo.reorder_storage(x, y, c) specifies planar storage (entire red, green, and blue images one after the other in memory).</p>
<p>If you leave out some dimensions, those remain in the same positions in the nesting order while the specified variables are reordered around them. </p>

</div>
</div>
<a id="a4ad4486909529683fd2d47b3d8b8d9cf" name="a4ad4486909529683fd2d47b3d8b8d9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad4486909529683fd2d47b3d8b8d9cf">&#9670;&#160;</a></span>reorder_storage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66cd53894a9e7385b3a80c9ec159346b" name="a66cd53894a9e7385b3a80c9ec159346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cd53894a9e7385b3a80c9ec159346b">&#9670;&#160;</a></span>reorder_storage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="class_halide_1_1_var.html">Var</a>, Args... &gt;<a class="el" href="#a90926a2fe1bd3b6db924e8bdd53b5ed4">::value</a>, <a class="el" href="class_halide_1_1_func.html">Func</a> &amp; &gt;<a class="el" href="#a2103b97e0f563aba56aaabd2f82e1d03">::type</a> Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02078">2078</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a6fa2fe6d902d1c426ad209ec6a986ace">args()</a>.</p>

</div>
</div>
<a id="a3b9c4e071b44874bdfa1e0b6eea507de" name="a3b9c4e071b44874bdfa1e0b6eea507de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9c4e071b44874bdfa1e0b6eea507de">&#9670;&#160;</a></span>align_storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::align_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the storage extent of a particular dimension of realizations of this function up to be a multiple of the specified alignment. </p>
<p>This guarantees that the strides for the dimensions stored outside of dim will be multiples of the specified alignment, where the strides and alignment are measured in numbers of elements.</p>
<p>For example, to guarantee that a function foo(x, y, c) representing an image has scanlines starting on offsets aligned to multiples of 16, use foo.align_storage(x, 16). </p>

</div>
</div>
<a id="aa8900f676c8ba7a07181b96977f00d74" name="aa8900f676c8ba7a07181b96977f00d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8900f676c8ba7a07181b96977f00d74">&#9670;&#160;</a></span>fold_storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::fold_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fold_forward</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store realizations of this function in a circular buffer of a given extent. </p>
<p>This is more efficient when the extent of the circular buffer is a power of 2. If the fold factor is too small, or the dimension is not accessed monotonically, the pipeline will generate an error at runtime.</p>
<p>The fold_forward option indicates that the new values of the producer are accessed by the consumer in a monotonically increasing order. Folding storage of producers is also supported if the new values are accessed in a monotonically decreasing order by setting fold_forward to false.</p>
<p>For example, consider the pipeline: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x, y+1);</div>
</div><!-- fragment --><p>If we schedule f like so:</p>
<div class="fragment"><div class="line">g.<a class="code hl_function" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(f, y).<a class="code hl_function" href="#ac93658c5f706df4dced8b276400885c9">store_root</a>().<a class="code hl_function" href="#aa8900f676c8ba7a07181b96977f00d74">fold_storage</a>(y, 2);</div>
<div class="ttc" id="aclass_halide_1_1_func_html_aa8900f676c8ba7a07181b96977f00d74"><div class="ttname"><a href="#aa8900f676c8ba7a07181b96977f00d74">Halide::Func::fold_storage</a></div><div class="ttdeci">Func &amp; fold_storage(const Var &amp;dim, const Expr &amp;extent, bool fold_forward=true)</div><div class="ttdoc">Store realizations of this function in a circular buffer of a given extent.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_ac93658c5f706df4dced8b276400885c9"><div class="ttname"><a href="#ac93658c5f706df4dced8b276400885c9">Halide::Func::store_root</a></div><div class="ttdeci">Func &amp; store_root()</div><div class="ttdoc">Equivalent to Func::store_at, but schedules storage outside the outermost loop.</div></div>
<div class="ttc" id="aclass_halide_1_1_func_html_af4aca8ca6331e64a6fdfd98fccf1757a"><div class="ttname"><a href="#af4aca8ca6331e64a6fdfd98fccf1757a">Halide::Func::compute_at</a></div><div class="ttdeci">Func &amp; compute_at(const Func &amp;f, const Var &amp;var)</div><div class="ttdoc">Compute this function as needed for each unique value of the given var for the given calling function...</div></div>
</div><!-- fragment --><p>Then g will be computed at each row of f and stored in a buffer with an extent in y of 2, alternately storing each computed row of g in row y=0 or y=1. </p>

</div>
</div>
<a id="af4aca8ca6331e64a6fdfd98fccf1757a" name="af4aca8ca6331e64a6fdfd98fccf1757a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4aca8ca6331e64a6fdfd98fccf1757a">&#9670;&#160;</a></span>compute_at() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute this function as needed for each unique value of the given var for the given calling function f. </p>
<p>For example, consider the simple pipeline: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</div>
</div><!-- fragment --><p>If we schedule f like so:</p>
<div class="fragment"><div class="line">g.<a class="code hl_function" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(f, x);</div>
</div><!-- fragment --><p>Then the C code equivalent to this pipeline will look like this</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordtype">int</span> g[2][2];</div>
<div class="line">        g[0][0] = x*y;</div>
<div class="line">        g[0][1] = (x+1)*y;</div>
<div class="line">        g[1][0] = x*(y+1);</div>
<div class="line">        g[1][1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][0] + g[1][0] + g[0][1] + g[1][1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The allocation and computation of g is within f's loop over x, and enough of g is computed to satisfy all that f will need for that iteration. This has excellent locality - values of g are used as soon as they are computed, but it does redundant work. Each value of g ends up getting computed four times. If we instead schedule f like so:</p>
<div class="fragment"><div class="line">g.<a class="code hl_function" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(f, y);</div>
</div><!-- fragment --><p>The equivalent C code is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][width+1];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        g[0][x] = x*y;</div>
<div class="line">        g[1][x] = x*(y+1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The allocation and computation of g is within f's loop over y, and enough of g is computed to satisfy all that f will need for that iteration. This does less redundant work (each point in g ends up being evaluated twice), but the locality is not quite as good, and we have to allocate more temporary memory to store g. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a6">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a14">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a10">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a14ab65cc3d4f1b0d0e1813d9eab4a526" name="a14ab65cc3d4f1b0d0e1813d9eab4a526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ab65cc3d4f1b0d0e1813d9eab4a526">&#9670;&#160;</a></span>compute_at() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a function to be computed within the iteration over some dimension of an update domain. </p>
<p>Produces equivalent code to the version of compute_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>. </p>

</div>
</div>
<a id="aaf98ea895de7cb30f564b52e4670ba64" name="aaf98ea895de7cb30f564b52e4670ba64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf98ea895de7cb30f564b52e4670ba64">&#9670;&#160;</a></span>compute_at() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a function to be computed within the iteration over a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>

</div>
</div>
<a id="a8f1204939742d77c847c0928e865d318" name="a8f1204939742d77c847c0928e865d318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1204939742d77c847c0928e865d318">&#9670;&#160;</a></span>compute_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>align</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the iteration over the initial definition of this function to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>

</div>
</div>
<a id="a8a1a60b53a44e9cda48647da7509ae91" name="a8a1a60b53a44e9cda48647da7509ae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1a60b53a44e9cda48647da7509ae91">&#9670;&#160;</a></span>compute_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a></td>          <td class="paramname"><span class="paramname"><em>align</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5b42699e504977b50f9a8196da81a3" name="a1c5b42699e504977b50f9a8196da81a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5b42699e504977b50f9a8196da81a3">&#9670;&#160;</a></span>compute_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>align</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69f0512b7c3f16f16662dc49bba53775" name="a69f0512b7c3f16f16662dc49bba53775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0512b7c3f16f16662dc49bba53775">&#9670;&#160;</a></span>compute_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a></td>          <td class="paramname"><span class="paramname"><em>align</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67f5d6e8023b42e81d577a7c9c0c8df0" name="a67f5d6e8023b42e81d577a7c9c0c8df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f5d6e8023b42e81d577a7c9c0c8df0">&#9670;&#160;</a></span>compute_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all of this function once ahead of time. </p>
<p>Reusing the example in <a class="el" href="#af4aca8ca6331e64a6fdfd98fccf1757a">Func::compute_at</a> :</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</div>
<div class="line"> </div>
<div class="line">g.<a class="code hl_function" href="#a67f5d6e8023b42e81d577a7c9c0c8df0">compute_root</a>();</div>
</div><!-- fragment --><p>is equivalent to</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordtype">int</span> g[height+1][width+1];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height+1; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width+1; x++) {</div>
<div class="line">        g[y][x] = x*y;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        f[y][x] = g[y][x] + g[y+1][x] + g[y][x+1] + g[y+1][x+1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>g is computed once ahead of time, and enough is computed to satisfy all uses of it. This does no redundant work (each point in g is evaluated once), but has poor locality (values of g are probably not still in cache when they are used by f), and allocates lots of temporary memory to store g. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a5">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a4">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a0c2880397c0b550288d17e6f4e08cf27" name="a0c2880397c0b550288d17e6f4e08cf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2880397c0b550288d17e6f4e08cf27">&#9670;&#160;</a></span>memoize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::memoize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_eviction_key.html">EvictionKey</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>eviction_key</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_eviction_key.html">EvictionKey</a>()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the halide_memoization_cache_... interface to store a computed version of this function across invocations of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>If an eviction_key is provided, it must be constructed with <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> of integer or handle type. The key <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> will be promoted to a uint64_t and can be used with halide_memoization_cache_evict to remove memoized entries using this eviction key from the cache. Memoized computations that do not provide an eviction key will never be evicted by this mechanism. </p>

</div>
</div>
<a id="a2442a24f054511ab4e181465196012d8" name="a2442a24f054511ab4e181465196012d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2442a24f054511ab4e181465196012d8">&#9670;&#160;</a></span>async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::async </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> asynchronously in a separate thread. </p>
<p>Consumers will be run by the task system when the production is complete. If this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s store level is different to its compute level, consumers will be run concurrently, blocking as necessary to prevent reading ahead of what the producer has computed. If storage is folded, then the producer will additionally not be permitted to run too far ahead of the consumer, to avoid clobbering data that has not yet been used.</p>
<p>Take special care when combining this with custom thread pool implementations, as avoiding deadlock with producer-consumer parallelism requires a much more sophisticated parallel runtime than with data parallelism alone. It is strongly recommended you just use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s default thread pool, which guarantees no deadlock and a bound on the number of threads launched. </p>

</div>
</div>
<a id="a826751d5d61453465b2320474f8ef852" name="a826751d5d61453465b2320474f8ef852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826751d5d61453465b2320474f8ef852">&#9670;&#160;</a></span>ring_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::ring_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>extent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands the storage of the function by an extra dimension to enable ring buffering. </p>
<p>For this to be useful the storage of the function has to be hoisted to an upper loop level using <a class="el" href="#ad425d2e003947d41a69ad6c8077c2567">Func::hoist_storage</a>. The index for the new ring buffer dimension is calculated implicitly based on a linear combination of the all of the loop variables between hoist_storage and compute_at/store_at loop levels. Scheduling a function with ring_buffer increases the amount of memory required for this function by an <em>extent</em> times. ring_buffer is especially useful in combination with <a class="el" href="#a2442a24f054511ab4e181465196012d8">Func::async</a>, but can be used without it.</p>
<p>The extent is expected to be a positive integer. </p>

</div>
</div>
<a id="adf605eef64da4a4b3bb17a1483181dc6" name="adf605eef64da4a4b3bb17a1483181dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf605eef64da4a4b3bb17a1483181dc6">&#9670;&#160;</a></span>bound_storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::bound_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the extent of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s storage, but not extent of its compute. </p>
<p>This can be useful for forcing a function's allocation to be a fixed size, which often means it can go on the stack. If bounds inference decides that it requires more storage for this function than the allocation size you have stated, a runtime error will occur when you try to run the pipeline. </p>

</div>
</div>
<a id="aa5d784c5fe960c2c0e4c89961b8b71ef" name="aa5d784c5fe960c2c0e4c89961b8b71ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d784c5fe960c2c0e4c89961b8b71ef">&#9670;&#160;</a></span>store_at() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::store_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage for this function within f's loop over var. </p>
<p>Scheduling storage is optional, and can be used to separate the loop level at which storage occurs from the loop level at which computation occurs to trade off between locality and redundant work. This can open the door for two types of optimization.</p>
<p>Consider again the pipeline from <a class="el" href="#af4aca8ca6331e64a6fdfd98fccf1757a">Func::compute_at</a> : </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);</div>
</div><!-- fragment --><p>If we schedule it like so:</p>
<div class="fragment"><div class="line">g.<a class="code hl_function" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(f, x).<a class="code hl_function" href="#aa5d784c5fe960c2c0e4c89961b8b71ef">store_at</a>(f, y);</div>
<div class="ttc" id="aclass_halide_1_1_func_html_aa5d784c5fe960c2c0e4c89961b8b71ef"><div class="ttname"><a href="#aa5d784c5fe960c2c0e4c89961b8b71ef">Halide::Func::store_at</a></div><div class="ttdeci">Func &amp; store_at(const Func &amp;f, const Var &amp;var)</div><div class="ttdoc">Allocate storage for this function within f's loop over var.</div></div>
</div><!-- fragment --><p>Then the computation of g takes place within the loop over x, but the storage takes place within the loop over y:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][width+1];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        g[0][x] = x*y;</div>
<div class="line">        g[0][x+1] = (x+1)*y;</div>
<div class="line">        g[1][x] = x*(y+1);</div>
<div class="line">        g[1][x+1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Provided the for loop over x is serial, halide then automatically performs the following sliding window optimization:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][width+1];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordflow">if</span> (x == 0) {</div>
<div class="line">            g[0][x] = x*y;</div>
<div class="line">            g[1][x] = x*(y+1);</div>
<div class="line">        }</div>
<div class="line">        g[0][x+1] = (x+1)*y;</div>
<div class="line">        g[1][x+1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Two of the assignments to g only need to be done when x is zero. The rest of the time, those sites have already been filled in by a previous iteration. This version has the locality of compute_at(f, x), but allocates more memory and does much less redundant work.</p>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> then further optimizes this pipeline like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][2];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordflow">if</span> (x == 0) {</div>
<div class="line">            g[0][0] = x*y;</div>
<div class="line">            g[1][0] = x*(y+1);</div>
<div class="line">        }</div>
<div class="line">        g[0][(x+1)%2] = (x+1)*y;</div>
<div class="line">        g[1][(x+1)%2] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][x%2] + g[1][x%2] + g[0][(x+1)%2] + g[1][(x+1)%2];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> has detected that it's possible to use a circular buffer to represent g, and has reduced all accesses to g modulo 2 in the x dimension. This optimization only triggers if the for loop over x is serial, and if halide can statically determine some power of two large enough to cover the range needed. For powers of two, the modulo operator compiles to more efficient bit-masking. This optimization reduces memory usage, and also improves locality by reusing recently-accessed memory instead of pulling new memory into cache. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a12">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a18">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a12">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="abca1a5c2f0bc941129f2125b13d753b8" name="abca1a5c2f0bc941129f2125b13d753b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca1a5c2f0bc941129f2125b13d753b8">&#9670;&#160;</a></span>store_at() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::store_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain. </p>

</div>
</div>
<a id="a8b04c0b2d479b7cd2714a6b905564926" name="a8b04c0b2d479b7cd2714a6b905564926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b04c0b2d479b7cd2714a6b905564926">&#9670;&#160;</a></span>store_at() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::store_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage at a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>

</div>
</div>
<a id="ac93658c5f706df4dced8b276400885c9" name="ac93658c5f706df4dced8b276400885c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93658c5f706df4dced8b276400885c9">&#9670;&#160;</a></span>store_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::store_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="#aa5d784c5fe960c2c0e4c89961b8b71ef">Func::store_at</a>, but schedules storage outside the outermost loop. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a7">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad425d2e003947d41a69ad6c8077c2567" name="ad425d2e003947d41a69ad6c8077c2567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad425d2e003947d41a69ad6c8077c2567">&#9670;&#160;</a></span>hoist_storage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::hoist_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist storage for this function within f's loop over var. </p>
<p>This is different from <a class="el" href="#aa5d784c5fe960c2c0e4c89961b8b71ef">Func::store_at</a>, because hoist_storage simply moves an actual allocation to a given loop level and doesn't trigger any of the optimizations such as sliding window. Hoisting storage is optional and can be used as an optimization to avoid unnecessary allocations by moving it out from an inner loop.</p>
<p>Consider again the pipeline from <a class="el" href="#af4aca8ca6331e64a6fdfd98fccf1757a">Func::compute_at</a> : </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</div>
</div><!-- fragment --><p>If we schedule f like so:</p>
<div class="fragment"><div class="line">g.<a class="code hl_function" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(f, x);</div>
</div><!-- fragment --><p>Then the C code equivalent to this pipeline will look like this</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordtype">int</span> g[2][2];</div>
<div class="line">        g[0][0] = x*y;</div>
<div class="line">        g[0][1] = (x+1)*y;</div>
<div class="line">        g[1][0] = x*(y+1);</div>
<div class="line">        g[1][1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][0] + g[1][0] + g[0][1] + g[1][1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the allocation for g inside of the loop over variable x which can happen for each iteration of the inner loop (in total height * width times). In some cases allocation can be expensive, so it might be better to do it once and reuse allocated memory across all iterations of the loop.</p>
<p>This can be done by scheduling g like so:</p>
<div class="fragment"><div class="line">g.<a class="code hl_function" href="#af4aca8ca6331e64a6fdfd98fccf1757a">compute_at</a>(f, x).<a class="code hl_function" href="#ad425d2e003947d41a69ad6c8077c2567">hoist_storage</a>(f, <a class="code hl_function" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>());</div>
<div class="ttc" id="aclass_halide_1_1_func_html_ad425d2e003947d41a69ad6c8077c2567"><div class="ttname"><a href="#ad425d2e003947d41a69ad6c8077c2567">Halide::Func::hoist_storage</a></div><div class="ttdeci">Func &amp; hoist_storage(const Func &amp;f, const Var &amp;var)</div><div class="ttdoc">Hoist storage for this function within f's loop over var.</div></div>
<div class="ttc" id="aclass_halide_1_1_var_html_aae5374d79ed234db176e6a59057bdb1b"><div class="ttname"><a href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Halide::Var::outermost</a></div><div class="ttdeci">static Var outermost()</div><div class="ttdoc">A Var that represents the location outside the outermost loop.</div><div class="ttdef"><b>Definition</b> <a href="_var_8h_source.html#l00163">Var.h:163</a></div></div>
</div><!-- fragment --><p>Then the C code equivalent to this pipeline will look like this</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordtype">int</span> g[2][2];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        g[0][0] = x*y;</div>
<div class="line">        g[0][1] = (x+1)*y;</div>
<div class="line">        g[1][0] = x*(y+1);</div>
<div class="line">        g[1][1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][0] + g[1][0] + g[0][1] + g[1][1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>hoist_storage can be used together with <a class="el" href="#aa5d784c5fe960c2c0e4c89961b8b71ef">Func::store_at</a> and <a class="el" href="#aa8900f676c8ba7a07181b96977f00d74">Func::fold_storage</a> (for example, to hoist the storage allocated after sliding window optimization). </p>

</div>
</div>
<a id="af5e67f7ad66ec91022f81e26d5875a05" name="af5e67f7ad66ec91022f81e26d5875a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e67f7ad66ec91022f81e26d5875a05">&#9670;&#160;</a></span>hoist_storage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::hoist_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the version of hoist_storage that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain. </p>

</div>
</div>
<a id="ae8900d497f117025455bc81c77f979f2" name="ae8900d497f117025455bc81c77f979f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8900d497f117025455bc81c77f979f2">&#9670;&#160;</a></span>hoist_storage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::hoist_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the version of hoist_storage that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage at a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>

</div>
</div>
<a id="aa9506f5d7199888be026f849b952a355" name="aa9506f5d7199888be026f849b952a355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9506f5d7199888be026f849b952a355">&#9670;&#160;</a></span>hoist_storage_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::hoist_storage_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="#aa9506f5d7199888be026f849b952a355">Func::hoist_storage_root</a>, but schedules storage outside the outermost loop. </p>

</div>
</div>
<a id="ad6136616192c9453749c6b501557ca08" name="ad6136616192c9453749c6b501557ca08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6136616192c9453749c6b501557ca08">&#9670;&#160;</a></span>compute_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::compute_inline </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggressively inline all uses of this function. </p>
<p>This is the default schedule, so you're unlikely to need to call this. For a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with an update definition, that means it gets computed as close to the innermost loop as possible.</p>
<p>Consider once more the pipeline from <a class="el" href="#af4aca8ca6331e64a6fdfd98fccf1757a">Func::compute_at</a> :</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_func.html">Func</a> f, g;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);</div>
</div><!-- fragment --><p>Leaving g as inline, this compiles to code equivalent to the following C:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a34b8c4bece8042e500f838b72ed2b718" name="a34b8c4bece8042e500f838b72ed2b718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b8c4bece8042e500f838b72ed2b718">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> Halide::Func::update </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle on an update step for the purposes of scheduling it. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a11">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00245">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a20b30d5ddaa9d8eeb50122ddb03d80c3" name="a20b30d5ddaa9d8eeb50122ddb03d80c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b30d5ddaa9d8eeb50122ddb03d80c3">&#9670;&#160;</a></span>store_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::store_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a></td>          <td class="paramname"><span class="paramname"><em>memory_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the type of memory this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> should be stored in. </p>
<p>Controls whether allocations go on the stack or the heap on the CPU, and in global vs shared vs local on the GPU. See the documentation on MemoryType for more detail. </p>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a0e9226c8b5e603fc788e33882898aa4f" name="a0e9226c8b5e603fc788e33882898aa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9226c8b5e603fc788e33882898aa4f">&#9670;&#160;</a></span>trace_loads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::trace_loads </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace all loads from this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace. </p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is inlined, this has no effect. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a4">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0e34adc5c6dc2549d4ef28e56e3fac6d" name="a0e34adc5c6dc2549d4ef28e56e3fac6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e34adc5c6dc2549d4ef28e56e3fac6d">&#9670;&#160;</a></span>trace_stores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::trace_stores </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace all stores to the buffer backing this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace. </p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is inlined, this call has no effect. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a2">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a2">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#a2">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a2">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a5">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6aca2015bde5fc377ca1e4612f7c0c97" name="a6aca2015bde5fc377ca1e4612f7c0c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aca2015bde5fc377ca1e4612f7c0c97">&#9670;&#160;</a></span>trace_realizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::trace_realizations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace all realizations of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace. </p>

</div>
</div>
<a id="aba743330df92f4f979cb0cfd7f6c934a" name="aba743330df92f4f979cb0cfd7f6c934a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba743330df92f4f979cb0cfd7f6c934a">&#9670;&#160;</a></span>add_trace_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::add_trace_tag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>trace_tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a string of arbitrary text that will be passed thru to trace inspection code if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is realized in trace mode. </p>
<p>(Funcs that are inlined won't have their tags emitted.) Ignored entirely if tracing is not enabled for the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> (or globally). </p>

</div>
</div>
<a id="aebe98bb08abd1d03ecee62a2d2e0f754" name="aebe98bb08abd1d03ecee62a2d2e0f754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe98bb08abd1d03ecee62a2d2e0f754">&#9670;&#160;</a></span>no_profiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> &amp; Halide::Func::no_profiling </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks this function as a function that should not be profiled when using the target feature Profile or ProfileByTimer. </p>
<p>This is useful when this function is does too little work at once such that the overhead of setting the profiling token might become significant, or that the measured time is not representative due to modern processors (instruction level parallelism, out-of-order execution). </p>

</div>
</div>
<a id="a19e0eb9703d560b2d08965747e26bae7" name="a19e0eb9703d560b2d08965747e26bae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e0eb9703d560b2d08965747e26bae7">&#9670;&#160;</a></span>function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> Halide::Func::function </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle on the internal halide function that this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> represents. </p>
<p>Useful if you want to do introspection on <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02576">2576</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a id="a3f623d418efe24a783d8609d2718ea06" name="a3f623d418efe24a783d8609d2718ea06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f623d418efe24a783d8609d2718ea06">&#9670;&#160;</a></span>operator Stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::operator <a class="el" href="class_halide_1_1_stage.html">Stage</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can cast a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to its pure stage for the purposes of scheduling it. </p>

</div>
</div>
<a id="a9f8a7b45374c9820810ef6a4a9d6740c" name="a9f8a7b45374c9820810ef6a4a9d6740c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8a7b45374c9820810ef6a4a9d6740c">&#9670;&#160;</a></span>output_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a> Halide::Func::output_buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle on the output buffer for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Only relevant if this is the output <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in a pipeline. Useful for making static promises about strides, mins, and extents. </p>

</div>
</div>
<a id="af0fe7a7b21b04d42a6aca24132b4b470" name="af0fe7a7b21b04d42a6aca24132b4b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fe7a7b21b04d42a6aca24132b4b470">&#9670;&#160;</a></span>output_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a> &gt; Halide::Func::output_buffers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a823545aae17330fb3d630bffc1720709" name="a823545aae17330fb3d630bffc1720709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823545aae17330fb3d630bffc1720709">&#9670;&#160;</a></span>operator ExternFuncArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::operator <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> as an argument to an external stage. </p>

</div>
</div>
<a id="aa203357492e584a49694d02372d2c557" name="aa203357492e584a49694d02372d2c557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa203357492e584a49694d02372d2c557">&#9670;&#160;</a></span>infer_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; Halide::Func::infer_arguments </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the arguments to the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, sorted into a canonical order: all buffers (sorted alphabetically by name), followed by all non-buffers (sorted alphabetically by name). </p>
<p>This lets you write things like: </p><div class="fragment"><div class="line">func.compile_to_assembly(<span class="stringliteral">&quot;/dev/stdout&quot;</span>, func.infer_arguments());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af74510055cf3aa69aafca6e1dbb8aa74" name="af74510055cf3aa69aafca6e1dbb8aa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74510055cf3aa69aafca6e1dbb8aa74">&#9670;&#160;</a></span>get_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp; Halide::Func::get_schedule </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current StageSchedule associated with this initial <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a> of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>For introspection only: to modify schedule, use the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> interface. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02608">2608</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00106">Halide::Stage::get_schedule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_func.html">Func</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
