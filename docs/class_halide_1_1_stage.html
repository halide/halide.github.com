<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Stage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_halide_1_1_stage.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_stage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Halide::Stage Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91222724ee6ff9f4d01dcb4f836d7627" id="r_a91222724ee6ff9f4d01dcb4f836d7627"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91222724ee6ff9f4d01dcb4f836d7627">Stage</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> f, <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Internal::Definition</a> d, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> stage_index)</td></tr>
<tr class="separator:a91222724ee6ff9f4d01dcb4f836d7627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f2793f8e9e9fead538e2cde9239d96" id="r_aa2f2793f8e9e9fead538e2cde9239d96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f2793f8e9e9fead538e2cde9239d96">get_schedule</a> () const</td></tr>
<tr class="memdesc:aa2f2793f8e9e9fead538e2cde9239d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current StageSchedule associated with this <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a>.  <br /></td></tr>
<tr class="separator:aa2f2793f8e9e9fead538e2cde9239d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae73b461d876d4d921474d5042dad65" id="r_aeae73b461d876d4d921474d5042dad65"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeae73b461d876d4d921474d5042dad65">dump_argument_list</a> () const</td></tr>
<tr class="memdesc:aeae73b461d876d4d921474d5042dad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing the current var list taking into account all the splits, reorders, and tiles.  <br /></td></tr>
<tr class="separator:aeae73b461d876d4d921474d5042dad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075401098fc0eb3fa260bbb93a21e80b" id="r_a075401098fc0eb3fa260bbb93a21e80b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075401098fc0eb3fa260bbb93a21e80b">name</a> () const</td></tr>
<tr class="memdesc:a075401098fc0eb3fa260bbb93a21e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this stage, e.g.  <br /></td></tr>
<tr class="separator:a075401098fc0eb3fa260bbb93a21e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51279e6a9e09a72445846f28387b0abb" id="r_a51279e6a9e09a72445846f28387b0abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51279e6a9e09a72445846f28387b0abb">rfactor</a> (std::vector&lt; std::pair&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a>, <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &gt; preserved)</td></tr>
<tr class="memdesc:a51279e6a9e09a72445846f28387b0abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling <a class="el" href="#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> on an associative update definition a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> will split the update into an intermediate which computes the partial results and replaces the current update definition with a new definition which merges the partial results.  <br /></td></tr>
<tr class="separator:a51279e6a9e09a72445846f28387b0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad5f03630fb3fd72a3ab0b0563502cc" id="r_a2ad5f03630fb3fd72a3ab0b0563502cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad5f03630fb3fd72a3ab0b0563502cc">rfactor</a> (const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;r, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;v)</td></tr>
<tr class="separator:a2ad5f03630fb3fd72a3ab0b0563502cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd245c66c941885f339c824afd4532e" id="r_a3fd245c66c941885f339c824afd4532e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd245c66c941885f339c824afd4532e">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;align)</td></tr>
<tr class="memdesc:a3fd245c66c941885f339c824afd4532e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the iteration over this stage to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <br /></td></tr>
<tr class="separator:a3fd245c66c941885f339c824afd4532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e81c2dafddd51a486071ad927df0b8" id="r_a98e81c2dafddd51a486071ad927df0b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98e81c2dafddd51a486071ad927df0b8">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:a98e81c2dafddd51a486071ad927df0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d49917ac2e488a72d03a27afce1ce2" id="r_a27d49917ac2e488a72d03a27afce1ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d49917ac2e488a72d03a27afce1ce2">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;align)</td></tr>
<tr class="separator:a27d49917ac2e488a72d03a27afce1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6511739735cff1a0526c6975bf9cf1a" id="r_ab6511739735cff1a0526c6975bf9cf1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6511739735cff1a0526c6975bf9cf1a">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:ab6511739735cff1a0526c6975bf9cf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accee02c7cbd10ed1d9e06d192396d30d" id="r_accee02c7cbd10ed1d9e06d192396d30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accee02c7cbd10ed1d9e06d192396d30d">split</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:accee02c7cbd10ed1d9e06d192396d30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this stage is traversed.  <br /></td></tr>
<tr class="separator:accee02c7cbd10ed1d9e06d192396d30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b373ea2beafa6f44cbda818e7a3259" id="r_aa8b373ea2beafa6f44cbda818e7a3259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b373ea2beafa6f44cbda818e7a3259">fuse</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;fused)</td></tr>
<tr class="separator:aa8b373ea2beafa6f44cbda818e7a3259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34c217376890998bd14d714ae99b828" id="r_aa34c217376890998bd14d714ae99b828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa34c217376890998bd14d714ae99b828">serial</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:aa34c217376890998bd14d714ae99b828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4b238ac563c21c4800a43e59c42733" id="r_a9b4b238ac563c21c4800a43e59c42733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b4b238ac563c21c4800a43e59c42733">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a9b4b238ac563c21c4800a43e59c42733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cddae992bed87a0ee529d6ec4946356" id="r_a2cddae992bed87a0ee529d6ec4946356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cddae992bed87a0ee529d6ec4946356">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a2cddae992bed87a0ee529d6ec4946356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c995abf6a28d50340abfb7c62a7a1" id="r_a3c5c995abf6a28d50340abfb7c62a7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c5c995abf6a28d50340abfb7c62a7a1">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a3c5c995abf6a28d50340abfb7c62a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d47a2c04c3cddad66c69ec44eb2d806" id="r_a5d47a2c04c3cddad66c69ec44eb2d806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d47a2c04c3cddad66c69ec44eb2d806">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;task_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a5d47a2c04c3cddad66c69ec44eb2d806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1a26a58cc5c354ab63992a291aa8ea" id="r_aad1a26a58cc5c354ab63992a291aa8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad1a26a58cc5c354ab63992a291aa8ea">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:aad1a26a58cc5c354ab63992a291aa8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68271b7ea00a77f2472bf296558c20bb" id="r_a68271b7ea00a77f2472bf296558c20bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68271b7ea00a77f2472bf296558c20bb">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a68271b7ea00a77f2472bf296558c20bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ebe43e9a1b2efd8561d72ac2e4d669" id="r_a66ebe43e9a1b2efd8561d72ac2e4d669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66ebe43e9a1b2efd8561d72ac2e4d669">partition</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="namespace_halide.html#af5048e52b474e6d6733ffa66f800b881">Partition</a> partition_policy)</td></tr>
<tr class="separator:a66ebe43e9a1b2efd8561d72ac2e4d669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad308dfedbc58f8ced7fcd717f88f06cb" id="r_ad308dfedbc58f8ced7fcd717f88f06cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad308dfedbc58f8ced7fcd717f88f06cb">never_partition_all</a> ()</td></tr>
<tr class="separator:ad308dfedbc58f8ced7fcd717f88f06cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cbe51b4bbd40551d81d66877a516c" id="r_a344cbe51b4bbd40551d81d66877a516c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a344cbe51b4bbd40551d81d66877a516c">never_partition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="separator:a344cbe51b4bbd40551d81d66877a516c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b1e987416ef84776eae7b03d69e491" id="r_ad2b1e987416ef84776eae7b03d69e491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b1e987416ef84776eae7b03d69e491">always_partition_all</a> ()</td></tr>
<tr class="separator:ad2b1e987416ef84776eae7b03d69e491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513b2b4538ec00ca20d16d59d34f8e4" id="r_af513b2b4538ec00ca20d16d59d34f8e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af513b2b4538ec00ca20d16d59d34f8e4">always_partition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="separator:af513b2b4538ec00ca20d16d59d34f8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac638da06726dd7df2b0969126db5961f" id="r_ac638da06726dd7df2b0969126db5961f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac638da06726dd7df2b0969126db5961f">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:ac638da06726dd7df2b0969126db5961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7e4f046051894423937c1408c18a49" id="r_a5a7e4f046051894423937c1408c18a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a7e4f046051894423937c1408c18a49">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a5a7e4f046051894423937c1408c18a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370980f98758a209673f784ca5b2a2d" id="r_a9370980f98758a209673f784ca5b2a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9370980f98758a209673f784ca5b2a2d">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;tails)</td></tr>
<tr class="separator:a9370980f98758a209673f784ca5b2a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603a0d98a647e0b1349d4a19a06a03c3" id="r_a603a0d98a647e0b1349d4a19a06a03c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a603a0d98a647e0b1349d4a19a06a03c3">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a603a0d98a647e0b1349d4a19a06a03c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af473a0048caa53e3074213ac0c6de" id="r_a10af473a0048caa53e3074213ac0c6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10af473a0048caa53e3074213ac0c6de">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a10af473a0048caa53e3074213ac0c6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9046162bdca77e4e721416ed96a72c" id="r_a8d9046162bdca77e4e721416ed96a72c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d9046162bdca77e4e721416ed96a72c">reorder</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="separator:a8d9046162bdca77e4e721416ed96a72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d83cdc16b5cc0c2c136bfa67c2bd27" id="r_a25d83cdc16b5cc0c2c136bfa67c2bd27"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a25d83cdc16b5cc0c2c136bfa67c2bd27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25d83cdc16b5cc0c2c136bfa67c2bd27">reorder</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a25d83cdc16b5cc0c2c136bfa67c2bd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd7b3ad4b44fc8d461a603ca41315e4" id="r_aacd7b3ad4b44fc8d461a603ca41315e4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aacd7b3ad4b44fc8d461a603ca41315e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacd7b3ad4b44fc8d461a603ca41315e4">never_partition</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, Args &amp;&amp;...args)</td></tr>
<tr class="separator:aacd7b3ad4b44fc8d461a603ca41315e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe643b332bdf54779e4a1ea74382c90e" id="r_abe643b332bdf54779e4a1ea74382c90e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abe643b332bdf54779e4a1ea74382c90e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe643b332bdf54779e4a1ea74382c90e">always_partition</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, Args &amp;&amp;...args)</td></tr>
<tr class="separator:abe643b332bdf54779e4a1ea74382c90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f536a065c94e358c0f7a76a91be631b" id="r_a5f536a065c94e358c0f7a76a91be631b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f536a065c94e358c0f7a76a91be631b">rename</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old_name, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;new_name)</td></tr>
<tr class="separator:a5f536a065c94e358c0f7a76a91be631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8e12da382c2be8cfd512de0b5ddb36" id="r_a7d8e12da382c2be8cfd512de0b5ddb36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d8e12da382c2be8cfd512de0b5ddb36">specialize</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;condition)</td></tr>
<tr class="separator:a7d8e12da382c2be8cfd512de0b5ddb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99d85e44a0ea26a885216a6d722019c" id="r_ab99d85e44a0ea26a885216a6d722019c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab99d85e44a0ea26a885216a6d722019c">specialize_fail</a> (const std::string &amp;message)</td></tr>
<tr class="separator:ab99d85e44a0ea26a885216a6d722019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c747a1009aa40ea9324604baf2598" id="r_ad91c747a1009aa40ea9324604baf2598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91c747a1009aa40ea9324604baf2598">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ad91c747a1009aa40ea9324604baf2598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a104370352936c5d34d1c712d8cda8c" id="r_a1a104370352936c5d34d1c712d8cda8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a104370352936c5d34d1c712d8cda8c">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a1a104370352936c5d34d1c712d8cda8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8810dfadbbdf8d1b4f71b2e325e66511" id="r_a8810dfadbbdf8d1b4f71b2e325e66511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8810dfadbbdf8d1b4f71b2e325e66511">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a8810dfadbbdf8d1b4f71b2e325e66511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b011103b0796641640924e36d7eaae0" id="r_a3b011103b0796641640924e36d7eaae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b011103b0796641640924e36d7eaae0">gpu_lanes</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a3b011103b0796641640924e36d7eaae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fc2971080af50ece652a0db663ad7b" id="r_a64fc2971080af50ece652a0db663ad7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64fc2971080af50ece652a0db663ad7b">gpu_single_thread</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a64fc2971080af50ece652a0db663ad7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60049815a2ac3ca0e7dad45fa8e23bd" id="r_aa60049815a2ac3ca0e7dad45fa8e23bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60049815a2ac3ca0e7dad45fa8e23bd">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aa60049815a2ac3ca0e7dad45fa8e23bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918038fad64179016577205a644265a" id="r_ac918038fad64179016577205a644265a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac918038fad64179016577205a644265a">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ac918038fad64179016577205a644265a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b71e0c23d6dd88902326a6559945d" id="r_a930b71e0c23d6dd88902326a6559945d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a930b71e0c23d6dd88902326a6559945d">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a930b71e0c23d6dd88902326a6559945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef5b5e6d723d96960ac4e07b21f290" id="r_a2bef5b5e6d723d96960ac4e07b21f290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bef5b5e6d723d96960ac4e07b21f290">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a2bef5b5e6d723d96960ac4e07b21f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33939944bd37de9d52cdab4e17a0c5c" id="r_ab33939944bd37de9d52cdab4e17a0c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33939944bd37de9d52cdab4e17a0c5c">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ab33939944bd37de9d52cdab4e17a0c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0e9e1c3d4520b468d2509592712a93" id="r_a8f0e9e1c3d4520b468d2509592712a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f0e9e1c3d4520b468d2509592712a93">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a8f0e9e1c3d4520b468d2509592712a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e326e1af96a1c931c62d616e2c6429" id="r_a46e326e1af96a1c931c62d616e2c6429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e326e1af96a1c931c62d616e2c6429">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a46e326e1af96a1c931c62d616e2c6429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950302fd37d43d2d823db1a95815be2" id="r_a1950302fd37d43d2d823db1a95815be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1950302fd37d43d2d823db1a95815be2">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a1950302fd37d43d2d823db1a95815be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0db59614989f90b3f90aa5cf799b2f" id="r_a0a0db59614989f90b3f90aa5cf799b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a0db59614989f90b3f90aa5cf799b2f">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a0a0db59614989f90b3f90aa5cf799b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2b9c4a421828c5f176b402fe600eb7" id="r_aed2b9c4a421828c5f176b402fe600eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed2b9c4a421828c5f176b402fe600eb7">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aed2b9c4a421828c5f176b402fe600eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd1fb143091ed35baedde0c12f15e79" id="r_aefd1fb143091ed35baedde0c12f15e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefd1fb143091ed35baedde0c12f15e79">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bz, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aefd1fb143091ed35baedde0c12f15e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c8edfbea40ab234e644e3b298245a9" id="r_a44c8edfbea40ab234e644e3b298245a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c8edfbea40ab234e644e3b298245a9">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a44c8edfbea40ab234e644e3b298245a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bfa2520452780b2e3e818b56284da1" id="r_a51bfa2520452780b2e3e818b56284da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51bfa2520452780b2e3e818b56284da1">allow_race_conditions</a> ()</td></tr>
<tr class="separator:a51bfa2520452780b2e3e818b56284da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36ae738190f419d49bff57de1a5ee41" id="r_ad36ae738190f419d49bff57de1a5ee41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad36ae738190f419d49bff57de1a5ee41">atomic</a> (bool override_associativity_test=false)</td></tr>
<tr class="separator:ad36ae738190f419d49bff57de1a5ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ae551fdf75c6c80a89d796814ec18" id="r_aca8ae551fdf75c6c80a89d796814ec18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca8ae551fdf75c6c80a89d796814ec18">hexagon</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x=<a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>())</td></tr>
<tr class="separator:aca8ae551fdf75c6c80a89d796814ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f39c87435d0cb8f614c43fe0b188d5" id="r_a04f39c87435d0cb8f614c43fe0b188d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f39c87435d0cb8f614c43fe0b188d5">prefetch</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a04f39c87435d0cb8f614c43fe0b188d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba567f6866bdadb0e2cf9c67b0df0ce" id="r_a8ba567f6866bdadb0e2cf9c67b0df0ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba567f6866bdadb0e2cf9c67b0df0ce">prefetch</a> (const <a class="el" href="class_halide_1_1_parameter.html">Parameter</a> &amp;param, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a8ba567f6866bdadb0e2cf9c67b0df0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877ee5b5b51d19422b6319f45acc18ae" id="r_a877ee5b5b51d19422b6319f45acc18ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a877ee5b5b51d19422b6319f45acc18ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a877ee5b5b51d19422b6319f45acc18ae">prefetch</a> (const T &amp;image, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a877ee5b5b51d19422b6319f45acc18ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31af040ad702c3fa25208d1615254bd" id="r_af31af040ad702c3fa25208d1615254bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af31af040ad702c3fa25208d1615254bd">unscheduled</a> ()</td></tr>
<tr class="memdesc:af31af040ad702c3fa25208d1615254bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that this stage has intentionally been given no schedule, and suppress the warning about unscheduled update definitions that would otherwise fire.  <br /></td></tr>
<tr class="separator:af31af040ad702c3fa25208d1615254bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>May be a pure or update definition. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00069">69</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91222724ee6ff9f4d01dcb4f836d7627" name="a91222724ee6ff9f4d01dcb4f836d7627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91222724ee6ff9f4d01dcb4f836d7627">&#9670;&#160;</a></span>Stage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Stage::Stage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Internal::Definition</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a></td>          <td class="paramname"><span class="paramname"><em>stage_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00093">93</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a79b6581a7346b5f381f495853efed1f6">Halide::Internal::Definition::args()</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">Halide::Internal::Function::args()</a>, <a class="el" href="class_halide_1_1_internal_1_1_definition.html#add2ca6ed247cf025facda56bd82da44c">Halide::Internal::Definition::defined()</a>, and <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2f2793f8e9e9fead538e2cde9239d96" name="aa2f2793f8e9e9fead538e2cde9239d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f2793f8e9e9fead538e2cde9239d96">&#9670;&#160;</a></span>get_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp; Halide::Stage::get_schedule </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current StageSchedule associated with this <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a>. </p>
<p>For introspection only: to modify schedule, use the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> interface. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00106">106</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_definition.html#ad0cdab27ae97e245c88225078b9e264f">Halide::Internal::Definition::schedule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l02608">Halide::Func::get_schedule()</a>.</p>

</div>
</div>
<a id="aeae73b461d876d4d921474d5042dad65" name="aeae73b461d876d4d921474d5042dad65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae73b461d876d4d921474d5042dad65">&#9670;&#160;</a></span>dump_argument_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::dump_argument_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string describing the current var list taking into account all the splits, reorders, and tiles. </p>

</div>
</div>
<a id="a075401098fc0eb3fa260bbb93a21e80b" name="a075401098fc0eb3fa260bbb93a21e80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075401098fc0eb3fa260bbb93a21e80b">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this stage, e.g. </p>
<p>"f.update(2)" </p>

</div>
</div>
<a id="a51279e6a9e09a72445846f28387b0abb" name="a51279e6a9e09a72445846f28387b0abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51279e6a9e09a72445846f28387b0abb">&#9670;&#160;</a></span>rfactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Stage::rfactor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a>, <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>preserved</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling <a class="el" href="#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> on an associative update definition a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> will split the update into an intermediate which computes the partial results and replaces the current update definition with a new definition which merges the partial results. </p>
<p>If called on a init/pure definition, this will throw an error. <a class="el" href="#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> will automatically infer the associative reduction operator and identity of the operator. If it can't prove the operation is associative or if it cannot find an identity for that operator, this will throw an error. In addition, commutativity of the operator is required if <a class="el" href="#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> is called on the inner dimension but excluding the outer dimensions.</p>
<p><a class="el" href="#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> takes as input 'preserved', which is a list of &lt;<a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>, <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>&gt; pairs. The rvars not listed in 'preserved' are removed from the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and are lifted to the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. The remaining rvars (the ones in 'preserved') are made pure in the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. The intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition inherits all scheduling directives (e.g. split,fuse, etc.) applied to the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition. The loop order of the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition is the same as the original, although the RVars in 'preserved' are replaced by the new pure Vars. The loop order of the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s init definition from innermost to outermost is the args' order of the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s init definition followed by the new pure Vars.</p>
<p>The intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> also inherits storage order from the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with the new pure Vars added to the outermost.</p>
<p>For example, f.update(0).rfactor({{r.y, u}}) would rewrite a pipeline like this: </p><div class="fragment"><div class="line">f(x, y) = 0;</div>
<div class="line">f(x, y) += g(r.x, r.y);</div>
</div><!-- fragment --><p> into a pipeline like this: </p><div class="fragment"><div class="line">f_intm(x, y, u) = 0;</div>
<div class="line">f_intm(x, y, u) += g(r.x, u);</div>
<div class="line"> </div>
<div class="line">f(x, y) = 0;</div>
<div class="line">f(x, y) += f_intm(x, y, r.y);</div>
</div><!-- fragment --><p>This has a variety of uses. You can use it to split computation of an associative reduction: </p><div class="fragment"><div class="line">f(x, y) = 10;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, 96);</div>
<div class="line">f(x, y) = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(x, y), g(x, y, r.x));</div>
<div class="line">f.update(0).split(r.x, rxo, rxi, 8).reorder(y, x).parallel(x);</div>
<div class="line">f.update(0).rfactor({{rxo, u}}).compute_root().parallel(u).update(0).parallel(u);</div>
<div class="ttc" id="aclass_halide_1_1_r_dom_html"><div class="ttname"><a href="class_halide_1_1_r_dom.html">Halide::RDom</a></div><div class="ttdoc">A multi-dimensional domain over which to iterate.</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00193">RDom.h:193</a></div></div>
<div class="ttc" id="anamespace_halide_html_aea2c7f5fe6c79a49dcbb28951cf8405d"><div class="ttname"><a href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">Halide::max</a></div><div class="ttdeci">Expr max(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdef"><b>Definition</b> <a href="_func_8h_source.html#l00600">Func.h:600</a></div></div>
</div><!-- fragment --><p>, which is equivalent to: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> u = 0 to 11:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <span class="keywordflow">for</span> x:</div>
<div class="line">      f_intm(x, y, u) = -inf</div>
<div class="line"><a class="code hl_function" href="#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> x:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <a class="code hl_function" href="#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> u = 0 to 11:</div>
<div class="line">      <span class="keywordflow">for</span> rxi = 0 to 7:</div>
<div class="line">        f_intm(x, y, u) = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_intm(x, y, u), g(8*u + rxi))</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    f(x, y) = 10</div>
<div class="line"><a class="code hl_function" href="#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> x:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <span class="keywordflow">for</span> rxo = 0 to 11:</div>
<div class="line">      f(x, y) = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(x, y), f_intm(x, y, rxo))</div>
<div class="ttc" id="aclass_halide_1_1_stage_html_a9b4b238ac563c21c4800a43e59c42733"><div class="ttname"><a href="#a9b4b238ac563c21c4800a43e59c42733">Halide::Stage::parallel</a></div><div class="ttdeci">Stage &amp; parallel(const VarOrRVar &amp;var)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ad5f03630fb3fd72a3ab0b0563502cc" name="a2ad5f03630fb3fd72a3ab0b0563502cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad5f03630fb3fd72a3ab0b0563502cc">&#9670;&#160;</a></span>rfactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Stage::rfactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fd245c66c941885f339c824afd4532e" name="a3fd245c66c941885f339c824afd4532e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd245c66c941885f339c824afd4532e">&#9670;&#160;</a></span>compute_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>align</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the iteration over this stage to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>
<p>'this' stage will be computed AFTER 's' in the innermost fused dimension. There should not be any dependencies between those two fused stages. If either of the stages being fused is a stage of an extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, this will throw an error.</p>
<p>Note that the two stages that are fused together should have the same exact schedule from the outermost to the innermost fused dimension, and the stage we are calling compute_with on should not have specializations, e.g. f2.compute_with(f1, x) is allowed only if f2 has no specializations.</p>
<p>Also, if a producer is desired to be computed at the fused loop level, the function passed to the compute_at() needs to be the "parent". Consider the following code: </p><div class="fragment"><div class="line">input(x, y) = x + y;</div>
<div class="line">f(x, y) = input(x, y);</div>
<div class="line">f(x, y) += 5;</div>
<div class="line">g(x, y) = x - y;</div>
<div class="line">g(x, y) += 10;</div>
<div class="line">f.compute_with(g, y);</div>
<div class="line">f.update().compute_with(g.update(), y);</div>
</div><!-- fragment --><p>To compute 'input' at the fused loop level at dimension y, we specify input.compute_at(g, y) instead of input.compute_at(f, y) since 'g' is the "parent" for this fused loop (i.e. 'g' is computed first before 'f' is computed). On the other hand, to compute 'input' at the innermost dimension of 'f', we specify input.compute_at(f, x) instead of input.compute_at(g, x) since the x dimension of 'f' is not fused (only the y dimension is).</p>
<p>Given the constraints, this has a variety of uses. Consider the following code: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">g(x, y) = x - y;</div>
<div class="line">h(x, y) = f(x, y) + g(x, y);</div>
<div class="line">f.compute_root();</div>
<div class="line">g.compute_root();</div>
<div class="line">f.split(x, xo, xi, 8);</div>
<div class="line">g.split(x, xo, xi, 8);</div>
<div class="line">g.compute_with(f, xo);</div>
</div><!-- fragment --><p>This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> xo:</div>
<div class="line">    <span class="keywordflow">for</span> xi:</div>
<div class="line">      f(8*xo + xi) = (8*xo + xi) + y</div>
<div class="line">    <span class="keywordflow">for</span> xi:</div>
<div class="line">      g(8*xo + xi) = (8*xo + xi) - y</div>
<div class="line">for y:</div>
<div class="line">  for x:</div>
<div class="line">    h(x, y) = f(x, y) + g(x, y)</div>
</div><!-- fragment --><p>The size of the dimensions of the stages computed_with do not have to match. Consider the following code where 'g' is half the size of 'f': </p><div class="fragment"><div class="line">Image&lt;int&gt; f_im(size, size), g_im(size/2, size/2);</div>
<div class="line">input(x, y) = x + y;</div>
<div class="line">f(x, y) = input(x, y);</div>
<div class="line">g(x, y) = input(2*x, 2*y);</div>
<div class="line">g.compute_with(f, y);</div>
<div class="line">input.compute_at(f, y);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_pipeline.html">Pipeline</a>({f, g}).realize({f_im, g_im});</div>
<div class="ttc" id="aclass_halide_1_1_pipeline_html"><div class="ttname"><a href="class_halide_1_1_pipeline.html">Halide::Pipeline</a></div><div class="ttdoc">A class representing a Halide pipeline.</div><div class="ttdef"><b>Definition</b> <a href="_pipeline_8h_source.html#l00107">Pipeline.h:107</a></div></div>
</div><!-- fragment --><p>This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y = 0 to size-1:</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size-1:</div>
<div class="line">    input(x, y) = x + y;</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size-1:</div>
<div class="line">    f(x, y) = input(x, y)</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size/2-1:</div>
<div class="line">    <span class="keywordflow">if</span> (y &lt; size/2-1):</div>
<div class="line">      g(x, y) = input(2*x, 2*y)</div>
</div><!-- fragment --><p>'align' specifies how the loop iteration of each dimension of the two stages being fused should be aligned in the fused loop nests (see LoopAlignStrategy for options). Consider the following loop nests: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> z = f_min_z to f_max_z:</div>
<div class="line">  <span class="keywordflow">for</span> y = f_min_y to f_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = f_min_x to f_max_x:</div>
<div class="line">      f(x, y, z) = x + y + z</div>
<div class="line"><span class="keywordflow">for</span> z = g_min_z to g_max_z:</div>
<div class="line">  <span class="keywordflow">for</span> y = g_min_y to g_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = g_min_x to g_max_x:</div>
<div class="line">      g(x, y, z) = x - y - z</div>
</div><!-- fragment --><p>If no alignment strategy is specified, the following loop nest will be generated: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> z = <a class="code hl_function" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_z, g_min_z) to <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_z, g_max_z):</div>
<div class="line">  for y = min(f_min_y, g_min_y) to max(f_max_y, g_max_y):</div>
<div class="line">    for x = f_min_x to f_max_x:</div>
<div class="line">      if (f_min_z &lt;= z &lt;= f_max_z):</div>
<div class="line">        if (f_min_y &lt;= y &lt;= f_max_y):</div>
<div class="line">          f(x, y, z) = x + y + z</div>
<div class="line">    for x = g_min_x to g_max_x:</div>
<div class="line">      if (g_min_z &lt;= z &lt;= g_max_z):</div>
<div class="line">        if (g_min_y &lt;= y &lt;= g_max_y):</div>
<div class="line">          g(x, y, z) = x - y - z</div>
<div class="ttc" id="anamespace_halide_html_a842daf6fbd0f87ec9ea8336cb0cdd23e"><div class="ttname"><a href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">Halide::min</a></div><div class="ttdeci">Expr min(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdoc">Explicit overloads of min and max for FuncRef.</div><div class="ttdef"><b>Definition</b> <a href="_func_8h_source.html#l00597">Func.h:597</a></div></div>
</div><!-- fragment --><p>Instead, these alignment strategies: </p><div class="fragment"><div class="line">g.compute_with(f, y, {{z, <a class="code hl_enumvalue" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">LoopAlignStrategy::AlignStart</a>}, {y, <a class="code hl_enumvalue" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">LoopAlignStrategy::AlignEnd</a>}});</div>
<div class="ttc" id="anamespace_halide_html_a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af"><div class="ttname"><a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">Halide::LoopAlignStrategy::AlignEnd</a></div><div class="ttdeci">@ AlignEnd</div><div class="ttdoc">Shift the end of the fused loops to align.</div></div>
<div class="ttc" id="anamespace_halide_html_a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b"><div class="ttname"><a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">Halide::LoopAlignStrategy::AlignStart</a></div><div class="ttdeci">@ AlignStart</div><div class="ttdoc">Shift the start of the fused loops to align.</div></div>
</div><!-- fragment --><p> will produce the following loop nest: </p><div class="fragment"><div class="line">f_loop_min_z = f_min_z</div>
<div class="line">f_loop_max_z = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_z, (f_min_z - g_min_z) + g_max_z)</div>
<div class="line"><span class="keywordflow">for</span> z = f_min_z to f_loop_max_z:</div>
<div class="line">  f_loop_min_y = <a class="code hl_function" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_y, (f_max_y - g_max_y) + g_min_y)</div>
<div class="line">  f_loop_max_y = f_max_y</div>
<div class="line">  <span class="keywordflow">for</span> y = f_loop_min_y to f_loop_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = f_min_x to f_max_x:</div>
<div class="line">      <span class="keywordflow">if</span> (f_loop_min_z &lt;= z &lt;= f_loop_max_z):</div>
<div class="line">        <span class="keywordflow">if</span> (f_loop_min_y &lt;= y &lt;= f_loop_max_y):</div>
<div class="line">          f(x, y, z) = x + y + z</div>
<div class="line">    <span class="keywordflow">for</span> x = g_min_x to g_max_x:</div>
<div class="line">      g_shift_z = g_min_z - f_loop_min_z</div>
<div class="line">      g_shift_y = g_max_y - f_loop_max_y</div>
<div class="line">      <span class="keywordflow">if</span> (g_min_z &lt;= (z + g_shift_z) &lt;= g_max_z):</div>
<div class="line">        <span class="keywordflow">if</span> (g_min_y &lt;= (y + g_shift_y) &lt;= g_max_y):</div>
<div class="line">          g(x, y + g_shift_y, z + g_shift_z) = x - (y + g_shift_y) - (z + g_shift_z)</div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b" title="Shift the start of the fused loops to align.">LoopAlignStrategy::AlignStart</a> on dimension z will shift the loop iteration of 'g' at dimension z so that its starting value matches that of 'f'. Likewise, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af" title="Shift the end of the fused loops to align.">LoopAlignStrategy::AlignEnd</a> on dimension y will shift the loop iteration of 'g' at dimension y so that its end value matches that of 'f'. </p>

</div>
</div>
<a id="a98e81c2dafddd51a486071ad927df0b8" name="a98e81c2dafddd51a486071ad927df0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e81c2dafddd51a486071ad927df0b8">&#9670;&#160;</a></span>compute_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>loop_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a></td>          <td class="paramname"><span class="paramname"><em>align</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27d49917ac2e488a72d03a27afce1ce2" name="a27d49917ac2e488a72d03a27afce1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d49917ac2e488a72d03a27afce1ce2">&#9670;&#160;</a></span>compute_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>align</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6511739735cff1a0526c6975bf9cf1a" name="ab6511739735cff1a0526c6975bf9cf1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6511739735cff1a0526c6975bf9cf1a">&#9670;&#160;</a></span>compute_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a></td>          <td class="paramname"><span class="paramname"><em>align</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accee02c7cbd10ed1d9e06d192396d30d" name="accee02c7cbd10ed1d9e06d192396d30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accee02c7cbd10ed1d9e06d192396d30d">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this stage is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> for the meanings. </p>

</div>
</div>
<a id="aa8b373ea2beafa6f44cbda818e7a3259" name="aa8b373ea2beafa6f44cbda818e7a3259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b373ea2beafa6f44cbda818e7a3259">&#9670;&#160;</a></span>fuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fused</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa34c217376890998bd14d714ae99b828" name="aa34c217376890998bd14d714ae99b828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34c217376890998bd14d714ae99b828">&#9670;&#160;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b4b238ac563c21c4800a43e59c42733" name="a9b4b238ac563c21c4800a43e59c42733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4b238ac563c21c4800a43e59c42733">&#9670;&#160;</a></span>parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a2cddae992bed87a0ee529d6ec4946356" name="a2cddae992bed87a0ee529d6ec4946356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cddae992bed87a0ee529d6ec4946356">&#9670;&#160;</a></span>vectorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a12">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="anderson2021_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a3c5c995abf6a28d50340abfb7c62a7a1" name="a3c5c995abf6a28d50340abfb7c62a7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5c995abf6a28d50340abfb7c62a7a1">&#9670;&#160;</a></span>unroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="anderson2021_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a5d47a2c04c3cddad66c69ec44eb2d806" name="a5d47a2c04c3cddad66c69ec44eb2d806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d47a2c04c3cddad66c69ec44eb2d806">&#9670;&#160;</a></span>parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>task_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad1a26a58cc5c354ab63992a291aa8ea" name="aad1a26a58cc5c354ab63992a291aa8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1a26a58cc5c354ab63992a291aa8ea">&#9670;&#160;</a></span>vectorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68271b7ea00a77f2472bf296558c20bb" name="a68271b7ea00a77f2472bf296558c20bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68271b7ea00a77f2472bf296558c20bb">&#9670;&#160;</a></span>unroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66ebe43e9a1b2efd8561d72ac2e4d669" name="a66ebe43e9a1b2efd8561d72ac2e4d669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ebe43e9a1b2efd8561d72ac2e4d669">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#af5048e52b474e6d6733ffa66f800b881">Partition</a></td>          <td class="paramname"><span class="paramname"><em>partition_policy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad308dfedbc58f8ced7fcd717f88f06cb" name="ad308dfedbc58f8ced7fcd717f88f06cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad308dfedbc58f8ced7fcd717f88f06cb">&#9670;&#160;</a></span>never_partition_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::never_partition_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a344cbe51b4bbd40551d81d66877a516c" name="a344cbe51b4bbd40551d81d66877a516c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344cbe51b4bbd40551d81d66877a516c">&#9670;&#160;</a></span>never_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::never_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00390">never_partition()</a>.</p>

</div>
</div>
<a id="ad2b1e987416ef84776eae7b03d69e491" name="ad2b1e987416ef84776eae7b03d69e491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b1e987416ef84776eae7b03d69e491">&#9670;&#160;</a></span>always_partition_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::always_partition_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af513b2b4538ec00ca20d16d59d34f8e4" name="af513b2b4538ec00ca20d16d59d34f8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af513b2b4538ec00ca20d16d59d34f8e4">&#9670;&#160;</a></span>always_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::always_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00397">always_partition()</a>.</p>

</div>
</div>
<a id="ac638da06726dd7df2b0969126db5961f" name="ac638da06726dd7df2b0969126db5961f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac638da06726dd7df2b0969126db5961f">&#9670;&#160;</a></span>tile() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a7e4f046051894423937c1408c18a49" name="a5a7e4f046051894423937c1408c18a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7e4f046051894423937c1408c18a49">&#9670;&#160;</a></span>tile() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>yfactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9370980f98758a209673f784ca5b2a2d" name="a9370980f98758a209673f784ca5b2a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370980f98758a209673f784ca5b2a2d">&#9670;&#160;</a></span>tile() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a603a0d98a647e0b1349d4a19a06a03c3" name="a603a0d98a647e0b1349d4a19a06a03c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603a0d98a647e0b1349d4a19a06a03c3">&#9670;&#160;</a></span>tile() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10af473a0048caa53e3074213ac0c6de" name="a10af473a0048caa53e3074213ac0c6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10af473a0048caa53e3074213ac0c6de">&#9670;&#160;</a></span>tile() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d9046162bdca77e4e721416ed96a72c" name="a8d9046162bdca77e4e721416ed96a72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9046162bdca77e4e721416ed96a72c">&#9670;&#160;</a></span>reorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="adams2019_2cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l00383">reorder()</a>.</p>

</div>
</div>
<a id="a25d83cdc16b5cc0c2c136bfa67c2bd27" name="a25d83cdc16b5cc0c2c136bfa67c2bd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d83cdc16b5cc0c2c136bfa67c2bd27">&#9670;&#160;</a></span>reorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type Halide::Stage::reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00383">383</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a8d9046162bdca77e4e721416ed96a72c">reorder()</a>.</p>

</div>
</div>
<a id="aacd7b3ad4b44fc8d461a603ca41315e4" name="aacd7b3ad4b44fc8d461a603ca41315e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd7b3ad4b44fc8d461a603ca41315e4">&#9670;&#160;</a></span>never_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type Halide::Stage::never_partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00390">390</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a344cbe51b4bbd40551d81d66877a516c">never_partition()</a>.</p>

</div>
</div>
<a id="abe643b332bdf54779e4a1ea74382c90e" name="abe643b332bdf54779e4a1ea74382c90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe643b332bdf54779e4a1ea74382c90e">&#9670;&#160;</a></span>always_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type Halide::Stage::always_partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00397">397</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#af513b2b4538ec00ca20d16d59d34f8e4">always_partition()</a>.</p>

</div>
</div>
<a id="a5f536a065c94e358c0f7a76a91be631b" name="a5f536a065c94e358c0f7a76a91be631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f536a065c94e358c0f7a76a91be631b">&#9670;&#160;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>old_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>new_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d8e12da382c2be8cfd512de0b5ddb36" name="a7d8e12da382c2be8cfd512de0b5ddb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8e12da382c2be8cfd512de0b5ddb36">&#9670;&#160;</a></span>specialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> Halide::Stage::specialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>condition</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab99d85e44a0ea26a885216a6d722019c" name="ab99d85e44a0ea26a885216a6d722019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99d85e44a0ea26a885216a6d722019c">&#9670;&#160;</a></span>specialize_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Stage::specialize_fail </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad91c747a1009aa40ea9324604baf2598" name="ad91c747a1009aa40ea9324604baf2598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c747a1009aa40ea9324604baf2598">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a104370352936c5d34d1c712d8cda8c" name="a1a104370352936c5d34d1c712d8cda8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a104370352936c5d34d1c712d8cda8c">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8810dfadbbdf8d1b4f71b2e325e66511" name="a8810dfadbbdf8d1b4f71b2e325e66511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8810dfadbbdf8d1b4f71b2e325e66511">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b011103b0796641640924e36d7eaae0" name="a3b011103b0796641640924e36d7eaae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b011103b0796641640924e36d7eaae0">&#9670;&#160;</a></span>gpu_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64fc2971080af50ece652a0db663ad7b" name="a64fc2971080af50ece652a0db663ad7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fc2971080af50ece652a0db663ad7b">&#9670;&#160;</a></span>gpu_single_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_single_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa60049815a2ac3ca0e7dad45fa8e23bd" name="aa60049815a2ac3ca0e7dad45fa8e23bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60049815a2ac3ca0e7dad45fa8e23bd">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac918038fad64179016577205a644265a" name="ac918038fad64179016577205a644265a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918038fad64179016577205a644265a">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a930b71e0c23d6dd88902326a6559945d" name="a930b71e0c23d6dd88902326a6559945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930b71e0c23d6dd88902326a6559945d">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bef5b5e6d723d96960ac4e07b21f290" name="a2bef5b5e6d723d96960ac4e07b21f290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bef5b5e6d723d96960ac4e07b21f290">&#9670;&#160;</a></span>gpu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab33939944bd37de9d52cdab4e17a0c5c" name="ab33939944bd37de9d52cdab4e17a0c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33939944bd37de9d52cdab4e17a0c5c">&#9670;&#160;</a></span>gpu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0e9e1c3d4520b468d2509592712a93" name="a8f0e9e1c3d4520b468d2509592712a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0e9e1c3d4520b468d2509592712a93">&#9670;&#160;</a></span>gpu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46e326e1af96a1c931c62d616e2c6429" name="a46e326e1af96a1c931c62d616e2c6429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e326e1af96a1c931c62d616e2c6429">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1950302fd37d43d2d823db1a95815be2" name="a1950302fd37d43d2d823db1a95815be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1950302fd37d43d2d823db1a95815be2">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a0db59614989f90b3f90aa5cf799b2f" name="a0a0db59614989f90b3f90aa5cf799b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0db59614989f90b3f90aa5cf799b2f">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>by</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed2b9c4a421828c5f176b402fe600eb7" name="aed2b9c4a421828c5f176b402fe600eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2b9c4a421828c5f176b402fe600eb7">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefd1fb143091ed35baedde0c12f15e79" name="aefd1fb143091ed35baedde0c12f15e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd1fb143091ed35baedde0c12f15e79">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>by</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c8edfbea40ab234e644e3b298245a9" name="a44c8edfbea40ab234e644e3b298245a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c8edfbea40ab234e644e3b298245a9">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a></td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51bfa2520452780b2e3e818b56284da1" name="a51bfa2520452780b2e3e818b56284da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bfa2520452780b2e3e818b56284da1">&#9670;&#160;</a></span>allow_race_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::allow_race_conditions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad36ae738190f419d49bff57de1a5ee41" name="ad36ae738190f419d49bff57de1a5ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36ae738190f419d49bff57de1a5ee41">&#9670;&#160;</a></span>atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::atomic </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>override_associativity_test</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca8ae551fdf75c6c80a89d796814ec18" name="aca8ae551fdf75c6c80a89d796814ec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8ae551fdf75c6c80a89d796814ec18">&#9670;&#160;</a></span>hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::hexagon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04f39c87435d0cb8f614c43fe0b188d5" name="a04f39c87435d0cb8f614c43fe0b188d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f39c87435d0cb8f614c43fe0b188d5">&#9670;&#160;</a></span>prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00468">prefetch()</a>.</p>

</div>
</div>
<a id="a8ba567f6866bdadb0e2cf9c67b0df0ce" name="a8ba567f6866bdadb0e2cf9c67b0df0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba567f6866bdadb0e2cf9c67b0df0ce">&#9670;&#160;</a></span>prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_parameter.html">Parameter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a877ee5b5b51d19422b6319f45acc18ae" name="a877ee5b5b51d19422b6319f45acc18ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877ee5b5b51d19422b6319f45acc18ae">&#9670;&#160;</a></span>prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>image</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00468">468</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a04f39c87435d0cb8f614c43fe0b188d5">prefetch()</a>.</p>

</div>
</div>
<a id="af31af040ad702c3fa25208d1615254bd" name="af31af040ad702c3fa25208d1615254bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31af040ad702c3fa25208d1615254bd">&#9670;&#160;</a></span>unscheduled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Stage::unscheduled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that this stage has intentionally been given no schedule, and suppress the warning about unscheduled update definitions that would otherwise fire. </p>
<p>This counts as a schedule, so calling this twice on the same <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a> will fail the assertion. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_stage.html">Stage</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
