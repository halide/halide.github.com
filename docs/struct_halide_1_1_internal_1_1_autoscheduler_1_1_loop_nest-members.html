<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Member List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Halide::Internal::Autoscheduler::LoopNest Member List</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the complete list of members for <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a>, including all inherited members.</p>
<table class="directory">
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a6006fced11249a63ebf64feb92f93ed7">accesses_input_buffer</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a6006fced11249a63ebf64feb92f93ed7">accesses_input_buffer</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aeff788e06ad2cb18322442c1c8228221">add_gpu_thread_tilings</a>(const FunctionDAG::Node *f, const Anderson2021Params &amp;params, const Target &amp;target, int v, vector&lt; IntrusivePtr&lt; const LoopNest &gt;&gt; &amp;result, const vector&lt; int64_t &gt; &amp;max_size)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a68fb9c6fa101fe66bf7314e7bfc65220">all_paths_to_leaves_have_thread_loop</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a316d77e23131bb55355e211cd47bbf3d">all_strides_exist</a>(const LoadJacobian &amp;jac, const FunctionDAG::Node *storage_node, const LoopNest &amp;root) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a14c44debf50dcd635595befee452f1b5">apply</a>(LoopLevel here, StageMap&lt; std::unique_ptr&lt; StageScheduleState &gt;&gt; &amp;state_map, double num_cores, int depth, const LoopNest *parent, const LoopNest *compute_site) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a4c27cd93245af1c7235595ba4704664d">apply</a>(LoopLevel here, StageMap&lt; std::unique_ptr&lt; StageScheduleState &gt;&gt; &amp;state_map, double num_cores, int depth, const LoopNest *parent, const LoopNest *compute_site, const Target &amp;target, std::vector&lt; StageScheduleState * &gt; &amp;ancestors, const NodeMap&lt; bool &gt; &amp;all_inlined) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac14b1dcccf2d067391be02f4306b2c97">bounds</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ace9956684575ca9b6fa66e07a4d66683">calls</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ace9956684575ca9b6fa66e07a4d66683">calls</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad74cf9acca55831316de26c9dd83398f">can_vectorize_access_for_innermost_dim</a>(const LoadJacobian &amp;jac, const FunctionDAG::Node *accessed, int innermost_dim, int loop_index) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#add9ecef6f243eb84b7de26d060d8ace9">can_vectorize_store_access</a>(const LoadJacobian &amp;jac, const FunctionDAG::Node *accessed, bool accessed_has_been_scheduled, int innermost_dim, int loop_index, const GPUMemoryType &amp;mem_type) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a95a1081e0362927e821532d09c492ffc">children</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#adf750fc8ea75db7220e9fdc6a6ddc0c3">children</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aa3ce33be4ac6505cf3cf84a1905f67cc">collect_all_inlined</a>(NodeMap&lt; bool &gt; &amp;all_inlined) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a7a00676947afac86b2374c2736275bb7">collect_nodes_that_should_be_inlined</a>(const NodeMap&lt; bool &gt; &amp;nodes_to_freeze, NodeMap&lt; bool &gt; &amp;inlined_nodes) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad168ae6255dd9ca106872f3713e2483c">collect_producers</a>(const StageMap&lt; Sites &gt; &amp;sites) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#afa8f0b390e61be4957ec6710e1304a7e">collect_producers</a>(const StageMap&lt; Sites &gt; &amp;sites) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a5c413022bf18c1383c94f236d77dff6a">collect_stages</a>(std::set&lt; const FunctionDAG::Node::Stage * &gt; &amp;stages) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a5c413022bf18c1383c94f236d77dff6a">collect_stages</a>(std::set&lt; const FunctionDAG::Node::Stage * &gt; &amp;stages) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a41fbea1db709effd7e7a9e37ba929d72">compute_alloc_size_of_node_here</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a682611abef2d38fa0b2a5e0184572df1">compute_features</a>(const FunctionDAG &amp;dag, const Adams2019Params &amp;params, const StageMap&lt; Sites &gt; &amp;sites, int64_t instances, int64_t parallelism, const LoopNest *parent, const LoopNest *grandparent, const LoopNest &amp;root, int64_t *working_set, StageMap&lt; ScheduleFeatures &gt; *features, bool use_cached_features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#acbd241530c06f439b697e6e0c6a48fef">compute_features</a>(const FunctionDAG &amp;dag, const Anderson2021Params &amp;params, const Target &amp;target, const StageMap&lt; Sites &gt; &amp;sites, int64_t instances, int64_t parallelism, const LoopNest *parent, const LoopNest *grandparent, const LoopNest &amp;root, GPULoopInfo gpu_loop_info, bool use_memoized_features, const StageMap&lt; int64_t &gt; &amp;total_shared_mem_alloc_sizes, int64_t *working_set, int64_t *working_set_local_constant, int64_t *working_set_local_dynamic, StageMap&lt; ScheduleFeatures &gt; *features, Statistics &amp;stats, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a4981aed1ccfc3fabef7ebe005d40d533">compute_gpu_store_features</a>(const LoadJacobian &amp;jac, int consumer_innermost_dim, const FunctionDAG::Node *node, const Bound &amp;consumer_store_bounds, const GPULoopInfo &amp;gpu_loop_info, const std::vector&lt; int64_t &gt; &amp;inner_serial_loop_extents, const Sites &amp;consumer_site, ScheduleFeatures &amp;feat, const LoopNest *parent, const LoopNest &amp;root, GlobalMemInfo &amp;global_mem_loads, SharedMemInfo &amp;shared_mem_loads, LocalMemInfo &amp;local_mem_loads, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac2409ae36da8ad0bdda29923e879886c">compute_hash_of_producers_stored_at_root</a>(const StageMap&lt; Sites &gt; &amp;sites) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac2409ae36da8ad0bdda29923e879886c">compute_hash_of_producers_stored_at_root</a>(const StageMap&lt; Sites &gt; &amp;sites) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#acd757a3299ce06b58ce8ca83e2ddbaf0">compute_here</a>(const FunctionDAG::Node *f, bool tileable, int v, const Adams2019Params &amp;params)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#af60d69c2598848b6e2dd6a14f1559659">compute_here</a>(const FunctionDAG::Node *f, bool tileable, int v, bool in_threads_loop, const Anderson2021Params &amp;params, const Target &amp;target)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ab85f3ad4299a824d0c9b3832d1351a33">compute_in_tiles</a>(const FunctionDAG::Node *f, const LoopNest *parent, const Adams2019Params &amp;params, int v, bool in_realization) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac1af369020de7a9bf93a38711002abd4">compute_in_tiles</a>(const FunctionDAG::Node *f, const LoopNest *parent, const Anderson2021Params &amp;params, const Target &amp;target, const SearchSpaceOptions &amp;search_space_options, int v, bool in_realization, bool in_threads_loop, bool is_pre_pass, vector&lt; int64_t &gt; union_counts=vector&lt; int64_t &gt;()) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a4f1bca64273a1c2f7a5128c31f8d776a">compute_licm_amortization</a>(const LoopNest *innermost, const LoopNest *parent, const ScheduleFeatures &amp;feat, const LoadJacobian &amp;jac, int producer_dims) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad9d887a66141f415273be58929a3dc66">compute_local_mem_store_features</a>(const LoadJacobian &amp;jac, int consumer_innermost_dim, const FunctionDAG::Node *node, const Bound &amp;consumer_store_bounds, const LoopNest &amp;root, double serial_loop_extents) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aa04c6e944adc1d2f6568bf4c7c24e5a4">compute_local_mem_stride</a>(double stride, double bytes) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a4be4d6de358920eb503a204d9e1b7f89">compute_mem_load_features</a>(const LoadJacobian &amp;jac, int producer_innermost_dim, const FunctionDAG::Node *node, const Bound &amp;producer_store_bounds, bool producer_has_been_scheduled, const ThreadInfo &amp;thread_info, MemInfoType&lt; T &gt; &amp;mem_info, double serial_loop_extents, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a2e0dc51c0e857cf168fca0b48529f28b">compute_mem_store_info</a>(const LoadJacobian &amp;jac, int consumer_innermost_dim, const FunctionDAG::Node *node, const Bound &amp;consumer_store_bounds, const ThreadInfo &amp;thread_info, double serial_loop_extents, bool verbose) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a481dc335864d242a924f5a8351df325b">compute_num_mem_accesses_per_block</a>(const LoadJacobian &amp;jac, const FunctionDAG::Node *node, const Bound &amp;store_bounds, const ThreadInfo &amp;thread_info, int innermost_dim, double num_requests_per_warp, MemInfoType&lt; T &gt; &amp;mem_info, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a83e9c3947b5314f4ee2d087aaaf485eb">compute_shared_mem_occupancy</a>(const Anderson2021Params &amp;params, const Target &amp;target, int64_t total_shared_mem_alloc_size, ScheduleFeatures &amp;feat) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aa43f54bc541a5bb419b457be57fcb28a">compute_strides</a>(const LoadJacobian &amp;jac, int innermost_storage_dim, const FunctionDAG::Node *storage_node, const Bound &amp;store_bounds, const ThreadInfo &amp;thread_info, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a6f537b8dff50dbcb84fb03f9c312b185">compute_warp_and_block_occupancy</a>(const Anderson2021Params &amp;params, ScheduleFeatures &amp;feat, const GPULoopInfo &amp;gpu_loop_info) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae2a8cc55353bc2f86bd68f94fc8d7b36">compute_warp_features</a>(ScheduleFeatures &amp;features, const GPULoopInfo &amp;gpu_loop_info) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#afd1db0a086a53162594fdd921f6bd089">compute_working_set_from_features</a>(int64_t *working_set, const StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#afd1db0a086a53162594fdd921f6bd089">compute_working_set_from_features</a>(int64_t *working_set, const StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a8b3efad3daf1cb27a5cb4bec6a6d36c6">computes</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a8b3efad3daf1cb27a5cb4bec6a6d36c6">computes</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a9891c9a1e72e40f6f019d6f55dad7fba">copy_from</a>(const LoopNest &amp;n)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a9891c9a1e72e40f6f019d6f55dad7fba">copy_from</a>(const LoopNest &amp;n)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad643decc0e25f098daef58f5e0c9b31f">copy_from_including_features</a>(const LoopNest &amp;n)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad643decc0e25f098daef58f5e0c9b31f">copy_from_including_features</a>(const LoopNest &amp;n)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ab8c1b1dafa34df1b0b7224cba4b51671">dump</a>(std::ostream &amp;os, string prefix, const LoopNest *parent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#addbc3337efa1e23b13ce51456bdf9927">dump</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a290e390e7fb6b77bb003dbd6e1a7041e">dump</a>(T &amp;stream, string prefix, const LoopNest *parent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a54e320dc1f0154f77d144e5308baeb57">exceeds_serial_extents_limit</a>(const Target &amp;target, const LoopNest *parent, bool in_threads_loop) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a80f051ddbddd686d87c59dec742ffcf1">feature_intermediates</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#af14ca27d131bf6cec47ac8677f294f1f">feature_intermediates_cache</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1b6e98505d41561dd26dc62a4871a40e">features</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a877515df2909b8ce495cf7109cc1afcf">features_cache</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a352b2498efffcf9c780bcb8d2686a291">find_innermost_and_parent</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#affcc95a09b01bba792fd98f92eaa63de">find_pure_stage_loop_nest</a>(const FunctionDAG::Node *node) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae4ae3127de5ab1b893c399ddf68ef9f7">funcs_realized_or_inlined</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae4ae3127de5ab1b893c399ddf68ef9f7">funcs_realized_or_inlined</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a37607b296331f08ff70a2c9907676435">generate_vec_dim_serial_tilings</a>(vector&lt; int &gt; &amp;serial_sizes) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a815d18005c10e4d74d46623206724ed3">get_actual_vector_dim</a>(const Bound &amp;store_bounds) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae269e79f08d91abbe1880dfffd1dab42">get_allocs_that_can_be_promoted_to_registers</a>(const Target &amp;target, StageMap&lt; Sites &gt; &amp;sites, NodeMap&lt; bool &gt; &amp;can_be_promoted_to_registers, const LoopNest *grandparent, const LoopNest *parent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#add358fadb6a40974bd40ece7935c2ee0">get_block_and_serial_extents</a>(const LoopNest *block) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad900f5c78c3f0463ca47b15fc068e3ea">get_bounds</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad900f5c78c3f0463ca47b15fc068e3ea">get_bounds</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a61218f2bab05d6542da4ea7a4990caaa">get_bounds_along_edge_chain</a>(const FunctionDAG::Node *f, const vector&lt; const FunctionDAG::Edge * &gt; &amp;edge_chain) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aecae9a4050c71beb50be46b01ac4e771">get_enclosing_block</a>(const LoopNest *parent, const LoopNest *grandparent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a6e4268fdf5086c903d74ce1bc1090aad">get_gpu_memory_type</a>(bool in_block, bool in_thread, bool is_inlined=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1dd5b72dcb75f5e30b3f951914dae70d">get_pure_stage_vectorized_loop_index</a>(const FunctionDAG::Node *node) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a63e06d8f6a7a7d2d2edaec1b72997410">get_sites</a>(StageMap&lt; Sites &gt; &amp;sites, const LoopNest *task=nullptr, const LoopNest *parent=nullptr) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#acd60d15bdfd3e8bc2b7193cc30fb4c22">get_sites</a>(const Target &amp;target, StageMap&lt; Sites &gt; &amp;sites, StageMap&lt; int64_t &gt; &amp;shared_mem_alloc_sizes, const LoopNest *task=nullptr, const LoopNest *parent=nullptr, const LoopNest *current_thread_loop=nullptr) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1b53cd6b02decce7cb172d8f0a58b6f6">get_stage_sizes</a>(const FunctionDAG::Node *f, vector&lt; vector&lt; int64_t &gt;&gt; &amp;stage_sizes, vector&lt; vector&lt; int &gt;&gt; &amp;pure_dims, vector&lt; int &gt; &amp;vectorized_indices) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1f1c022c1e7a606291c9feedac4639e0">get_stages_computed_in_each_compute_root_loop</a>(StageMap&lt; StageMap&lt; bool &gt;&gt; &amp;descendants, const LoopNest *compute_root_loop_nest=nullptr) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a647e0a028d9a94f9f4e8ad80d14a8192">get_total_constant_local_mem_alloc_size</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#af64fe08a48eef7bd38fca63e4a9d2138">get_total_local_mem_alloc_size</a>(bool constant_allocs_only=false, bool in_threads_loop=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a10749b2ebed53e692519b85b3defcf47">get_union_thread_counts</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a8ada07b04c8f834ad9559e738d1cf29e">get_vectorized_loop_index_from_pure_stage</a>(const LoopNest &amp;root) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a30340933c8356bb7dc31cca05ade37e1">gpu_label</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a9f4540b511e8256749b311a198847ef9">has_constant_region_computed</a>(const FunctionDAG::Node *node) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1a411b818755a3a986dbe7b989c8af2b">has_constant_region_required</a>(const FunctionDAG::Node *node) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a9f170065dad9ad30e21b29b786b7a5c3">has_dynamic_allocation_inside_thread</a>(bool in_thread_loop) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ada154e1c7b3654511378e4d1b27a6dfd">has_thread_loop_descendant</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a7b6e5a73c4f75b14d46012508cc8ac8b">has_valid_thread_extents</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ab63adb13a6f625098c54555c2d5a6229">hash_combine</a>(uint64_t &amp;h, uint64_t next)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ab63adb13a6f625098c54555c2d5a6229">hash_combine</a>(uint64_t &amp;h, uint64_t next)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a32389f73bb4534c1b403ee089dac4cea">inline_func</a>(const FunctionDAG::Node *f)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a32389f73bb4534c1b403ee089dac4cea">inline_func</a>(const FunctionDAG::Node *f)</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#afa174b40f80ba38486c3dec1ef3808a0">inlined</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac7da95f17badb497858c6a4ac2516ca3">innermost</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a5246b78318047fa7f69ae47b26865c40">is_gpu_block</a>(const Target &amp;target) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aaad8422a7db0cf93d21b7da78a6693a2">is_gpu_serial</a>(const Target &amp;target) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a0534ae25bf1bd615aacf5094c9ed4cd1">is_gpu_thread</a>(const Target &amp;target) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a10a223dd58020296550794c6bf129da9">is_root</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a10a223dd58020296550794c6bf129da9">is_root</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1276b8e4c24d8bebbcf4dbd044337557">is_scalar</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aafba95030bc7ef16c6cdacb912b17a41">max_idle_lane_wastage</a>(const Target &amp;target, GPULoopInfo gpu_loop_info) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac432ada24cc10cd43063f60d1efea0a4">max_inlined_calls</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac432ada24cc10cd43063f60d1efea0a4">max_inlined_calls</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a6ae2ed076d3fc9c9d5eff1a8d41fb76d">memoize_features</a>(StageMap&lt; ScheduleFeatures &gt; &amp;memoized_features, const StageMap&lt; ScheduleFeatures &gt; *features_to_insert) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aa36429ae4c9844b103b1e437c1ff6214">memoize_features</a>(StageMap&lt; ScheduleFeatures &gt; &amp;memoized_features, const StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a9f31b0d91691a9cc84494d1f936b57fb">memoize_points_computed_minimum</a>(StageMap&lt; ScheduleFeatures &gt; &amp;memoized_features, const StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a9f31b0d91691a9cc84494d1f936b57fb">memoize_points_computed_minimum</a>(StageMap&lt; ScheduleFeatures &gt; &amp;memoized_features, const StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a5334ea87cb1a1d64712d6d77262f75c8">node_has_dynamic_region_computed</a>(const FunctionDAG::Node *f) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a14300d753b33d15988b9d4e595c9a99f">num_serial_loops</a>(const FunctionDAG::Node::Stage *stage) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a1ab93fe46df7741fd556514bd75f95a5">num_serial_loops</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac8c50018057e8e80ab28a651d1cfbb12">other_stage_has_same_producer</a>(const FunctionDAG::Node *producer) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ace6549b94773e60c3d2e61a7b925a24a">parallel</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a68e0253cd289b6c5189fcbfd5d0eab40">parallelize_in_tiles</a>(const Adams2019Params &amp;params, const vector&lt; int64_t &gt; &amp;tiling, const LoopNest *parent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a8c5af3a66525a083b10e940ce608583c">parallelize_in_tiles</a>(const vector&lt; int64_t &gt; &amp;tiling, const LoopNest *parent, const Anderson2021Params &amp;params, const Target &amp;target, bool inner_tiling, bool adjust_tiling, bool move_all_rvars_inward=true, const vector&lt; int &gt; &amp;rvars_to_move_inward={}) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ab8d806df3b4df4552d4614464aa37c46">points_accessed_per_thread</a>(const Anderson2021Params &amp;params, const Target &amp;target, const GPULoopInfo &amp;gpu_loop_info, const std::vector&lt; const FunctionDAG::Edge * &gt; &amp;edge_chain, const LoadJacobian &amp;jac, const LoopNest *parent, const LoopNest *grandparent, int64_t n, const ScheduleFeatures &amp;feat, const LoadJacobian &amp;serial_jac, bool producer_has_been_scheduled, int producer_innermost_dim, const GPUMemoryType &amp;mem_type, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad1d455dc8d32e4b8b63e6869b86598bc">producer_computed_here_or_further_in</a>(const FunctionDAG::Node *producer) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a4ff6db1bbd8a477830f85795cc7745e4">product_of_descendants</a>(int loop_index) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a2ffc82f121129811ad60af057510a7fc">product_of_self_and_descendants</a>(int loop_index) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a99bebc4f9dc5e46d377f58487886f783">promote_allocs_to_registers</a>(const Target &amp;target, StageMap&lt; Sites &gt; &amp;sites) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a317ccf53146ba48b5e0b182d3bbbc335">recompute_inlined_features</a>(const StageMap&lt; Sites &gt; &amp;sites, StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a317ccf53146ba48b5e0b182d3bbbc335">recompute_inlined_features</a>(const StageMap&lt; Sites &gt; &amp;sites, StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ab9a1e0d893e5f721cb35e6bc347d74ae">ref_count</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">mutable</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a3a64e691432204114b166c433d277395">region_computed_shrinks</a>(const FunctionDAG::Node *f, const LoopNest *parent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a50cbca9c1975632bd983a2e7e2699e66">requires_dynamic_allocation</a>(const FunctionDAG::Node *f, const Target &amp;target, bool in_threads_loop) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a48e20c75a4248298dfdf646a38aed5a2">set_bounds</a>(const FunctionDAG::Node *f, BoundContents *b) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a48e20c75a4248298dfdf646a38aed5a2">set_bounds</a>(const FunctionDAG::Node *f, BoundContents *b) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a96f033062ae5c95a80d26f38dc32ae46">set_working_set_at_task_feature</a>(int64_t working_set, StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a96f033062ae5c95a80d26f38dc32ae46">set_working_set_at_task_feature</a>(int64_t working_set, StageMap&lt; ScheduleFeatures &gt; *features) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"><span class="mlabel">inline</span></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a60ab63803a47071cb7d0bead75019ff6">size</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae322fdeca7f5d3b43074a1b7aff206f2">size</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ac451c4521ccf418a9e05a6d5d8b1e9e1">stage</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a8ecd3040c89e4d475f9193d341f987b4">storage_stride</a>(const LoadJacobian &amp;jac, int innermost_storage_dim, const FunctionDAG::Node *storage_node, const Bound &amp;store_bounds, const LoopNest &amp;root) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aedb584f3dab343d643d76c925813ed07">store_at</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae3312b1d7aec8fa45390e4b0a6160387">structural_hash</a>(uint64_t &amp;h, int depth) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ae3312b1d7aec8fa45390e4b0a6160387">structural_hash</a>(uint64_t &amp;h, int depth) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a8f782ad834ede04dac6a52a66517c8bd">tileable</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#aa980686372412b174e4e6126b112f9ba">to_string</a>() const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#af2824f14d6a433299a2e3f43bb680732">unrolled_loops</a>(const Target &amp;target, const LoopNest *parent, const LoopNest *grandparent) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#ad92033c0099e44d37bb92cfb5f262cf9">update_producers_to_be_staged</a>(StageScheduleState &amp;state, const NodeMap&lt; bool &gt; &amp;all_inlined) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a77d5faa6e442d6e06b9d6a8af3ca9b90">vector_dim</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#afd6a176ceadde6bb4b77d2d9c6455001">vectorized_access_size</a>(size_t loop_index, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a66da14860cbf0999dbbe2d749989839f">vectorized_load_access_size</a>(const LoadJacobian &amp;jac, const FunctionDAG::Node *accessed, bool accessed_has_been_scheduled, int innermost_dim, const GPUMemoryType &amp;mem_type, bool verbose=false) const</td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
  <tr><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html#a0aed41f28aca14d26b722edd02d6be7a">vectorized_loop_index</a></td><td class="entry"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">Halide::Internal::Autoscheduler::LoopNest</a></td><td class="entry"></td></tr>
</table></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
