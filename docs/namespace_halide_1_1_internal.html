<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_halide_1_1_internal.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Halide::Internal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html">Autoscheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_elf.html">Elf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html">GeneratorMinMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html">IRMatcher</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_internal_1_1_i_r_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative template-metaprogramming approach to expression matching. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_abstract_generator.html">AbstractGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_abstract_generator.html" title="AbstractGenerator is an ABC that defines the API a Generator must provide to work with the existing G...">AbstractGenerator</a> is an ABC that defines the API a <a class="el" href="class_halide_1_1_generator.html">Generator</a> must provide to work with the existing <a class="el" href="class_halide_1_1_generator.html">Generator</a> infrastructure (GenGen, RunGen, <a class="el" href="#ac8012ee5b0051705ecbc75a83ae6b465" title="Execute a Generator for AOT compilation â€“ this provides the implementation of the command-line Genera...">execute_generator()</a>, <a class="el" href="class_halide_1_1_generator.html">Generator</a> Stubs).  <a href="class_halide_1_1_internal_1_1_abstract_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_acquire.html">Acquire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">all_are_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__printable__args.html">all_are_printable_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name.html">all_ints_and_optional_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_01_first_00_01_rest_8_8_8_01_4.html">all_ints_and_optional_name&lt; First, Rest... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_01_t_01_4.html">all_ints_and_optional_name&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_4.html">all_ints_and_optional_name&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1aslog.html">aslog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then evaluate and return the message, which should be a call to an error function.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent the equivalent associative op of an update definition.  <a href="struct_halide_1_1_internal_1_1_associative_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an associative op with its identity.  <a href="struct_halide_1_1_internal_1_1_associative_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_atomic.html">Atomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all the <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a> nodes in the body statement.  <a href="struct_halide_1_1_internal_1_1_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_bound.html">Bound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bound on a loop, typically from <a class="el" href="class_halide_1_1_func.html#af0a2825e04367798cb1d2b58cf13a7b2" title="Statically declare that the range over which a function should be evaluated is given by the second an...">Func::bound</a>.  <a href="struct_halide_1_1_internal_1_1_bound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the bounds of a region of arbitrary dimension.  <a href="struct_halide_1_1_internal_1_1_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'lanes' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_builder.html">BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to help create Exprs representing <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> structs (e.g.  <a href="struct_halide_1_1_internal_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all calls to image buffers and parameters in the function.  <a href="struct_halide_1_1_internal_1_1_buffer_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual IR nodes begin here.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___c.html">CodeGen_GPU_C</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for GPU backends that require C-like shader output.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___py_torch.html">CodeGen_PyTorch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code to wrap a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline so that it can be used as a C++ extension operator in <a class="el" href="namespace_halide_1_1_py_torch.html">PyTorch</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___py_torch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent ranges of integers.  <a href="struct_halide_1_1_internal_1_1_constant_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cost.html">Cost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> optional debugging during codegen, use the debug class as follows:  <a href="class_halide_1_1_internal_1_1debug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition which can either represent a init or an update definition.  <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html">DeviceArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> looks similar to an <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Halide::Argument</a>, but has behavioral differences that make it specific to the GPU pipeline; the fact that neither is-a nor has-a <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Halide::Argument</a> is deliberate.  <a href="struct_halide_1_1_internal_1_1_device_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_halide_1_1_internal_1_1_dim.html" title="The Dim struct represents one loop in the schedule&#39;s representation of a loop nest.">Dim</a> struct represents one loop in the schedule's representation of a loop nest.  <a href="struct_halide_1_1_internal_1_1_dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_dimension.html">Dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_execute_generator_args.html">ExecuteGeneratorArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_execute_generator_args.html" title="ExecuteGeneratorArgs is the set of arguments to execute_generator().">ExecuteGeneratorArgs</a> is the set of arguments to <a class="el" href="#ac8012ee5b0051705ecbc75a83ae6b465" title="Execute a Generator for AOT compilation â€“ this provides the implementation of the command-line Genera...">execute_generator()</a>.  <a href="struct_halide_1_1_internal_1_1_execute_generator_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_expr_uses_vars.html">ExprUsesVars</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_feature_intermediates.html">FeatureIntermediates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_find_all_calls.html">FindAllCalls</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for keeping track of functions that are directly called and the arguments with which they are called.  <a href="class_halide_1_1_internal_1_1_find_all_calls.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_fork.html">Fork</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of statements executed concurrently.  <a href="struct_halide_1_1_internal_1_1_fork.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer.">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_func_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A possibly-weak pointer to a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> function.  <a href="struct_halide_1_1_internal_1_1_function_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents two stages with fused loop nests from outermost to a specific loop level.  <a href="struct_halide_1_1_internal_1_1_fused_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html">GeneratorFactoryProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html" title="GeneratorFactoryProvider provides a way to customize the Generators that are visible to generate_filt...">GeneratorFactoryProvider</a> provides a way to customize the Generators that are visible to generate_filter_main (which otherwise would just look at the global registry of C++ Generators).  <a href="class_halide_1_1_internal_1_1_generator_factory_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___dynamic_scalar.html">GeneratorInput_DynamicScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_base.html">GeneratorInputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_impl.html">GeneratorInputImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_base.html">GeneratorOutputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_impl.html">GeneratorOutputImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___auto_scheduler_params.html">GeneratorParam_AutoSchedulerParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___string.html">GeneratorParam_String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___synthetic.html">GeneratorParam_Synthetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_impl.html">GeneratorParamImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_info.html">GeneratorParamInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html">GIOBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html" title="GIOBase is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not pa...">GIOBase</a> is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not part of the public API and should never be used directly by user code.  <a href="class_halide_1_1_internal_1_1_g_i_o_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_p_u_compilation_cache.html">GPUCompilationCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_gpu_object_lifetime_tracker.html">GpuObjectLifetimeTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_halide_buffer_static_type_and_dims.html">HalideBufferStaticTypeAndDims</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_halide_buffer_static_type_and_dims_3_1_1_halide_1_1_buffer_3_01_t_00_01_dims_01_4_01_4.html">HalideBufferStaticTypeAndDims&lt;::Halide::Buffer&lt; T, Dims &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_halide_buffer_static_type_and_dims_3_1_1_halide_1_1_runtime_1_1_b8d8ac39b23a82e9bee18ec92e3902f12.html">HalideBufferStaticTypeAndDims&lt;::Halide::Runtime::Buffer&lt; T, Dims &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method_3_01_t2_00_01typename_01type__si902d603523cc7c0df71b135e75cbe224.html">has_static_halide_type_method&lt; T2, typename type_sink&lt; decltype(T2::static_halide_type())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_hexagon_alignment_analyzer.html">HexagonAlignmentAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_hoisted_storage.html">HoistedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location where storage will be hoisted to for a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> / <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> node with a given name.  <a href="struct_halide_1_1_internal_1_1_hoisted_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_host_closure.html">HostClosure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures.">Closure</a> modified to inspect GPU-specific memory accesses, and produce a vector of <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> objects.  <a href="class_halide_1_1_internal_1_1_host_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_indentation.html">Indentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inferred argument.  <a href="struct_halide_1_1_internal_1_1_inferred_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent ranges of Exprs.  <a href="struct_halide_1_1_internal_1_1_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html">IRDeepCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct built around less_than, for use as the comparison object in a std::map or std::set.  <a href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_graph_deep_compare.html">IRGraphDeepCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct built around graph_less_than, for use as the comparison object in a std::map or std::set.  <a href="struct_halide_1_1_internal_1_1_i_r_graph_deep_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_mutator.html">IRGraphMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator that caches and reapplies previously-done mutations, so that it can handle graphs of IR that have not had CSE done to them.  <a href="class_halide_1_1_internal_1_1_i_r_graph_mutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1is__printable__arg.html">is_printable_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_halide_buffer.html">IsHalideBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_halide_buffer_3_01const_01halide__buffer__t_01_5_01_4.html">IsHalideBuffer&lt; const halide_buffer_t * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_halide_buffer_3_01halide__buffer__t_01_5_01_4.html">IsHalideBuffer&lt; halide_buffer_t * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_halide_buffer_3_1_1_halide_1_1_buffer_3_01_t_00_01_dims_01_4_01_4.html">IsHalideBuffer&lt;::Halide::Buffer&lt; T, Dims &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_halide_buffer_3_1_1_halide_1_1_runtime_1_1_buffer_3_01_t_00_01_dims_01_4_01_4.html">IsHalideBuffer&lt;::Halide::Runtime::Buffer&lt; T, Dims &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_roundtrippable.html">IsRoundtrippable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_cache.html">JITCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_error_buffer.html">JITErrorBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_func_call_context.html">JITFuncCallContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_module.html">JITModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_i_t_shared_runtime.html">JITSharedRuntime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html">JSONCompilerLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html" title="JSONCompilerLogger is a basic implementation of the CompilerLogger interface that saves logged data,...">JSONCompilerLogger</a> is a basic implementation of the <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> interface that saves logged data, then logs it all in JSON format in <a class="el" href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html#aaf493487a64b0a1f2b40e7d273ed96cd" title="Emit all the gathered data to the given stream.">emit_to_stream()</a>.  <a href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true.">Load</a> a value from a named symbol if predicate is true.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> of an argument to a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a>.  <a href="struct_halide_1_1_internal_1_1_lowered_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> of a lowered function.  <a href="struct_halide_1_1_internal_1_1_lowered_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">meta_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_01_4.html">meta_and&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or.html">meta_or</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or_3_01_t1_00_01_args_8_8_8_01_4.html">meta_or&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations.html">NoRealizations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_01_t_00_01_args_8_8_8_01_4.html">NoRealizations&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_4.html">NoRealizations&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_object_instance_registry.html">ObjectInstanceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_output_info.html">OutputInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_pipeline_features.html">PipelineFeatures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch.html">Prefetch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a multi-dimensional region of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> that needs to be prefetched.  <a href="struct_halide_1_1_internal_1_1_prefetch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_print_span.html">PrintSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow easily printing the contents of containers, or std::vector-like containers, in debug output.  <a href="struct_halide_1_1_internal_1_1_print_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_print_span_ln.html">PrintSpanLn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow easily printing the contents of spans, or std::vector-like spans, in debug output.  <a href="struct_halide_1_1_internal_1_1_print_span_ln.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_producer_consumer.html">ProducerConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_producer_consumer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_python_extension_gen.html">PythonExtensionGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain.">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of reduction variables the expression or tuple depends on.  <a href="struct_halide_1_1_internal_1_1_reduction_variable_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself.">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_region_costs.html">RegionCosts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto scheduling component which is used to assign costs for computing a region of a function or one of its stages.  <a href="struct_halide_1_1_internal_1_1_region_costs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_register_generator.html">RegisterGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reinterpret.html">Reinterpret</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_reinterpret.html" title="Reinterpret value as another type, without affecting any of the bits (on little-endian systems).">Reinterpret</a> value as another type, without affecting any of the bits (on little-endian systems).  <a href="struct_halide_1_1_internal_1_1_reinterpret.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_binding.html">ScopedBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for pushing/popping Scope&lt;&gt; values, to allow for early-exit in Visitor/Mutators that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_binding_3_01void_01_4.html">ScopedBinding&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_value.html">ScopedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for saving/restoring variable values on the stack, to allow for early-exit that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type_3_01_first_01_4.html">select_type&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new vector by taking elements from another sequence of vectors.  <a href="struct_halide_1_1_internal_1_1_shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_simplify.html">Simplify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack_3_01void_01_4.html">SmallStack&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_static_cast.html">StaticCast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_storage_dim.html">StorageDim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties of one axis of the storage of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="struct_halide_1_1_internal_1_1_storage_dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a> a 'value' to the buffer called 'name' at a given 'index' if 'predicate' is true.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input.html">StubInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html">StubInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html" title="StubInputBuffer is the placeholder that a Stub uses when it requires a Buffer for an input (rather th...">StubInputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an input (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>).  <a href="class_halide_1_1_internal_1_1_stub_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html">StubOutputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html" title="StubOutputBuffer is the placeholder that a Stub uses when it requires a Buffer for an output (rather ...">StubOutputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an output (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>).  <a href="class_halide_1_1_internal_1_1_stub_output_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer_base.html">StubOutputBufferBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_temporary_file.html">TemporaryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class that creates a temporary file in its ctor and deletes that file in its dtor; this is useful for temporary files that you want to ensure are deleted when exiting a certain scope.  <a href="class_halide_1_1_internal_1_1_temporary_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1type__sink.html">type_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html">UIntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer constants.  <a href="struct_halide_1_1_internal_1_1_u_int_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_variadic_visitor.html">VariadicVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor/mutator capable of passing arbitrary arguments to the visit methods using CRTP and returning any types from them.  <a href="class_halide_1_1_internal_1_1_variadic_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html">VectorReduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally reduce a vector to a scalar or narrower vector using the given commutative and associative binary operator.  <a href="struct_halide_1_1_internal_1_1_vector_reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_voidifier.html">Voidifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_wasm_module.html">WasmModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to compiled wasm code which can be called later.  <a href="struct_halide_1_1_internal_1_1_wasm_module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_weights.html">Weights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acc8e4407368c814081b11769fa150132" id="r_acc8e4407368c814081b11769fa150132"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8e4407368c814081b11769fa150132">AbstractGeneratorPtr</a> = std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_abstract_generator.html">AbstractGenerator</a>&gt;</td></tr>
<tr class="separator:acc8e4407368c814081b11769fa150132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff8dba5612d856cc2acfab99e3cf479" id="r_abff8dba5612d856cc2acfab99e3cf479"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a></td></tr>
<tr class="separator:abff8dba5612d856cc2acfab99e3cf479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0611a86047e2c583dd061a620dcc6e" id="r_aaa0611a86047e2c583dd061a620dcc6e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a></td></tr>
<tr class="separator:aaa0611a86047e2c583dd061a620dcc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13aeea9641a9bbf0013901f4326dd58" id="r_ac13aeea9641a9bbf0013901f4326dd58"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ac13aeea9641a9bbf0013901f4326dd58"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac13aeea9641a9bbf0013901f4326dd58">add_const_if_T_is_const</a> = typename std::conditional&lt;std::is_const&lt;T&gt;::value, const T2, T2&gt;::type</td></tr>
<tr class="separator:ac13aeea9641a9bbf0013901f4326dd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c7e335aa48b00b3c72b510582b5524" id="r_ad7c7e335aa48b00b3c72b510582b5524"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7c7e335aa48b00b3c72b510582b5524"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7c7e335aa48b00b3c72b510582b5524">GeneratorParamImplBase</a></td></tr>
<tr class="separator:ad7c7e335aa48b00b3c72b510582b5524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a7a3695e256e17892889cb17ae3c19" id="r_a00a7a3695e256e17892889cb17ae3c19"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:a00a7a3695e256e17892889cb17ae3c19"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00a7a3695e256e17892889cb17ae3c19">GeneratorInputImplBase</a></td></tr>
<tr class="separator:a00a7a3695e256e17892889cb17ae3c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f72664152ee17c9a9a0a206b76ae0" id="r_a5a8f72664152ee17c9a9a0a206b76ae0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:a5a8f72664152ee17c9a9a0a206b76ae0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a8f72664152ee17c9a9a0a206b76ae0">GeneratorOutputImplBase</a></td></tr>
<tr class="separator:a5a8f72664152ee17c9a9a0a206b76ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cfa4b673c27588073a14e4025df4cf" id="r_a60cfa4b673c27588073a14e4025df4cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60cfa4b673c27588073a14e4025df4cf">GeneratorFactory</a> = std::function&lt;<a class="el" href="#acc8e4407368c814081b11769fa150132">AbstractGeneratorPtr</a>(const <a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a> &amp;context)&gt;</td></tr>
<tr class="separator:a60cfa4b673c27588073a14e4025df4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114c2dcec2af79da28735c5b11c0916" id="r_a7114c2dcec2af79da28735c5b11c0916"><td class="memItemLeft" align="right" valign="top">typedef llvm::raw_pwrite_stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7114c2dcec2af79da28735c5b11c0916">LLVMOStream</a></td></tr>
<tr class="separator:a7114c2dcec2af79da28735c5b11c0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0396411abf88410baf6a6e6e41ea1419" id="r_a0396411abf88410baf6a6e6e41ea1419"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0396411abf88410baf6a6e6e41ea1419">ArgInfoKind</a> { <a class="el" href="#a0396411abf88410baf6a6e6e41ea1419af60357a8d17e45793298323f1b372a74">Scalar</a>
, <a class="el" href="#a0396411abf88410baf6a6e6e41ea1419a86408593c34af77fdd90df932f8b5261">Function</a>
, <a class="el" href="#a0396411abf88410baf6a6e6e41ea1419a7e62bc342f41c946868f0ea6f0b712d8">Buffer</a>
 }</td></tr>
<tr class="separator:a0396411abf88410baf6a6e6e41ea1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb05011033eb11f001b6a4cb5a6ae619" id="r_adb05011033eb11f001b6a4cb5a6ae619"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb05011033eb11f001b6a4cb5a6ae619">ArgInfoDirection</a> { <a class="el" href="#adb05011033eb11f001b6a4cb5a6ae619a324118a6721dd6b8a9b9f4e327df2bf5">Input</a>
, <a class="el" href="#adb05011033eb11f001b6a4cb5a6ae619a29c2c02a361c9d7028472e5d92cd4a54">Output</a>
 }</td></tr>
<tr class="separator:adb05011033eb11f001b6a4cb5a6ae619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8548315fd4d13ccebe45a8123369f7ca" id="r_a8548315fd4d13ccebe45a8123369f7ca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> { <a class="el" href="#a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec">Upper</a>
, <a class="el" href="#a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93">Lower</a>
 }</td></tr>
<tr class="memdesc:a8548315fd4d13ccebe45a8123369f7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a varying expression, try to find a constant that is either: An upper bound (always greater than or equal to the expression), or A lower bound (always less than or equal to the expression) If it fails, returns an undefined Expr.  <a href="#a8548315fd4d13ccebe45a8123369f7ca">More...</a><br /></td></tr>
<tr class="separator:a8548315fd4d13ccebe45a8123369f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e0b8e5376e2294d74ded8e7de9ef2" id="r_aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> { <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417">IntImm</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8">UIntImm</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07">FloatImm</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73">StringImm</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842">Broadcast</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c">Cast</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a2939cc096ba90c44ede434ba24ed3436">Reinterpret</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9">Variable</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2">Sub</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a">Div</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2">Min</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233">Max</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47">EQ</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0">NE</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b">LT</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6">LE</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020">GT</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9">GE</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b">And</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c">Or</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666">Not</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff">Select</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb">Load</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb">Ramp</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e">Call</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6">Let</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ae8b4b40ec3622e371789b790caabc083">Shuffle</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5">VectorReduce</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2">LetStmt</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742">AssertStmt</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0">ProducerConsumer</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11">For</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a993ca650a85e8e69b8f7eaa4809c4862">Acquire</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72">Store</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7">Provide</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f">Allocate</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594">Free</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc">Realize</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2">Block</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a36c81967df3424f919e89b09ed34c90d">Fork</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c">IfThenElse</a>
, <br />
&#160;&#160;<a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f">Evaluate</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a18540d940813866480eaca8d3f32d18e">Prefetch</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a557eccd321b7f10f5127c1ef27aaac7d">Atomic</a>
, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2ab8b1a8074f151efb78b9b1c0010a23c2">HoistedStorage</a>
<br />
 }</td></tr>
<tr class="memdesc:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">All our IR node types get unique IDs for the purposes of RTTI.  <a href="#aee9e0b8e5376e2294d74ded8e7de9ef2">More...</a><br /></td></tr>
<tr class="separator:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8761f129e6554b9ea03de31bf066f1" id="r_a6a8761f129e6554b9ea03de31bf066f1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> { <br />
&#160;&#160;<a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493">Serial</a>
, <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131">Parallel</a>
, <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725">Vectorized</a>
, <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac">Unrolled</a>
, <br />
&#160;&#160;<a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1a498ab78ee0b25ce33c83714c1a453831">Extern</a>
, <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1a9ad52f412f8b405c833cd317db050a28">GPUBlock</a>
, <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1a403672f982053243315d59e56d8a3b8d">GPUThread</a>
, <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1ab6f9478bd3fd1adac23a5802d786d642">GPULane</a>
<br />
 }</td></tr>
<tr class="memdesc:a6a8761f129e6554b9ea03de31bf066f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing a type of loop traversal.  <a href="#a6a8761f129e6554b9ea03de31bf066f1">More...</a><br /></td></tr>
<tr class="separator:a6a8761f129e6554b9ea03de31bf066f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43770c59ec0f13935f4b33502ba7e817" id="r_a43770c59ec0f13935f4b33502ba7e817"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43770c59ec0f13935f4b33502ba7e817">SyntheticParamType</a> { <a class="el" href="#a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>
, <a class="el" href="#a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9">Dim</a>
, <a class="el" href="#a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c">ArraySize</a>
 }</td></tr>
<tr class="separator:a43770c59ec0f13935f4b33502ba7e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc0c8c1adc38d2c5a80979948f0007c" id="r_a7dc0c8c1adc38d2c5a80979948f0007c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> { <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255">Constant</a>
, <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd">Increasing</a>
, <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b">Decreasing</a>
, <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>
 }</td></tr>
<tr class="memdesc:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown.  <a href="#a7dc0c8c1adc38d2c5a80979948f0007c">More...</a><br /></td></tr>
<tr class="separator:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c72fcb8800b47e313c62f5416a4fe" id="r_a5b8c72fcb8800b47e313c62f5416a4fe"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4fe">DimType</a> { <a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4feafbbbe5ac592bfdafcfa397cd609d8117">PureVar</a> = 0
, <a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4fead117eadbd7c1c4d821b3a598d54d03f2">PureRVar</a>
, <a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4feac2ab1e3a4730b5543c84be4a4a223b83">ImpureRVar</a>
 }</td></tr>
<tr class="memdesc:a5b8c72fcb8800b47e313c62f5416a4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each Dim below has a dim_type, which tells you what transformations are legal on it.  <a href="#a5b8c72fcb8800b47e313c62f5416a4fe">More...</a><br /></td></tr>
<tr class="separator:a5b8c72fcb8800b47e313c62f5416a4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3a92e4cf0e42a7ea4777922833ff77fd" id="r_a3a92e4cf0e42a7ea4777922833ff77fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a92e4cf0e42a7ea4777922833ff77fd">add_atomic_mutex</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:a3a92e4cf0e42a7ea4777922833ff77fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5c6a19891ace3a590f49ba456ca1d6" id="r_afe5c6a19891ace3a590f49ba456ca1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe5c6a19891ace3a590f49ba456ca1d6">add_image_checks</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;fb, bool will_inject_host_copies)</td></tr>
<tr class="memdesc:afe5c6a19891ace3a590f49ba456ca1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g.  <br /></td></tr>
<tr class="separator:afe5c6a19891ace3a590f49ba456ca1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1610da9bbdeab59ba5d7724231352ab" id="r_af1610da9bbdeab59ba5d7724231352ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1610da9bbdeab59ba5d7724231352ab">add_parameter_checks</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;requirements, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:af1610da9bbdeab59ba5d7724231352ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure that all referenced parameters meet their constraints.  <br /></td></tr>
<tr class="separator:af1610da9bbdeab59ba5d7724231352ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8465b7af6ae07e3bf1ae88bce4d931e" id="r_aa8465b7af6ae07e3bf1ae88bce4d931e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8465b7af6ae07e3bf1ae88bce4d931e">add_split_factor_checks</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aa8465b7af6ae07e3bf1ae88bce4d931e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks that all split factors that depend on scalar parameters are strictly positive.  <br /></td></tr>
<tr class="separator:aa8465b7af6ae07e3bf1ae88bce4d931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca3c458ab863fb376fee3f42f4ded8d" id="r_aeca3c458ab863fb376fee3f42f4ded8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca3c458ab863fb376fee3f42f4ded8d">align_loads</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, int alignment, int min_bytes_to_align)</td></tr>
<tr class="memdesc:aeca3c458ab863fb376fee3f42f4ded8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors.  <br /></td></tr>
<tr class="separator:aeca3c458ab863fb376fee3f42f4ded8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410eac3ad68dfb697c5ee97100f2053f" id="r_a410eac3ad68dfb697c5ee97100f2053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a410eac3ad68dfb697c5ee97100f2053f">allocation_bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr class="memdesc:a410eac3ad68dfb697c5ee97100f2053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes in terms of variables, and define values for those variables.  <br /></td></tr>
<tr class="separator:a410eac3ad68dfb697c5ee97100f2053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39733fd9ce489f24117a0188d89107a8" id="r_a39733fd9ce489f24117a0188d89107a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39733fd9ce489f24117a0188d89107a8">apply_split</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;split, const std::string &amp;prefix, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;dim_extent_alignment)</td></tr>
<tr class="memdesc:a39733fd9ce489f24117a0188d89107a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> schedule on a definition (init or update), return a list of of predicates on the definition, substitutions that needs to be applied to the definition (in ascending order of application), and let stmts which defined the values of variables referred by the predicates and substitutions (ordered from innermost to outermost let).  <br /></td></tr>
<tr class="separator:a39733fd9ce489f24117a0188d89107a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3589e250311bb913b71fd2355258098" id="r_ad3589e250311bb913b71fd2355258098"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3589e250311bb913b71fd2355258098">compute_loop_bounds_after_split</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;split, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ad3589e250311bb913b71fd2355258098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the loop bounds of the new dimensions resulting from applying the split schedules using the loop bounds of the old dimensions.  <br /></td></tr>
<tr class="separator:ad3589e250311bb913b71fd2355258098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459944d05613a6737daffec0a67d865c" id="r_a459944d05613a6737daffec0a67d865c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a459944d05613a6737daffec0a67d865c">get_ops_table</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;exprs)</td></tr>
<tr class="separator:a459944d05613a6737daffec0a67d865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf049bd392c948b161c1435e23184a20" id="r_acf049bd392c948b161c1435e23184a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf049bd392c948b161c1435e23184a20">prove_associativity</a> (const std::string &amp;f, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; args, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; exprs)</td></tr>
<tr class="memdesc:acf049bd392c948b161c1435e23184a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any.  <br /></td></tr>
<tr class="separator:acf049bd392c948b161c1435e23184a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6050713d80d82d1ba201fc9f709b7" id="r_a74a6050713d80d82d1ba201fc9f709b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a6050713d80d82d1ba201fc9f709b7">associativity_test</a> ()</td></tr>
<tr class="separator:a74a6050713d80d82d1ba201fc9f709b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0092d026f554bbd98a3c603e58e6e46e" id="r_a0092d026f554bbd98a3c603e58e6e46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0092d026f554bbd98a3c603e58e6e46e">fork_async_producers</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="separator:a0092d026f554bbd98a3c603e58e6e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf8e17b611c700b1a41969a8dc7c1e1" id="r_acdf8e17b611c700b1a41969a8dc7c1e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdf8e17b611c700b1a41969a8dc7c1e1">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an int representation of 's'.  <br /></td></tr>
<tr class="separator:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553a170f5d655144a90d342f46bb5bc7" id="r_a553a170f5d655144a90d342f46bb5bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553a170f5d655144a90d342f46bb5bc7">substitute_var_estimates</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a553a170f5d655144a90d342f46bb5bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> with its estimate if specified.  <br /></td></tr>
<tr class="separator:a553a170f5d655144a90d342f46bb5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c43260020b62213bc2383cb13f7aeb" id="r_a78c43260020b62213bc2383cb13f7aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78c43260020b62213bc2383cb13f7aeb">substitute_var_estimates</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="separator:a78c43260020b62213bc2383cb13f7aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09ed39b20fb0f51fbda5a7b14c7f93" id="r_a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f09ed39b20fb0f51fbda5a7b14c7f93">get_extent</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;i)</td></tr>
<tr class="memdesc:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an interval.  <br /></td></tr>
<tr class="separator:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce3144d60aa2f3abdb127b3750cb73" id="r_a09ce3144d60aa2f3abdb127b3750cb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ce3144d60aa2f3abdb127b3750cb73">box_size</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a09ce3144d60aa2f3abdb127b3750cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an n-d box.  <br /></td></tr>
<tr class="separator:a09ce3144d60aa2f3abdb127b3750cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f30fc5e0c64f2e3f32ffe1416f045b0" id="r_a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f30fc5e0c64f2e3f32ffe1416f045b0">disp_regions</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;regions)</td></tr>
<tr class="memdesc:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to print the bounds of a region.  <br /></td></tr>
<tr class="separator:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf44d2ab2c8eca7437d770011107830" id="r_a4cf44d2ab2c8eca7437d770011107830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cf44d2ab2c8eca7437d770011107830">get_stage_definition</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num)</td></tr>
<tr class="memdesc:a4cf44d2ab2c8eca7437d770011107830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corresponding definition of a function given the stage.  <br /></td></tr>
<tr class="separator:a4cf44d2ab2c8eca7437d770011107830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5decec1772348bc3b6479452a35808cd" id="r_a5decec1772348bc3b6479452a35808cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5decec1772348bc3b6479452a35808cd">get_stage_dims</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num)</td></tr>
<tr class="memdesc:a5decec1772348bc3b6479452a35808cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corresponding loop dimensions of a function given the stage.  <br /></td></tr>
<tr class="separator:a5decec1772348bc3b6479452a35808cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753561dbe4e01ef75c2af4ce17d3dfb1" id="r_a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753561dbe4e01ef75c2af4ce17d3dfb1">combine_load_costs</a> (std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;partial)</td></tr>
<tr class="memdesc:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> partial load costs to the corresponding function in the result costs.  <br /></td></tr>
<tr class="separator:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f47061da7dd7653e9d9058b850d94e5" id="r_a2f47061da7dd7653e9d9058b850d94e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f47061da7dd7653e9d9058b850d94e5">get_stage_bounds</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num, const <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;pure_bounds)</td></tr>
<tr class="memdesc:a2f47061da7dd7653e9d9058b850d94e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the required bounds of an intermediate stage (f, stage_num) of function 'f' given the bounds of the pure dimensions.  <br /></td></tr>
<tr class="separator:a2f47061da7dd7653e9d9058b850d94e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904ad5c1870b23c0f80cd43faa2d3d72" id="r_a904ad5c1870b23c0f80cd43faa2d3d72"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a904ad5c1870b23c0f80cd43faa2d3d72">get_stage_bounds</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, const <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;pure_bounds)</td></tr>
<tr class="memdesc:a904ad5c1870b23c0f80cd43faa2d3d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the required bounds for all the stages of the function 'f'.  <br /></td></tr>
<tr class="separator:a904ad5c1870b23c0f80cd43faa2d3d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7faaf922e66ac6f7367697d18fd1cd" id="r_a1d7faaf922e66ac6f7367697d18fd1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d7faaf922e66ac6f7367697d18fd1cd">perform_inline</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::set&lt; std::string &gt; &amp;inlines=std::set&lt; std::string &gt;(), const std::vector&lt; std::string &gt; &amp;order=std::vector&lt; std::string &gt;())</td></tr>
<tr class="memdesc:a1d7faaf922e66ac6f7367697d18fd1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively inline all the functions in the set 'inlines' into the expression 'e' and return the resulting expression.  <br /></td></tr>
<tr class="separator:a1d7faaf922e66ac6f7367697d18fd1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b21e1dbf854a3f46f5403f9224af7d" id="r_a11b21e1dbf854a3f46f5403f9224af7d"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b21e1dbf854a3f46f5403f9224af7d">get_parents</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, int stage)</td></tr>
<tr class="memdesc:a11b21e1dbf854a3f46f5403f9224af7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all functions that are directly called by a function stage (f, stage).  <br /></td></tr>
<tr class="separator:a11b21e1dbf854a3f46f5403f9224af7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c203107b702636e6f2cf5ba896f95" id="r_a765c203107b702636e6f2cf5ba896f95"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a765c203107b702636e6f2cf5ba896f95"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a765c203107b702636e6f2cf5ba896f95">get_element</a> (const std::map&lt; K, V &gt; &amp;m, const K &amp;key)</td></tr>
<tr class="memdesc:a765c203107b702636e6f2cf5ba896f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of element within a map.  <br /></td></tr>
<tr class="separator:a765c203107b702636e6f2cf5ba896f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fc3b223b6e3e0268c901df78a45da2" id="r_ae7fc3b223b6e3e0268c901df78a45da2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ae7fc3b223b6e3e0268c901df78a45da2"><td class="memTemplItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7fc3b223b6e3e0268c901df78a45da2">get_element</a> (std::map&lt; K, V &gt; &amp;m, const K &amp;key)</td></tr>
<tr class="separator:ae7fc3b223b6e3e0268c901df78a45da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976aabd7126fce7f9d7a46daeee8fd40" id="r_a976aabd7126fce7f9d7a46daeee8fd40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976aabd7126fce7f9d7a46daeee8fd40">inline_all_trivial_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a976aabd7126fce7f9d7a46daeee8fd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the cost of computing a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is about the same as calling the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, inline the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <br /></td></tr>
<tr class="separator:a976aabd7126fce7f9d7a46daeee8fd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120045d61aae3bbe15e3da7b81bbb821" id="r_a120045d61aae3bbe15e3da7b81bbb821"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a120045d61aae3bbe15e3da7b81bbb821">is_func_called_element_wise</a> (const std::vector&lt; std::string &gt; &amp;order, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> index, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a120045d61aae3bbe15e3da7b81bbb821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> (order[index]) is only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner.  <br /></td></tr>
<tr class="separator:a120045d61aae3bbe15e3da7b81bbb821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e38c670066041490103529f6c5707" id="r_adb0e38c670066041490103529f6c5707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb0e38c670066041490103529f6c5707">inline_all_element_wise_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:adb0e38c670066041490103529f6c5707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> if its values are only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner.  <br /></td></tr>
<tr class="separator:adb0e38c670066041490103529f6c5707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654878c752bfbc9f2aa979007ff80037" id="r_a654878c752bfbc9f2aa979007ff80037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a654878c752bfbc9f2aa979007ff80037">propagate_estimate_test</a> ()</td></tr>
<tr class="separator:a654878c752bfbc9f2aa979007ff80037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24815856c33f2ea729a891cdf4f3e494" id="r_a24815856c33f2ea729a891cdf4f3e494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24815856c33f2ea729a891cdf4f3e494">bound_constant_extent_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a24815856c33f2ea729a891cdf4f3e494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all loop extents of unrolled or vectorized loops with constants, by substituting and simplifying as needed.  <br /></td></tr>
<tr class="separator:a24815856c33f2ea729a891cdf4f3e494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9718bfbc37263743f6a0a168f986f2" id="r_a7f9718bfbc37263743f6a0a168f986f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a> ()</td></tr>
<tr class="separator:a7f9718bfbc37263743f6a0a168f986f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963b0883bbda1c2664341158fce0b030" id="r_a963b0883bbda1c2664341158fce0b030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a963b0883bbda1c2664341158fce0b030">bounds_of_expr_in_scope</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope, const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>(), bool const_bound=false)</td></tr>
<tr class="memdesc:a963b0883bbda1c2664341158fce0b030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <br /></td></tr>
<tr class="separator:a963b0883bbda1c2664341158fce0b030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f08062dfc06a1816ce78793faf5477" id="r_a61f08062dfc06a1816ce78793faf5477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f08062dfc06a1816ce78793faf5477">find_constant_bound</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> d, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope())</td></tr>
<tr class="separator:a61f08062dfc06a1816ce78793faf5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34593e7612bf139260707200b6dacb3" id="r_aa34593e7612bf139260707200b6dacb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa34593e7612bf139260707200b6dacb3">find_constant_bounds</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:aa34593e7612bf139260707200b6dacb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bounds for a varying expression that are either constants or +/-inf.  <br /></td></tr>
<tr class="separator:aa34593e7612bf139260707200b6dacb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f62c0ee3ace8de2be57a9db369a3e4" id="r_ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f62c0ee3ace8de2be57a9db369a3e4">merge_boxes</a> (<a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand box a to encompass box b.  <br /></td></tr>
<tr class="separator:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9641dd947fdf6352ccd5e34548db35e" id="r_ac9641dd947fdf6352ccd5e34548db35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9641dd947fdf6352ccd5e34548db35e">boxes_overlap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac9641dd947fdf6352ccd5e34548db35e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a could possibly overlap box b.  <br /></td></tr>
<tr class="separator:ac9641dd947fdf6352ccd5e34548db35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86d8a9b260b097d115182e4b8488f09" id="r_af86d8a9b260b097d115182e4b8488f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af86d8a9b260b097d115182e4b8488f09">box_union</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:af86d8a9b260b097d115182e4b8488f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of two boxes.  <br /></td></tr>
<tr class="separator:af86d8a9b260b097d115182e4b8488f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57c8cff1c0ff811a01724b58086bdc" id="r_a8c57c8cff1c0ff811a01724b58086bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c57c8cff1c0ff811a01724b58086bdc">box_intersection</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a8c57c8cff1c0ff811a01724b58086bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intersection of two boxes.  <br /></td></tr>
<tr class="separator:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198438916c78b87c90e665d665a18cd" id="r_a9198438916c78b87c90e665d665a18cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9198438916c78b87c90e665d665a18cd">box_contains</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a9198438916c78b87c90e665d665a18cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a provably contains box b.  <br /></td></tr>
<tr class="separator:a9198438916c78b87c90e665d665a18cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06242669df2b37e586deb5740de64b2" id="r_ad06242669df2b37e586deb5740de64b2"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad06242669df2b37e586deb5740de64b2">boxes_required</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:ad06242669df2b37e586deb5740de64b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression.  <br /></td></tr>
<tr class="separator:ad06242669df2b37e586deb5740de64b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4af1849bf39d9530f6e37a8a1c478fc" id="r_ae4af1849bf39d9530f6e37a8a1c478fc"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4af1849bf39d9530f6e37a8a1c478fc">boxes_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:ae4af1849bf39d9530f6e37a8a1c478fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8a3b4956c0e75a82926667995f658e" id="r_a8a8a3b4956c0e75a82926667995f658e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a8a3b4956c0e75a82926667995f658e">boxes_provided</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a8a8a3b4956c0e75a82926667995f658e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <br /></td></tr>
<tr class="separator:a8a8a3b4956c0e75a82926667995f658e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535b6fbb514f724d8df850efeaaea0bd" id="r_a535b6fbb514f724d8df850efeaaea0bd"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a535b6fbb514f724d8df850efeaaea0bd">boxes_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a535b6fbb514f724d8df850efeaaea0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836aabb32682c2147c8780c6dd9bffa8" id="r_a836aabb32682c2147c8780c6dd9bffa8"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a836aabb32682c2147c8780c6dd9bffa8">boxes_touched</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a836aabb32682c2147c8780c6dd9bffa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <br /></td></tr>
<tr class="separator:a836aabb32682c2147c8780c6dd9bffa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f6aa1329d6c1141e5f8557b243c7f7" id="r_aa3f6aa1329d6c1141e5f8557b243c7f7"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f6aa1329d6c1141e5f8557b243c7f7">boxes_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:aa3f6aa1329d6c1141e5f8557b243c7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6463d6b6c8c2d39485ca75d70bf7b246" id="r_a6463d6b6c8c2d39485ca75d70bf7b246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6463d6b6c8c2d39485ca75d70bf7b246">box_required</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a6463d6b6c8c2d39485ca75d70bf7b246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <br /></td></tr>
<tr class="separator:a6463d6b6c8c2d39485ca75d70bf7b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9b1c2da827d6cb5394a0bb7e34533" id="r_a98c9b1c2da827d6cb5394a0bb7e34533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98c9b1c2da827d6cb5394a0bb7e34533">box_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a98c9b1c2da827d6cb5394a0bb7e34533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48514c5115221230858e6e5b8584877" id="r_ae48514c5115221230858e6e5b8584877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae48514c5115221230858e6e5b8584877">box_provided</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:ae48514c5115221230858e6e5b8584877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f44cfeb8474bb0aaa36e526fd65e35" id="r_a48f44cfeb8474bb0aaa36e526fd65e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48f44cfeb8474bb0aaa36e526fd65e35">box_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a48f44cfeb8474bb0aaa36e526fd65e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b563d3cf1a063d9c85a584f796d032" id="r_aa4b563d3cf1a063d9c85a584f796d032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4b563d3cf1a063d9c85a584f796d032">box_touched</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:aa4b563d3cf1a063d9c85a584f796d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3eadf5a7fa994f622e31c373bcf3d3" id="r_a6d3eadf5a7fa994f622e31c373bcf3d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d3eadf5a7fa994f622e31c373bcf3d3">box_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a6d3eadf5a7fa994f622e31c373bcf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b807d0d1524fb2f20b1533d05032c02" id="r_a0b807d0d1524fb2f20b1533d05032c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b807d0d1524fb2f20b1533d05032c02">compute_function_value_bounds</a> (const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0b807d0d1524fb2f20b1533d05032c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum and minimum possible value for each function in an environment.  <br /></td></tr>
<tr class="separator:a0b807d0d1524fb2f20b1533d05032c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8f095ebce4f6ea07a0dd3ec7bbdb77" id="r_a9b8f095ebce4f6ea07a0dd3ec7bbdb77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8f095ebce4f6ea07a0dd3ec7bbdb77">span_of_bounds</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;bounds)</td></tr>
<tr class="separator:a9b8f095ebce4f6ea07a0dd3ec7bbdb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ef9127bf30f5e2a67963eb8db0323" id="r_a439ef9127bf30f5e2a67963eb8db0323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a439ef9127bf30f5e2a67963eb8db0323">bounds_test</a> ()</td></tr>
<tr class="separator:a439ef9127bf30f5e2a67963eb8db0323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff79174f5ffa82cd2af8a447439d3c3d" id="r_aff79174f5ffa82cd2af8a447439d3c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff79174f5ffa82cd2af8a447439d3c3d">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;<a class="el" href="#a16182ff30077d1ecfc92f992ff2faccc">realization_order</a>, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;fused_groups, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:aff79174f5ffa82cd2af8a447439d3c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <br /></td></tr>
<tr class="separator:aff79174f5ffa82cd2af8a447439d3c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7428f5e071a4f8c2d89a79afc6b426a0" id="r_a7428f5e071a4f8c2d89a79afc6b426a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7428f5e071a4f8c2d89a79afc6b426a0">bound_small_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="separator:a7428f5e071a4f8c2d89a79afc6b426a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58338c6b3553965f8360efe1d31788" id="r_a9b58338c6b3553965f8360efe1d31788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b58338c6b3553965f8360efe1d31788">buffer_accessor</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;buf, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a9b58338c6b3553965f8360efe1d31788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefca0281fde1b4caf8d1d188d4bd809d" id="r_aefca0281fde1b4caf8d1d188d4bd809d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_convertible&lt;T, std::string&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefca0281fde1b4caf8d1d188d4bd809d">get_name_from_end_of_parameter_pack</a> (T &amp;&amp;)</td></tr>
<tr class="separator:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3480ee712c4aecb9425a7e5c540889f" id="r_ae3480ee712c4aecb9425a7e5c540889f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3480ee712c4aecb9425a7e5c540889f">get_name_from_end_of_parameter_pack</a> (const std::string &amp;n)</td></tr>
<tr class="separator:ae3480ee712c4aecb9425a7e5c540889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a8762a4f14a3d708461f0d1616bc2" id="r_a016a8762a4f14a3d708461f0d1616bc2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a016a8762a4f14a3d708461f0d1616bc2">get_name_from_end_of_parameter_pack</a> ()</td></tr>
<tr class="separator:a016a8762a4f14a3d708461f0d1616bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ab4586f42653c6b16a6e0ad186f1e5" id="r_a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Args&gt; </td></tr>
<tr class="memitem:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70ab4586f42653c6b16a6e0ad186f1e5">get_name_from_end_of_parameter_pack</a> (First first, Second second, Args &amp;&amp;...rest)</td></tr>
<tr class="separator:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab882d8987fcdb737d28066db1130b509" id="r_ab882d8987fcdb737d28066db1130b509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab882d8987fcdb737d28066db1130b509">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="separator:ab882d8987fcdb737d28066db1130b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d23994d86bd76a8167c6144f3a3dc" id="r_a352d23994d86bd76a8167c6144f3a3dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a352d23994d86bd76a8167c6144f3a3dc">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;)</td></tr>
<tr class="separator:a352d23994d86bd76a8167c6144f3a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc82b2d635d098a40d4b87018edd0a73" id="r_afc82b2d635d098a40d4b87018edd0a73"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afc82b2d635d098a40d4b87018edd0a73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc82b2d635d098a40d4b87018edd0a73">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;result, int x, Args &amp;&amp;...rest)</td></tr>
<tr class="separator:afc82b2d635d098a40d4b87018edd0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274816d577057576634316a33e721fa6" id="r_a274816d577057576634316a33e721fa6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a274816d577057576634316a33e721fa6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a274816d577057576634316a33e721fa6">get_shape_from_start_of_parameter_pack</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a274816d577057576634316a33e721fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844f5db8861adba47dc2dc0e38666407" id="r_a844f5db8861adba47dc2dc0e38666407"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a844f5db8861adba47dc2dc0e38666407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a844f5db8861adba47dc2dc0e38666407">buffer_type_name_non_const</a> (std::ostream &amp;s)</td></tr>
<tr class="separator:a844f5db8861adba47dc2dc0e38666407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f55fb27359093d52c4c4447db053edc" id="r_a7f55fb27359093d52c4c4447db053edc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7f55fb27359093d52c4c4447db053edc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f55fb27359093d52c4c4447db053edc">buffer_type_name_non_const&lt; void &gt;</a> (std::ostream &amp;s)</td></tr>
<tr class="separator:a7f55fb27359093d52c4c4447db053edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14638fa4f1475b6b6acb22a9419afea" id="r_ab14638fa4f1475b6b6acb22a9419afea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab14638fa4f1475b6b6acb22a9419afea"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab14638fa4f1475b6b6acb22a9419afea">buffer_type_name</a> ()</td></tr>
<tr class="separator:ab14638fa4f1475b6b6acb22a9419afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefe960250b26cc13e38cb734803057" id="r_a5eefe960250b26cc13e38cb734803057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eefe960250b26cc13e38cb734803057">canonicalize_gpu_vars</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a5eefe960250b26cc13e38cb734803057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize GPU var names into some pre-determined block/thread names (i.e.  <br /></td></tr>
<tr class="separator:a5eefe960250b26cc13e38cb734803057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1439caec64a653845e9e5b54451cf04" id="r_af1439caec64a653845e9e5b54451cf04"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1439caec64a653845e9e5b54451cf04">gpu_thread_name</a> (int index)</td></tr>
<tr class="memdesc:af1439caec64a653845e9e5b54451cf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Names for the thread and block id variables.  <br /></td></tr>
<tr class="separator:af1439caec64a653845e9e5b54451cf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26df9ce0b1c15dbac336657403c9e283" id="r_a26df9ce0b1c15dbac336657403c9e283"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26df9ce0b1c15dbac336657403c9e283">gpu_block_name</a> (int index)</td></tr>
<tr class="separator:a26df9ce0b1c15dbac336657403c9e283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3151a74eb9c7d9f02bcef32d445e46" id="r_a7c3151a74eb9c7d9f02bcef32d445e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c3151a74eb9c7d9f02bcef32d445e46">clamp_unsafe_accesses</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds)</td></tr>
<tr class="memdesc:a7c3151a74eb9c7d9f02bcef32d445e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject clamps around func calls h(...) when all the following conditions hold:  <br /></td></tr>
<tr class="separator:a7c3151a74eb9c7d9f02bcef32d445e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111cc33bcb7f01e11e82e552dea299e3" id="r_a111cc33bcb7f01e11e82e552dea299e3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a111cc33bcb7f01e11e82e552dea299e3">new_CodeGen_D3D12Compute_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a111cc33bcb7f01e11e82e552dea299e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979a66a6c1d81f22528e9b996970568c" id="r_a979a66a6c1d81f22528e9b996970568c"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a979a66a6c1d81f22528e9b996970568c">get_vector_element_type</a> (llvm::Type *)</td></tr>
<tr class="memdesc:a979a66a6c1d81f22528e9b996970568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scalar type of an llvm vector type.  <br /></td></tr>
<tr class="separator:a979a66a6c1d81f22528e9b996970568c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc60421b682a09ea4c4dcaaaa3e105e2" id="r_adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc60421b682a09ea4c4dcaaaa3e105e2">function_takes_user_context</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which built-in functions require a user-context first argument?  <br /></td></tr>
<tr class="separator:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abe6b887804e86f403f0af16d5a2ba1" id="r_a4abe6b887804e86f403f0af16d5a2ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4abe6b887804e86f403f0af16d5a2ba1">can_allocation_fit_on_stack</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr class="memdesc:a4abe6b887804e86f403f0af16d5a2ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False.  <br /></td></tr>
<tr class="separator:a4abe6b887804e86f403f0af16d5a2ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234c39a0f1f0d90412f454dca60cddc0" id="r_a234c39a0f1f0d90412f454dca60cddc0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a234c39a0f1f0d90412f454dca60cddc0">long_div_mod_round_to_zero</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, std::optional&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &gt; max_abs=std::nullopt)</td></tr>
<tr class="memdesc:a234c39a0f1f0d90412f454dca60cddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a {div/mod}_round_to_zero using binary long division for int/uint.  <br /></td></tr>
<tr class="separator:a234c39a0f1f0d90412f454dca60cddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a110889396502096d2b5e3995734ef6" id="r_a7a110889396502096d2b5e3995734ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a110889396502096d2b5e3995734ef6">lower_mux</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *<a class="el" href="namespace_halide.html#a6872ea25baf89339321f85340ed48c14">mux</a>)</td></tr>
<tr class="memdesc:a7a110889396502096d2b5e3995734ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a mux intrinsic to a select tree.  <br /></td></tr>
<tr class="separator:a7a110889396502096d2b5e3995734ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc739e6b8e85830218314de3e9805476" id="r_acc739e6b8e85830218314de3e9805476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc739e6b8e85830218314de3e9805476">lower_round_to_nearest_ties_to_even</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:acc739e6b8e85830218314de3e9805476"><td class="mdescLeft">&#160;</td><td class="mdescRight">An vectorizable implementation of <a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe" title="Return the whole number closest to a floating-point expression.">Halide::round</a> that doesn't depend on any standard library being present.  <br /></td></tr>
<tr class="separator:acc739e6b8e85830218314de3e9805476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdf83ff7a22966e4055a11ab6cad5ed" id="r_adcdf83ff7a22966e4055a11ab6cad5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcdf83ff7a22966e4055a11ab6cad5ed">get_target_options</a> (const llvm::Module &amp;module, llvm::TargetOptions &amp;options)</td></tr>
<tr class="memdesc:adcdf83ff7a22966e4055a11ab6cad5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, set llvm:TargetOptions information.  <br /></td></tr>
<tr class="separator:adcdf83ff7a22966e4055a11ab6cad5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b16d175882e16f544bf4bf92ec931b5" id="r_a1b16d175882e16f544bf4bf92ec931b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b16d175882e16f544bf4bf92ec931b5">clone_target_options</a> (const llvm::Module &amp;from, llvm::Module &amp;to)</td></tr>
<tr class="memdesc:a1b16d175882e16f544bf4bf92ec931b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two llvm::Modules, clone target options from one to the other.  <br /></td></tr>
<tr class="separator:a1b16d175882e16f544bf4bf92ec931b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b22ce8e56396b149f8b733f5ca50f" id="r_aaf3b22ce8e56396b149f8b733f5ca50f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::TargetMachine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf3b22ce8e56396b149f8b733f5ca50f">make_target_machine</a> (const llvm::Module &amp;module)</td></tr>
<tr class="memdesc:aaf3b22ce8e56396b149f8b733f5ca50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, get or create an llvm:TargetMachine.  <br /></td></tr>
<tr class="separator:aaf3b22ce8e56396b149f8b733f5ca50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa0254caf56536ecb7df5d16554b555" id="r_a0fa0254caf56536ecb7df5d16554b555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa0254caf56536ecb7df5d16554b555">set_function_attributes_from_halide_target_options</a> (llvm::Function &amp;)</td></tr>
<tr class="memdesc:a0fa0254caf56536ecb7df5d16554b555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> attributes given the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>.  <br /></td></tr>
<tr class="separator:a0fa0254caf56536ecb7df5d16554b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fd598253847fcd510e32b107aeb2f3" id="r_a36fd598253847fcd510e32b107aeb2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36fd598253847fcd510e32b107aeb2f3">embed_bitcode</a> (llvm::Module *M, const std::string &amp;halide_command)</td></tr>
<tr class="memdesc:a36fd598253847fcd510e32b107aeb2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a copy of the llvm IR currently represented by the module as data in the __LLVM,__bitcode section.  <br /></td></tr>
<tr class="separator:a36fd598253847fcd510e32b107aeb2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285c6a355dd43fb4eae87548b5841548" id="r_a285c6a355dd43fb4eae87548b5841548"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285c6a355dd43fb4eae87548b5841548">new_CodeGen_Metal_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a285c6a355dd43fb4eae87548b5841548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4bf60d96cab45e7145ca44a8542d0a" id="r_a0c4bf60d96cab45e7145ca44a8542d0a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4bf60d96cab45e7145ca44a8542d0a">new_CodeGen_OpenCL_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a0c4bf60d96cab45e7145ca44a8542d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dd25060fd735a84357d75f67c345c8" id="r_ae3dd25060fd735a84357d75f67c345c8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3dd25060fd735a84357d75f67c345c8">new_CodeGen_PTX_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:ae3dd25060fd735a84357d75f67c345c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab446ce0e3637ad7e9006c93022200a4c" id="r_ab446ce0e3637ad7e9006c93022200a4c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab446ce0e3637ad7e9006c93022200a4c">new_CodeGen_ARM</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ab446ce0e3637ad7e9006c93022200a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct CodeGen object for a variety of targets.  <br /></td></tr>
<tr class="separator:ab446ce0e3637ad7e9006c93022200a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f72a928bf2d91cfba4dfc1046cfa3ae" id="r_a3f72a928bf2d91cfba4dfc1046cfa3ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f72a928bf2d91cfba4dfc1046cfa3ae">new_CodeGen_Hexagon</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a3f72a928bf2d91cfba4dfc1046cfa3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78c445df369d9606ab540cff1a85ebd" id="r_af78c445df369d9606ab540cff1a85ebd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af78c445df369d9606ab540cff1a85ebd">new_CodeGen_PowerPC</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:af78c445df369d9606ab540cff1a85ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa119b1d9cb91d6b0a7a94e9fd17ec" id="r_a43fa119b1d9cb91d6b0a7a94e9fd17ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43fa119b1d9cb91d6b0a7a94e9fd17ec">new_CodeGen_RISCV</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a43fa119b1d9cb91d6b0a7a94e9fd17ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377069a6a413445be03054d91043de25" id="r_a377069a6a413445be03054d91043de25"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a377069a6a413445be03054d91043de25">new_CodeGen_X86</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a377069a6a413445be03054d91043de25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab096d5698556bf5900c1a54f4f4919e2" id="r_ab096d5698556bf5900c1a54f4f4919e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab096d5698556bf5900c1a54f4f4919e2">new_CodeGen_WebAssembly</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:ab096d5698556bf5900c1a54f4f4919e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33af520f7d407be6c1418b63885cbda7" id="r_a33af520f7d407be6c1418b63885cbda7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33af520f7d407be6c1418b63885cbda7">new_CodeGen_Vulkan_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a33af520f7d407be6c1418b63885cbda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94c47fa0c540277b9eccf0c8c61b3b2" id="r_aa94c47fa0c540277b9eccf0c8c61b3b2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa94c47fa0c540277b9eccf0c8c61b3b2">new_CodeGen_WebGPU_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:aa94c47fa0c540277b9eccf0c8c61b3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe83125b8be0309eb52d612706da1e" id="r_a04fe83125b8be0309eb52d612706da1e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04fe83125b8be0309eb52d612706da1e">set_compiler_logger</a> (std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt; compiler_logger)</td></tr>
<tr class="memdesc:a04fe83125b8be0309eb52d612706da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object, replacing any existing one.  <br /></td></tr>
<tr class="separator:a04fe83125b8be0309eb52d612706da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ec914dec8d50c32639aec31f38285" id="r_adc3ec914dec8d50c32639aec31f38285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc3ec914dec8d50c32639aec31f38285">get_compiler_logger</a> ()</td></tr>
<tr class="memdesc:adc3ec914dec8d50c32639aec31f38285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object.  <br /></td></tr>
<tr class="separator:adc3ec914dec8d50c32639aec31f38285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912ff057c46bcc6010cb73a32da15bb4" id="r_a912ff057c46bcc6010cb73a32da15bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a912ff057c46bcc6010cb73a32da15bb4">constant_integer_bounds</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt;::empty_scope(), std::map&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>, <a class="el" href="struct_halide_1_1_expr_compare.html">ExprCompare</a> &gt; *cache=nullptr)</td></tr>
<tr class="memdesc:a912ff057c46bcc6010cb73a32da15bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce constant integer bounds on an expression.  <br /></td></tr>
<tr class="separator:a912ff057c46bcc6010cb73a32da15bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92669b308fbca96c8eb735abe84be0a3" id="r_a92669b308fbca96c8eb735abe84be0a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92669b308fbca96c8eb735abe84be0a3">operator+</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="memdesc:a92669b308fbca96c8eb735abe84be0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic operators on ConstantIntervals.  <br /></td></tr>
<tr class="separator:a92669b308fbca96c8eb735abe84be0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2e6104ca77d5871f561e41c2a75c42" id="r_afe2e6104ca77d5871f561e41c2a75c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe2e6104ca77d5871f561e41c2a75c42">operator+</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:afe2e6104ca77d5871f561e41c2a75c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e21c111cd68481735b95e47fc3db9c" id="r_a81e21c111cd68481735b95e47fc3db9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81e21c111cd68481735b95e47fc3db9c">operator-</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a81e21c111cd68481735b95e47fc3db9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4dd3fc8b69826ce624e7fa7debf6d" id="r_a9bd4dd3fc8b69826ce624e7fa7debf6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bd4dd3fc8b69826ce624e7fa7debf6d">operator-</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9bd4dd3fc8b69826ce624e7fa7debf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aa3e21bfb2956a4db1a8991961f8f1" id="r_a77aa3e21bfb2956a4db1a8991961f8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77aa3e21bfb2956a4db1a8991961f8f1">operator/</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a77aa3e21bfb2956a4db1a8991961f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cf4bba76bed4a2d53717d0613e255f" id="r_af6cf4bba76bed4a2d53717d0613e255f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cf4bba76bed4a2d53717d0613e255f">operator/</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:af6cf4bba76bed4a2d53717d0613e255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055285f67268b5e556780587ecf465a1" id="r_a055285f67268b5e556780587ecf465a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a055285f67268b5e556780587ecf465a1">operator*</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a055285f67268b5e556780587ecf465a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad834081c5e1d711413349f2c0603fbe3" id="r_ad834081c5e1d711413349f2c0603fbe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad834081c5e1d711413349f2c0603fbe3">operator*</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:ad834081c5e1d711413349f2c0603fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a12585a7cc096074cbf08af93a7ffb6" id="r_a3a12585a7cc096074cbf08af93a7ffb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a12585a7cc096074cbf08af93a7ffb6">operator%</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a3a12585a7cc096074cbf08af93a7ffb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7407909cc8b2551de2ab93fac3cc27c" id="r_ad7407909cc8b2551de2ab93fac3cc27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7407909cc8b2551de2ab93fac3cc27c">operator%</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:ad7407909cc8b2551de2ab93fac3cc27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d5010a34ae900ef4f855ee5420a923" id="r_a41d5010a34ae900ef4f855ee5420a923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d5010a34ae900ef4f855ee5420a923">min</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a41d5010a34ae900ef4f855ee5420a923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0978acb21de1206dcb04a4ec81f75548" id="r_a0978acb21de1206dcb04a4ec81f75548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0978acb21de1206dcb04a4ec81f75548">min</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a0978acb21de1206dcb04a4ec81f75548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e34906118319ac8ae12858ba6faf5b" id="r_a60e34906118319ac8ae12858ba6faf5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60e34906118319ac8ae12858ba6faf5b">max</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a60e34906118319ac8ae12858ba6faf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2d36dcc5dd64521f4478ed8bae725" id="r_ac5b2d36dcc5dd64521f4478ed8bae725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5b2d36dcc5dd64521f4478ed8bae725">max</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:ac5b2d36dcc5dd64521f4478ed8bae725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1afa23d45af239fce2e9679f5b0ec5" id="r_ada1afa23d45af239fce2e9679f5b0ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1afa23d45af239fce2e9679f5b0ec5">abs</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a)</td></tr>
<tr class="separator:ada1afa23d45af239fce2e9679f5b0ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6ffc605e9727100d4c1530346a142" id="r_ab3f6ffc605e9727100d4c1530346a142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f6ffc605e9727100d4c1530346a142">operator&lt;&lt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:ab3f6ffc605e9727100d4c1530346a142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7130963c67bad2e41b3812d990f2dcea" id="r_a7130963c67bad2e41b3812d990f2dcea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7130963c67bad2e41b3812d990f2dcea">operator&lt;&lt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a7130963c67bad2e41b3812d990f2dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051243ea3642a3cbaef2dcd8d65b0c81" id="r_a051243ea3642a3cbaef2dcd8d65b0c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a051243ea3642a3cbaef2dcd8d65b0c81">operator&lt;&lt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a051243ea3642a3cbaef2dcd8d65b0c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28db82ad42721d89dc2759d9efa40b36" id="r_a28db82ad42721d89dc2759d9efa40b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28db82ad42721d89dc2759d9efa40b36">operator&gt;&gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a28db82ad42721d89dc2759d9efa40b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f5e8e18b145d9a4effb5fadfd7788" id="r_a189f5e8e18b145d9a4effb5fadfd7788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a189f5e8e18b145d9a4effb5fadfd7788">operator&gt;&gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a189f5e8e18b145d9a4effb5fadfd7788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea396032a9365b9f0cb602e3a75daa4a" id="r_aea396032a9365b9f0cb602e3a75daa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea396032a9365b9f0cb602e3a75daa4a">operator&gt;&gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:aea396032a9365b9f0cb602e3a75daa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac893cdcea474d9026e9b70a7025d94c4" id="r_ac893cdcea474d9026e9b70a7025d94c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac893cdcea474d9026e9b70a7025d94c4">operator&lt;=</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="memdesc:ac893cdcea474d9026e9b70a7025d94c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operators on ConstantIntervals.  <br /></td></tr>
<tr class="separator:ac893cdcea474d9026e9b70a7025d94c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d576493933c11e526d4dc6dbb84111" id="r_a77d576493933c11e526d4dc6dbb84111"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77d576493933c11e526d4dc6dbb84111">operator&lt;=</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a77d576493933c11e526d4dc6dbb84111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4fc61bc2d91bc44b936e36892dff1c" id="r_aed4fc61bc2d91bc44b936e36892dff1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4fc61bc2d91bc44b936e36892dff1c">operator&lt;=</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:aed4fc61bc2d91bc44b936e36892dff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e6907eb71719c21550de578bc3f1ae" id="r_a86e6907eb71719c21550de578bc3f1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86e6907eb71719c21550de578bc3f1ae">operator&lt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a86e6907eb71719c21550de578bc3f1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223e00fe33173430eb29414b47d12dfa" id="r_a223e00fe33173430eb29414b47d12dfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a223e00fe33173430eb29414b47d12dfa">operator&lt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a223e00fe33173430eb29414b47d12dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b93d80d505efcfda82487b5cb025d7" id="r_ab8b93d80d505efcfda82487b5cb025d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8b93d80d505efcfda82487b5cb025d7">operator&lt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:ab8b93d80d505efcfda82487b5cb025d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ebd06b19c2a372ed04fc5029d872d" id="r_a1d9ebd06b19c2a372ed04fc5029d872d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d9ebd06b19c2a372ed04fc5029d872d">operator&gt;=</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a1d9ebd06b19c2a372ed04fc5029d872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad674d5fe674999b2287b27f750ea9f0c" id="r_ad674d5fe674999b2287b27f750ea9f0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad674d5fe674999b2287b27f750ea9f0c">operator&gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:ad674d5fe674999b2287b27f750ea9f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a23f9536c013fd60d882aee7ca21383" id="r_a5a23f9536c013fd60d882aee7ca21383"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a23f9536c013fd60d882aee7ca21383">operator&gt;=</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a5a23f9536c013fd60d882aee7ca21383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b7eed41d4ce4dfcccdf845a1662f2" id="r_a4b2b7eed41d4ce4dfcccdf845a1662f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b2b7eed41d4ce4dfcccdf845a1662f2">operator&gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a4b2b7eed41d4ce4dfcccdf845a1662f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805040b1b432becfb2fc18487b632473" id="r_a805040b1b432becfb2fc18487b632473"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a805040b1b432becfb2fc18487b632473">operator&gt;=</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:a805040b1b432becfb2fc18487b632473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbacc8f24707096d3d98f6ea77a5f659" id="r_adbacc8f24707096d3d98f6ea77a5f659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbacc8f24707096d3d98f6ea77a5f659">operator&gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;b)</td></tr>
<tr class="separator:adbacc8f24707096d3d98f6ea77a5f659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9170638fdb8e1cb975e1ff7fb561a560" id="r_a9170638fdb8e1cb975e1ff7fb561a560"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9170638fdb8e1cb975e1ff7fb561a560">cplusplus_function_mangled_name</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;namespaces, <a class="el" href="struct_halide_1_1_type.html">Type</a> return_type, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;args, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a9170638fdb8e1cb975e1ff7fb561a560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mangled C++ name for a function.  <br /></td></tr>
<tr class="separator:a9170638fdb8e1cb975e1ff7fb561a560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d63fc361474a95f58c2839461cc7df" id="r_a67d63fc361474a95f58c2839461cc7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d63fc361474a95f58c2839461cc7df">cplusplus_mangle_test</a> ()</td></tr>
<tr class="separator:a67d63fc361474a95f58c2839461cc7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2af44447b9269918e9d63d948ea8bd" id="r_a5f2af44447b9269918e9d63d948ea8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f2af44447b9269918e9d63d948ea8bd">common_subexpression_elimination</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;, bool lift_all=false)</td></tr>
<tr class="memdesc:a5f2af44447b9269918e9d63d948ea8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <br /></td></tr>
<tr class="separator:a5f2af44447b9269918e9d63d948ea8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03dcb48bcb8e81238a1c6cfea195e1a" id="r_ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac03dcb48bcb8e81238a1c6cfea195e1a">common_subexpression_elimination</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;, bool lift_all=false)</td></tr>
<tr class="memdesc:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <br /></td></tr>
<tr class="separator:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cbc086e9926046bdb9f4ade681111a" id="r_a88cbc086e9926046bdb9f4ade681111a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88cbc086e9926046bdb9f4ade681111a">cse_test</a> ()</td></tr>
<tr class="separator:a88cbc086e9926046bdb9f4ade681111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98f0a702bd775e67baed5bcd986ae27" id="r_ab98f0a702bd775e67baed5bcd986ae27"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab98f0a702bd775e67baed5bcd986ae27">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:ab98f0a702bd775e67baed5bcd986ae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <br /></td></tr>
<tr class="separator:ab98f0a702bd775e67baed5bcd986ae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029791644c90ea7a194d58fc87ab41bf" id="r_a029791644c90ea7a194d58fc87ab41bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a029791644c90ea7a194d58fc87ab41bf">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;)</td></tr>
<tr class="memdesc:a029791644c90ea7a194d58fc87ab41bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> in a human readable format.  <br /></td></tr>
<tr class="separator:a029791644c90ea7a194d58fc87ab41bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbba1897af954502671d8f3b831c8a6a" id="r_acbba1897af954502671d8f3b831c8a6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbba1897af954502671d8f3b831c8a6a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acbba1897af954502671d8f3b831c8a6a">PrintSpan</a> (const T &amp;) -&gt; PrintSpan&lt; T &gt;</td></tr>
<tr class="separator:acbba1897af954502671d8f3b831c8a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad8dccc6a0450dc6d0acabbdd72f7b9" id="r_a0ad8dccc6a0450dc6d0acabbdd72f7b9"><td class="memTemplParams" colspan="2">template&lt;typename StreamT , typename T &gt; </td></tr>
<tr class="memitem:a0ad8dccc6a0450dc6d0acabbdd72f7b9"><td class="memTemplItemLeft" align="right" valign="top">StreamT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ad8dccc6a0450dc6d0acabbdd72f7b9">operator&lt;&lt;</a> (StreamT &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_print_span.html">PrintSpan</a>&lt; T &gt; &amp;wrapper)</td></tr>
<tr class="separator:a0ad8dccc6a0450dc6d0acabbdd72f7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1021cbfec3656d88b8ef964c301d258" id="r_aa1021cbfec3656d88b8ef964c301d258"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1021cbfec3656d88b8ef964c301d258"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1021cbfec3656d88b8ef964c301d258">PrintSpanLn</a> (const T &amp;) -&gt; PrintSpanLn&lt; T &gt;</td></tr>
<tr class="separator:aa1021cbfec3656d88b8ef964c301d258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4423b8304272bfe7d448d568ff80ebe1" id="r_a4423b8304272bfe7d448d568ff80ebe1"><td class="memTemplParams" colspan="2">template&lt;typename StreamT , typename T &gt; </td></tr>
<tr class="memitem:a4423b8304272bfe7d448d568ff80ebe1"><td class="memTemplItemLeft" align="right" valign="top">StreamT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4423b8304272bfe7d448d568ff80ebe1">operator&lt;&lt;</a> (StreamT &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_print_span_ln.html">PrintSpanLn</a>&lt; T &gt; &amp;wrapper)</td></tr>
<tr class="separator:a4423b8304272bfe7d448d568ff80ebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866d7f181b8a337d445a1df28de18384" id="r_a866d7f181b8a337d445a1df28de18384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a866d7f181b8a337d445a1df28de18384">debug_arguments</a> (<a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> *func, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a866d7f181b8a337d445a1df28de18384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects debug prints in a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> that describe the target and arguments.  <br /></td></tr>
<tr class="separator:a866d7f181b8a337d445a1df28de18384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2b563fa94726a65b596979b9d2f85" id="r_aaea2b563fa94726a65b596979b9d2f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaea2b563fa94726a65b596979b9d2f85">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aaea2b563fa94726a65b596979b9d2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered.  <br /></td></tr>
<tr class="separator:aaea2b563fa94726a65b596979b9d2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949dd909bf5d0b5aadc590c5dd2a61d0" id="r_a949dd909bf5d0b5aadc590c5dd2a61d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a949dd909bf5d0b5aadc590c5dd2a61d0">extract_odd_lanes</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="memdesc:a949dd909bf5d0b5aadc590c5dd2a61d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <br /></td></tr>
<tr class="separator:a949dd909bf5d0b5aadc590c5dd2a61d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52cdf2d45822985407927e4a553dbe8" id="r_ad52cdf2d45822985407927e4a553dbe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad52cdf2d45822985407927e4a553dbe8">extract_even_lanes</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="memdesc:ad52cdf2d45822985407927e4a553dbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <br /></td></tr>
<tr class="separator:ad52cdf2d45822985407927e4a553dbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fea986b372b2a3932ae617ca62116d" id="r_a24fea986b372b2a3932ae617ca62116d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24fea986b372b2a3932ae617ca62116d">extract_lane</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;vec, int lane)</td></tr>
<tr class="memdesc:a24fea986b372b2a3932ae617ca62116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <br /></td></tr>
<tr class="separator:a24fea986b372b2a3932ae617ca62116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba806ef5f80bcc7ad6905f7789906cd" id="r_acba806ef5f80bcc7ad6905f7789906cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba806ef5f80bcc7ad6905f7789906cd">rewrite_interleavings</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:acba806ef5f80bcc7ad6905f7789906cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <br /></td></tr>
<tr class="separator:acba806ef5f80bcc7ad6905f7789906cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc1b0ff156c8b0ca5fd26956ee482a9" id="r_a8dc1b0ff156c8b0ca5fd26956ee482a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dc1b0ff156c8b0ca5fd26956ee482a9">deinterleave_vector_test</a> ()</td></tr>
<tr class="separator:a8dc1b0ff156c8b0ca5fd26956ee482a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d3c39b97b822e2c3e50a1c977441aa" id="r_aa8d3c39b97b822e2c3e50a1c977441aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8d3c39b97b822e2c3e50a1c977441aa">remove_let_definitions</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all let definitions of expr.  <br /></td></tr>
<tr class="separator:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d22fd92b955a2c3acba3667a98a71" id="r_a183d22fd92b955a2c3acba3667a98a71"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183d22fd92b955a2c3acba3667a98a71">gather_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::vector&lt; std::string &gt; &amp;filter)</td></tr>
<tr class="memdesc:a183d22fd92b955a2c3acba3667a98a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of variables' indices that expr depends on and are in the filter.  <br /></td></tr>
<tr class="separator:a183d22fd92b955a2c3acba3667a98a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a098fb2be362edf25fbd143941d338" id="r_a56a098fb2be362edf25fbd143941d338"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56a098fb2be362edf25fbd143941d338">gather_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;filter)</td></tr>
<tr class="separator:a56a098fb2be362edf25fbd143941d338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94009170105d2109c42128558cbb8025" id="r_a94009170105d2109c42128558cbb8025"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94009170105d2109c42128558cbb8025">gather_rvariables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a94009170105d2109c42128558cbb8025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad561cb6a78a9aee95f7f84f72b893fb3" id="r_ad561cb6a78a9aee95f7f84f72b893fb3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad561cb6a78a9aee95f7f84f72b893fb3">gather_rvariables</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;tuple)</td></tr>
<tr class="separator:ad561cb6a78a9aee95f7f84f72b893fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66032c9826d25bfa470c4c974081d5" id="r_a9b66032c9826d25bfa470c4c974081d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b66032c9826d25bfa470c4c974081d5">add_let_expression</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping, const std::vector&lt; std::string &gt; &amp;let_variables)</td></tr>
<tr class="memdesc:a9b66032c9826d25bfa470c4c974081d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> necessary let expressions to expr.  <br /></td></tr>
<tr class="separator:a9b66032c9826d25bfa470c4c974081d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441d4dafa32011fb68745cf2dc0edd70" id="r_a441d4dafa32011fb68745cf2dc0edd70"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a441d4dafa32011fb68745cf2dc0edd70">sort_expressions</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a441d4dafa32011fb68745cf2dc0edd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically sort the expression graph expressed by expr.  <br /></td></tr>
<tr class="separator:a441d4dafa32011fb68745cf2dc0edd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f51d01b47fe0ae71fcae1c7f1751e5a" id="r_a6f51d01b47fe0ae71fcae1c7f1751e5a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f51d01b47fe0ae71fcae1c7f1751e5a">inference_bounds</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;funcs, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;output_bounds)</td></tr>
<tr class="memdesc:a6f51d01b47fe0ae71fcae1c7f1751e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounds of funcs.  <br /></td></tr>
<tr class="separator:a6f51d01b47fe0ae71fcae1c7f1751e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16b7b3ca684e45e291f1aeaafa71d92" id="r_af16b7b3ca684e45e291f1aeaafa71d92"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af16b7b3ca684e45e291f1aeaafa71d92">inference_bounds</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;func, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;output_bounds)</td></tr>
<tr class="separator:af16b7b3ca684e45e291f1aeaafa71d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba9163fc25824f5bcd2600ca177ff64" id="r_a3ba9163fc25824f5bcd2600ca177ff64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ba9163fc25824f5bcd2600ca177ff64">box_to_vector</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;bounds)</td></tr>
<tr class="memdesc:a3ba9163fc25824f5bcd2600ca177ff64"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> <a class="el" href="struct_halide_1_1_internal_1_1_box.html" title="Represents the bounds of a region of arbitrary dimension.">Box</a> to vector of (min, extent)  <br /></td></tr>
<tr class="separator:a3ba9163fc25824f5bcd2600ca177ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d062e9354cd14001f47cd01e82b93a" id="r_a44d062e9354cd14001f47cd01e82b93a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44d062e9354cd14001f47cd01e82b93a">equal</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;bounds0, const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;bounds1)</td></tr>
<tr class="memdesc:a44d062e9354cd14001f47cd01e82b93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if bounds0 and bounds1 represent the same bounds.  <br /></td></tr>
<tr class="separator:a44d062e9354cd14001f47cd01e82b93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e106cdd351599c04f797fa4800e999c" id="r_a2e106cdd351599c04f797fa4800e999c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e106cdd351599c04f797fa4800e999c">vars_to_strings</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a2e106cdd351599c04f797fa4800e999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of variable names.  <br /></td></tr>
<tr class="separator:a2e106cdd351599c04f797fa4800e999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c20a455c5f2aed48623d012438b99d" id="r_a96c20a455c5f2aed48623d012438b99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96c20a455c5f2aed48623d012438b99d">extract_rdom</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a96c20a455c5f2aed48623d012438b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reduction domain used by expr.  <br /></td></tr>
<tr class="separator:a96c20a455c5f2aed48623d012438b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7cb31887777df4c2dc43b245a1f212" id="r_a8c7cb31887777df4c2dc43b245a1f212"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7cb31887777df4c2dc43b245a1f212">solve_inverse</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const std::string &amp;new_var, const std::string &amp;var)</td></tr>
<tr class="memdesc:a8c7cb31887777df4c2dc43b245a1f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">expr is new_var == f(var), solve for var == g(new_var) if multiple new_var corresponds to same var, introduce a <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>  <br /></td></tr>
<tr class="separator:a8c7cb31887777df4c2dc43b245a1f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a6aafa3b32bfb28cc454b60f96fe3a" id="r_a53a6aafa3b32bfb28cc454b60f96fe3a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53a6aafa3b32bfb28cc454b60f96fe3a">find_buffer_param_calls</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;func)</td></tr>
<tr class="separator:a53a6aafa3b32bfb28cc454b60f96fe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a602126292ec5996c54fee2442f89b" id="r_ab5a602126292ec5996c54fee2442f89b"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5a602126292ec5996c54fee2442f89b">find_implicit_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab5a602126292ec5996c54fee2442f89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all implicit variables in expr.  <br /></td></tr>
<tr class="separator:ab5a602126292ec5996c54fee2442f89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7c0a6c9d1ffb171d4343876021f604" id="r_aea7c0a6c9d1ffb171d4343876021f604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea7c0a6c9d1ffb171d4343876021f604">substitute_rdom_predicate</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aea7c0a6c9d1ffb171d4343876021f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the variable.  <br /></td></tr>
<tr class="separator:aea7c0a6c9d1ffb171d4343876021f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b228248e212d4e140a3b7499f65a8c4" id="r_a4b228248e212d4e140a3b7499f65a8c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b228248e212d4e140a3b7499f65a8c4">is_calling_function</a> (const std::string &amp;func_name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping)</td></tr>
<tr class="memdesc:a4b228248e212d4e140a3b7499f65a8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr contains call to func_name.  <br /></td></tr>
<tr class="separator:a4b228248e212d4e140a3b7499f65a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1be017ee388aad7a1cb19fa653e300" id="r_add1be017ee388aad7a1cb19fa653e300"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add1be017ee388aad7a1cb19fa653e300">is_calling_function</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping)</td></tr>
<tr class="memdesc:add1be017ee388aad7a1cb19fa653e300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr depends on any function or buffer.  <br /></td></tr>
<tr class="separator:add1be017ee388aad7a1cb19fa653e300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038d35b4053c243832706da480e78f80" id="r_a038d35b4053c243832706da480e78f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a038d35b4053c243832706da480e78f80">substitute_call_arg_with_pure_arg</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, int variable_id, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a038d35b4053c243832706da480e78f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces call to <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f in <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e such that the call argument at variable_id is the pure argument.  <br /></td></tr>
<tr class="separator:a038d35b4053c243832706da480e78f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb129e599eb08042ff95446b7e040233" id="r_adb129e599eb08042ff95446b7e040233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb129e599eb08042ff95446b7e040233">make_device_interface_call</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a> memory_type=<a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a06b9281e396db002010bde1de57262eb">MemoryType::Auto</a>)</td></tr>
<tr class="memdesc:adb129e599eb08042ff95446b7e040233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> which evaluates to the device interface for the given device api at runtime.  <br /></td></tr>
<tr class="separator:adb129e599eb08042ff95446b7e040233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8c5e751e4ac4a80ab5d2cd4538ebdd" id="r_add8c5e751e4ac4a80ab5d2cd4538ebdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add8c5e751e4ac4a80ab5d2cd4538ebdd">distribute_shifts</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>, bool multiply_adds)</td></tr>
<tr class="separator:add8c5e751e4ac4a80ab5d2cd4538ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4af08fdc8caf03891015c7dec4c8c9" id="r_a9a4af08fdc8caf03891015c7dec4c8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a4af08fdc8caf03891015c7dec4c8c9">inject_early_frees</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a9a4af08fdc8caf03891015c7dec4c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <br /></td></tr>
<tr class="separator:a9a4af08fdc8caf03891015c7dec4c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0747a9e54d0da5a37c1530162121942f" id="r_a0747a9e54d0da5a37c1530162121942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0747a9e54d0da5a37c1530162121942f">eliminated_bool_type</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> bool_type, <a class="el" href="struct_halide_1_1_type.html">Type</a> other_type)</td></tr>
<tr class="memdesc:a0747a9e54d0da5a37c1530162121942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors.  <br /></td></tr>
<tr class="separator:a0747a9e54d0da5a37c1530162121942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e1020025973b3e49f515e57e126d5" id="r_a860e1020025973b3e49f515e57e126d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a860e1020025973b3e49f515e57e126d5">is_float16_transcendental</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *)</td></tr>
<tr class="memdesc:a860e1020025973b3e49f515e57e126d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a call is a float16 transcendental (e.g.  <br /></td></tr>
<tr class="separator:a860e1020025973b3e49f515e57e126d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9ff6cdf658b71397ad57ada686d8f" id="r_a4cd9ff6cdf658b71397ad57ada686d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd9ff6cdf658b71397ad57ada686d8f">lower_float16_transcendental_to_float32_equivalent</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *)</td></tr>
<tr class="memdesc:a4cd9ff6cdf658b71397ad57ada686d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a float16 transcendental using the float32 equivalent.  <br /></td></tr>
<tr class="separator:a4cd9ff6cdf658b71397ad57ada686d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d9776355fa799b71816c0ab2e97e6" id="r_a7c0d9776355fa799b71816c0ab2e97e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0d9776355fa799b71816c0ab2e97e6">float32_to_bfloat16</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a7c0d9776355fa799b71816c0ab2e97e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> to/from float and bfloat using bitwise math.  <br /></td></tr>
<tr class="separator:a7c0d9776355fa799b71816c0ab2e97e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bc1fe74ae6a148b8e7ee57f26c994d" id="r_aa8bc1fe74ae6a148b8e7ee57f26c994d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8bc1fe74ae6a148b8e7ee57f26c994d">float32_to_float16</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:aa8bc1fe74ae6a148b8e7ee57f26c994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386f43e07f78c9b4be57358b183150ce" id="r_a386f43e07f78c9b4be57358b183150ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a386f43e07f78c9b4be57358b183150ce">float16_to_float32</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:a386f43e07f78c9b4be57358b183150ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc4c96649e436c9f67531779788b077" id="r_adfc4c96649e436c9f67531779788b077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfc4c96649e436c9f67531779788b077">bfloat16_to_float32</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:adfc4c96649e436c9f67531779788b077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79be785c18917d142a0fa55c86ab3a87" id="r_a79be785c18917d142a0fa55c86ab3a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79be785c18917d142a0fa55c86ab3a87">lower_float16_cast</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a> *op)</td></tr>
<tr class="separator:a79be785c18917d142a0fa55c86ab3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b07cc26c89acd41e49cdbacfd9a9f" id="r_aac2b07cc26c89acd41e49cdbacfd9a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a011fabf6af2c9c965cacaf866d579f8a">HALIDE_EXPORT_SYMBOL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac2b07cc26c89acd41e49cdbacfd9a9f">unhandled_exception_handler</a> ()</td></tr>
<tr class="separator:aac2b07cc26c89acd41e49cdbacfd9a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2683940f0565aba5f12746c727dc9c" id="r_a7a2683940f0565aba5f12746c727dc9c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7a2683940f0565aba5f12746c727dc9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a2683940f0565aba5f12746c727dc9c">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *t) noexcept</td></tr>
<tr class="separator:a7a2683940f0565aba5f12746c727dc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d80243a2f3de47f613df12b48475c3" id="r_ad3d80243a2f3de47f613df12b48475c3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad3d80243a2f3de47f613df12b48475c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3d80243a2f3de47f613df12b48475c3">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *t)</td></tr>
<tr class="separator:ad3d80243a2f3de47f613df12b48475c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b46f80479d5e41ff7ebf80ced31267" id="r_a89b46f80479d5e41ff7ebf80ced31267"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89b46f80479d5e41ff7ebf80ced31267">is_unordered_parallel</a> (<a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> for_type)</td></tr>
<tr class="memdesc:a89b46f80479d5e41ff7ebf80ced31267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if for_type executes for loop iterations in parallel and unordered.  <br /></td></tr>
<tr class="separator:a89b46f80479d5e41ff7ebf80ced31267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25b9bc3a80bac033c05e5178ab5a4c7" id="r_aa25b9bc3a80bac033c05e5178ab5a4c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25b9bc3a80bac033c05e5178ab5a4c7">is_parallel</a> (<a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> for_type)</td></tr>
<tr class="memdesc:aa25b9bc3a80bac033c05e5178ab5a4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if for_type executes for loop iterations in parallel.  <br /></td></tr>
<tr class="separator:aa25b9bc3a80bac033c05e5178ab5a4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2c029124d1533110e9f330f8e54918" id="r_a7d2c029124d1533110e9f330f8e54918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d2c029124d1533110e9f330f8e54918">is_gpu</a> (<a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> for_type)</td></tr>
<tr class="memdesc:a7d2c029124d1533110e9f330f8e54918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if for_type is GPUBlock, GPUThread, or GPULane.  <br /></td></tr>
<tr class="separator:a7d2c029124d1533110e9f330f8e54918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16792c0d67cebb47fe0a30377c3e7212" id="r_a16792c0d67cebb47fe0a30377c3e7212"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr , typename T &gt; </td></tr>
<tr class="memitem:a16792c0d67cebb47fe0a30377c3e7212"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16792c0d67cebb47fe0a30377c3e7212">stmt_or_expr_uses_vars</a> (const StmtOrExpr &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a16792c0d67cebb47fe0a30377c3e7212"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <br /></td></tr>
<tr class="separator:a16792c0d67cebb47fe0a30377c3e7212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d94fcb5a93f4d4ddc839dc3f7631e5e" id="r_a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr &gt; </td></tr>
<tr class="memitem:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d94fcb5a93f4d4ddc839dc3f7631e5e">stmt_or_expr_uses_var</a> (const StmtOrExpr &amp;e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <br /></td></tr>
<tr class="separator:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734ee6c4861fe4be70badd557199d84" id="r_af734ee6c4861fe4be70badd557199d84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af734ee6c4861fe4be70badd557199d84">expr_uses_var</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af734ee6c4861fe4be70badd557199d84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <br /></td></tr>
<tr class="separator:af734ee6c4861fe4be70badd557199d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdd19ef6ec57aee5d5bea413bed3452" id="r_a0fdd19ef6ec57aee5d5bea413bed3452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fdd19ef6ec57aee5d5bea413bed3452">stmt_uses_var</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a0fdd19ef6ec57aee5d5bea413bed3452"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <br /></td></tr>
<tr class="separator:a0fdd19ef6ec57aee5d5bea413bed3452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31bec6d9fdbb014d4e6b82549452065" id="r_ae31bec6d9fdbb014d4e6b82549452065"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae31bec6d9fdbb014d4e6b82549452065"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae31bec6d9fdbb014d4e6b82549452065">expr_uses_vars</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:ae31bec6d9fdbb014d4e6b82549452065"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <br /></td></tr>
<tr class="separator:ae31bec6d9fdbb014d4e6b82549452065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8bcd8e6cf2ad8368c7f106f5852f1e" id="r_a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d8bcd8e6cf2ad8368c7f106f5852f1e">stmt_uses_vars</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <br /></td></tr>
<tr class="separator:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb2bf360bb8b29ddbeb01605062fe8" id="r_a45cb2bf360bb8b29ddbeb01605062fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45cb2bf360bb8b29ddbeb01605062fe8">extract_tile_operations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a45cb2bf360bb8b29ddbeb01605062fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite any AMX tile operations that have been stored in the AMXTile memory type as intrinsic calls, to be used in the X86 backend.  <br /></td></tr>
<tr class="separator:a45cb2bf360bb8b29ddbeb01605062fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3ba4ff8fc8b6574e63c0457e396d97" id="r_afc3ba4ff8fc8b6574e63c0457e396d97"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc3ba4ff8fc8b6574e63c0457e396d97">find_direct_calls</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="memdesc:afc3ba4ff8fc8b6574e63c0457e396d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> extents.  <br /></td></tr>
<tr class="separator:afc3ba4ff8fc8b6574e63c0457e396d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994c8afe69a4c81e58c463fc1f5836f9" id="r_a994c8afe69a4c81e58c463fc1f5836f9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994c8afe69a4c81e58c463fc1f5836f9">find_transitive_calls</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="memdesc:a994c8afe69a4c81e58c463fc1f5836f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, or indirectly in those functions' definitions, recursively.  <br /></td></tr>
<tr class="separator:a994c8afe69a4c81e58c463fc1f5836f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f5192ac624544dd004e7e9b58baeed" id="r_ac3f5192ac624544dd004e7e9b58baeed"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3f5192ac624544dd004e7e9b58baeed">build_environment</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;funcs)</td></tr>
<tr class="memdesc:ac3f5192ac624544dd004e7e9b58baeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all Functions transitively referenced by any <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> in <code>funcs</code> and return a map of them.  <br /></td></tr>
<tr class="separator:ac3f5192ac624544dd004e7e9b58baeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2db5263e219c293da13bb1ccbddfbcc" id="r_ad2db5263e219c293da13bb1ccbddfbcc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2db5263e219c293da13bb1ccbddfbcc">called_funcs_in_order_found</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;funcs)</td></tr>
<tr class="memdesc:ad2db5263e219c293da13bb1ccbddfbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the same Functions as build_environment, but returns a vector of Functions instead, where the order is the order in which the Functions were first encountered.  <br /></td></tr>
<tr class="separator:ad2db5263e219c293da13bb1ccbddfbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747e2381aa255e5e68c5da44e80c0f1" id="r_a2747e2381aa255e5e68c5da44e80c0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2747e2381aa255e5e68c5da44e80c0f1">lower_widen_right_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a2747e2381aa255e5e68c5da44e80c0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement intrinsics with non-intrinsic using equivalents.  <br /></td></tr>
<tr class="separator:a2747e2381aa255e5e68c5da44e80c0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d7552c738220034a57048125449f4" id="r_a7b1d7552c738220034a57048125449f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b1d7552c738220034a57048125449f4">lower_widen_right_mul</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a7b1d7552c738220034a57048125449f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ca570db1c9d68fd46c628469b55486" id="r_a77ca570db1c9d68fd46c628469b55486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77ca570db1c9d68fd46c628469b55486">lower_widen_right_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a77ca570db1c9d68fd46c628469b55486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f298be9b8105946543dd390b374ff" id="r_a543f298be9b8105946543dd390b374ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543f298be9b8105946543dd390b374ff">lower_widening_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a543f298be9b8105946543dd390b374ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ae1b99eee51f16210b3d97effc25bd" id="r_ab8ae1b99eee51f16210b3d97effc25bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ae1b99eee51f16210b3d97effc25bd">lower_widening_mul</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:ab8ae1b99eee51f16210b3d97effc25bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac43abd869f41381772e6bb7d2c6e5d" id="r_aaac43abd869f41381772e6bb7d2c6e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac43abd869f41381772e6bb7d2c6e5d">lower_widening_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:aaac43abd869f41381772e6bb7d2c6e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49839698df68c878972d04abb2f0c2e5" id="r_a49839698df68c878972d04abb2f0c2e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49839698df68c878972d04abb2f0c2e5">lower_widening_shift_left</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a49839698df68c878972d04abb2f0c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72390cac65d124349c7e74677aa87167" id="r_a72390cac65d124349c7e74677aa87167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72390cac65d124349c7e74677aa87167">lower_widening_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a72390cac65d124349c7e74677aa87167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e70aeecd9a6473b07d533436feee25" id="r_ad1e70aeecd9a6473b07d533436feee25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e70aeecd9a6473b07d533436feee25">lower_rounding_shift_left</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:ad1e70aeecd9a6473b07d533436feee25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c2f27463a8c2007fb94474a7d31e6" id="r_a8c3c2f27463a8c2007fb94474a7d31e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c3c2f27463a8c2007fb94474a7d31e6">lower_rounding_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a8c3c2f27463a8c2007fb94474a7d31e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52903c4a764166671b47c1bee5972657" id="r_a52903c4a764166671b47c1bee5972657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52903c4a764166671b47c1bee5972657">lower_saturating_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a52903c4a764166671b47c1bee5972657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc65673b59449764669bf6424de17481" id="r_acc65673b59449764669bf6424de17481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc65673b59449764669bf6424de17481">lower_saturating_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:acc65673b59449764669bf6424de17481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665bcbdbb3b2749f1d5b263034c76fd3" id="r_a665bcbdbb3b2749f1d5b263034c76fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a665bcbdbb3b2749f1d5b263034c76fd3">lower_saturating_cast</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="separator:a665bcbdbb3b2749f1d5b263034c76fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb06df309ffae62a414ff80f298064c" id="r_a3cb06df309ffae62a414ff80f298064c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cb06df309ffae62a414ff80f298064c">lower_halving_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a3cb06df309ffae62a414ff80f298064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab3fa4ef1d631a29d7440487960a6e1" id="r_a3ab3fa4ef1d631a29d7440487960a6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ab3fa4ef1d631a29d7440487960a6e1">lower_halving_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a3ab3fa4ef1d631a29d7440487960a6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d347c813cf72a9fff938583a277f0" id="r_a433d347c813cf72a9fff938583a277f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a433d347c813cf72a9fff938583a277f0">lower_rounding_halving_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a433d347c813cf72a9fff938583a277f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb394d68a7ad936ee9c6653aa493d4e" id="r_a0cb394d68a7ad936ee9c6653aa493d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb394d68a7ad936ee9c6653aa493d4e">lower_sorted_avg</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a0cb394d68a7ad936ee9c6653aa493d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b142cb92430ccaabc491be73e179f1" id="r_a34b142cb92430ccaabc491be73e179f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b142cb92430ccaabc491be73e179f1">lower_mul_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;q)</td></tr>
<tr class="separator:a34b142cb92430ccaabc491be73e179f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab576461c931a66fd08808afe8c9c4eb8" id="r_ab576461c931a66fd08808afe8c9c4eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab576461c931a66fd08808afe8c9c4eb8">lower_rounding_mul_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;q)</td></tr>
<tr class="separator:ab576461c931a66fd08808afe8c9c4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4767c0dccb944d87678d84e2eae8c7a" id="r_ab4767c0dccb944d87678d84e2eae8c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4767c0dccb944d87678d84e2eae8c7a">lower_intrinsic</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *op)</td></tr>
<tr class="memdesc:ab4767c0dccb944d87678d84e2eae8c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace one of the above ops with equivalent arithmetic.  <br /></td></tr>
<tr class="separator:ab4767c0dccb944d87678d84e2eae8c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09931c2014b2d9371646a16e8f70040" id="r_ab09931c2014b2d9371646a16e8f70040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09931c2014b2d9371646a16e8f70040">find_intrinsics</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:ab09931c2014b2d9371646a16e8f70040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace common arithmetic patterns with intrinsics.  <br /></td></tr>
<tr class="separator:ab09931c2014b2d9371646a16e8f70040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac549d8172be01dcee56b59f1b78801ef" id="r_ac549d8172be01dcee56b59f1b78801ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac549d8172be01dcee56b59f1b78801ef">find_intrinsics</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="separator:ac549d8172be01dcee56b59f1b78801ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771bb6d2ec214f749b0c1b294d5c5a90" id="r_a771bb6d2ec214f749b0c1b294d5c5a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a771bb6d2ec214f749b0c1b294d5c5a90">lower_intrinsics</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a771bb6d2ec214f749b0c1b294d5c5a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse of find_intrinsics.  <br /></td></tr>
<tr class="separator:a771bb6d2ec214f749b0c1b294d5c5a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a93dc6272bd86b8d10c171d0c1e26d" id="r_a24a93dc6272bd86b8d10c171d0c1e26d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24a93dc6272bd86b8d10c171d0c1e26d">lower_intrinsics</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="separator:a24a93dc6272bd86b8d10c171d0c1e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf714a588746f3f1017dc77dad68a67" id="r_afdf714a588746f3f1017dc77dad68a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdf714a588746f3f1017dc77dad68a67">flatten_nested_ramps</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:afdf714a588746f3f1017dc77dad68a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement/expression and replace nested ramps and broadcasts.  <br /></td></tr>
<tr class="separator:afdf714a588746f3f1017dc77dad68a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2729ffaedee0544f9b584f53bc91954b" id="r_a2729ffaedee0544f9b584f53bc91954b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2729ffaedee0544f9b584f53bc91954b">flatten_nested_ramps</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="separator:a2729ffaedee0544f9b584f53bc91954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45" id="r_a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b98bf6f8f3475caaa691d7884a31d45">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f" id="r_abec0560d55ceb7384483f00da38ad73f"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abec0560d55ceb7384483f00da38ad73f">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:abec0560d55ceb7384483f00da38ad73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015" id="r_a32bce2836846aa0286859b005b6aa015"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32bce2836846aa0286859b005b6aa015">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, Last last)</td></tr>
<tr class="separator:a32bce2836846aa0286859b005b6aa015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae" id="r_acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acdc822256984ddc07c031b230ce2b8ae">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, First first, Second second, Rest &amp;&amp;...rest)</td></tr>
<tr class="separator:acdc822256984ddc07c031b230ce2b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bfb55aa0058e51d72037fde785fb0" id="r_a1f9bfb55aa0058e51d72037fde785fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f9bfb55aa0058e51d72037fde785fb0">schedule_scalar</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f)</td></tr>
<tr class="separator:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba803e43297e957a7e469082d37d68c" id="r_a2ba803e43297e957a7e469082d37d68c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba803e43297e957a7e469082d37d68c">deep_copy</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a2ba803e43297e957a7e469082d37d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy an entire <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> DAG.  <br /></td></tr>
<tr class="separator:a2ba803e43297e957a7e469082d37d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4235fdb540be5dde3f9942604be666f0" id="r_a4235fdb540be5dde3f9942604be666f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4235fdb540be5dde3f9942604be666f0">zero_gpu_loop_mins</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a4235fdb540be5dde3f9942604be666f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all GPU loops to have a min of zero.  <br /></td></tr>
<tr class="separator:a4235fdb540be5dde3f9942604be666f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0081752824625e87b5e95bfae979499f" id="r_a0081752824625e87b5e95bfae979499f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0081752824625e87b5e95bfae979499f">fuse_gpu_thread_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0081752824625e87b5e95bfae979499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model.  <br /></td></tr>
<tr class="separator:a0081752824625e87b5e95bfae979499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f235cf0feb61ceabb0ad10573d85f84" id="r_a5f235cf0feb61ceabb0ad10573d85f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f235cf0feb61ceabb0ad10573d85f84">fuzz_float_stores</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a5f235cf0feb61ceabb0ad10573d85f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">On every store of a floating point value, mask off the least-significant-bit of the mantissa.  <br /></td></tr>
<tr class="separator:a5f235cf0feb61ceabb0ad10573d85f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4be7daed1a8c6cd914be946f22ea4df" id="r_ac4be7daed1a8c6cd914be946f22ea4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4be7daed1a8c6cd914be946f22ea4df">generator_test</a> ()</td></tr>
<tr class="separator:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b454e42dc909eaf6be644f7d502d1a3" id="r_a4b454e42dc909eaf6be644f7d502d1a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b454e42dc909eaf6be644f7d502d1a3">parameter_constraints</a> (const <a class="el" href="class_halide_1_1_parameter.html">Parameter</a> &amp;p)</td></tr>
<tr class="separator:a4b454e42dc909eaf6be644f7d502d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce" id="r_a9b54f450e1cd03c240743907e45487ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b54f450e1cd03c240743907e45487ce">enum_to_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const T &amp;t)</td></tr>
<tr class="separator:a9b54f450e1cd03c240743907e45487ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c" id="r_afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd2308d89d4a9b9eef0803e92c383b0c">enum_from_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const std::string &amp;s)</td></tr>
<tr class="separator:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af487202db575c63bd3dbb93d93e4f5f3" id="r_af487202db575c63bd3dbb93d93e4f5f3"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af487202db575c63bd3dbb93d93e4f5f3">get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:af487202db575c63bd3dbb93d93e4f5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc7c793b324e02e15a109f1e8af548c" id="r_a2cc7c793b324e02e15a109f1e8af548c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cc7c793b324e02e15a109f1e8af548c">halide_type_to_enum_string</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a2cc7c793b324e02e15a109f1e8af548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600136fc73541f81f75ee07095a62025" id="r_a600136fc73541f81f75ee07095a62025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a600136fc73541f81f75ee07095a62025">halide_type_to_c_source</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a600136fc73541f81f75ee07095a62025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f71298de4ece7dc2e59ae811c3fd2" id="r_a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8f71298de4ece7dc2e59ae811c3fd2">halide_type_to_c_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02c1bb6c77110ad47015ce36529775a" id="r_ad02c1bb6c77110ad47015ce36529775a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html">GeneratorFactoryProvider</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02c1bb6c77110ad47015ce36529775a">get_registered_generators</a> ()</td></tr>
<tr class="memdesc:ad02c1bb6c77110ad47015ce36529775a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html" title="GeneratorFactoryProvider provides a way to customize the Generators that are visible to generate_filt...">GeneratorFactoryProvider</a> that knows about all the currently-registered C++ Generators.  <br /></td></tr>
<tr class="separator:ad02c1bb6c77110ad47015ce36529775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239019adaa0b7ed8fb0c6c81a6f694d3" id="r_a239019adaa0b7ed8fb0c6c81a6f694d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239019adaa0b7ed8fb0c6c81a6f694d3">generate_filter_main</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a239019adaa0b7ed8fb0c6c81a6f694d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a239019adaa0b7ed8fb0c6c81a6f694d3" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a2ffc5102a3af64eff76abddc80ee4a9b">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <br /></td></tr>
<tr class="separator:a239019adaa0b7ed8fb0c6c81a6f694d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994b36c5b1464443ec692ee2f4b6015" id="r_ae994b36c5b1464443ec692ee2f4b6015"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae994b36c5b1464443ec692ee2f4b6015">generate_filter_main</a> (int argc, char **argv, const <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html">GeneratorFactoryProvider</a> &amp;generator_factory_provider)</td></tr>
<tr class="memdesc:ae994b36c5b1464443ec692ee2f4b6015"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload of generate_filter_main lets you provide your own provider for how to enumerate and/or create the generators based on registration name; this is useful if you want to re-use the 'main' logic but avoid the global <a class="el" href="class_halide_1_1_generator.html">Generator</a> registry (e.g.  <br /></td></tr>
<tr class="separator:ae994b36c5b1464443ec692ee2f4b6015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34" id="r_ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae47fa4b8f49636c214b214f5d0f4ed34">parse_scalar</a> (const std::string &amp;value)</td></tr>
<tr class="separator:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1ffda17ab474ae9e88062f2c486d7b" id="r_a9e1ffda17ab474ae9e88062f2c486d7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e1ffda17ab474ae9e88062f2c486d7b">parse_halide_type_list</a> (const std::string &amp;types)</td></tr>
<tr class="separator:a9e1ffda17ab474ae9e88062f2c486d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8012ee5b0051705ecbc75a83ae6b465" id="r_ac8012ee5b0051705ecbc75a83ae6b465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8012ee5b0051705ecbc75a83ae6b465">execute_generator</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_execute_generator_args.html">ExecuteGeneratorArgs</a> &amp;args)</td></tr>
<tr class="memdesc:ac8012ee5b0051705ecbc75a83ae6b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a <a class="el" href="class_halide_1_1_generator.html">Generator</a> for AOT compilation &ndash; this provides the implementation of the command-line <a class="el" href="class_halide_1_1_generator.html">Generator</a> interface <code><a class="el" href="#a239019adaa0b7ed8fb0c6c81a6f694d3" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a></code>, but with a structured API that is more suitable for calling directly from code (vs command line).  <br /></td></tr>
<tr class="separator:ac8012ee5b0051705ecbc75a83ae6b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8696c48228f0cb335255ae46954909e1" id="r_a8696c48228f0cb335255ae46954909e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8696c48228f0cb335255ae46954909e1">inject_hexagon_rpc</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;host_target, <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module)</td></tr>
<tr class="memdesc:a8696c48228f0cb335255ae46954909e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module.  <br /></td></tr>
<tr class="separator:a8696c48228f0cb335255ae46954909e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada520284696ef879c882132d47d56575" id="r_ada520284696ef879c882132d47d56575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada520284696ef879c882132d47d56575">compile_module_to_hexagon_shared_object</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa6f4724604c6a1ca02d92a9900beb4734">device_code</a>)</td></tr>
<tr class="separator:ada520284696ef879c882132d47d56575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9944b3d2cbfb0262a46b72ec515ab130" id="r_a9944b3d2cbfb0262a46b72ec515ab130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9944b3d2cbfb0262a46b72ec515ab130">optimize_hexagon_shuffles</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, int lut_alignment)</td></tr>
<tr class="memdesc:a9944b3d2cbfb0262a46b72ec515ab130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace indirect and other loads with simple loads + vlut calls.  <br /></td></tr>
<tr class="separator:a9944b3d2cbfb0262a46b72ec515ab130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e99863aa9fd2833e535440b632093" id="r_ad61e99863aa9fd2833e535440b632093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad61e99863aa9fd2833e535440b632093">scatter_gather_generator</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="separator:ad61e99863aa9fd2833e535440b632093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2278e803f98fc7b6e2b382ace8052975" id="r_a2278e803f98fc7b6e2b382ace8052975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2278e803f98fc7b6e2b382ace8052975">optimize_hexagon_instructions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a2278e803f98fc7b6e2b382ace8052975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations.  <br /></td></tr>
<tr class="separator:a2278e803f98fc7b6e2b382ace8052975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a62ca468e067e12843e66cfa0fb33d" id="r_a33a62ca468e067e12843e66cfa0fb33d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33a62ca468e067e12843e66cfa0fb33d">native_deinterleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:a33a62ca468e067e12843e66cfa0fb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <br /></td></tr>
<tr class="separator:a33a62ca468e067e12843e66cfa0fb33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90cfab6d9f71632c8e4b712c7c400e8" id="r_ad90cfab6d9f71632c8e4b712c7c400e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad90cfab6d9f71632c8e4b712c7c400e8">native_interleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:ad90cfab6d9f71632c8e4b712c7c400e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5ab59246b78ff782aceed334637e4c" id="r_aaf5ab59246b78ff782aceed334637e4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf5ab59246b78ff782aceed334637e4c">is_native_deinterleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:aaf5ab59246b78ff782aceed334637e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa264f8cbd16a2062c62a731ef88a261" id="r_aaa264f8cbd16a2062c62a731ef88a261"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa264f8cbd16a2062c62a731ef88a261">is_native_interleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:aaa264f8cbd16a2062c62a731ef88a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5b91e32017e38df05ae28f39a8b78c" id="r_ada5b91e32017e38df05ae28f39a8b78c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5b91e32017e38df05ae28f39a8b78c">type_suffix</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> type, bool signed_variants=true)</td></tr>
<tr class="separator:ada5b91e32017e38df05ae28f39a8b78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edb350d77a097d5b1dce8ba2a9890cf" id="r_a6edb350d77a097d5b1dce8ba2a9890cf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6edb350d77a097d5b1dce8ba2a9890cf">type_suffix</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, bool signed_variants=true)</td></tr>
<tr class="separator:a6edb350d77a097d5b1dce8ba2a9890cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b52d96bb5a9b758cbaf557e35f4695" id="r_af6b52d96bb5a9b758cbaf557e35f4695"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6b52d96bb5a9b758cbaf557e35f4695">type_suffix</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, bool signed_variants=true)</td></tr>
<tr class="separator:af6b52d96bb5a9b758cbaf557e35f4695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d49ddfaea99d3ddf07425940e67dd0" id="r_a93d49ddfaea99d3ddf07425940e67dd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d49ddfaea99d3ddf07425940e67dd0">type_suffix</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;ops, bool signed_variants=true)</td></tr>
<tr class="separator:a93d49ddfaea99d3ddf07425940e67dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac100c7daa45cf5358113252833505ee8" id="r_ac100c7daa45cf5358113252833505ee8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac100c7daa45cf5358113252833505ee8">infer_arguments</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;body, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:ac100c7daa45cf5358113252833505ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f932b31fe791a7b2002b829c8e5364" id="r_a50f932b31fe791a7b2002b829c8e5364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50f932b31fe791a7b2002b829c8e5364">call_extern_and_assert</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a50f932b31fe791a7b2002b829c8e5364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to call an extern function, and assert that it returns 0.  <br /></td></tr>
<tr class="separator:a50f932b31fe791a7b2002b829c8e5364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa15ced2f13142e6c4b5e5f4649aa15" id="r_a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa15ced2f13142e6c4b5e5f4649aa15">inject_host_dev_buffer_copies</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed.  <br /></td></tr>
<tr class="separator:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e110a8277167d2764e231d1dbebf5" id="r_a983e110a8277167d2764e231d1dbebf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a983e110a8277167d2764e231d1dbebf5">inline_function</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="memdesc:a983e110a8277167d2764e231d1dbebf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <br /></td></tr>
<tr class="separator:a983e110a8277167d2764e231d1dbebf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114825936949569e0a72294236a775c" id="r_a7114825936949569e0a72294236a775c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7114825936949569e0a72294236a775c">inline_function</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a7114825936949569e0a72294236a775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720ad50bc88a71450138fcec77b3b73c" id="r_a720ad50bc88a71450138fcec77b3b73c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a720ad50bc88a71450138fcec77b3b73c">inline_function</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> caller, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a720ad50bc88a71450138fcec77b3b73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6883343b90964967cb0bafb2551f5c3" id="r_ab6883343b90964967cb0bafb2551f5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6883343b90964967cb0bafb2551f5c3">validate_schedule_inlined_function</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:ab6883343b90964967cb0bafb2551f5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the schedule of an inlined function is legal, throwing an error if it is not.  <br /></td></tr>
<tr class="separator:ab6883343b90964967cb0bafb2551f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a81310ace17087de643bc9a31efeba1" id="r_a5a81310ace17087de643bc9a31efeba1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a81310ace17087de643bc9a31efeba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a81310ace17087de643bc9a31efeba1">ref_count</a> (const T *t) noexcept</td></tr>
<tr class="memdesc:a5a81310ace17087de643bc9a31efeba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <br /></td></tr>
<tr class="separator:a5a81310ace17087de643bc9a31efeba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca920b642ef490aeac2b4e864d6254" id="r_a11ca920b642ef490aeac2b4e864d6254"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11ca920b642ef490aeac2b4e864d6254"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11ca920b642ef490aeac2b4e864d6254">destroy</a> (const T *t)</td></tr>
<tr class="separator:a11ca920b642ef490aeac2b4e864d6254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bafeb4c15a672e45dbec02785b93716" id="r_a7bafeb4c15a672e45dbec02785b93716"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bafeb4c15a672e45dbec02785b93716">equal_impl</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="separator:a7bafeb4c15a672e45dbec02785b93716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56589d680e47d47cb99043ee9040312" id="r_aa56589d680e47d47cb99043ee9040312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa56589d680e47d47cb99043ee9040312">graph_equal_impl</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="separator:aa56589d680e47d47cb99043ee9040312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b281bee331928a19675ab3947ec7be0" id="r_a8b281bee331928a19675ab3947ec7be0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b281bee331928a19675ab3947ec7be0">less_than_impl</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="separator:a8b281bee331928a19675ab3947ec7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f07e1ec3fcdbe94c6de092a705ecc9c" id="r_a6f07e1ec3fcdbe94c6de092a705ecc9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f07e1ec3fcdbe94c6de092a705ecc9c">graph_less_than_impl</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="separator:a6f07e1ec3fcdbe94c6de092a705ecc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13e686a28ec56a80633dd2f884a66fd" id="r_aa13e686a28ec56a80633dd2f884a66fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa13e686a28ec56a80633dd2f884a66fd">equal</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, int b)</td></tr>
<tr class="memdesc:aa13e686a28ec56a80633dd2f884a66fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> to an int literal.  <br /></td></tr>
<tr class="separator:aa13e686a28ec56a80633dd2f884a66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c05dd091f826bcce807e1be2b1bda22" id="r_a4c05dd091f826bcce807e1be2b1bda22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c05dd091f826bcce807e1be2b1bda22">equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="memdesc:a4c05dd091f826bcce807e1be2b1bda22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two defined Stmts or Exprs are equal.  <br /></td></tr>
<tr class="separator:a4c05dd091f826bcce807e1be2b1bda22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada037871ad1de9ce6e77781a241aaea0" id="r_ada037871ad1de9ce6e77781a241aaea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada037871ad1de9ce6e77781a241aaea0">equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;b)</td></tr>
<tr class="memdesc:ada037871ad1de9ce6e77781a241aaea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two possible-undefined Stmts or Exprs are equal.  <br /></td></tr>
<tr class="separator:ada037871ad1de9ce6e77781a241aaea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab949751502a795d7147cfa5200965837" id="r_ab949751502a795d7147cfa5200965837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab949751502a795d7147cfa5200965837">graph_equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="memdesc:ab949751502a795d7147cfa5200965837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two defined Stmts or Exprs are equal.  <br /></td></tr>
<tr class="separator:ab949751502a795d7147cfa5200965837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896dcb5b101600c38f4a962f1bb1554f" id="r_a896dcb5b101600c38f4a962f1bb1554f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896dcb5b101600c38f4a962f1bb1554f">graph_equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;b)</td></tr>
<tr class="memdesc:a896dcb5b101600c38f4a962f1bb1554f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two possibly-undefined Stmts or Exprs are equal.  <br /></td></tr>
<tr class="separator:a896dcb5b101600c38f4a962f1bb1554f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a59a2f31e593fb22349fc1f33b8aa" id="r_ab11a59a2f31e593fb22349fc1f33b8aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab11a59a2f31e593fb22349fc1f33b8aa">less_than</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="memdesc:ab11a59a2f31e593fb22349fc1f33b8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two defined Stmts or Exprs are in a lexicographic order.  <br /></td></tr>
<tr class="separator:ab11a59a2f31e593fb22349fc1f33b8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e88e34c586a1b9a0d907e8411c8631" id="r_a34e88e34c586a1b9a0d907e8411c8631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34e88e34c586a1b9a0d907e8411c8631">less_than</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;b)</td></tr>
<tr class="memdesc:a34e88e34c586a1b9a0d907e8411c8631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two possibly-undefined Stmts or Exprs are in a lexicographic order.  <br /></td></tr>
<tr class="separator:a34e88e34c586a1b9a0d907e8411c8631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651465ccda8d4388bf2ae0651ef6f0c6" id="r_a651465ccda8d4388bf2ae0651ef6f0c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a651465ccda8d4388bf2ae0651ef6f0c6">graph_less_than</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;b)</td></tr>
<tr class="memdesc:a651465ccda8d4388bf2ae0651ef6f0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two defined Stmts or Exprs are in a lexicographic order.  <br /></td></tr>
<tr class="separator:a651465ccda8d4388bf2ae0651ef6f0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44671b17b544e30b42100c14a337704" id="r_ae44671b17b544e30b42100c14a337704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae44671b17b544e30b42100c14a337704">graph_less_than</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;b)</td></tr>
<tr class="memdesc:ae44671b17b544e30b42100c14a337704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two possibly-undefined Stmts or Exprs are in a lexicographic order.  <br /></td></tr>
<tr class="separator:ae44671b17b544e30b42100c14a337704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59065f04bcf4e664007d95affa7ce3f" id="r_ac59065f04bcf4e664007d95affa7ce3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59065f04bcf4e664007d95affa7ce3f">ir_equality_test</a> ()</td></tr>
<tr class="separator:ac59065f04bcf4e664007d95affa7ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10452d8940fd9d44b657a915b7cea42" id="r_ad10452d8940fd9d44b657a915b7cea42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad10452d8940fd9d44b657a915b7cea42">expr_match</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;pattern, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad10452d8940fd9d44b657a915b7cea42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <br /></td></tr>
<tr class="separator:ad10452d8940fd9d44b657a915b7cea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d77cbd158befc1b58416319609f313" id="r_ad8d77cbd158befc1b58416319609f313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8d77cbd158befc1b58416319609f313">expr_match</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;pattern, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad8d77cbd158befc1b58416319609f313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <br /></td></tr>
<tr class="separator:ad8d77cbd158befc1b58416319609f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7dcf498f892ed7052bf6f812fe8b90" id="r_abc7dcf498f892ed7052bf6f812fe8b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7dcf498f892ed7052bf6f812fe8b90">with_lanes</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x, int lanes)</td></tr>
<tr class="memdesc:abc7dcf498f892ed7052bf6f812fe8b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the expression x to have <code>lanes</code> lanes.  <br /></td></tr>
<tr class="separator:abc7dcf498f892ed7052bf6f812fe8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eed932bc0eb3a15edcb20795bfb8c2f" id="r_a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eed932bc0eb3a15edcb20795bfb8c2f">expr_match_test</a> ()</td></tr>
<tr class="separator:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0512dbf6acb2e3ef16f95249e75117a" id="r_ad0512dbf6acb2e3ef16f95249e75117a"><td class="memTemplParams" colspan="2">template&lt;typename Mutator , typename... Args&gt; </td></tr>
<tr class="memitem:ad0512dbf6acb2e3ef16f95249e75117a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0512dbf6acb2e3ef16f95249e75117a">mutate_region</a> (Mutator *mutator, const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;bounds, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ad0512dbf6acb2e3ef16f95249e75117a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for mutator-like things to mutate regions.  <br /></td></tr>
<tr class="separator:ad0512dbf6acb2e3ef16f95249e75117a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d0eaaf5222de9d1151bf81479beb9" id="r_af11d0eaaf5222de9d1151bf81479beb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af11d0eaaf5222de9d1151bf81479beb9">is_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af11d0eaaf5222de9d1151bf81479beb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants.">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <br /></td></tr>
<tr class="separator:af11d0eaaf5222de9d1151bf81479beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0438766d0040aa39c5f420f1a92b01b" id="r_ad0438766d0040aa39c5f420f1a92b01b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0438766d0040aa39c5f420f1a92b01b">is_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:ad0438766d0040aa39c5f420f1a92b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <br /></td></tr>
<tr class="separator:ad0438766d0040aa39c5f420f1a92b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c8aa1b8748ca0958837f0ba0674bd2" id="r_a04c8aa1b8748ca0958837f0ba0674bd2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04c8aa1b8748ca0958837f0ba0674bd2">as_const_int</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a04c8aa1b8748ca0958837f0ba0674bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a its value.  <br /></td></tr>
<tr class="separator:a04c8aa1b8748ca0958837f0ba0674bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a87fabe7e34ddc531f4b42a423f5f8" id="r_a12a87fabe7e34ddc531f4b42a423f5f8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12a87fabe7e34ddc531f4b42a423f5f8">as_const_uint</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a12a87fabe7e34ddc531f4b42a423f5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a>, return its value.  <br /></td></tr>
<tr class="separator:a12a87fabe7e34ddc531f4b42a423f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447a267df279f56f32fee9bcdc0a66a8" id="r_a447a267df279f56f32fee9bcdc0a66a8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447a267df279f56f32fee9bcdc0a66a8">as_const_float</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a447a267df279f56f32fee9bcdc0a66a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return its value.  <br /></td></tr>
<tr class="separator:a447a267df279f56f32fee9bcdc0a66a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a71170ae43c163cec618d27391445be" id="r_a5a71170ae43c163cec618d27391445be"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a71170ae43c163cec618d27391445be">is_const_power_of_two_integer</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a5a71170ae43c163cec618d27391445be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <br /></td></tr>
<tr class="separator:a5a71170ae43c163cec618d27391445be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f44339d0ca10a75d9e240ed916c34e" id="r_a96f44339d0ca10a75d9e240ed916c34e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f44339d0ca10a75d9e240ed916c34e">is_const_power_of_two_integer</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>)</td></tr>
<tr class="separator:a96f44339d0ca10a75d9e240ed916c34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc1e8d7fbd26b5fa0aff1fbb4d1b157" id="r_a0fc1e8d7fbd26b5fa0aff1fbb4d1b157"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc1e8d7fbd26b5fa0aff1fbb4d1b157">is_const_power_of_two_integer</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="separator:a0fc1e8d7fbd26b5fa0aff1fbb4d1b157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26b6233cff17bdbf097bfe981e096c" id="r_a5f26b6233cff17bdbf097bfe981e096c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f26b6233cff17bdbf097bfe981e096c">is_positive_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a5f26b6233cff17bdbf097bfe981e096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <br /></td></tr>
<tr class="separator:a5f26b6233cff17bdbf097bfe981e096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e57c1aaa1719ed42fac6dc6661ebe90" id="r_a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e57c1aaa1719ed42fac6dc6661ebe90">is_negative_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <br /></td></tr>
<tr class="separator:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb4bb1c7164222794e270f58c428eb7" id="r_a0eb4bb1c7164222794e270f58c428eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eb4bb1c7164222794e270f58c428eb7">is_undef</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0eb4bb1c7164222794e270f58c428eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <br /></td></tr>
<tr class="separator:a0eb4bb1c7164222794e270f58c428eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0490ee622445eeba11163a7a936177d7" id="r_a0490ee622445eeba11163a7a936177d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0490ee622445eeba11163a7a936177d7">is_const_zero</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0490ee622445eeba11163a7a936177d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <br /></td></tr>
<tr class="separator:a0490ee622445eeba11163a7a936177d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3534f733e8b7b7c617fd03714ccca697" id="r_a3534f733e8b7b7c617fd03714ccca697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3534f733e8b7b7c617fd03714ccca697">is_const_one</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a3534f733e8b7b7c617fd03714ccca697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <br /></td></tr>
<tr class="separator:a3534f733e8b7b7c617fd03714ccca697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916dccb9f4ad5763ce86721ab3187cfc" id="r_a916dccb9f4ad5763ce86721ab3187cfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a916dccb9f4ad5763ce86721ab3187cfc">is_no_op</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a916dccb9f4ad5763ce86721ab3187cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> node of a constant)  <br /></td></tr>
<tr class="separator:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325254f314a3811cc5ebebf4497466d" id="r_a8325254f314a3811cc5ebebf4497466d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8325254f314a3811cc5ebebf4497466d">is_pure</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a8325254f314a3811cc5ebebf4497466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, and 2) Evaluating it has no side-effects.  <br /></td></tr>
<tr class="separator:a8325254f314a3811cc5ebebf4497466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a057ef6ceb8462dbca18eb9020bc297" id="r_a5a057ef6ceb8462dbca18eb9020bc297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a5a057ef6ceb8462dbca18eb9020bc297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <br /></td></tr>
<tr class="separator:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69927d11c0fe7c6cf4092a811f6676d7" id="r_a69927d11c0fe7c6cf4092a811f6676d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69927d11c0fe7c6cf4092a811f6676d7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="separator:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a72bc2d5b95e6a43e803a9f7c4acea" id="r_ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a72bc2d5b95e6a43e803a9f7c4acea">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, double val)</td></tr>
<tr class="separator:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7" id="r_aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaae8ca905f0ce9cde74cc0897a61c4e7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b" id="r_a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b64c00a450c92807011cdc02f8b29b">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c" id="r_a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df9ef655a78f9fb233fa0322525496c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd" id="r_af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14e2dade91eb04482b4b5ffdfc920dd">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d" id="r_a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5231b80b8e1a7904cdd4fcac7b89a98d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa" id="r_ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a1ece36d20a64a59c92bf7f8c4e9aa">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c" id="r_addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addbd965eccbcfc1f5b80eaa0607f698c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, bool val)</td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de" id="r_aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa90929bcfb18413ffd527152bb8580de">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, float val)</td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d" id="r_a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6592ef00a06a1d8f017b48359099c16d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1float16__t.html">float16_t</a> val)</td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee83b2e74ffd9ee144d046aebbf87cca" id="r_aee83b2e74ffd9ee144d046aebbf87cca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee83b2e74ffd9ee144d046aebbf87cca">make_signed_integer_overflow</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> type)</td></tr>
<tr class="memdesc:aee83b2e74ffd9ee144d046aebbf87cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unique signed_integer_overflow <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>.  <br /></td></tr>
<tr class="separator:aee83b2e74ffd9ee144d046aebbf87cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68abd1ad9ed8a6e22cb63c19bfc89695" id="r_a68abd1ad9ed8a6e22cb63c19bfc89695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68abd1ad9ed8a6e22cb63c19bfc89695">is_signed_integer_overflow</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a68abd1ad9ed8a6e22cb63c19bfc89695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an expression is a signed_integer_overflow.  <br /></td></tr>
<tr class="separator:a68abd1ad9ed8a6e22cb63c19bfc89695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de10096d923cdc0f02582981b718854" id="r_a2de10096d923cdc0f02582981b718854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2de10096d923cdc0f02582981b718854">check_representable</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a2de10096d923cdc0f02582981b718854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <br /></td></tr>
<tr class="separator:a2de10096d923cdc0f02582981b718854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2aa7992959c35ebe5895999b762b34" id="r_ace2aa7992959c35ebe5895999b762b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace2aa7992959c35ebe5895999b762b34">make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:ace2aa7992959c35ebe5895999b762b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <br /></td></tr>
<tr class="separator:ace2aa7992959c35ebe5895999b762b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4b9c03c76d9a19a0d7a7de2036f1b6" id="r_a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e4b9c03c76d9a19a0d7a7de2036f1b6">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <br /></td></tr>
<tr class="separator:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e5ab6b1524fd81132823c77c35d717" id="r_a01e5ab6b1524fd81132823c77c35d717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01e5ab6b1524fd81132823c77c35d717">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a01e5ab6b1524fd81132823c77c35d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <br /></td></tr>
<tr class="separator:a01e5ab6b1524fd81132823c77c35d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bdd8230cefd6bf9f84ac909311d87e" id="r_a14bdd8230cefd6bf9f84ac909311d87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bdd8230cefd6bf9f84ac909311d87e">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a14bdd8230cefd6bf9f84ac909311d87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <br /></td></tr>
<tr class="separator:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb413640f7f46493733fa33d95ea9fc" id="r_a5fb413640f7f46493733fa33d95ea9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb413640f7f46493733fa33d95ea9fc">const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a5fb413640f7f46493733fa33d95ea9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <br /></td></tr>
<tr class="separator:a5fb413640f7f46493733fa33d95ea9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c84e726218144cf4c5d3a08b38f8d" id="r_ab94c84e726218144cf4c5d3a08b38f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94c84e726218144cf4c5d3a08b38f8d">const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:ab94c84e726218144cf4c5d3a08b38f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <br /></td></tr>
<tr class="separator:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3801143ed91f421de409bb02a23590" id="r_aca3801143ed91f421de409bb02a23590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3801143ed91f421de409bb02a23590">lossless_cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::map&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>, <a class="el" href="struct_halide_1_1_expr_compare.html">ExprCompare</a> &gt; *cache=nullptr)</td></tr>
<tr class="memdesc:aca3801143ed91f421de409bb02a23590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <br /></td></tr>
<tr class="separator:aca3801143ed91f421de409bb02a23590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626e40f7f540859a774c59d38a673bd" id="r_aa626e40f7f540859a774c59d38a673bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa626e40f7f540859a774c59d38a673bd">lossless_negate</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:aa626e40f7f540859a774c59d38a673bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to negate x without introducing new IR and without overflow.  <br /></td></tr>
<tr class="separator:aa626e40f7f540859a774c59d38a673bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365bfad96972abe9e008bb1b601223f9" id="r_a365bfad96972abe9e008bb1b601223f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365bfad96972abe9e008bb1b601223f9">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a365bfad96972abe9e008bb1b601223f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <br /></td></tr>
<tr class="separator:a365bfad96972abe9e008bb1b601223f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdcef00b83af48e34920fd58d1da84" id="r_addfdcef00b83af48e34920fd58d1da84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addfdcef00b83af48e34920fd58d1da84">match_types_bitwise</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, const char *op_name)</td></tr>
<tr class="memdesc:addfdcef00b83af48e34920fd58d1da84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that both expressions are integer types and are either both signed or both unsigned.  <br /></td></tr>
<tr class="separator:addfdcef00b83af48e34920fd58d1da84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81818fbb02804a8e8f9056a0a24e0f56" id="r_a81818fbb02804a8e8f9056a0a24e0f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81818fbb02804a8e8f9056a0a24e0f56">halide_log</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="memdesc:a81818fbb02804a8e8f9056a0a24e0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s vectorizable transcendentals.  <br /></td></tr>
<tr class="separator:a81818fbb02804a8e8f9056a0a24e0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f176922ae87268701a0234b48ead883" id="r_a4f176922ae87268701a0234b48ead883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f176922ae87268701a0234b48ead883">halide_exp</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="separator:a4f176922ae87268701a0234b48ead883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30907ab1fd2dfde808351ed05d262548" id="r_a30907ab1fd2dfde808351ed05d262548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30907ab1fd2dfde808351ed05d262548">halide_erf</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="separator:a30907ab1fd2dfde808351ed05d262548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec662f503947166115071493eaa00780" id="r_aec662f503947166115071493eaa00780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec662f503947166115071493eaa00780">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:aec662f503947166115071493eaa00780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <br /></td></tr>
<tr class="separator:aec662f503947166115071493eaa00780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839473cf858ba53326b678db072411d2" id="r_a839473cf858ba53326b678db072411d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a839473cf858ba53326b678db072411d2">split_into_ands</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a839473cf858ba53326b678db072411d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <br /></td></tr>
<tr class="separator:a839473cf858ba53326b678db072411d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f512f02bfc12c8a4d1d87ab77bc0b6" id="r_aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f512f02bfc12c8a4d1d87ab77bc0b6">strided_ramp_base</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, int stride=1)</td></tr>
<tr class="memdesc:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If e is a ramp expression with stride, default 1, return the base, otherwise undefined.  <br /></td></tr>
<tr class="separator:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97" id="r_a6cd3908859c82249a2c7f10158883a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a6cd3908859c82249a2c7f10158883a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  <br /></td></tr>
<tr class="separator:a6cd3908859c82249a2c7f10158883a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974" id="r_a0442f9a0450f45683938a69ce0273974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr class="separator:a0442f9a0450f45683938a69ce0273974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4" id="r_adff5495089b812474881ee939c4701c4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:adff5495089b812474881ee939c4701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034" id="r_ac9a60708c880da445554b8eeb778c034"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:ac9a60708c880da445554b8eeb778c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523" id="r_aa13a82f37fe6336c154122f66d294523"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa13a82f37fe6336c154122f66d294523">div_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:aa13a82f37fe6336c154122f66d294523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a" id="r_a3965c871f086a60fda2cc31e678d050a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3965c871f086a60fda2cc31e678d050a">div_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:a3965c871f086a60fda2cc31e678d050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7df709582bdb9d7844efa9cd6b69625" id="r_af7df709582bdb9d7844efa9cd6b69625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7df709582bdb9d7844efa9cd6b69625">remove_likelies</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af7df709582bdb9d7844efa9cd6b69625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed.  <br /></td></tr>
<tr class="separator:af7df709582bdb9d7844efa9cd6b69625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf82ffcc64c0c61b7cb7fc6ac7c916" id="r_a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">remove_likelies</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed.  <br /></td></tr>
<tr class="separator:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa743928f81a0671c4ebc2cd2be4821f7" id="r_aa743928f81a0671c4ebc2cd2be4821f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa743928f81a0671c4ebc2cd2be4821f7">remove_promises</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:aa743928f81a0671c4ebc2cd2be4821f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="#a90683a918dfa5840b97406468fef7501" title="FOR INTERNAL USE ONLY.">promise_clamped()</a> and <a class="el" href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17" title="Create an Expr that that promises another Expr is clamped but do not generate code to check the asser...">unsafe_promise_clamped()</a> removed.  <br /></td></tr>
<tr class="separator:aa743928f81a0671c4ebc2cd2be4821f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fb7ba79c8a67a1ce85a0b8d78d4ada" id="r_a72fb7ba79c8a67a1ce85a0b8d78d4ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72fb7ba79c8a67a1ce85a0b8d78d4ada">remove_promises</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a72fb7ba79c8a67a1ce85a0b8d78d4ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="#a90683a918dfa5840b97406468fef7501" title="FOR INTERNAL USE ONLY.">promise_clamped()</a> and <a class="el" href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17" title="Create an Expr that that promises another Expr is clamped but do not generate code to check the asser...">unsafe_promise_clamped()</a> removed.  <br /></td></tr>
<tr class="separator:a72fb7ba79c8a67a1ce85a0b8d78d4ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d42146de36c1cbc7633214f80795ad9" id="r_a9d42146de36c1cbc7633214f80795ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d42146de36c1cbc7633214f80795ad9">unwrap_tags</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a9d42146de36c1cbc7633214f80795ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression is a tag helper call, remove it and return the tagged expression.  <br /></td></tr>
<tr class="separator:a9d42146de36c1cbc7633214f80795ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ed2ca593eca53111eaf753a7fc9bf" id="r_acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf7ed2ca593eca53111eaf753a7fc9bf">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b" id="r_a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d7c2f51029190ae224290688b7c4c3b">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, const char *arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:a4d7c2f51029190ae224290688b7c4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661" id="r_adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adda140fdf727dfa11f6f3151fc4f7661">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:adda140fdf727dfa11f6f3151fc4f7661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da582526c949b1bd11ede8f20bce2e" id="r_a12da582526c949b1bd11ede8f20bce2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12da582526c949b1bd11ede8f20bce2e">requirement_failed_error</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a12da582526c949b1bd11ede8f20bce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082d3bda0d60128ae127d0879e7e38c9" id="r_a082d3bda0d60128ae127d0879e7e38c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a082d3bda0d60128ae127d0879e7e38c9">memoize_tag_helper</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:a082d3bda0d60128ae127d0879e7e38c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1a5b9726e5efce554d5d4dcdf90257" id="r_a7c1a5b9726e5efce554d5d4dcdf90257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c1a5b9726e5efce554d5d4dcdf90257">reset_random_counters</a> ()</td></tr>
<tr class="memdesc:a7c1a5b9726e5efce554d5d4dcdf90257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the counters used for random-number seeds in random_float/int/uint.  <br /></td></tr>
<tr class="separator:a7c1a5b9726e5efce554d5d4dcdf90257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac69b419fd1f9624e9513d53b80671e" id="r_a2ac69b419fd1f9624e9513d53b80671e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ac69b419fd1f9624e9513d53b80671e">unreachable</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t=<a class="el" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32))</td></tr>
<tr class="memdesc:a2ac69b419fd1f9624e9513d53b80671e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that should never be evaluated.  <br /></td></tr>
<tr class="separator:a2ac69b419fd1f9624e9513d53b80671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f17e150d50c8c4cad84a9b003c62f41" id="r_a1f17e150d50c8c4cad84a9b003c62f41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f17e150d50c8c4cad84a9b003c62f41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f17e150d50c8c4cad84a9b003c62f41">unreachable</a> ()</td></tr>
<tr class="separator:a1f17e150d50c8c4cad84a9b003c62f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90683a918dfa5840b97406468fef7501" id="r_a90683a918dfa5840b97406468fef7501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90683a918dfa5840b97406468fef7501">promise_clamped</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;value, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="#a41d5010a34ae900ef4f855ee5420a923">min</a>, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="#a60e34906118319ac8ae12858ba6faf5b">max</a>)</td></tr>
<tr class="memdesc:a90683a918dfa5840b97406468fef7501"><td class="mdescLeft">&#160;</td><td class="mdescRight">FOR INTERNAL USE ONLY.  <br /></td></tr>
<tr class="separator:a90683a918dfa5840b97406468fef7501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2a400fa1e1be0e5b629fdaddc3fef2" id="r_a4a2a400fa1e1be0e5b629fdaddc3fef2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a2a400fa1e1be0e5b629fdaddc3fef2">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a>)</td></tr>
<tr class="memdesc:a4a2a400fa1e1be0e5b629fdaddc3fef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide node type on an output stream (such as std::cout) in human-readable form.  <br /></td></tr>
<tr class="separator:a4a2a400fa1e1be0e5b629fdaddc3fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab484ec2f86cc767a395f35fa69eb1b8b" id="r_ab484ec2f86cc767a395f35fa69eb1b8b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab484ec2f86cc767a395f35fa69eb1b8b">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &amp;)</td></tr>
<tr class="memdesc:ab484ec2f86cc767a395f35fa69eb1b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide associative pattern on an output stream (such as std::cout) in a human-readable form.  <br /></td></tr>
<tr class="separator:ab484ec2f86cc767a395f35fa69eb1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e184dac97733cb81db3d44c4475c41" id="r_af7e184dac97733cb81db3d44c4475c41"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e184dac97733cb81db3d44c4475c41">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &amp;)</td></tr>
<tr class="memdesc:af7e184dac97733cb81db3d44c4475c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide associative op on an output stream (such as std::cout) in a human-readable form.  <br /></td></tr>
<tr class="separator:af7e184dac97733cb81db3d44c4475c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdc87d74601a359729f465add4a57c5" id="r_a1bdc87d74601a359729f465add4a57c5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bdc87d74601a359729f465add4a57c5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;)</td></tr>
<tr class="memdesc:a1bdc87d74601a359729f465add4a57c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <br /></td></tr>
<tr class="separator:a1bdc87d74601a359729f465add4a57c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c84fe3f99dd05b0ffa69af2f042ff5" id="r_ac5c84fe3f99dd05b0ffa69af2f042ff5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5c84fe3f99dd05b0ffa69af2f042ff5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27">VectorReduce::Operator</a> &amp;)</td></tr>
<tr class="memdesc:ac5c84fe3f99dd05b0ffa69af2f042ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a horizontal vector reduction op in human-readable form.  <br /></td></tr>
<tr class="separator:ac5c84fe3f99dd05b0ffa69af2f042ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a9502cb7a58446fa468b44bfc4b6d1" id="r_a10a9502cb7a58446fa468b44bfc4b6d1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a9502cb7a58446fa468b44bfc4b6d1">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> &amp;)</td></tr>
<tr class="memdesc:a10a9502cb7a58446fa468b44bfc4b6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide name mangling value in a human readable format.  <br /></td></tr>
<tr class="separator:a10a9502cb7a58446fa468b44bfc4b6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a977b805b5c8efe49a00e5c294253e4" id="r_a1a977b805b5c8efe49a00e5c294253e4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a977b805b5c8efe49a00e5c294253e4">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> &amp;)</td></tr>
<tr class="memdesc:a1a977b805b5c8efe49a00e5c294253e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide linkage value in a human readable format.  <br /></td></tr>
<tr class="separator:a1a977b805b5c8efe49a00e5c294253e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a7fc654d26338936dd99a9fb50949a" id="r_a18a7fc654d26338936dd99a9fb50949a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18a7fc654d26338936dd99a9fb50949a">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4fe">DimType</a> &amp;)</td></tr>
<tr class="memdesc:a18a7fc654d26338936dd99a9fb50949a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide dimension type in human-readable format.  <br /></td></tr>
<tr class="separator:a18a7fc654d26338936dd99a9fb50949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84711b7fb71c0151bdf4cdff0274203a" id="r_a84711b7fb71c0151bdf4cdff0274203a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84711b7fb71c0151bdf4cdff0274203a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;c)</td></tr>
<tr class="memdesc:a84711b7fb71c0151bdf4cdff0274203a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures.">Closure</a> in human-readable form.  <br /></td></tr>
<tr class="separator:a84711b7fb71c0151bdf4cdff0274203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523ae8336558d8709f4510731bd2a298" id="r_a523ae8336558d8709f4510731bd2a298"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a523ae8336558d8709f4510731bd2a298">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;c)</td></tr>
<tr class="memdesc:a523ae8336558d8709f4510731bd2a298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="struct_halide_1_1_internal_1_1_interval.html" title="A class to represent ranges of Exprs.">Interval</a> in human-readable form.  <br /></td></tr>
<tr class="separator:a523ae8336558d8709f4510731bd2a298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ed3ae16af25caf69d9a03ec9aaf9c3" id="r_a79ed3ae16af25caf69d9a03ec9aaf9c3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ed3ae16af25caf69d9a03ec9aaf9c3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;c)</td></tr>
<tr class="memdesc:a79ed3ae16af25caf69d9a03ec9aaf9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html" title="A class to represent ranges of integers.">ConstantInterval</a> in human-readable form.  <br /></td></tr>
<tr class="separator:a79ed3ae16af25caf69d9a03ec9aaf9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819144ed78ee773e7fbcd5271c9d1253" id="r_a819144ed78ee773e7fbcd5271c9d1253"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819144ed78ee773e7fbcd5271c9d1253">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;c)</td></tr>
<tr class="memdesc:a819144ed78ee773e7fbcd5271c9d1253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html" title="The result of modulus_remainder analysis.">ModulusRemainder</a> in human-readable form.  <br /></td></tr>
<tr class="separator:a819144ed78ee773e7fbcd5271c9d1253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8a7f7d4b6a6e27fcd31efcce988328" id="r_aba8a7f7d4b6a6e27fcd31efcce988328"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba8a7f7d4b6a6e27fcd31efcce988328">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_indentation.html">Indentation</a> &amp;)</td></tr>
<tr class="separator:aba8a7f7d4b6a6e27fcd31efcce988328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c051d2259a5836298986de038a3e110" id="r_a3c051d2259a5836298986de038a3e110"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c051d2259a5836298986de038a3e110">get_symbol_address</a> (const char *s)</td></tr>
<tr class="separator:a3c051d2259a5836298986de038a3e110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151b37ef92bd2ae4f11005143282ce67" id="r_a151b37ef92bd2ae4f11005143282ce67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a151b37ef92bd2ae4f11005143282ce67">lower_lerp</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> final_type, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;weight, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a151b37ef92bd2ae4f11005143282ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR that computes a lerp.  <br /></td></tr>
<tr class="separator:a151b37ef92bd2ae4f11005143282ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4933314cbff0bf637e348d5efc0a1499" id="r_a4933314cbff0bf637e348d5efc0a1499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4933314cbff0bf637e348d5efc0a1499">hoist_loop_invariant_values</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a4933314cbff0bf637e348d5efc0a1499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariants out of inner loops.  <br /></td></tr>
<tr class="separator:a4933314cbff0bf637e348d5efc0a1499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de2b04122d0ac7aba914d93c97b2589" id="r_a3de2b04122d0ac7aba914d93c97b2589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3de2b04122d0ac7aba914d93c97b2589">hoist_loop_invariant_if_statements</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a3de2b04122d0ac7aba914d93c97b2589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just hoist loop-invariant if statements as far up as possible.  <br /></td></tr>
<tr class="separator:a3de2b04122d0ac7aba914d93c97b2589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d2c57ff18ef709b6a4e444f4af5ff" id="r_a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e9d2c57ff18ef709b6a4e444f4af5ff">iterator_to_pointer</a> (T iter) -&gt; decltype(&amp;*std::declval&lt; T &gt;())</td></tr>
<tr class="separator:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880810f84064e696c65e574223e8170a" id="r_a880810f84064e696c65e574223e8170a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a880810f84064e696c65e574223e8170a">get_llvm_function_name</a> (const llvm::Function *f)</td></tr>
<tr class="separator:a880810f84064e696c65e574223e8170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e2fec06de5b48f541b7a7b18d7bfb1" id="r_ae2e2fec06de5b48f541b7a7b18d7bfb1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e2fec06de5b48f541b7a7b18d7bfb1">get_llvm_function_name</a> (const llvm::Function &amp;f)</td></tr>
<tr class="separator:ae2e2fec06de5b48f541b7a7b18d7bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19498b7ba32a1bddbafd858d07b402a5" id="r_a19498b7ba32a1bddbafd858d07b402a5"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19498b7ba32a1bddbafd858d07b402a5">get_llvm_struct_type_by_name</a> (llvm::Module *module, const char *name)</td></tr>
<tr class="separator:a19498b7ba32a1bddbafd858d07b402a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496ad11988df981c987a2557c3cd2d8c" id="r_a496ad11988df981c987a2557c3cd2d8c"><td class="memItemLeft" align="right" valign="top">llvm::Triple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a496ad11988df981c987a2557c3cd2d8c">get_triple_for_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a496ad11988df981c987a2557c3cd2d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>.  <br /></td></tr>
<tr class="separator:a496ad11988df981c987a2557c3cd2d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04027d1e41197c21cc803367b612e08" id="r_ad04027d1e41197c21cc803367b612e08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad04027d1e41197c21cc803367b612e08">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *, bool for_shared_jit_runtime=false, bool just_gpu=false)</td></tr>
<tr class="memdesc:ad04027d1e41197c21cc803367b612e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <br /></td></tr>
<tr class="separator:ad04027d1e41197c21cc803367b612e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f50077affbb1487e3680d0d879e243" id="r_a67f50077affbb1487e3680d0d879e243"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67f50077affbb1487e3680d0d879e243">get_initial_module_for_ptx_device</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *c)</td></tr>
<tr class="memdesc:a67f50077affbb1487e3680d0d879e243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <br /></td></tr>
<tr class="separator:a67f50077affbb1487e3680d0d879e243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2253813b438bcb811778d84b98e94" id="r_af5c2253813b438bcb811778d84b98e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5c2253813b438bcb811778d84b98e94">add_bitcode_to_module</a> (llvm::LLVMContext *context, llvm::Module &amp;module, const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa05bcd6bc2c5f7d9a2881e398f0b47046">bitcode</a>, const std::string &amp;name)</td></tr>
<tr class="memdesc:af5c2253813b438bcb811778d84b98e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a block of llvm bitcode into an llvm module.  <br /></td></tr>
<tr class="separator:af5c2253813b438bcb811778d84b98e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7830b669a6e68edeeb27c58d65e55a" id="r_a7f7830b669a6e68edeeb27c58d65e55a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f7830b669a6e68edeeb27c58d65e55a">link_with_wasm_jit_runtime</a> (llvm::LLVMContext *c, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, std::unique_ptr&lt; llvm::Module &gt; extra_module)</td></tr>
<tr class="memdesc:a7f7830b669a6e68edeeb27c58d65e55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the llvm::Module(s) in extra_modules (if any), add the runtime modules needed for the WASM JIT, and link into a single llvm::Module.  <br /></td></tr>
<tr class="separator:a7f7830b669a6e68edeeb27c58d65e55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc91c3863b2f3b6afe3902a717ff68b" id="r_a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fc91c3863b2f3b6afe3902a717ff68b">loop_carry</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, int max_carried_values=8)</td></tr>
<tr class="memdesc:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load.  <br /></td></tr>
<tr class="separator:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3120dac0bea3e48403dd0d63420e929c" id="r_a3120dac0bea3e48403dd0d63420e929c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3120dac0bea3e48403dd0d63420e929c">lower</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> linkage_type, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;requirements=std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt;(), bool trace_pipeline=false, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt;())</td></tr>
<tr class="memdesc:a3120dac0bea3e48403dd0d63420e929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of scheduled halide functions, create a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> that evaluates it.  <br /></td></tr>
<tr class="separator:a3120dac0bea3e48403dd0d63420e929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6912ab26d3b04864d43af52502ebeb7" id="r_aa6912ab26d3b04864d43af52502ebeb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6912ab26d3b04864d43af52502ebeb7">lower_main_stmt</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;requirements=std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt;(), bool trace_pipeline=false, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt;())</td></tr>
<tr class="memdesc:aa6912ab26d3b04864d43af52502ebeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <br /></td></tr>
<tr class="separator:aa6912ab26d3b04864d43af52502ebeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bfe43201bab68cf4820993fe1469b" id="r_a4d3bfe43201bab68cf4820993fe1469b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr class="separator:a4d3bfe43201bab68cf4820993fe1469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac932a9ede73796baeeb77ff860e97472" id="r_ac932a9ede73796baeeb77ff860e97472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac932a9ede73796baeeb77ff860e97472">lower_parallel_tasks</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &gt; &amp;closure_implementations, const std::string &amp;name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="separator:ac932a9ede73796baeeb77ff860e97472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7df44ea516ceb85971b6d8bcd9b1e0" id="r_a8b7df44ea516ceb85971b6d8bcd9b1e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b7df44ea516ceb85971b6d8bcd9b1e0">lower_warp_shuffles</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a8b7df44ea516ceb85971b6d8bcd9b1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite access to things stored outside the loop over GPU lanes to use nvidia's warp shuffle instructions.  <br /></td></tr>
<tr class="separator:a8b7df44ea516ceb85971b6d8bcd9b1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66d64dd9cb646535816aff25b0d38ad" id="r_ac66d64dd9cb646535816aff25b0d38ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac66d64dd9cb646535816aff25b0d38ad">inject_memoization</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;name, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:ac66d64dd9cb646535816aff25b0d38ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache.  <br /></td></tr>
<tr class="separator:ac66d64dd9cb646535816aff25b0d38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af597feabae6ec97802ee2f800667a0f7" id="r_af597feabae6ec97802ee2f800667a0f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af597feabae6ec97802ee2f800667a0f7">rewrite_memoized_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:af597feabae6ec97802ee2f800667a0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called after Storage Flattening has added Allocation IR nodes.  <br /></td></tr>
<tr class="separator:af597feabae6ec97802ee2f800667a0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bea6a35a3aba9e68cda72e574560b9" id="r_aa7bea6a35a3aba9e68cda72e574560b9"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2af">OutputFileType</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_output_info.html">OutputInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7bea6a35a3aba9e68cda72e574560b9">get_output_info</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:aa7bea6a35a3aba9e68cda72e574560b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4287e047c221ec0bd503eca610e59cd1" id="r_a4287e047c221ec0bd503eca610e59cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4287e047c221ec0bd503eca610e59cd1">operator+</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:a4287e047c221ec0bd503eca610e59cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4ed3e58311ee5699c067d4a6c53c2d" id="r_ade4ed3e58311ee5699c067d4a6c53c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade4ed3e58311ee5699c067d4a6c53c2d">operator-</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:ade4ed3e58311ee5699c067d4a6c53c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc51636317f397ae70e341f81805f8e" id="r_a4fc51636317f397ae70e341f81805f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc51636317f397ae70e341f81805f8e">operator*</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:a4fc51636317f397ae70e341f81805f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d56ea77b1fc65e72abc6025d15e2e" id="r_ae26d56ea77b1fc65e72abc6025d15e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae26d56ea77b1fc65e72abc6025d15e2e">operator/</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:ae26d56ea77b1fc65e72abc6025d15e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc141be36f0586ef2dd5080befce47" id="r_a42bc141be36f0586ef2dd5080befce47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42bc141be36f0586ef2dd5080befce47">operator%</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:a42bc141be36f0586ef2dd5080befce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad920f0d7b02a7331b8211d84e3f10208" id="r_ad920f0d7b02a7331b8211d84e3f10208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad920f0d7b02a7331b8211d84e3f10208">operator+</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:ad920f0d7b02a7331b8211d84e3f10208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f39c3da5f8430464ac63973af1737ae" id="r_a9f39c3da5f8430464ac63973af1737ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f39c3da5f8430464ac63973af1737ae">operator-</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9f39c3da5f8430464ac63973af1737ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e40311152e94d1bf520fa0a8eadafa9" id="r_a7e40311152e94d1bf520fa0a8eadafa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e40311152e94d1bf520fa0a8eadafa9">operator*</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a7e40311152e94d1bf520fa0a8eadafa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad30409f49c922a7b536de49b50abfa" id="r_a5ad30409f49c922a7b536de49b50abfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad30409f49c922a7b536de49b50abfa">operator/</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a5ad30409f49c922a7b536de49b50abfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5bf538dd23287f4a506afbe601b4a2" id="r_abe5bf538dd23287f4a506afbe601b4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5bf538dd23287f4a506afbe601b4a2">operator%</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:abe5bf538dd23287f4a506afbe601b4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0244f4d3e877af92bb3326b5ba74d2" id="r_a1b0244f4d3e877af92bb3326b5ba74d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b0244f4d3e877af92bb3326b5ba74d2">modulus_remainder</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a1b0244f4d3e877af92bb3326b5ba74d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <br /></td></tr>
<tr class="separator:a1b0244f4d3e877af92bb3326b5ba74d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9e014546d86033dd6c81f699891267" id="r_aef9e014546d86033dd6c81f699891267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9e014546d86033dd6c81f699891267">modulus_remainder</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:aef9e014546d86033dd6c81f699891267"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <br /></td></tr>
<tr class="separator:aef9e014546d86033dd6c81f699891267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789149daec96e933f8758f71f8474dd6" id="r_a789149daec96e933f8758f71f8474dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a789149daec96e933f8758f71f8474dd6">modulus_remainder_test</a> ()</td></tr>
<tr class="separator:a789149daec96e933f8758f71f8474dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3383c51a3621854507bf149283901fd8" id="r_a3383c51a3621854507bf149283901fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3383c51a3621854507bf149283901fd8">gcd</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="memdesc:a3383c51a3621854507bf149283901fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <br /></td></tr>
<tr class="separator:a3383c51a3621854507bf149283901fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d5d650979fec41ce02d02ac0b7c20" id="r_aea6d5d650979fec41ce02d02ac0b7c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea6d5d650979fec41ce02d02ac0b7c20">lcm</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="memdesc:aea6d5d650979fec41ce02d02ac0b7c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least common multiple of two integers.  <br /></td></tr>
<tr class="separator:aea6d5d650979fec41ce02d02ac0b7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0301c6ab3540d1ce4c678d7f625d23b0" id="r_a0301c6ab3540d1ce4c678d7f625d23b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0301c6ab3540d1ce4c678d7f625d23b0">derivative_bounds</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;var, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a0301c6ab3540d1ce4c678d7f625d23b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the bounds of the derivative of an expression.  <br /></td></tr>
<tr class="separator:a0301c6ab3540d1ce4c678d7f625d23b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4b2947237a60faeb58784f49818c7" id="r_a51a4b2947237a60faeb58784f49818c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a4b2947237a60faeb58784f49818c7">is_monotonic</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;var, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt;::empty_scope())</td></tr>
<tr class="separator:a51a4b2947237a60faeb58784f49818c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86052cc97eb7a7774977da430b03274b" id="r_a86052cc97eb7a7774977da430b03274b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86052cc97eb7a7774977da430b03274b">is_monotonic</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;var, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &gt; &amp;scope)</td></tr>
<tr class="separator:a86052cc97eb7a7774977da430b03274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd75538cec762a0ec020c81708260b6" id="r_aecd75538cec762a0ec020c81708260b6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd75538cec762a0ec020c81708260b6">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &amp;m)</td></tr>
<tr class="memdesc:aecd75538cec762a0ec020c81708260b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the monotonic class in human-readable form for debugging.  <br /></td></tr>
<tr class="separator:aecd75538cec762a0ec020c81708260b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de4b237eafb498206aa2eb0c94b4ad" id="r_af6de4b237eafb498206aa2eb0c94b4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6de4b237eafb498206aa2eb0c94b4ad">is_monotonic_test</a> ()</td></tr>
<tr class="separator:af6de4b237eafb498206aa2eb0c94b4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad273923c5480df0e3753e3a70d240e6" id="r_aad273923c5480df0e3753e3a70d240e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad273923c5480df0e3753e3a70d240e6">inject_gpu_offload</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;host_target)</td></tr>
<tr class="memdesc:aad273923c5480df0e3753e3a70d240e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull loops marked with GPU device APIs to a separate module, and call them through the appropriate host runtime module.  <br /></td></tr>
<tr class="separator:aad273923c5480df0e3753e3a70d240e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6355b1954c20cf3e39d376f6dd17c5" id="r_a0e6355b1954c20cf3e39d376f6dd17c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e6355b1954c20cf3e39d376f6dd17c5">optimize_shuffles</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, int lut_alignment)</td></tr>
<tr class="separator:a0e6355b1954c20cf3e39d376f6dd17c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a87590be371b78913eaab20e563f335" id="r_a9a87590be371b78913eaab20e563f335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a87590be371b78913eaab20e563f335">can_parallelize_rvar</a> (const std::string &amp;rvar, const std::string &amp;func, const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;r)</td></tr>
<tr class="memdesc:a9a87590be371b78913eaab20e563f335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable.  <br /></td></tr>
<tr class="separator:a9a87590be371b78913eaab20e563f335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce66817377fbb1918bbe7510ab47b29" id="r_a0ce66817377fbb1918bbe7510ab47b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ce66817377fbb1918bbe7510ab47b29">check_call_arg_types</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *args, int dims)</td></tr>
<tr class="memdesc:a0ce66817377fbb1918bbe7510ab47b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate arguments to a call to a func, image or imageparam.  <br /></td></tr>
<tr class="separator:a0ce66817377fbb1918bbe7510ab47b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc76f59b0d70ea1055186a7098feef3b" id="r_abc76f59b0d70ea1055186a7098feef3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc76f59b0d70ea1055186a7098feef3b">has_uncaptured_likely_tag</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&gt; &amp;scope)</td></tr>
<tr class="memdesc:abc76f59b0d70ea1055186a7098feef3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an expression uses a likely tag that isn't captured by an enclosing <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a>, <a class="el" href="struct_halide_1_1_internal_1_1_min.html" title="The lesser of two values.">Min</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a>.  <br /></td></tr>
<tr class="separator:abc76f59b0d70ea1055186a7098feef3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0074d04170e6df774a2a0982b5ba78b5" id="r_a0074d04170e6df774a2a0982b5ba78b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0074d04170e6df774a2a0982b5ba78b5">has_likely_tag</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&gt; &amp;scope)</td></tr>
<tr class="memdesc:a0074d04170e6df774a2a0982b5ba78b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an expression uses a likely tag.  <br /></td></tr>
<tr class="separator:a0074d04170e6df774a2a0982b5ba78b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00fe3db9030d30827191d78c36fda5" id="r_a3d00fe3db9030d30827191d78c36fda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d00fe3db9030d30827191d78c36fda5">partition_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a3d00fe3db9030d30827191d78c36fda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions loop bodies into a prologue, a steady state, and an epilogue.  <br /></td></tr>
<tr class="separator:a3d00fe3db9030d30827191d78c36fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e0c79704de005e7e9ca2283da97c6" id="r_a9d9e0c79704de005e7e9ca2283da97c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d9e0c79704de005e7e9ca2283da97c6">inject_placeholder_prefetch</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;prefetches)</td></tr>
<tr class="memdesc:a9d9e0c79704de005e7e9ca2283da97c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject placeholder prefetches to 's'.  <br /></td></tr>
<tr class="separator:a9d9e0c79704de005e7e9ca2283da97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1427ae551e1c2cce79b7042c3fa4620" id="r_ab1427ae551e1c2cce79b7042c3fa4620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1427ae551e1c2cce79b7042c3fa4620">inject_prefetch</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:ab1427ae551e1c2cce79b7042c3fa4620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the actual region to be prefetched and place it to the placholder prefetch.  <br /></td></tr>
<tr class="separator:ab1427ae551e1c2cce79b7042c3fa4620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cbede92a4cd09354b032a40829a9d1" id="r_a23cbede92a4cd09354b032a40829a9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23cbede92a4cd09354b032a40829a9d1">reduce_prefetch_dimension</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a23cbede92a4cd09354b032a40829a9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a multi-dimensional prefetch into a prefetch of lower dimension (max dimension of the prefetch is specified by target architecture).  <br /></td></tr>
<tr class="separator:a23cbede92a4cd09354b032a40829a9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cb2c3d2c016e1eb6e6621599f9d731" id="r_ae4cb2c3d2c016e1eb6e6621599f9d731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4cb2c3d2c016e1eb6e6621599f9d731">hoist_prefetches</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:ae4cb2c3d2c016e1eb6e6621599f9d731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist all the prefetches in a <a class="el" href="struct_halide_1_1_internal_1_1_block.html" title="A sequence of statements to be executed in-order.">Block</a> to the beginning of the <a class="el" href="struct_halide_1_1_internal_1_1_block.html" title="A sequence of statements to be executed in-order.">Block</a>.  <br /></td></tr>
<tr class="separator:ae4cb2c3d2c016e1eb6e6621599f9d731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ddfd891459204fae6afbcbdb6bac6" id="r_aa35ddfd891459204fae6afbcbdb6bac6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa35ddfd891459204fae6afbcbdb6bac6">print_loop_nest</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs)</td></tr>
<tr class="memdesc:aa35ddfd891459204fae6afbcbdb6bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses.  <br /></td></tr>
<tr class="separator:aa35ddfd891459204fae6afbcbdb6bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae902f8e74df2649f97a92da9edd25d01" id="r_ae902f8e74df2649f97a92da9edd25d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae902f8e74df2649f97a92da9edd25d01">inject_profiling</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;, const std::string &amp;, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:ae902f8e74df2649f97a92da9edd25d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end.  <br /></td></tr>
<tr class="separator:ae902f8e74df2649f97a92da9edd25d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875f0768e69428144a610e591c7d9796" id="r_a875f0768e69428144a610e591c7d9796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a875f0768e69428144a610e591c7d9796">purify_index_math</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:a875f0768e69428144a610e591c7d9796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds inference and related stages can lift integer bounds expressions out of if statements that guard against those integer expressions doing side-effecty things like dividing or modding by zero.  <br /></td></tr>
<tr class="separator:a875f0768e69428144a610e591c7d9796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f12f161a6ba2a7b3476dbb1dbf809" id="r_aac0f12f161a6ba2a7b3476dbb1dbf809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac0f12f161a6ba2a7b3476dbb1dbf809">qualify</a> (const std::string &amp;prefix, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;value)</td></tr>
<tr class="memdesc:aac0f12f161a6ba2a7b3476dbb1dbf809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix all variable names in the given expression with the prefix string.  <br /></td></tr>
<tr class="separator:aac0f12f161a6ba2a7b3476dbb1dbf809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f343747d7f716a33198907c3e7d25" id="r_a795f343747d7f716a33198907c3e7d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795f343747d7f716a33198907c3e7d25">random_float</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a795f343747d7f716a33198907c3e7d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random floating-point number between zero and one that varies deterministically based on the input expressions.  <br /></td></tr>
<tr class="separator:a795f343747d7f716a33198907c3e7d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e64539c6d89123f6200b919ec28fbb" id="r_ae4e64539c6d89123f6200b919ec28fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4e64539c6d89123f6200b919ec28fbb">random_int</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ae4e64539c6d89123f6200b919ec28fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers).  <br /></td></tr>
<tr class="separator:ae4e64539c6d89123f6200b919ec28fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c33f7c870e8bd885383ccdc626112e" id="r_af6c33f7c870e8bd885383ccdc626112e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c33f7c870e8bd885383ccdc626112e">lower_random</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;free_vars, int tag)</td></tr>
<tr class="memdesc:af6c33f7c870e8bd885383ccdc626112e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> calls to random() to IR generated by random_float and random_int.  <br /></td></tr>
<tr class="separator:af6c33f7c870e8bd885383ccdc626112e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16182ff30077d1ecfc92f992ff2faccc" id="r_a16182ff30077d1ecfc92f992ff2faccc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::vector&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16182ff30077d1ecfc92f992ff2faccc">realization_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a16182ff30077d1ecfc92f992ff2faccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine an order in which to do the scheduling.  <br /></td></tr>
<tr class="separator:a16182ff30077d1ecfc92f992ff2faccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070fbe2943a2ab08b480fb4672e1617d" id="r_a070fbe2943a2ab08b480fb4672e1617d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070fbe2943a2ab08b480fb4672e1617d">topological_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a070fbe2943a2ab08b480fb4672e1617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine a topological order which stays constant regardless of the schedule.  <br /></td></tr>
<tr class="separator:a070fbe2943a2ab08b480fb4672e1617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d1cbe18a4f88b265c955be144a5bd6" id="r_aa9d1cbe18a4f88b265c955be144a5bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9d1cbe18a4f88b265c955be144a5bd6">rebase_loops_to_zero</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:aa9d1cbe18a4f88b265c955be144a5bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the mins of most loops to 0.  <br /></td></tr>
<tr class="separator:aa9d1cbe18a4f88b265c955be144a5bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcc74570e61290111488ef861e03d0f" id="r_aedcc74570e61290111488ef861e03d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedcc74570e61290111488ef861e03d0f">split_predicate_test</a> ()</td></tr>
<tr class="separator:aedcc74570e61290111488ef861e03d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8bfb7d84886e922f43c911740f2b1e" id="r_a6b8bfb7d84886e922f43c911740f2b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8bfb7d84886e922f43c911740f2b1e">is_func_trivial_to_inline</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;func)</td></tr>
<tr class="memdesc:a6b8bfb7d84886e922f43c911740f2b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cost of inlining a function is equivalent to the cost of calling the function directly.  <br /></td></tr>
<tr class="separator:a6b8bfb7d84886e922f43c911740f2b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f341c9e3b9dd03353afdeacd6092db" id="r_af5f341c9e3b9dd03353afdeacd6092db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5f341c9e3b9dd03353afdeacd6092db">remove_dead_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:af5f341c9e3b9dd03353afdeacd6092db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>.  <br /></td></tr>
<tr class="separator:af5f341c9e3b9dd03353afdeacd6092db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7966c5570f5dfae1e45df7995c34a762" id="r_a7966c5570f5dfae1e45df7995c34a762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7966c5570f5dfae1e45df7995c34a762">remove_extern_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a7966c5570f5dfae1e45df7995c34a762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes placeholder loops for extern stages.  <br /></td></tr>
<tr class="separator:a7966c5570f5dfae1e45df7995c34a762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fe646230de310959c4506c76de02e" id="r_a078fe646230de310959c4506c76de02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a078fe646230de310959c4506c76de02e">remove_undef</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a078fe646230de310959c4506c76de02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stores that depend on undef values, and statements that only contain such stores.  <br /></td></tr>
<tr class="separator:a078fe646230de310959c4506c76de02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe516bcacc2d5ea4d657228f8a8b49ad" id="r_abe516bcacc2d5ea4d657228f8a8b49ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe516bcacc2d5ea4d657228f8a8b49ad">schedule_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;fused_groups, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, bool &amp;any_memoized)</td></tr>
<tr class="memdesc:abe516bcacc2d5ea4d657228f8a8b49ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> realizations at the appropriate places using the schedule.  <br /></td></tr>
<tr class="separator:abe516bcacc2d5ea4d657228f8a8b49ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a75e74ba61493371c211e87046c189" id="r_a15a75e74ba61493371c211e87046c189"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15a75e74ba61493371c211e87046c189"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15a75e74ba61493371c211e87046c189">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a15a75e74ba61493371c211e87046c189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c068fc071822f5554d35e8cce582f54" id="r_a3c068fc071822f5554d35e8cce582f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c068fc071822f5554d35e8cce582f54">select_gpu_api</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a3c068fc071822f5554d35e8cce582f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target.  <br /></td></tr>
<tr class="separator:a3c068fc071822f5554d35e8cce582f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e925c5d658d689e0798106019bc083" id="r_ae8e925c5d658d689e0798106019bc083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e925c5d658d689e0798106019bc083">simplify</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;, bool remove_dead_code=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope(), const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;assumptions=std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;())</td></tr>
<tr class="memdesc:ae8e925c5d658d689e0798106019bc083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <br /></td></tr>
<tr class="separator:ae8e925c5d658d689e0798106019bc083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ad0375ba62ff83d5d5a2ed88610989" id="r_ab7ad0375ba62ff83d5d5a2ed88610989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7ad0375ba62ff83d5d5a2ed88610989">simplify</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;, bool remove_dead_code=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope(), const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;assumptions=std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;())</td></tr>
<tr class="separator:ab7ad0375ba62ff83d5d5a2ed88610989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5068393c9b9f8b58f7e1c164bee99f0b" id="r_a5068393c9b9f8b58f7e1c164bee99f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5068393c9b9f8b58f7e1c164bee99f0b">can_prove</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a5068393c9b9f8b58f7e1c164bee99f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to statically prove an expression is true using the simplifier.  <br /></td></tr>
<tr class="separator:a5068393c9b9f8b58f7e1c164bee99f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0918e7154f0624c9f1a15d34f4776c54" id="r_a0918e7154f0624c9f1a15d34f4776c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0918e7154f0624c9f1a15d34f4776c54">simplify_exprs</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a0918e7154f0624c9f1a15d34f4776c54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_simplify.html">Simplify</a> expressions found in a statement, but don't simplify across different statements.  <br /></td></tr>
<tr class="separator:a0918e7154f0624c9f1a15d34f4776c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145896c0b84da47b601412c7f451cb4" id="r_a9145896c0b84da47b601412c7f451cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9145896c0b84da47b601412c7f451cb4">simplify_correlated_differences</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a9145896c0b84da47b601412c7f451cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic interval arithmetic can be extremely conservative in cases where we analyze the difference between two correlated expressions.  <br /></td></tr>
<tr class="separator:a9145896c0b84da47b601412c7f451cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bee2a544c782fdc8ca228e53c43845e" id="r_a0bee2a544c782fdc8ca228e53c43845e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bee2a544c782fdc8ca228e53c43845e">bound_correlated_differences</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0bee2a544c782fdc8ca228e53c43845e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refactor the expression to remove correlated differences or rewrite them in a form that is more amenable to bounds inference.  <br /></td></tr>
<tr class="separator:a0bee2a544c782fdc8ca228e53c43845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4259425c64a0a9b25760e1c38123c13" id="r_af4259425c64a0a9b25760e1c38123c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4259425c64a0a9b25760e1c38123c13">simplify_specializations</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:af4259425c64a0a9b25760e1c38123c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the RHS/LHS of a function's definition based on its specializations.  <br /></td></tr>
<tr class="separator:af4259425c64a0a9b25760e1c38123c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fa9eb646f186793b4dd4a8e994b6c9" id="r_ab9fa9eb646f186793b4dd4a8e994b6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9fa9eb646f186793b4dd4a8e994b6c9">skip_stages</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:ab9fa9eb646f186793b4dd4a8e994b6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used.  <br /></td></tr>
<tr class="separator:ab9fa9eb646f186793b4dd4a8e994b6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3db85e95026207aa687c6f56c53cba" id="r_a6e3db85e95026207aa687c6f56c53cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e3db85e95026207aa687c6f56c53cba">sliding_window</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a6e3db85e95026207aa687c6f56c53cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <br /></td></tr>
<tr class="separator:a6e3db85e95026207aa687c6f56c53cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ed8a60a9ef19bd666e8f12a11f269" id="r_a285ed8a60a9ef19bd666e8f12a11f269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285ed8a60a9ef19bd666e8f12a11f269">solve_expression</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;variable, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a285ed8a60a9ef19bd666e8f12a11f269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e.  <br /></td></tr>
<tr class="separator:a285ed8a60a9ef19bd666e8f12a11f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa500a3f20519d9a27d718f77e1c1e" id="r_a01aa500a3f20519d9a27d718f77e1c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01aa500a3f20519d9a27d718f77e1c1e">solve_for_outer_interval</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a01aa500a3f20519d9a27d718f77e1c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it.  <br /></td></tr>
<tr class="separator:a01aa500a3f20519d9a27d718f77e1c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af37b4f0075b3dcd203546133878d54" id="r_a6af37b4f0075b3dcd203546133878d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af37b4f0075b3dcd203546133878d54">solve_for_inner_interval</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a6af37b4f0075b3dcd203546133878d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it.  <br /></td></tr>
<tr class="separator:a6af37b4f0075b3dcd203546133878d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4e051947dc094f3136a7b1e69a1e1" id="r_a1fe4e051947dc094f3136a7b1e69a1e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe4e051947dc094f3136a7b1e69a1e1">and_condition_over_domain</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;varying)</td></tr>
<tr class="memdesc:a1fe4e051947dc094f3136a7b1e69a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables.  <br /></td></tr>
<tr class="separator:a1fe4e051947dc094f3136a7b1e69a1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1e287e68d69ec35fd8a1e62d1c30ed" id="r_a6e1e287e68d69ec35fd8a1e62d1c30ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1e287e68d69ec35fd8a1e62d1c30ed">solve_test</a> ()</td></tr>
<tr class="separator:a6e1e287e68d69ec35fd8a1e62d1c30ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de0d574c401a3e0b47ae9b677181f15" id="r_a7de0d574c401a3e0b47ae9b677181f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7de0d574c401a3e0b47ae9b677181f15">spirv_ir_test</a> ()</td></tr>
<tr class="memdesc:a7de0d574c401a3e0b47ae9b677181f15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a> test for SPIR-V IR.  <br /></td></tr>
<tr class="separator:a7de0d574c401a3e0b47ae9b677181f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8dbe6ebbf9e99beda91f45eead442f" id="r_a1e8dbe6ebbf9e99beda91f45eead442f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8dbe6ebbf9e99beda91f45eead442f">split_tuples</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a1e8dbe6ebbf9e99beda91f45eead442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all tuple-valued Realizations, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a> nodes, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes into several scalar-valued ones, so that later lowering passes only need to think about scalar-valued productions.  <br /></td></tr>
<tr class="separator:a1e8dbe6ebbf9e99beda91f45eead442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7043faa4b3ad9b3a4898c0eb9974fbcd" id="r_a7043faa4b3ad9b3a4898c0eb9974fbcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7043faa4b3ad9b3a4898c0eb9974fbcd">stage_strided_loads</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a7043faa4b3ad9b3a4898c0eb9974fbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> all unpredicated strided loads in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> into dense loads followed by shuffles.  <br /></td></tr>
<tr class="separator:a7043faa4b3ad9b3a4898c0eb9974fbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1f44f72e9adf92ab081eec58cb67c4" id="r_a6e1f44f72e9adf92ab081eec58cb67c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1f44f72e9adf92ab081eec58cb67c4">print_to_stmt_html</a> (const std::string &amp;html_output_filename, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;m, const std::string &amp;assembly_input_filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a6e1f44f72e9adf92ab081eec58cb67c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted visualization of a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> to filename.  <br /></td></tr>
<tr class="separator:a6e1f44f72e9adf92ab081eec58cb67c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237581902c246cec8b1a5d62ccd7596f" id="r_a237581902c246cec8b1a5d62ccd7596f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237581902c246cec8b1a5d62ccd7596f">print_to_conceptual_stmt_html</a> (const std::string &amp;html_output_filename, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;m, const std::string &amp;assembly_input_filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a237581902c246cec8b1a5d62ccd7596f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted visualization of a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a>'s conceptual <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> code to filename.  <br /></td></tr>
<tr class="separator:a237581902c246cec8b1a5d62ccd7596f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb6fe2cb6171bf79124c2c1b1e867f" id="r_ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8cb6fe2cb6171bf79124c2c1b1e867f">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true.">Load</a> nodes respectively.  <br /></td></tr>
<tr class="separator:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328a1d6d3f0c78ffdc58ac5df812f05a" id="r_a328a1d6d3f0c78ffdc58ac5df812f05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a328a1d6d3f0c78ffdc58ac5df812f05a">storage_folding</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a328a1d6d3f0c78ffdc58ac5df812f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <br /></td></tr>
<tr class="separator:a328a1d6d3f0c78ffdc58ac5df812f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a5dab8c12346254d9348060878045c" id="r_ad8a5dab8c12346254d9348060878045c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a5dab8c12346254d9348060878045c">strictify_float</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:ad8a5dab8c12346254d9348060878045c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate strict_float intrinisics such that they immediately wrap all floating-point expressions.  <br /></td></tr>
<tr class="separator:ad8a5dab8c12346254d9348060878045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984524908e4478131a952e4a9230f0cb" id="r_a984524908e4478131a952e4a9230f0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a984524908e4478131a952e4a9230f0cb">strip_asserts</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="separator:a984524908e4478131a952e4a9230f0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77fafc3670bd07362c388820dd10c11" id="r_ab77fafc3670bd07362c388820dd10c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab77fafc3670bd07362c388820dd10c11">substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab77fafc3670bd07362c388820dd10c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <br /></td></tr>
<tr class="separator:ab77fafc3670bd07362c388820dd10c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953484f8812539e108a6c4e137ebfc62" id="r_a953484f8812539e108a6c4e137ebfc62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a953484f8812539e108a6c4e137ebfc62">substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>)</td></tr>
<tr class="memdesc:a953484f8812539e108a6c4e137ebfc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <br /></td></tr>
<tr class="separator:a953484f8812539e108a6c4e137ebfc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d044309ede4782cabce475570934a8" id="r_a92d044309ede4782cabce475570934a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d044309ede4782cabce475570934a8">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a92d044309ede4782cabce475570934a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <br /></td></tr>
<tr class="separator:a92d044309ede4782cabce475570934a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ebb6536c3233e6466073757f0e59e7" id="r_a14ebb6536c3233e6466073757f0e59e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ebb6536c3233e6466073757f0e59e7">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>)</td></tr>
<tr class="separator:a14ebb6536c3233e6466073757f0e59e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07967ab74e22a0103d6af67ec62cc3b7" id="r_a07967ab74e22a0103d6af67ec62cc3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07967ab74e22a0103d6af67ec62cc3b7">substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a07967ab74e22a0103d6af67ec62cc3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <br /></td></tr>
<tr class="separator:a07967ab74e22a0103d6af67ec62cc3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b12ab6ef3f59e897315145d1e996e2" id="r_ae1b12ab6ef3f59e897315145d1e996e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b12ab6ef3f59e897315145d1e996e2">substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>)</td></tr>
<tr class="separator:ae1b12ab6ef3f59e897315145d1e996e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e67268c787fe55a7bc5e3559f43cc" id="r_a457e67268c787fe55a7bc5e3559f43cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457e67268c787fe55a7bc5e3559f43cc">graph_substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a457e67268c787fe55a7bc5e3559f43cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <br /></td></tr>
<tr class="separator:a457e67268c787fe55a7bc5e3559f43cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95627cc6470e3f8975ab3b1fa2048e3e" id="r_a95627cc6470e3f8975ab3b1fa2048e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95627cc6470e3f8975ab3b1fa2048e3e">graph_substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>)</td></tr>
<tr class="separator:a95627cc6470e3f8975ab3b1fa2048e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219abd8f63bb237e29a7b878a445836" id="r_a8219abd8f63bb237e29a7b878a445836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8219abd8f63bb237e29a7b878a445836">graph_substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a8219abd8f63bb237e29a7b878a445836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e9db71fa11a9eb45590a8fd5ff774" id="r_a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d8e9db71fa11a9eb45590a8fd5ff774">graph_substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>)</td></tr>
<tr class="separator:a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafce6d574b476cf9c9acd5f622450ab" id="r_aaafce6d574b476cf9c9acd5f622450ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaafce6d574b476cf9c9acd5f622450ab">substitute_in_all_lets</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aaafce6d574b476cf9c9acd5f622450ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute in all let Exprs in a piece of IR.  <br /></td></tr>
<tr class="separator:aaafce6d574b476cf9c9acd5f622450ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a57aa0cf600e63ac832ea799f354acc" id="r_a6a57aa0cf600e63ac832ea799f354acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a57aa0cf600e63ac832ea799f354acc">substitute_in_all_lets</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;<a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>)</td></tr>
<tr class="separator:a6a57aa0cf600e63ac832ea799f354acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca85eaf8baf3957bda33b83b20c694" id="r_ae0ca85eaf8baf3957bda33b83b20c694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0ca85eaf8baf3957bda33b83b20c694">target_test</a> ()</td></tr>
<tr class="separator:ae0ca85eaf8baf3957bda33b83b20c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245b1ad737987567e573697e339729b2" id="r_a245b1ad737987567e573697e339729b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245b1ad737987567e573697e339729b2">lower_target_query_ops</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="separator:a245b1ad737987567e573697e339729b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402f1bcce3709f5f726b4a791d555a99" id="r_a402f1bcce3709f5f726b4a791d555a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a402f1bcce3709f5f726b4a791d555a99">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::string &amp;pipeline_name, bool trace_pipeline, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;<a class="el" href="struct_halide_1_1_target.html">Target</a>)</td></tr>
<tr class="memdesc:a402f1bcce3709f5f726b4a791d555a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <br /></td></tr>
<tr class="separator:a402f1bcce3709f5f726b4a791d555a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7fd6fdb5eb7b96d5dcf4a9d52985f7" id="r_aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">trim_no_ops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate loop bounds to the region over which they actually do something.  <br /></td></tr>
<tr class="separator:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8803d2593422e45d64b2d15429cfde0d" id="r_a8803d2593422e45d64b2d15429cfde0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8803d2593422e45d64b2d15429cfde0d">unify_duplicate_lets</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a8803d2593422e45d64b2d15429cfde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones.  <br /></td></tr>
<tr class="separator:a8803d2593422e45d64b2d15429cfde0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400b238529ddcab092d8bfa88ad33880" id="r_a400b238529ddcab092d8bfa88ad33880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400b238529ddcab092d8bfa88ad33880">uniquify_variable_names</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a400b238529ddcab092d8bfa88ad33880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <br /></td></tr>
<tr class="separator:a400b238529ddcab092d8bfa88ad33880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ff22da036ee4307f0963aadc7fa9fe" id="r_a60ff22da036ee4307f0963aadc7fa9fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60ff22da036ee4307f0963aadc7fa9fe">uniquify_variable_names_test</a> ()</td></tr>
<tr class="separator:a60ff22da036ee4307f0963aadc7fa9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffc3710f4a568f3e626e253bc758c2" id="r_a49ffc3710f4a568f3e626e253bc758c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49ffc3710f4a568f3e626e253bc758c2">unpack_buffers</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a49ffc3710f4a568f3e626e253bc758c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates let stmts for the various buffer components (e.g.  <br /></td></tr>
<tr class="separator:a49ffc3710f4a568f3e626e253bc758c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f57de73c898a70875fff4fad5cbf3" id="r_ada0f57de73c898a70875fff4fad5cbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada0f57de73c898a70875fff4fad5cbf3">unroll_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:ada0f57de73c898a70875fff4fad5cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <br /></td></tr>
<tr class="separator:ada0f57de73c898a70875fff4fad5cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7ac6d7399bf2ba00640fe7aa794f7f" id="r_a0b7ac6d7399bf2ba00640fe7aa794f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7ac6d7399bf2ba00640fe7aa794f7f">lower_unsafe_promises</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a0b7ac6d7399bf2ba00640fe7aa794f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower all unsafe promises into either assertions or unchecked code, depending on the target.  <br /></td></tr>
<tr class="separator:a0b7ac6d7399bf2ba00640fe7aa794f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d28d6c47ed91864a2f92e8b2868128" id="r_aa0d28d6c47ed91864a2f92e8b2868128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d28d6c47ed91864a2f92e8b2868128">lower_safe_promises</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:aa0d28d6c47ed91864a2f92e8b2868128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower all safe promises by just stripping them.  <br /></td></tr>
<tr class="separator:aa0d28d6c47ed91864a2f92e8b2868128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c" id="r_ab7501900efa7660edf445ed1b14c020c"><td class="memTemplParams" colspan="2">template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplItemLeft" align="right" valign="top">DST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7501900efa7660edf445ed1b14c020c">safe_numeric_cast</a> (SRC s)</td></tr>
<tr class="memdesc:ab7501900efa7660edf445ed1b14c020c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible.  <br /></td></tr>
<tr class="separator:ab7501900efa7660edf445ed1b14c020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008" id="r_a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <br /></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c63ee87658cd904e2f4a0ba78b78b" id="r_a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7c63ee87658cd904e2f4a0ba78b78b">get_env_variable</a> (char const *env_var_name)</td></tr>
<tr class="memdesc:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of an environment variable.  <br /></td></tr>
<tr class="separator:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b793745b048fa1fd344907ec4ec9aa" id="r_ab4b793745b048fa1fd344907ec4ec9aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4b793745b048fa1fd344907ec4ec9aa">running_program_name</a> ()</td></tr>
<tr class="memdesc:ab4b793745b048fa1fd344907ec4ec9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the currently running executable.  <br /></td></tr>
<tr class="separator:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd490221160a7206bb151d6eae65624" id="r_aabd490221160a7206bb151d6eae65624"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabd490221160a7206bb151d6eae65624">unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:aabd490221160a7206bb151d6eae65624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <br /></td></tr>
<tr class="separator:aabd490221160a7206bb151d6eae65624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0bd73d997ddc50f3523a21448471f" id="r_a7ec0bd73d997ddc50f3523a21448471f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ec0bd73d997ddc50f3523a21448471f">unique_name</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a7ec0bd73d997ddc50f3523a21448471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ca52c958b993ebd766f4b83de2cf9" id="r_af26ca52c958b993ebd766f4b83de2cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af26ca52c958b993ebd766f4b83de2cf9">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af26ca52c958b993ebd766f4b83de2cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string starts with the second string.  <br /></td></tr>
<tr class="separator:af26ca52c958b993ebd766f4b83de2cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290fb244405de2c014ebdc3cd1fc8f08" id="r_a290fb244405de2c014ebdc3cd1fc8f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a290fb244405de2c014ebdc3cd1fc8f08">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a290fb244405de2c014ebdc3cd1fc8f08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string ends with the second string.  <br /></td></tr>
<tr class="separator:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06bf852ad18eb3e9014495f5816c1f" id="r_a9c06bf852ad18eb3e9014495f5816c1f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c06bf852ad18eb3e9014495f5816c1f">replace_all</a> (const std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a9c06bf852ad18eb3e9014495f5816c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <br /></td></tr>
<tr class="separator:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa393afcc0cc51743eee04899674d90c0" id="r_aa393afcc0cc51743eee04899674d90c0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa393afcc0cc51743eee04899674d90c0">split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aa393afcc0cc51743eee04899674d90c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <br /></td></tr>
<tr class="separator:aa393afcc0cc51743eee04899674d90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90bc6b6e38d6f8cc725a3b54b66183" id="r_a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c90bc6b6e38d6f8cc725a3b54b66183">join_strings</a> (const std::vector&lt; T &gt; &amp;sources, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the source vector using 'delim' as the divider.  <br /></td></tr>
<tr class="separator:a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba" id="r_aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaaee1bb2b0dc659851899df7c12437ba">fold_left</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:aaaee1bb2b0dc659851899df7c12437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold of a vector.  <br /></td></tr>
<tr class="separator:aaaee1bb2b0dc659851899df7c12437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a" id="r_afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afedfcf82469516f0f05eb5a4699f480a">fold_right</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:afedfcf82469516f0f05eb5a4699f480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right fold of a vector.  <br /></td></tr>
<tr class="separator:afedfcf82469516f0f05eb5a4699f480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93192a2ea0afe58664e69232595ae08e" id="r_a93192a2ea0afe58664e69232595ae08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93192a2ea0afe58664e69232595ae08e">extract_namespaces</a> (const std::string &amp;name, std::vector&lt; std::string &gt; &amp;namespaces)</td></tr>
<tr class="memdesc:a93192a2ea0afe58664e69232595ae08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns base name and fills in namespaces, outermost one first in vector.  <br /></td></tr>
<tr class="separator:a93192a2ea0afe58664e69232595ae08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf75f489ee0a40366b6374ff9113260" id="r_afbf75f489ee0a40366b6374ff9113260"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf75f489ee0a40366b6374ff9113260">strip_namespaces</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:afbf75f489ee0a40366b6374ff9113260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="#a93192a2ea0afe58664e69232595ae08e" title="Returns base name and fills in namespaces, outermost one first in vector.">extract_namespaces()</a>, but strip and discard the namespaces, returning base name only.  <br /></td></tr>
<tr class="separator:afbf75f489ee0a40366b6374ff9113260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8aad349dd3bfc69483b792fcab0f96" id="r_a4f8aad349dd3bfc69483b792fcab0f96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8aad349dd3bfc69483b792fcab0f96">file_make_temp</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a4f8aad349dd3bfc69483b792fcab0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed.  <br /></td></tr>
<tr class="separator:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf8a5ee39d2b222d8a0be57894a2f75" id="r_abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf8a5ee39d2b222d8a0be57894a2f75">dir_make_temp</a> ()</td></tr>
<tr class="memdesc:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed.  <br /></td></tr>
<tr class="separator:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a323363444e3d16237848f6f8715b" id="r_aff2a323363444e3d16237848f6f8715b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2a323363444e3d16237848f6f8715b">file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aff2a323363444e3d16237848f6f8715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for access().  <br /></td></tr>
<tr class="separator:aff2a323363444e3d16237848f6f8715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034796c3683c3301a09c0102c6adb8b0" id="r_a034796c3683c3301a09c0102c6adb8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a034796c3683c3301a09c0102c6adb8b0">assert_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a034796c3683c3301a09c0102c6adb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file doesn't exist.  <br /></td></tr>
<tr class="separator:a034796c3683c3301a09c0102c6adb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8356033bf440e2f990bdc9f27cdcdcf" id="r_ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8356033bf440e2f990bdc9f27cdcdcf">assert_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file DOES exist.  <br /></td></tr>
<tr class="separator:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd8ec86534a0e22d1ab4f2037bc562" id="r_a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05dd8ec86534a0e22d1ab4f2037bc562">file_unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for unlink().  <br /></td></tr>
<tr class="separator:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c611b7403f5613f08fb701ea6eed6" id="r_a947c611b7403f5613f08fb701ea6eed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947c611b7403f5613f08fb701ea6eed6">ensure_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a947c611b7403f5613f08fb701ea6eed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that no file with this path exists.  <br /></td></tr>
<tr class="separator:a947c611b7403f5613f08fb701ea6eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710588d377ce398aa366fc00f6d436aa" id="r_a710588d377ce398aa366fc00f6d436aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710588d377ce398aa366fc00f6d436aa">dir_rmdir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a710588d377ce398aa366fc00f6d436aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rmdir().  <br /></td></tr>
<tr class="separator:a710588d377ce398aa366fc00f6d436aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f41b4199ab2236fb4056661f20cc11" id="r_aa0f41b4199ab2236fb4056661f20cc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f41b4199ab2236fb4056661f20cc11">file_stat</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa0f41b4199ab2236fb4056661f20cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for stat().  <br /></td></tr>
<tr class="separator:aa0f41b4199ab2236fb4056661f20cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b13a717252cb9bda0e37b585d5f65ef" id="r_a4b13a717252cb9bda0e37b585d5f65ef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b13a717252cb9bda0e37b585d5f65ef">read_entire_file</a> (const std::string &amp;pathname)</td></tr>
<tr class="memdesc:a4b13a717252cb9bda0e37b585d5f65ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire contents of a file into a vector&lt;char&gt;.  <br /></td></tr>
<tr class="separator:a4b13a717252cb9bda0e37b585d5f65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a74e2116e6583961430bb9f96dc64" id="r_a4a0a74e2116e6583961430bb9f96dc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0a74e2116e6583961430bb9f96dc64">write_entire_file</a> (const std::string &amp;pathname, const void *source, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> source_len)</td></tr>
<tr class="memdesc:a4a0a74e2116e6583961430bb9f96dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or replace the contents of a file with a given pointer-and-length of memory.  <br /></td></tr>
<tr class="separator:a4a0a74e2116e6583961430bb9f96dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a41c09f705e2859eea67df0e04501" id="r_a687a41c09f705e2859eea67df0e04501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a687a41c09f705e2859eea67df0e04501">write_entire_file</a> (const std::string &amp;pathname, const std::vector&lt; char &gt; &amp;source)</td></tr>
<tr class="separator:a687a41c09f705e2859eea67df0e04501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc678d669d07fdd15685b87e3b8b620" id="r_a8cc678d669d07fdd15685b87e3b8b620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc678d669d07fdd15685b87e3b8b620">add_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a8cc678d669d07fdd15685b87e3b8b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <br /></td></tr>
<tr class="separator:a8cc678d669d07fdd15685b87e3b8b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c64641e261b5596a2ab6d7da7f8ef8" id="r_a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82c64641e261b5596a2ab6d7da7f8ef8">sub_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa735c9ff93372dce25222fb551b67" id="r_a9aaa735c9ff93372dce25222fb551b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aaa735c9ff93372dce25222fb551b67">mul_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9aaa735c9ff93372dce25222fb551b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddf0741f1360ab02ae2c5871a50e5c9" id="r_a7ddf0741f1360ab02ae2c5871a50e5c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ddf0741f1360ab02ae2c5871a50e5c9">add_with_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *result)</td></tr>
<tr class="memdesc:a7ddf0741f1360ab02ae2c5871a50e5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to perform arithmetic on signed types without triggering signed overflow.  <br /></td></tr>
<tr class="separator:a7ddf0741f1360ab02ae2c5871a50e5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6eced9ecc08886e52cb8df1aee61b2" id="r_adc6eced9ecc08886e52cb8df1aee61b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc6eced9ecc08886e52cb8df1aee61b2">sub_with_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *result)</td></tr>
<tr class="separator:adc6eced9ecc08886e52cb8df1aee61b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94090aac2902ca0d3861c9eb80d39a47" id="r_a94090aac2902ca0d3861c9eb80d39a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94090aac2902ca0d3861c9eb80d39a47">mul_with_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *result)</td></tr>
<tr class="separator:a94090aac2902ca0d3861c9eb80d39a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342a753f8441a0b29418b0d22cbda86" id="r_ae342a753f8441a0b29418b0d22cbda86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae342a753f8441a0b29418b0d22cbda86">halide_tic_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:ae342a753f8441a0b29418b0d22cbda86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23694d45bd4c42ec1dc97a17bb78f6" id="r_a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c23694d45bd4c42ec1dc97a17bb78f6">halide_toc_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b578ca36f6632806a5f37bc631f801c" id="r_a2b578ca36f6632806a5f37bc631f801c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b578ca36f6632806a5f37bc631f801c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b578ca36f6632806a5f37bc631f801c">begin</a> (<a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt; i)</td></tr>
<tr class="separator:a2b578ca36f6632806a5f37bc631f801c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9c9be1aaf01be6d77cd6f83a0f591" id="r_ae1d9c9be1aaf01be6d77cd6f83a0f591"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1d9c9be1aaf01be6d77cd6f83a0f591"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1d9c9be1aaf01be6d77cd6f83a0f591">end</a> (<a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt; i)</td></tr>
<tr class="separator:ae1d9c9be1aaf01be6d77cd6f83a0f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c98c7054db881ad405869df25669c9" id="r_ab1c98c7054db881ad405869df25669c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1c98c7054db881ad405869df25669c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1c98c7054db881ad405869df25669c9">reverse_view</a> (T &amp;&amp;range)</td></tr>
<tr class="memdesc:ab1c98c7054db881ad405869df25669c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-order adaptor for range-based for-loops.  <br /></td></tr>
<tr class="separator:ab1c98c7054db881ad405869df25669c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7465fda53b7318463f0f45f6511dc075" id="r_a7465fda53b7318463f0f45f6511dc075"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7465fda53b7318463f0f45f6511dc075">c_print_name</a> (const std::string &amp;name, bool prefix_underscore=true)</td></tr>
<tr class="memdesc:a7465fda53b7318463f0f45f6511dc075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a version of a string that is a valid identifier in C (.  <br /></td></tr>
<tr class="separator:a7465fda53b7318463f0f45f6511dc075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591746c6ae0cd3e8d24c2c2420772d8a" id="r_a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591746c6ae0cd3e8d24c2c2420772d8a">get_llvm_version</a> ()</td></tr>
<tr class="memdesc:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVM_VERSION against which this libHalide is compiled.  <br /></td></tr>
<tr class="separator:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe57f2ce9ba5592659449fccd5c1c6" id="r_a45fe57f2ce9ba5592659449fccd5c1c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45fe57f2ce9ba5592659449fccd5c1c6">run_with_large_stack</a> (const std::function&lt; void()&gt; &amp;action)</td></tr>
<tr class="memdesc:a45fe57f2ce9ba5592659449fccd5c1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> the given action in a platform-specific context that provides at least the stack space returned by get_compiler_stack_size.  <br /></td></tr>
<tr class="separator:a45fe57f2ce9ba5592659449fccd5c1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac117f9e0b3bbb544807e9ddb1f6c49d9" id="r_ac117f9e0b3bbb544807e9ddb1f6c49d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac117f9e0b3bbb544807e9ddb1f6c49d9">popcount64</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> x)</td></tr>
<tr class="memdesc:ac117f9e0b3bbb544807e9ddb1f6c49d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable versions of popcount, count-leading-zeros, and count-trailing-zeros.  <br /></td></tr>
<tr class="separator:ac117f9e0b3bbb544807e9ddb1f6c49d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c27f5abba4dce3848962690f15c0ac" id="r_a77c27f5abba4dce3848962690f15c0ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77c27f5abba4dce3848962690f15c0ac">clz64</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> x)</td></tr>
<tr class="separator:a77c27f5abba4dce3848962690f15c0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0b4593680c5fcfc77b72f709a69cb" id="r_a04b0b4593680c5fcfc77b72f709a69cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b0b4593680c5fcfc77b72f709a69cb">ctz64</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> x)</td></tr>
<tr class="separator:a04b0b4593680c5fcfc77b72f709a69cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbca40dc6f536bd853f878af922df261" id="r_acbca40dc6f536bd853f878af922df261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbca40dc6f536bd853f878af922df261">next_power_of_two</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> x)</td></tr>
<tr class="memdesc:acbca40dc6f536bd853f878af922df261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer 2^n, for some n, which is &gt;= x.  <br /></td></tr>
<tr class="separator:acbca40dc6f536bd853f878af922df261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f5eea16013aba7cc1c195fa251dd7" id="r_a043f5eea16013aba7cc1c195fa251dd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a043f5eea16013aba7cc1c195fa251dd7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a043f5eea16013aba7cc1c195fa251dd7">align_up</a> (T x, int n)</td></tr>
<tr class="separator:a043f5eea16013aba7cc1c195fa251dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e581c9e4b9559106c4f2b5b89b1f7c6" id="r_a2e581c9e4b9559106c4f2b5b89b1f7c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e581c9e4b9559106c4f2b5b89b1f7c6">make_argument_list</a> (int dimensionality)</td></tr>
<tr class="memdesc:a2e581c9e4b9559106c4f2b5b89b1f7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a list of unique arguments for definitions with unnamed arguments.  <br /></td></tr>
<tr class="separator:a2e581c9e4b9559106c4f2b5b89b1f7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44132e8c163a34a201c29a8e525038a4" id="r_a44132e8c163a34a201c29a8e525038a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44132e8c163a34a201c29a8e525038a4">vectorize_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a44132e8c163a34a201c29a8e525038a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <br /></td></tr>
<tr class="separator:a44132e8c163a34a201c29a8e525038a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae687a3d73d31063267f01aeac9a46884" id="r_ae687a3d73d31063267f01aeac9a46884"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae687a3d73d31063267f01aeac9a46884">wrap_func_calls</a> (const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:ae687a3d73d31063267f01aeac9a46884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions.  <br /></td></tr>
<tr class="separator:ae687a3d73d31063267f01aeac9a46884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d57ef08d50b32cd0f947c699a7508" id="r_abb9d57ef08d50b32cd0f947c699a7508"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb9d57ef08d50b32cd0f947c699a7508">get_test_tmp_dir</a> ()</td></tr>
<tr class="memdesc:abb9d57ef08d50b32cd0f947c699a7508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path to a directory that can be safely written to when running tests; the contents directory may or may not outlast the lifetime of test itself (ie, the files may be cleaned up after test execution).  <br /></td></tr>
<tr class="separator:abb9d57ef08d50b32cd0f947c699a7508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a25b077cb4a97dbf2fc64bb665826b512" id="r_a25b077cb4a97dbf2fc64bb665826b512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b077cb4a97dbf2fc64bb665826b512">lower_int_uint_div</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, bool round_to_zero=false)</td></tr>
<tr class="memdesc:a25b077cb4a97dbf2fc64bb665826b512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary.  <br /></td></tr>
<tr class="separator:a25b077cb4a97dbf2fc64bb665826b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b44815561924377a690cf1d967bd19f" id="r_a3b44815561924377a690cf1d967bd19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b44815561924377a690cf1d967bd19f">lower_int_uint_mod</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a3b44815561924377a690cf1d967bd19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary.  <br /></td></tr>
<tr class="separator:a3b44815561924377a690cf1d967bd19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7a4f18b650b23e1e6ed980d1feebcf5" id="r_ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7a4f18b650b23e1e6ed980d1feebcf5">lower_euclidean_div</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <br /></td></tr>
<tr class="separator:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d78fd7f3115750e17167ebf0fe920" id="r_ae81d78fd7f3115750e17167ebf0fe920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae81d78fd7f3115750e17167ebf0fe920">lower_euclidean_mod</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ae81d78fd7f3115750e17167ebf0fe920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <br /></td></tr>
<tr class="separator:ae81d78fd7f3115750e17167ebf0fe920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ce06cce9e67778758fd7090bd991421" id="r_a9ce06cce9e67778758fd7090bd991421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ce06cce9e67778758fd7090bd991421">lower_signed_shift_left</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a9ce06cce9e67778758fd7090bd991421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts.  <br /></td></tr>
<tr class="separator:a9ce06cce9e67778758fd7090bd991421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2637f42ac63c862b5f2a279164d640d1" id="r_a2637f42ac63c862b5f2a279164d640d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2637f42ac63c862b5f2a279164d640d1">lower_signed_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a2637f42ac63c862b5f2a279164d640d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts.  <br /></td></tr>
<tr class="separator:a2637f42ac63c862b5f2a279164d640d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afbb25911a1f7a8eaad4ca3f443c96e01" id="r_afbb25911a1f7a8eaad4ca3f443c96e01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb25911a1f7a8eaad4ca3f443c96e01">lower_extract_bits</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *c)</td></tr>
<tr class="memdesc:afbb25911a1f7a8eaad4ca3f443c96e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce bit extraction and concatenation to bit ops.  <br /></td></tr>
<tr class="separator:afbb25911a1f7a8eaad4ca3f443c96e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eae0313e2330e7c9003fc623ae4fe3b" id="r_a7eae0313e2330e7c9003fc623ae4fe3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eae0313e2330e7c9003fc623ae4fe3b">lower_concat_bits</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *c)</td></tr>
<tr class="memdesc:a7eae0313e2330e7c9003fc623ae4fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce bit extraction and concatenation to bit ops.  <br /></td></tr>
<tr class="separator:a7eae0313e2330e7c9003fc623ae4fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a371a9e04b6a14f9897b94bc78437023d" id="r_a371a9e04b6a14f9897b94bc78437023d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a371a9e04b6a14f9897b94bc78437023d">eliminate_bool_vectors</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a371a9e04b6a14f9897b94bc78437023d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <br /></td></tr>
<tr class="separator:a371a9e04b6a14f9897b94bc78437023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320940955c9bdcced50b4f31ddd3f18" id="r_a6320940955c9bdcced50b4f31ddd3f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6320940955c9bdcced50b4f31ddd3f18">eliminate_bool_vectors</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;s)</td></tr>
<tr class="memdesc:a6320940955c9bdcced50b4f31ddd3f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <br /></td></tr>
<tr class="separator:a6320940955c9bdcced50b4f31ddd3f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa99b1b712f2a914dfbcabeb1f7777857" id="r_aa99b1b712f2a914dfbcabeb1f7777857"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa99b1b712f2a914dfbcabeb1f7777857">lldb_string</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:aa99b1b712f2a914dfbcabeb1f7777857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging helpers for LLDB.  <br /></td></tr>
<tr class="separator:aa99b1b712f2a914dfbcabeb1f7777857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0538675339647d35ffaadca9ad09283f" id="r_a0538675339647d35ffaadca9ad09283f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0538675339647d35ffaadca9ad09283f">lldb_string</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">Internal::BaseExprNode</a> *)</td></tr>
<tr class="memdesc:a0538675339647d35ffaadca9ad09283f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging helpers for LLDB.  <br /></td></tr>
<tr class="separator:a0538675339647d35ffaadca9ad09283f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe53c86fe52500bdca596f46e8fb0d0" id="r_aefe53c86fe52500bdca596f46e8fb0d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefe53c86fe52500bdca596f46e8fb0d0">lldb_string</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:aefe53c86fe52500bdca596f46e8fb0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging helpers for LLDB.  <br /></td></tr>
<tr class="separator:aefe53c86fe52500bdca596f46e8fb0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ada0590e00c28750a1308739e988f82ab" id="r_ada0590e00c28750a1308739e988f82ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada0590e00c28750a1308739e988f82ab">reduce_expr_modulo</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> modulus, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *remainder)</td></tr>
<tr class="memdesc:ada0590e00c28750a1308739e988f82ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <br /></td></tr>
<tr class="separator:ada0590e00c28750a1308739e988f82ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5878a79c89558798237c40d7b54f3" id="r_a92c5878a79c89558798237c40d7b54f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c5878a79c89558798237c40d7b54f3">reduce_expr_modulo</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> modulus, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *remainder, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:a92c5878a79c89558798237c40d7b54f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <br /></td></tr>
<tr class="separator:a92c5878a79c89558798237c40d7b54f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac4e8d52841afa71f1f7bac7ce9611159" id="r_ac4e8d52841afa71f1f7bac7ce9611159"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e8d52841afa71f1f7bac7ce9611159">unknown</a> = std::numeric_limits&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt;<a class="el" href="#a41d5010a34ae900ef4f855ee5420a923">::min</a>()</td></tr>
<tr class="separator:ac4e8d52841afa71f1f7bac7ce9611159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf1a96be9fadff5521559de5f72935c" id="r_a4bf1a96be9fadff5521559de5f72935c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bf1a96be9fadff5521559de5f72935c">StrongestExprNodeType</a> = <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5">IRNodeType::VectorReduce</a></td></tr>
<tr class="separator:a4bf1a96be9fadff5521559de5f72935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a67af6498244e055c3e0ec8f69990" id="r_acf4a67af6498244e055c3e0ec8f69990"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4a67af6498244e055c3e0ec8f69990">random_variable_counter</a></td></tr>
<tr class="separator:acf4a67af6498244e055c3e0ec8f69990"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acc8e4407368c814081b11769fa150132" name="acc8e4407368c814081b11769fa150132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8e4407368c814081b11769fa150132">&#9670;&#160;</a></span>AbstractGeneratorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acc8e4407368c814081b11769fa150132">Halide::Internal::AbstractGeneratorPtr</a> = std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_abstract_generator.html">AbstractGenerator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_abstract_generator_8h_source.html#l00244">244</a> of file <a class="el" href="_abstract_generator_8h_source.html">AbstractGenerator.h</a>.</p>

</div>
</div>
<a id="abff8dba5612d856cc2acfab99e3cf479" name="abff8dba5612d856cc2acfab99e3cf479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff8dba5612d856cc2acfab99e3cf479">&#9670;&#160;</a></span>DimBounds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">Halide::Internal::DimBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00020">20</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

</div>
</div>
<a id="aaa0611a86047e2c583dd061a620dcc6e" name="aaa0611a86047e2c583dd061a620dcc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0611a86047e2c583dd061a620dcc6e">&#9670;&#160;</a></span>FuncValueBounds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;std::string, int&gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">Halide::Internal::FuncValueBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_bounds_8h_source.html#l00017">17</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a id="ac13aeea9641a9bbf0013901f4326dd58" name="ac13aeea9641a9bbf0013901f4326dd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13aeea9641a9bbf0013901f4326dd58">&#9670;&#160;</a></span>add_const_if_T_is_const</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac13aeea9641a9bbf0013901f4326dd58">Halide::Internal::add_const_if_T_is_const</a> = typename std::conditional&lt;std::is_const&lt;T&gt;::value, const T2, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00083">83</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="ad7c7e335aa48b00b3c72b510582b5524" name="ad7c7e335aa48b00b3c72b510582b5524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c7e335aa48b00b3c72b510582b5524">&#9670;&#160;</a></span>GeneratorParamImplBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad7c7e335aa48b00b3c72b510582b5524">Halide::Internal::GeneratorParamImplBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">typename</span> select_type&lt;</div>
<div class="line">        cond&lt;std::is_same&lt;T, Target&gt;::value, GeneratorParam_Target&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;T, LoopLevel&gt;::value, GeneratorParam_LoopLevel&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;T, std::string&gt;::value, GeneratorParam_String&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;T, Type&gt;::value, GeneratorParam_Type&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;T, bool&gt;::value, GeneratorParam_Bool&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_arithmetic&lt;T&gt;::value, GeneratorParam_Arithmetic&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_enum&lt;T&gt;::value, GeneratorParam_Enum&lt;T&gt;&gt;&gt;::type</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00941">941</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a00a7a3695e256e17892889cb17ae3c19" name="a00a7a3695e256e17892889cb17ae3c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a7a3695e256e17892889cb17ae3c19">&#9670;&#160;</a></span>GeneratorInputImplBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a00a7a3695e256e17892889cb17ae3c19">Halide::Internal::GeneratorInputImplBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">typename</span> select_type&lt;</div>
<div class="line">        cond&lt;has_static_halide_type_method&lt;TBase&gt;::value, GeneratorInput_Buffer&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;TBase, Func&gt;::value, GeneratorInput_Func&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_arithmetic&lt;TBase&gt;::value, GeneratorInput_Arithmetic&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_scalar&lt;TBase&gt;::value, GeneratorInput_Scalar&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;TBase, Expr&gt;::value, GeneratorInput_DynamicScalar&lt;T&gt;&gt;&gt;::type</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02175">2175</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a5a8f72664152ee17c9a9a0a206b76ae0" name="a5a8f72664152ee17c9a9a0a206b76ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8f72664152ee17c9a9a0a206b76ae0">&#9670;&#160;</a></span>GeneratorOutputImplBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5a8f72664152ee17c9a9a0a206b76ae0">Halide::Internal::GeneratorOutputImplBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">typename</span> select_type&lt;</div>
<div class="line">        cond&lt;has_static_halide_type_method&lt;TBase&gt;::value, GeneratorOutput_Buffer&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_same&lt;TBase, Func&gt;::value, GeneratorOutput_Func&lt;T&gt;&gt;,</div>
<div class="line">        cond&lt;std::is_arithmetic&lt;TBase&gt;::value, GeneratorOutput_Arithmetic&lt;T&gt;&gt;&gt;::type</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02786">2786</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a60cfa4b673c27588073a14e4025df4cf" name="a60cfa4b673c27588073a14e4025df4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cfa4b673c27588073a14e4025df4cf">&#9670;&#160;</a></span>GeneratorFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a60cfa4b673c27588073a14e4025df4cf">Halide::Internal::GeneratorFactory</a> = std::function&lt;<a class="el" href="#acc8e4407368c814081b11769fa150132">AbstractGeneratorPtr</a>(const <a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a> &amp;context)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03115">3115</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a7114c2dcec2af79da28735c5b11c0916" name="a7114c2dcec2af79da28735c5b11c0916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7114c2dcec2af79da28735c5b11c0916">&#9670;&#160;</a></span>LLVMOStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef llvm::raw_pwrite_stream <a class="el" href="#a7114c2dcec2af79da28735c5b11c0916">Halide::Internal::LLVMOStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___output_8h_source.html#l00027">27</a> of file <a class="el" href="_l_l_v_m___output_8h_source.html">LLVM_Output.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0396411abf88410baf6a6e6e41ea1419" name="a0396411abf88410baf6a6e6e41ea1419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0396411abf88410baf6a6e6e41ea1419">&#9670;&#160;</a></span>ArgInfoKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0396411abf88410baf6a6e6e41ea1419">Halide::Internal::ArgInfoKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0396411abf88410baf6a6e6e41ea1419af60357a8d17e45793298323f1b372a74" name="a0396411abf88410baf6a6e6e41ea1419af60357a8d17e45793298323f1b372a74"></a>Scalar&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0396411abf88410baf6a6e6e41ea1419a86408593c34af77fdd90df932f8b5261" name="a0396411abf88410baf6a6e6e41ea1419a86408593c34af77fdd90df932f8b5261"></a>Function&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0396411abf88410baf6a6e6e41ea1419a7e62bc342f41c946868f0ea6f0b712d8" name="a0396411abf88410baf6a6e6e41ea1419a7e62bc342f41c946868f0ea6f0b712d8"></a>Buffer&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_abstract_generator_8h_source.html#l00026">26</a> of file <a class="el" href="_abstract_generator_8h_source.html">AbstractGenerator.h</a>.</p>

</div>
</div>
<a id="adb05011033eb11f001b6a4cb5a6ae619" name="adb05011033eb11f001b6a4cb5a6ae619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb05011033eb11f001b6a4cb5a6ae619">&#9670;&#160;</a></span>ArgInfoDirection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#adb05011033eb11f001b6a4cb5a6ae619">Halide::Internal::ArgInfoDirection</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb05011033eb11f001b6a4cb5a6ae619a324118a6721dd6b8a9b9f4e327df2bf5" name="adb05011033eb11f001b6a4cb5a6ae619a324118a6721dd6b8a9b9f4e327df2bf5"></a>Input&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adb05011033eb11f001b6a4cb5a6ae619a29c2c02a361c9d7028472e5d92cd4a54" name="adb05011033eb11f001b6a4cb5a6ae619a29c2c02a361c9d7028472e5d92cd4a54"></a>Output&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_abstract_generator_8h_source.html#l00030">30</a> of file <a class="el" href="_abstract_generator_8h_source.html">AbstractGenerator.h</a>.</p>

</div>
</div>
<a id="a8548315fd4d13ccebe45a8123369f7ca" name="a8548315fd4d13ccebe45a8123369f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8548315fd4d13ccebe45a8123369f7ca">&#9670;&#160;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8548315fd4d13ccebe45a8123369f7ca">Halide::Internal::Direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a varying expression, try to find a constant that is either: An upper bound (always greater than or equal to the expression), or A lower bound (always less than or equal to the expression) If it fails, returns an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec" name="a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec"></a>Upper&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93" name="a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93"></a>Lower&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_bounds_8h_source.html#l00042">42</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a id="aee9e0b8e5376e2294d74ded8e7de9ef2" name="aee9e0b8e5376e2294d74ded8e7de9ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9e0b8e5376e2294d74ded8e7de9ef2">&#9670;&#160;</a></span>IRNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2">Halide::Internal::IRNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All our IR node types get unique IDs for the purposes of RTTI. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417" name="aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417"></a>IntImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8" name="aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8"></a>UIntImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07" name="aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07"></a>FloatImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73" name="aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73"></a>StringImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842" name="aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842"></a>Broadcast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c" name="aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c"></a>Cast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2939cc096ba90c44ede434ba24ed3436" name="aee9e0b8e5376e2294d74ded8e7de9ef2a2939cc096ba90c44ede434ba24ed3436"></a>Reinterpret&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9" name="aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9"></a>Variable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9" name="aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2" name="aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2"></a>Sub&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942" name="aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2" name="aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a" name="aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2" name="aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233" name="aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47" name="aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0" name="aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0"></a>NE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b" name="aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b"></a>LT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6" name="aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6"></a>LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020" name="aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020"></a>GT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9" name="aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9"></a>GE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b" name="aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c" name="aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666" name="aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff" name="aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff"></a>Select&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb" name="aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb"></a>Load&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb" name="aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb"></a>Ramp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e" name="aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e"></a>Call&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6" name="aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6"></a>Let&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae8b4b40ec3622e371789b790caabc083" name="aee9e0b8e5376e2294d74ded8e7de9ef2ae8b4b40ec3622e371789b790caabc083"></a>Shuffle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5" name="aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5"></a>VectorReduce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2" name="aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2"></a>LetStmt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742" name="aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742"></a>AssertStmt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0" name="aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0"></a>ProducerConsumer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11" name="aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11"></a>For&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a993ca650a85e8e69b8f7eaa4809c4862" name="aee9e0b8e5376e2294d74ded8e7de9ef2a993ca650a85e8e69b8f7eaa4809c4862"></a>Acquire&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72" name="aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72"></a>Store&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7" name="aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7"></a>Provide&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f" name="aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f"></a>Allocate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594" name="aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594"></a>Free&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc" name="aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc"></a>Realize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2" name="aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a36c81967df3424f919e89b09ed34c90d" name="aee9e0b8e5376e2294d74ded8e7de9ef2a36c81967df3424f919e89b09ed34c90d"></a>Fork&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c" name="aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f" name="aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f"></a>Evaluate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a18540d940813866480eaca8d3f32d18e" name="aee9e0b8e5376e2294d74ded8e7de9ef2a18540d940813866480eaca8d3f32d18e"></a>Prefetch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a557eccd321b7f10f5127c1ef27aaac7d" name="aee9e0b8e5376e2294d74ded8e7de9ef2a557eccd321b7f10f5127c1ef27aaac7d"></a>Atomic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ab8b1a8074f151efb78b9b1c0010a23c2" name="aee9e0b8e5376e2294d74ded8e7de9ef2ab8b1a8074f151efb78b9b1c0010a23c2"></a>HoistedStorage&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00025">25</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="a6a8761f129e6554b9ea03de31bf066f1" name="a6a8761f129e6554b9ea03de31bf066f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8761f129e6554b9ea03de31bf066f1">&#9670;&#160;</a></span>ForType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">Halide::Internal::ForType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of loop traversal. </p>
<p>Used in schedules, and in the <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> loop IR node. Serial is a conventional ordered for loop. Iterations occur in increasing order, and each iteration must appear to have finished before the next begins. Parallel, GPUBlock, and GPUThread are parallel and unordered: iterations may occur in any order, and multiple iterations may occur simultaneously. Vectorized and GPULane are parallel and synchronous: they act as if all iterations occur at the same time in lockstep. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493" name="a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493"></a>Serial&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131" name="a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725" name="a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac" name="a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a498ab78ee0b25ce33c83714c1a453831" name="a6a8761f129e6554b9ea03de31bf066f1a498ab78ee0b25ce33c83714c1a453831"></a>Extern&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a9ad52f412f8b405c833cd317db050a28" name="a6a8761f129e6554b9ea03de31bf066f1a9ad52f412f8b405c833cd317db050a28"></a>GPUBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a403672f982053243315d59e56d8a3b8d" name="a6a8761f129e6554b9ea03de31bf066f1a403672f982053243315d59e56d8a3b8d"></a>GPUThread&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1ab6f9478bd3fd1adac23a5802d786d642" name="a6a8761f129e6554b9ea03de31bf066f1ab6f9478bd3fd1adac23a5802d786d642"></a>GPULane&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00406">406</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="a43770c59ec0f13935f4b33502ba7e817" name="a43770c59ec0f13935f4b33502ba7e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43770c59ec0f13935f4b33502ba7e817">&#9670;&#160;</a></span>SyntheticParamType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a43770c59ec0f13935f4b33502ba7e817">Halide::Internal::SyntheticParamType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508" name="a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508"></a>Type&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9" name="a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9"></a>Dim&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c" name="a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c"></a>ArraySize&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02892">2892</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a7dc0c8c1adc38d2c5a80979948f0007c" name="a7dc0c8c1adc38d2c5a80979948f0007c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc0c8c1adc38d2c5a80979948f0007c">&#9670;&#160;</a></span>Monotonic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Halide::Internal::Monotonic</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255" name="a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd" name="a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd"></a>Increasing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b" name="a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b"></a>Decreasing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e" name="a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_monotonic_8h_source.html#l00026">26</a> of file <a class="el" href="_monotonic_8h_source.html">Monotonic.h</a>.</p>

</div>
</div>
<a id="a5b8c72fcb8800b47e313c62f5416a4fe" name="a5b8c72fcb8800b47e313c62f5416a4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c72fcb8800b47e313c62f5416a4fe">&#9670;&#160;</a></span>DimType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4fe">Halide::Internal::DimType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each <a class="el" href="struct_halide_1_1_internal_1_1_dim.html" title="The Dim struct represents one loop in the schedule&#39;s representation of a loop nest.">Dim</a> below has a dim_type, which tells you what transformations are legal on it. </p>
<p>When you combine two Dims of distinct DimTypes (e.g. with <a class="el" href="class_halide_1_1_stage.html#aa8b373ea2beafa6f44cbda818e7a3259">Stage::fuse</a>), the combined result has the greater enum value of the two types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5b8c72fcb8800b47e313c62f5416a4feafbbbe5ac592bfdafcfa397cd609d8117" name="a5b8c72fcb8800b47e313c62f5416a4feafbbbe5ac592bfdafcfa397cd609d8117"></a>PureVar&#160;</td><td class="fielddoc"><p>This dim originated from a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>. </p>
<p>You can evaluate a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of this <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> in any order over an interval that's at least as large as the interval required. In pure definitions you can even redundantly re-evaluate points. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b8c72fcb8800b47e313c62f5416a4fead117eadbd7c1c4d821b3a598d54d03f2" name="a5b8c72fcb8800b47e313c62f5416a4fead117eadbd7c1c4d821b3a598d54d03f2"></a>PureRVar&#160;</td><td class="fielddoc"><p>The dim originated from an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>. </p>
<p>You can evaluate a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of this <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in any order (including in parallel) over exactly the interval specified in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>. PureRVars can also be reordered arbitrarily in the dims list, as there are no data hazards between the evaluation of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of the <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>.</p>
<p>The most common case where an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> is considered pure is RVars that are used in a way which obeys all the syntactic constraints that a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> does, e.g:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, 100);</div>
<div class="line">f(r.x) = f(r.x) + 5;</div>
<div class="ttc" id="aclass_halide_1_1_r_dom_html"><div class="ttname"><a href="class_halide_1_1_r_dom.html">Halide::RDom</a></div><div class="ttdoc">A multi-dimensional domain over which to iterate.</div><div class="ttdef"><b>Definition</b> <a href="_r_dom_8h_source.html#l00193">RDom.h:193</a></div></div>
</div><!-- fragment --><p>Other cases where RVars are pure are where the sites being written to by the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> evaluated at one value of the <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> couldn't possibly collide with the sites being written or read by the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at a distinct value of the <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, r.x is pure in the following three definitions:</p>
<div class="fragment"><div class="line"><span class="comment">// This definition writes to even coordinates and reads from the</span></div>
<div class="line"><span class="comment">// same site (which no other value of r.x is writing to) and odd</span></div>
<div class="line"><span class="comment">// sites (which no other value of r.x is writing to):</span></div>
<div class="line">f(2*r.x) = <a class="code hl_function" href="#a60e34906118319ac8ae12858ba6faf5b">max</a>(f(2*r.x), f(2*r.x + 7));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This definition writes to scanline zero and reads from the the</span></div>
<div class="line"><span class="comment">// same site and scanline one:</span></div>
<div class="line">f(r.x, 0) += f(r.x, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This definition reads and writes over non-overlapping ranges:</span></div>
<div class="line">f(r.x + 100) += f(r.x);</div>
<div class="ttc" id="anamespace_halide_1_1_internal_html_a60e34906118319ac8ae12858ba6faf5b"><div class="ttname"><a href="#a60e34906118319ac8ae12858ba6faf5b">Halide::Internal::max</a></div><div class="ttdeci">ConstantInterval max(const ConstantInterval &amp;a, const ConstantInterval &amp;b)</div></div>
</div><!-- fragment --><p>To give two counterexamples, r.x is not pure in the following definitions:</p>
<div class="fragment"><div class="line"><span class="comment">// The same site is written by distinct values of the RVar</span></div>
<div class="line"><span class="comment">// (write-after-write hazard):</span></div>
<div class="line">f(r.x / 2) += f(r.x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// One value of r.x reads from a site that another value of r.x</span></div>
<div class="line"><span class="comment">// is writing to (read-after-write hazard):</span></div>
<div class="line">f(r.x) += f(r.x + 1);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a5b8c72fcb8800b47e313c62f5416a4feac2ab1e3a4730b5543c84be4a4a223b83" name="a5b8c72fcb8800b47e313c62f5416a4feac2ab1e3a4730b5543c84be4a4a223b83"></a>ImpureRVar&#160;</td><td class="fielddoc"><p>The dim originated from an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>. </p>
<p>You must evaluate a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of this <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in increasing order over precisely the interval specified in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>. ImpureRVars may not be reordered with respect to other ImpureRVars.</p>
<p>All RVars are impure by default. Those for which we can prove no data hazards exist get promoted to PureRVar. There are two instances in which ImpureRVars may be parallelized or reordered even in the presence of hazards:</p>
<p>1) In the case of an update definition that has been proven to be an associative and commutative reduction, reordering of ImpureRVars is allowed, and parallelizing them is allowed if the update has been made atomic.</p>
<p>2) ImpureRVars can also be reordered and parallelized if <a class="el" href="class_halide_1_1_func.html#a712365570e7695d9b157ba2e4b089343" title="Specify that race conditions are permitted for this Func, which enables parallelizing over RVars even...">Func::allow_race_conditions()</a> has been set. This is the escape hatch for when there are no hazards but the checks above failed to prove that (<a class="el" href="class_halide_1_1_r_dom.html#ab412e453375071f67584442a0dc71dd8" title="Add a predicate to the RDom.">RDom::where</a> can encode arbitrary facts about non-linear integer arithmetic, which is undecidable), or for when you don't actually care about the non-determinism introduced by data hazards (e.g. in the algorithm HOGWILD!). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_schedule_8h_source.html#l00357">357</a> of file <a class="el" href="_schedule_8h_source.html">Schedule.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3a92e4cf0e42a7ea4777922833ff77fd" name="a3a92e4cf0e42a7ea4777922833ff77fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a92e4cf0e42a7ea4777922833ff77fd">&#9670;&#160;</a></span>add_atomic_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_atomic_mutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe5c6a19891ace3a590f49ba456ca1d6" name="afe5c6a19891ace3a590f49ba456ca1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5c6a19891ace3a590f49ba456ca1d6">&#9670;&#160;</a></span>add_image_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_image_checks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>will_inject_host_copies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g. </p>
<p>stride.0 must be 1). </p>

</div>
</div>
<a id="af1610da9bbdeab59ba5d7724231352ab" name="af1610da9bbdeab59ba5d7724231352ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1610da9bbdeab59ba5d7724231352ab">&#9670;&#160;</a></span>add_parameter_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_parameter_checks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>requirements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure that all referenced parameters meet their constraints. </p>
<p>Also injects any custom requirements provided by the user. </p>

</div>
</div>
<a id="aa8465b7af6ae07e3bf1ae88bce4d931e" name="aa8465b7af6ae07e3bf1ae88bce4d931e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8465b7af6ae07e3bf1ae88bce4d931e">&#9670;&#160;</a></span>add_split_factor_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_split_factor_checks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks that all split factors that depend on scalar parameters are strictly positive. </p>

</div>
</div>
<a id="aeca3c458ab863fb376fee3f42f4ded8d" name="aeca3c458ab863fb376fee3f42f4ded8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca3c458ab863fb376fee3f42f4ded8d">&#9670;&#160;</a></span>align_loads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::align_loads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_bytes_to_align</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors. </p>
<p>Types that are less than min_bytes_to_align in size are not rewritten. This is intended to make a distinction between data that will be accessed as a scalar and that which will be accessed as a vector. </p>

</div>
</div>
<a id="a410eac3ad68dfb697c5ee97100f2053f" name="a410eac3ad68dfb697c5ee97100f2053f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410eac3ad68dfb697c5ee97100f2053f">&#9670;&#160;</a></span>allocation_bounds_inference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::allocation_bounds_inference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes in terms of variables, and define values for those variables. </p>

</div>
</div>
<a id="a39733fd9ce489f24117a0188d89107a8" name="a39733fd9ce489f24117a0188d89107a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39733fd9ce489f24117a0188d89107a8">&#9670;&#160;</a></span>apply_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a> &gt; Halide::Internal::apply_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>split</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dim_extent_alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> schedule on a definition (init or update), return a list of of predicates on the definition, substitutions that needs to be applied to the definition (in ascending order of application), and let stmts which defined the values of variables referred by the predicates and substitutions (ordered from innermost to outermost let). </p>

</div>
</div>
<a id="ad3589e250311bb913b71fd2355258098" name="ad3589e250311bb913b71fd2355258098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3589e250311bb913b71fd2355258098">&#9670;&#160;</a></span>compute_loop_bounds_after_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; Halide::Internal::compute_loop_bounds_after_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>split</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the loop bounds of the new dimensions resulting from applying the split schedules using the loop bounds of the old dimensions. </p>

</div>
</div>
<a id="a459944d05613a6737daffec0a67d865c" name="a459944d05613a6737daffec0a67d865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459944d05613a6737daffec0a67d865c">&#9670;&#160;</a></span>get_ops_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &gt; &amp; Halide::Internal::get_ops_table </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf049bd392c948b161c1435e23184a20" name="acf049bd392c948b161c1435e23184a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf049bd392c948b161c1435e23184a20">&#9670;&#160;</a></span>prove_associativity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> Halide::Internal::prove_associativity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any. </p>
<p>'is_associative' indicates if the operation was successfuly proven as associative. </p>

</div>
</div>
<a id="a74a6050713d80d82d1ba201fc9f709b7" name="a74a6050713d80d82d1ba201fc9f709b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a6050713d80d82d1ba201fc9f709b7">&#9670;&#160;</a></span>associativity_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::associativity_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0092d026f554bbd98a3c603e58e6e46e" name="a0092d026f554bbd98a3c603e58e6e46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0092d026f554bbd98a3c603e58e6e46e">&#9670;&#160;</a></span>fork_async_producers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fork_async_producers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdf8e17b611c700b1a41969a8dc7c1e1" name="acdf8e17b611c700b1a41969a8dc7c1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf8e17b611c700b1a41969a8dc7c1e1">&#9670;&#160;</a></span>string_to_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an int representation of 's'. </p>
<p>Throw an error on failure. </p>

</div>
</div>
<a id="a553a170f5d655144a90d342f46bb5bc7" name="a553a170f5d655144a90d342f46bb5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553a170f5d655144a90d342f46bb5bc7">&#9670;&#160;</a></span>substitute_var_estimates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_var_estimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> with its estimate if specified. </p>

</div>
</div>
<a id="a78c43260020b62213bc2383cb13f7aeb" name="a78c43260020b62213bc2383cb13f7aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c43260020b62213bc2383cb13f7aeb">&#9670;&#160;</a></span>substitute_var_estimates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute_var_estimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f09ed39b20fb0f51fbda5a7b14c7f93" name="a7f09ed39b20fb0f51fbda5a7b14c7f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f09ed39b20fb0f51fbda5a7b14c7f93">&#9670;&#160;</a></span>get_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::get_extent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an interval. </p>
<p>Return an undefined expr if the interval is unbounded. </p>

</div>
</div>
<a id="a09ce3144d60aa2f3abdb127b3750cb73" name="a09ce3144d60aa2f3abdb127b3750cb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce3144d60aa2f3abdb127b3750cb73">&#9670;&#160;</a></span>box_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::box_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an n-d box. </p>

</div>
</div>
<a id="a5f30fc5e0c64f2e3f32ffe1416f045b0" name="a5f30fc5e0c64f2e3f32ffe1416f045b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f30fc5e0c64f2e3f32ffe1416f045b0">&#9670;&#160;</a></span>disp_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::disp_regions </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to print the bounds of a region. </p>

</div>
</div>
<a id="a4cf44d2ab2c8eca7437d770011107830" name="a4cf44d2ab2c8eca7437d770011107830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf44d2ab2c8eca7437d770011107830">&#9670;&#160;</a></span>get_stage_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> Halide::Internal::get_stage_definition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stage_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corresponding definition of a function given the stage. </p>
<p>This will throw an assertion if the function is an extern function (Extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> does not have definition). </p>

</div>
</div>
<a id="a5decec1772348bc3b6479452a35808cd" name="a5decec1772348bc3b6479452a35808cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5decec1772348bc3b6479452a35808cd">&#9670;&#160;</a></span>get_stage_dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a> &gt; &amp; Halide::Internal::get_stage_dims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stage_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corresponding loop dimensions of a function given the stage. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, this will return a list of size 1 containing the dummy __outermost loop dimension. </p>

</div>
</div>
<a id="a753561dbe4e01ef75c2af4ce17d3dfb1" name="a753561dbe4e01ef75c2af4ce17d3dfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753561dbe4e01ef75c2af4ce17d3dfb1">&#9670;&#160;</a></span>combine_load_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::combine_load_costs </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>partial</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> partial load costs to the corresponding function in the result costs. </p>

</div>
</div>
<a id="a2f47061da7dd7653e9d9058b850d94e5" name="a2f47061da7dd7653e9d9058b850d94e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f47061da7dd7653e9d9058b850d94e5">&#9670;&#160;</a></span>get_stage_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> Halide::Internal::get_stage_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stage_num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pure_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the required bounds of an intermediate stage (f, stage_num) of function 'f' given the bounds of the pure dimensions. </p>

</div>
</div>
<a id="a904ad5c1870b23c0f80cd43faa2d3d72" name="a904ad5c1870b23c0f80cd43faa2d3d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904ad5c1870b23c0f80cd43faa2d3d72">&#9670;&#160;</a></span>get_stage_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &gt; Halide::Internal::get_stage_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pure_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the required bounds for all the stages of the function 'f'. </p>
<p>Each entry in the returned vector corresponds to a stage. </p>

</div>
</div>
<a id="a1d7faaf922e66ac6f7367697d18fd1cd" name="a1d7faaf922e66ac6f7367697d18fd1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7faaf922e66ac6f7367697d18fd1cd">&#9670;&#160;</a></span>perform_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::perform_inline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inlines</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::set&lt;&#160;std::string&#160;&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;std::string&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively inline all the functions in the set 'inlines' into the expression 'e' and return the resulting expression. </p>
<p>If 'order' is passed, inlining will be done in the reverse order of function realization to avoid extra inlining works. </p>

</div>
</div>
<a id="a11b21e1dbf854a3f46f5403f9224af7d" name="a11b21e1dbf854a3f46f5403f9224af7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b21e1dbf854a3f46f5403f9224af7d">&#9670;&#160;</a></span>get_parents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; Halide::Internal::get_parents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all functions that are directly called by a function stage (f, stage). </p>

</div>
</div>
<a id="a765c203107b702636e6f2cf5ba896f95" name="a765c203107b702636e6f2cf5ba896f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765c203107b702636e6f2cf5ba896f95">&#9670;&#160;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V Halide::Internal::get_element </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value of element within a map. </p>
<p>This will assert if the element is not in the map. </p>

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00101">101</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>.</p>

</div>
</div>
<a id="ae7fc3b223b6e3e0268c901df78a45da2" name="ae7fc3b223b6e3e0268c901df78a45da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fc3b223b6e3e0268c901df78a45da2">&#9670;&#160;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V &amp; Halide::Internal::get_element </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; K, V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00108">108</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>.</p>

</div>
</div>
<a id="a976aabd7126fce7f9d7a46daeee8fd40" name="a976aabd7126fce7f9d7a46daeee8fd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976aabd7126fce7f9d7a46daeee8fd40">&#9670;&#160;</a></span>inline_all_trivial_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::inline_all_trivial_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the cost of computing a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is about the same as calling the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, inline the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Return true of any of the Funcs is inlined. </p>

</div>
</div>
<a id="a120045d61aae3bbe15e3da7b81bbb821" name="a120045d61aae3bbe15e3da7b81bbb821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120045d61aae3bbe15e3da7b81bbb821">&#9670;&#160;</a></span>is_func_called_element_wise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::is_func_called_element_wise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> (order[index]) is only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner. </p>
<p>If it is, return the name of the consumer <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>; otherwise, return an empty string. </p>

</div>
</div>
<a id="adb0e38c670066041490103529f6c5707" name="adb0e38c670066041490103529f6c5707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e38c670066041490103529f6c5707">&#9670;&#160;</a></span>inline_all_element_wise_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::inline_all_element_wise_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> if its values are only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner. </p>

</div>
</div>
<a id="a654878c752bfbc9f2aa979007ff80037" name="a654878c752bfbc9f2aa979007ff80037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654878c752bfbc9f2aa979007ff80037">&#9670;&#160;</a></span>propagate_estimate_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::propagate_estimate_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24815856c33f2ea729a891cdf4f3e494" name="a24815856c33f2ea729a891cdf4f3e494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24815856c33f2ea729a891cdf4f3e494">&#9670;&#160;</a></span>bound_constant_extent_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bound_constant_extent_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all loop extents of unrolled or vectorized loops with constants, by substituting and simplifying as needed. </p>
<p>If we can't determine a constant extent, but can determine a constant upper bound, inject an if statement into the body. If we can't even determine a constant upper bound, throw a user error. </p>

</div>
</div>
<a id="a7f9718bfbc37263743f6a0a168f986f2" name="a7f9718bfbc37263743f6a0a168f986f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9718bfbc37263743f6a0a168f986f2">&#9670;&#160;</a></span>empty_func_value_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp; Halide::Internal::empty_func_value_bounds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a963b0883bbda1c2664341158fce0b030" name="a963b0883bbda1c2664341158fce0b030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963b0883bbda1c2664341158fce0b030">&#9670;&#160;</a></span>bounds_of_expr_in_scope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::bounds_of_expr_in_scope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>const_bound</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a> or min may be undefined expressions if the value is not bounded above or below. If the expression is a vector, also takes the bounds across the vector lanes and returns a scalar result.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a id="a61f08062dfc06a1816ce78793faf5477" name="a61f08062dfc06a1816ce78793faf5477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f08062dfc06a1816ce78793faf5477">&#9670;&#160;</a></span>find_constant_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::find_constant_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8548315fd4d13ccebe45a8123369f7ca">Direction</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa34593e7612bf139260707200b6dacb3" name="aa34593e7612bf139260707200b6dacb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34593e7612bf139260707200b6dacb3">&#9670;&#160;</a></span>find_constant_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::find_constant_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bounds for a varying expression that are either constants or +/-inf. </p>

</div>
</div>
<a id="ac2f62c0ee3ace8de2be57a9db369a3e4" name="ac2f62c0ee3ace8de2be57a9db369a3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f62c0ee3ace8de2be57a9db369a3e4">&#9670;&#160;</a></span>merge_boxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::merge_boxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand box a to encompass box b. </p>

</div>
</div>
<a id="ac9641dd947fdf6352ccd5e34548db35e" name="ac9641dd947fdf6352ccd5e34548db35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9641dd947fdf6352ccd5e34548db35e">&#9670;&#160;</a></span>boxes_overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::boxes_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a could possibly overlap box b. </p>

</div>
</div>
<a id="af86d8a9b260b097d115182e4b8488f09" name="af86d8a9b260b097d115182e4b8488f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86d8a9b260b097d115182e4b8488f09">&#9670;&#160;</a></span>box_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of two boxes. </p>

</div>
</div>
<a id="a8c57c8cff1c0ff811a01724b58086bdc" name="a8c57c8cff1c0ff811a01724b58086bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c57c8cff1c0ff811a01724b58086bdc">&#9670;&#160;</a></span>box_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intersection of two boxes. </p>

</div>
</div>
<a id="a9198438916c78b87c90e665d665a18cd" name="a9198438916c78b87c90e665d665a18cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9198438916c78b87c90e665d665a18cd">&#9670;&#160;</a></span>box_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::box_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a provably contains box b. </p>

</div>
</div>
<a id="ad06242669df2b37e586deb5740de64b2" name="ad06242669df2b37e586deb5740de64b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06242669df2b37e586deb5740de64b2">&#9670;&#160;</a></span>boxes_required() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. Respects control flow (e.g. encodes if statement conditions), but assumes all encountered asserts pass. If it encounters an assert(false) in one if branch, assumes the opposite if branch runs unconditionally. </p>

</div>
</div>
<a id="ae4af1849bf39d9530f6e37a8a1c478fc" name="ae4af1849bf39d9530f6e37a8a1c478fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4af1849bf39d9530f6e37a8a1c478fc">&#9670;&#160;</a></span>boxes_required() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a8a3b4956c0e75a82926667995f658e" name="a8a8a3b4956c0e75a82926667995f658e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8a3b4956c0e75a82926667995f658e">&#9670;&#160;</a></span>boxes_provided() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>
<p>Handles asserts in the same way as boxes_required. </p>

</div>
</div>
<a id="a535b6fbb514f724d8df850efeaaea0bd" name="a535b6fbb514f724d8df850efeaaea0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535b6fbb514f724d8df850efeaaea0bd">&#9670;&#160;</a></span>boxes_provided() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a836aabb32682c2147c8780c6dd9bffa8" name="a836aabb32682c2147c8780c6dd9bffa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836aabb32682c2147c8780c6dd9bffa8">&#9670;&#160;</a></span>boxes_touched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>
<p>Handles asserts in the same way as boxes_required. </p>

</div>
</div>
<a id="aa3f6aa1329d6c1141e5f8557b243c7f7" name="aa3f6aa1329d6c1141e5f8557b243c7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f6aa1329d6c1141e5f8557b243c7f7">&#9670;&#160;</a></span>boxes_touched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6463d6b6c8c2d39485ca75d70bf7b246" name="a6463d6b6c8c2d39485ca75d70bf7b246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6463d6b6c8c2d39485ca75d70bf7b246">&#9670;&#160;</a></span>box_required() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a id="a98c9b1c2da827d6cb5394a0bb7e34533" name="a98c9b1c2da827d6cb5394a0bb7e34533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9b1c2da827d6cb5394a0bb7e34533">&#9670;&#160;</a></span>box_required() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48514c5115221230858e6e5b8584877" name="ae48514c5115221230858e6e5b8584877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48514c5115221230858e6e5b8584877">&#9670;&#160;</a></span>box_provided() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f44cfeb8474bb0aaa36e526fd65e35" name="a48f44cfeb8474bb0aaa36e526fd65e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f44cfeb8474bb0aaa36e526fd65e35">&#9670;&#160;</a></span>box_provided() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4b563d3cf1a063d9c85a584f796d032" name="aa4b563d3cf1a063d9c85a584f796d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b563d3cf1a063d9c85a584f796d032">&#9670;&#160;</a></span>box_touched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d3eadf5a7fa994f622e31c373bcf3d3" name="a6d3eadf5a7fa994f622e31c373bcf3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3eadf5a7fa994f622e31c373bcf3d3">&#9670;&#160;</a></span>box_touched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7f9718bfbc37263743f6a0a168f986f2">empty_func_value_bounds</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b807d0d1524fb2f20b1533d05032c02" name="a0b807d0d1524fb2f20b1533d05032c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b807d0d1524fb2f20b1533d05032c02">&#9670;&#160;</a></span>compute_function_value_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> Halide::Internal::compute_function_value_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum and minimum possible value for each function in an environment. </p>

</div>
</div>
<a id="a9b8f095ebce4f6ea07a0dd3ec7bbdb77" name="a9b8f095ebce4f6ea07a0dd3ec7bbdb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8f095ebce4f6ea07a0dd3ec7bbdb77">&#9670;&#160;</a></span>span_of_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::span_of_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439ef9127bf30f5e2a67963eb8db0323" name="a439ef9127bf30f5e2a67963eb8db0323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439ef9127bf30f5e2a67963eb8db0323">&#9670;&#160;</a></span>bounds_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::bounds_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff79174f5ffa82cd2af8a447439d3c3d" name="aff79174f5ffa82cd2af8a447439d3c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff79174f5ffa82cd2af8a447439d3c3d">&#9670;&#160;</a></span>bounds_inference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bounds_inference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>realization_order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fused_groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>environment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a id="a7428f5e071a4f8c2d89a79afc6b426a0" name="a7428f5e071a4f8c2d89a79afc6b426a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7428f5e071a4f8c2d89a79afc6b426a0">&#9670;&#160;</a></span>bound_small_allocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bound_small_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b58338c6b3553965f8360efe1d31788" name="a9b58338c6b3553965f8360efe1d31788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b58338c6b3553965f8360efe1d31788">&#9670;&#160;</a></span>buffer_accessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::buffer_accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefca0281fde1b4caf8d1d188d4bd809d" name="aefca0281fde1b4caf8d1d188d4bd809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefca0281fde1b4caf8d1d188d4bd809d">&#9670;&#160;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_convertible&lt;T, std::string&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00044">44</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="ae3480ee712c4aecb9425a7e5c540889f" name="ae3480ee712c4aecb9425a7e5c540889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3480ee712c4aecb9425a7e5c540889f">&#9670;&#160;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00048">48</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a016a8762a4f14a3d708461f0d1616bc2" name="a016a8762a4f14a3d708461f0d1616bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016a8762a4f14a3d708461f0d1616bc2">&#9670;&#160;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00052">52</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00059">get_name_from_end_of_parameter_pack()</a>.</p>

</div>
</div>
<a id="a70ab4586f42653c6b16a6e0ad186f1e5" name="a70ab4586f42653c6b16a6e0ad186f1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ab4586f42653c6b16a6e0ad186f1e5">&#9670;&#160;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">First</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00059">59</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">References <a class="el" href="_buffer_8h_source.html#l00052">get_name_from_end_of_parameter_pack()</a>.</p>

</div>
</div>
<a id="ab882d8987fcdb737d28066db1130b509" name="ab882d8987fcdb737d28066db1130b509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab882d8987fcdb737d28066db1130b509">&#9670;&#160;</a></span>get_shape_from_start_of_parameter_pack_helper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00063">63</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00076">get_shape_from_start_of_parameter_pack()</a>, and <a class="el" href="_buffer_8h_source.html#l00070">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a id="a352d23994d86bd76a8167c6144f3a3dc" name="a352d23994d86bd76a8167c6144f3a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352d23994d86bd76a8167c6144f3a3dc">&#9670;&#160;</a></span>get_shape_from_start_of_parameter_pack_helper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00066">66</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="afc82b2d635d098a40d4b87018edd0a73" name="afc82b2d635d098a40d4b87018edd0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc82b2d635d098a40d4b87018edd0a73">&#9670;&#160;</a></span>get_shape_from_start_of_parameter_pack_helper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00070">70</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">References <a class="el" href="_buffer_8h_source.html#l00063">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a id="a274816d577057576634316a33e721fa6" name="a274816d577057576634316a33e721fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274816d577057576634316a33e721fa6">&#9670;&#160;</a></span>get_shape_from_start_of_parameter_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Halide::Internal::get_shape_from_start_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00076">76</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">References <a class="el" href="_buffer_8h_source.html#l00063">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a id="a844f5db8861adba47dc2dc0e38666407" name="a844f5db8861adba47dc2dc0e38666407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844f5db8861adba47dc2dc0e38666407">&#9670;&#160;</a></span>buffer_type_name_non_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::buffer_type_name_non_const </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00089">89</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a7f55fb27359093d52c4c4447db053edc" name="a7f55fb27359093d52c4c4447db053edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f55fb27359093d52c4c4447db053edc">&#9670;&#160;</a></span>buffer_type_name_non_const&lt; void &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="#a844f5db8861adba47dc2dc0e38666407">Halide::Internal::buffer_type_name_non_const</a>&lt; void &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00094">94</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="ab14638fa4f1475b6b6acb22a9419afea" name="ab14638fa4f1475b6b6acb22a9419afea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14638fa4f1475b6b6acb22a9419afea">&#9670;&#160;</a></span>buffer_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::buffer_type_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00099">99</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a5eefe960250b26cc13e38cb734803057" name="a5eefe960250b26cc13e38cb734803057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eefe960250b26cc13e38cb734803057">&#9670;&#160;</a></span>canonicalize_gpu_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::canonicalize_gpu_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize GPU var names into some pre-determined block/thread names (i.e. </p>
<p>__block_id_x, __thread_id_x, etc.). The x/y/z/w order is determined by the nesting order: innermost is assigned to x and so on. </p>

</div>
</div>
<a id="af1439caec64a653845e9e5b54451cf04" name="af1439caec64a653845e9e5b54451cf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1439caec64a653845e9e5b54451cf04">&#9670;&#160;</a></span>gpu_thread_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Internal::gpu_thread_name </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Names for the thread and block id variables. </p>
<p>Includes the leading dot. Indexed from inside out, so 0 gives you the innermost loop. </p>

</div>
</div>
<a id="a26df9ce0b1c15dbac336657403c9e283" name="a26df9ce0b1c15dbac336657403c9e283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26df9ce0b1c15dbac336657403c9e283">&#9670;&#160;</a></span>gpu_block_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Internal::gpu_block_name </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c3151a74eb9c7d9f02bcef32d445e46" name="a7c3151a74eb9c7d9f02bcef32d445e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3151a74eb9c7d9f02bcef32d445e46">&#9670;&#160;</a></span>clamp_unsafe_accesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::clamp_unsafe_accesses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject clamps around func calls h(...) when all the following conditions hold: </p>
<ol type="1">
<li>The call is in an indexing context, such as: f(x) = g(h(x));</li>
<li>The FuncValueBounds of h are smaller than those of its type</li>
<li>The allocation bounds of h might be wider than its compute bounds. </li>
</ol>

</div>
</div>
<a id="a111cc33bcb7f01e11e82e552dea299e3" name="a111cc33bcb7f01e11e82e552dea299e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111cc33bcb7f01e11e82e552dea299e3">&#9670;&#160;</a></span>new_CodeGen_D3D12Compute_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt; Halide::Internal::new_CodeGen_D3D12Compute_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a979a66a6c1d81f22528e9b996970568c" name="a979a66a6c1d81f22528e9b996970568c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979a66a6c1d81f22528e9b996970568c">&#9670;&#160;</a></span>get_vector_element_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * Halide::Internal::get_vector_element_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scalar type of an llvm vector type. </p>
<p>Returns the argument if it's not a vector type. </p>

</div>
</div>
<a id="adc60421b682a09ea4c4dcaaaa3e105e2" name="adc60421b682a09ea4c4dcaaaa3e105e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc60421b682a09ea4c4dcaaaa3e105e2">&#9670;&#160;</a></span>function_takes_user_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::function_takes_user_context </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Which built-in functions require a user-context first argument? </p>

</div>
</div>
<a id="a4abe6b887804e86f403f0af16d5a2ba1" name="a4abe6b887804e86f403f0af16d5a2ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abe6b887804e86f403f0af16d5a2ba1">&#9670;&#160;</a></span>can_allocation_fit_on_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_allocation_fit_on_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False. </p>
<p>This routine asserts if size is non-positive. </p>

</div>
</div>
<a id="a234c39a0f1f0d90412f454dca60cddc0" name="a234c39a0f1f0d90412f454dca60cddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234c39a0f1f0d90412f454dca60cddc0">&#9670;&#160;</a></span>long_div_mod_round_to_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; Halide::Internal::long_div_mod_round_to_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>max_abs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a {div/mod}_round_to_zero using binary long division for int/uint. </p>
<p>max_abs is the maximum absolute value of (a/b). Returns the pair {div_round_to_zero, mod_round_to_zero}. </p>

</div>
</div>
<a id="a25b077cb4a97dbf2fc64bb665826b512" name="a25b077cb4a97dbf2fc64bb665826b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b077cb4a97dbf2fc64bb665826b512">&#9670;&#160;</a></span>lower_int_uint_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_int_uint_div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>round_to_zero</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary. </p>
<p>Can introduce mulhi_shr and sorted_avg intrinsics as well as those from the lower_euclidean_ operation &ndash; div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="a3b44815561924377a690cf1d967bd19f" name="a3b44815561924377a690cf1d967bd19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b44815561924377a690cf1d967bd19f">&#9670;&#160;</a></span>lower_int_uint_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_int_uint_mod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary. </p>
<p>Can introduce mulhi_shr and sorted_avg intrinsics as well as those from the lower_euclidean_ operation &ndash; div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="ab7a4f18b650b23e1e6ed980d1feebcf5" name="ab7a4f18b650b23e1e6ed980d1feebcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a4f18b650b23e1e6ed980d1feebcf5">&#9670;&#160;</a></span>lower_euclidean_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="ae81d78fd7f3115750e17167ebf0fe920" name="ae81d78fd7f3115750e17167ebf0fe920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d78fd7f3115750e17167ebf0fe920">&#9670;&#160;</a></span>lower_euclidean_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_mod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="a9ce06cce9e67778758fd7090bd991421" name="a9ce06cce9e67778758fd7090bd991421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce06cce9e67778758fd7090bd991421">&#9670;&#160;</a></span>lower_signed_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_signed_shift_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts. </p>

</div>
</div>
<a id="a2637f42ac63c862b5f2a279164d640d1" name="a2637f42ac63c862b5f2a279164d640d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2637f42ac63c862b5f2a279164d640d1">&#9670;&#160;</a></span>lower_signed_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_signed_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts. </p>

</div>
</div>
<a id="a7a110889396502096d2b5e3995734ef6" name="a7a110889396502096d2b5e3995734ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a110889396502096d2b5e3995734ef6">&#9670;&#160;</a></span>lower_mux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_mux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em>mux</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a mux intrinsic to a select tree. </p>

</div>
</div>
<a id="afbb25911a1f7a8eaad4ca3f443c96e01" name="afbb25911a1f7a8eaad4ca3f443c96e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb25911a1f7a8eaad4ca3f443c96e01">&#9670;&#160;</a></span>lower_extract_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_extract_bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce bit extraction and concatenation to bit ops. </p>

</div>
</div>
<a id="a7eae0313e2330e7c9003fc623ae4fe3b" name="a7eae0313e2330e7c9003fc623ae4fe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eae0313e2330e7c9003fc623ae4fe3b">&#9670;&#160;</a></span>lower_concat_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_concat_bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce bit extraction and concatenation to bit ops. </p>

</div>
</div>
<a id="acc739e6b8e85830218314de3e9805476" name="acc739e6b8e85830218314de3e9805476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc739e6b8e85830218314de3e9805476">&#9670;&#160;</a></span>lower_round_to_nearest_ties_to_even()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_round_to_nearest_ties_to_even </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An vectorizable implementation of <a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe" title="Return the whole number closest to a floating-point expression.">Halide::round</a> that doesn't depend on any standard library being present. </p>

</div>
</div>
<a id="adcdf83ff7a22966e4055a11ab6cad5ed" name="adcdf83ff7a22966e4055a11ab6cad5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdf83ff7a22966e4055a11ab6cad5ed">&#9670;&#160;</a></span>get_target_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetOptions &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, set llvm:TargetOptions information. </p>

</div>
</div>
<a id="a1b16d175882e16f544bf4bf92ec931b5" name="a1b16d175882e16f544bf4bf92ec931b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b16d175882e16f544bf4bf92ec931b5">&#9670;&#160;</a></span>clone_target_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::clone_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two llvm::Modules, clone target options from one to the other. </p>

</div>
</div>
<a id="aaf3b22ce8e56396b149f8b733f5ca50f" name="aaf3b22ce8e56396b149f8b733f5ca50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3b22ce8e56396b149f8b733f5ca50f">&#9670;&#160;</a></span>make_target_machine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::TargetMachine &gt; Halide::Internal::make_target_machine </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>module</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, get or create an llvm:TargetMachine. </p>

</div>
</div>
<a id="a0fa0254caf56536ecb7df5d16554b555" name="a0fa0254caf56536ecb7df5d16554b555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa0254caf56536ecb7df5d16554b555">&#9670;&#160;</a></span>set_function_attributes_from_halide_target_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::set_function_attributes_from_halide_target_options </td>
          <td>(</td>
          <td class="paramtype">llvm::Function &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> attributes given the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="a36fd598253847fcd510e32b107aeb2f3" name="a36fd598253847fcd510e32b107aeb2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fd598253847fcd510e32b107aeb2f3">&#9670;&#160;</a></span>embed_bitcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::embed_bitcode </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>halide_command</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a copy of the llvm IR currently represented by the module as data in the __LLVM,__bitcode section. </p>
<p>Emulates clang's -fembed-bitcode flag and is useful to satisfy Apple's bitcode inclusion requirements. <br  />
 </p>

</div>
</div>
<a id="a285c6a355dd43fb4eae87548b5841548" name="a285c6a355dd43fb4eae87548b5841548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285c6a355dd43fb4eae87548b5841548">&#9670;&#160;</a></span>new_CodeGen_Metal_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt; Halide::Internal::new_CodeGen_Metal_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c4bf60d96cab45e7145ca44a8542d0a" name="a0c4bf60d96cab45e7145ca44a8542d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4bf60d96cab45e7145ca44a8542d0a">&#9670;&#160;</a></span>new_CodeGen_OpenCL_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt; Halide::Internal::new_CodeGen_OpenCL_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3dd25060fd735a84357d75f67c345c8" name="ae3dd25060fd735a84357d75f67c345c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dd25060fd735a84357d75f67c345c8">&#9670;&#160;</a></span>new_CodeGen_PTX_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt; Halide::Internal::new_CodeGen_PTX_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab446ce0e3637ad7e9006c93022200a4c" name="ab446ce0e3637ad7e9006c93022200a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab446ce0e3637ad7e9006c93022200a4c">&#9670;&#160;</a></span>new_CodeGen_ARM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt; Halide::Internal::new_CodeGen_ARM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct CodeGen object for a variety of targets. </p>

</div>
</div>
<a id="a3f72a928bf2d91cfba4dfc1046cfa3ae" name="a3f72a928bf2d91cfba4dfc1046cfa3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f72a928bf2d91cfba4dfc1046cfa3ae">&#9670;&#160;</a></span>new_CodeGen_Hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt; Halide::Internal::new_CodeGen_Hexagon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af78c445df369d9606ab540cff1a85ebd" name="af78c445df369d9606ab540cff1a85ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78c445df369d9606ab540cff1a85ebd">&#9670;&#160;</a></span>new_CodeGen_PowerPC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt; Halide::Internal::new_CodeGen_PowerPC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43fa119b1d9cb91d6b0a7a94e9fd17ec" name="a43fa119b1d9cb91d6b0a7a94e9fd17ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fa119b1d9cb91d6b0a7a94e9fd17ec">&#9670;&#160;</a></span>new_CodeGen_RISCV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt; Halide::Internal::new_CodeGen_RISCV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a377069a6a413445be03054d91043de25" name="a377069a6a413445be03054d91043de25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377069a6a413445be03054d91043de25">&#9670;&#160;</a></span>new_CodeGen_X86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt; Halide::Internal::new_CodeGen_X86 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab096d5698556bf5900c1a54f4f4919e2" name="ab096d5698556bf5900c1a54f4f4919e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab096d5698556bf5900c1a54f4f4919e2">&#9670;&#160;</a></span>new_CodeGen_WebAssembly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt; Halide::Internal::new_CodeGen_WebAssembly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33af520f7d407be6c1418b63885cbda7" name="a33af520f7d407be6c1418b63885cbda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33af520f7d407be6c1418b63885cbda7">&#9670;&#160;</a></span>new_CodeGen_Vulkan_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt; Halide::Internal::new_CodeGen_Vulkan_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa94c47fa0c540277b9eccf0c8c61b3b2" name="aa94c47fa0c540277b9eccf0c8c61b3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94c47fa0c540277b9eccf0c8c61b3b2">&#9670;&#160;</a></span>new_CodeGen_WebGPU_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt; Halide::Internal::new_CodeGen_WebGPU_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04fe83125b8be0309eb52d612706da1e" name="a04fe83125b8be0309eb52d612706da1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fe83125b8be0309eb52d612706da1e">&#9670;&#160;</a></span>set_compiler_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt; Halide::Internal::set_compiler_logger </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>compiler_logger</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object, replacing any existing one. </p>
<p>It is legal to pass in a nullptr (which means "don't do any compiler logging"). Returns the previous <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> (if any). </p>

</div>
</div>
<a id="adc3ec914dec8d50c32639aec31f38285" name="adc3ec914dec8d50c32639aec31f38285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3ec914dec8d50c32639aec31f38285">&#9670;&#160;</a></span>get_compiler_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> * Halide::Internal::get_compiler_logger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object. </p>
<p>If <a class="el" href="#a04fe83125b8be0309eb52d612706da1e" title="Set the active CompilerLogger object, replacing any existing one.">set_compiler_logger()</a> has never been called, a nullptr implementation will be returned. Do not save the pointer returned! It is intended to be used for immediate calls only. </p>

</div>
</div>
<a id="a912ff057c46bcc6010cb73a32da15bb4" name="a912ff057c46bcc6010cb73a32da15bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912ff057c46bcc6010cb73a32da15bb4">&#9670;&#160;</a></span>constant_integer_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::constant_integer_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>, <a class="el" href="struct_halide_1_1_expr_compare.html">ExprCompare</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cache</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce constant integer bounds on an expression. </p>
<p>This can be useful to decide if, for example, the expression can be cast to another type, be negated, be incremented, etc without risking overflow.</p>
<p>Also optionally accepts a scope containing the integer bounds of any variables that may be referenced, and a cache of constant integer bounds on known Exprs, which this function will update. The cache is helpful to short-circuit large numbers of redundant queries, but it should not be used in contexts where the same <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> object may take on different values within a single <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> (i.e. before uniquify_variable_names). </p>

</div>
</div>
<a id="a92669b308fbca96c8eb735abe84be0a3" name="a92669b308fbca96c8eb735abe84be0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92669b308fbca96c8eb735abe84be0a3">&#9670;&#160;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic operators on ConstantIntervals. </p>
<p>The resulting interval contains all possible values of the operator applied to any two elements of the argument intervals. Note that these operator on unbounded integers. If you are applying this to concrete small integer types, you will need to manually cast the constant interval back to the desired type to model the effect of overflow. </p>

</div>
</div>
<a id="afe2e6104ca77d5871f561e41c2a75c42" name="afe2e6104ca77d5871f561e41c2a75c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2e6104ca77d5871f561e41c2a75c42">&#9670;&#160;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81e21c111cd68481735b95e47fc3db9c" name="a81e21c111cd68481735b95e47fc3db9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e21c111cd68481735b95e47fc3db9c">&#9670;&#160;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bd4dd3fc8b69826ce624e7fa7debf6d" name="a9bd4dd3fc8b69826ce624e7fa7debf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd4dd3fc8b69826ce624e7fa7debf6d">&#9670;&#160;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77aa3e21bfb2956a4db1a8991961f8f1" name="a77aa3e21bfb2956a4db1a8991961f8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aa3e21bfb2956a4db1a8991961f8f1">&#9670;&#160;</a></span>operator/() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6cf4bba76bed4a2d53717d0613e255f" name="af6cf4bba76bed4a2d53717d0613e255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cf4bba76bed4a2d53717d0613e255f">&#9670;&#160;</a></span>operator/() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a055285f67268b5e556780587ecf465a1" name="a055285f67268b5e556780587ecf465a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055285f67268b5e556780587ecf465a1">&#9670;&#160;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad834081c5e1d711413349f2c0603fbe3" name="ad834081c5e1d711413349f2c0603fbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad834081c5e1d711413349f2c0603fbe3">&#9670;&#160;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a12585a7cc096074cbf08af93a7ffb6" name="a3a12585a7cc096074cbf08af93a7ffb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a12585a7cc096074cbf08af93a7ffb6">&#9670;&#160;</a></span>operator%() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7407909cc8b2551de2ab93fac3cc27c" name="ad7407909cc8b2551de2ab93fac3cc27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7407909cc8b2551de2ab93fac3cc27c">&#9670;&#160;</a></span>operator%() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41d5010a34ae900ef4f855ee5420a923" name="a41d5010a34ae900ef4f855ee5420a923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d5010a34ae900ef4f855ee5420a923">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l01201">Halide::Internal::GeneratorMinMax::min_forward()</a>, and <a class="el" href="_generator_8h_source.html#l01197">Halide::Internal::GeneratorMinMax::min_forward()</a>.</p>

</div>
</div>
<a id="a0978acb21de1206dcb04a4ec81f75548" name="a0978acb21de1206dcb04a4ec81f75548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0978acb21de1206dcb04a4ec81f75548">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60e34906118319ac8ae12858ba6faf5b" name="a60e34906118319ac8ae12858ba6faf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e34906118319ac8ae12858ba6faf5b">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l01210">Halide::Internal::GeneratorMinMax::max_forward()</a>, and <a class="el" href="_generator_8h_source.html#l01206">Halide::Internal::GeneratorMinMax::max_forward()</a>.</p>

</div>
</div>
<a id="ac5b2d36dcc5dd64521f4478ed8bae725" name="ac5b2d36dcc5dd64521f4478ed8bae725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b2d36dcc5dd64521f4478ed8bae725">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1afa23d45af239fce2e9679f5b0ec5" name="ada1afa23d45af239fce2e9679f5b0ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1afa23d45af239fce2e9679f5b0ec5">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3f6ffc605e9727100d4c1530346a142" name="ab3f6ffc605e9727100d4c1530346a142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6ffc605e9727100d4c1530346a142">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7130963c67bad2e41b3812d990f2dcea" name="a7130963c67bad2e41b3812d990f2dcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7130963c67bad2e41b3812d990f2dcea">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a051243ea3642a3cbaef2dcd8d65b0c81" name="a051243ea3642a3cbaef2dcd8d65b0c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051243ea3642a3cbaef2dcd8d65b0c81">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28db82ad42721d89dc2759d9efa40b36" name="a28db82ad42721d89dc2759d9efa40b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28db82ad42721d89dc2759d9efa40b36">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a189f5e8e18b145d9a4effb5fadfd7788" name="a189f5e8e18b145d9a4effb5fadfd7788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189f5e8e18b145d9a4effb5fadfd7788">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea396032a9365b9f0cb602e3a75daa4a" name="aea396032a9365b9f0cb602e3a75daa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea396032a9365b9f0cb602e3a75daa4a">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac893cdcea474d9026e9b70a7025d94c4" name="ac893cdcea474d9026e9b70a7025d94c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac893cdcea474d9026e9b70a7025d94c4">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operators on ConstantIntervals. </p>
<p>Returns whether the comparison is true for all values of the two intervals. </p>

</div>
</div>
<a id="a77d576493933c11e526d4dc6dbb84111" name="a77d576493933c11e526d4dc6dbb84111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d576493933c11e526d4dc6dbb84111">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed4fc61bc2d91bc44b936e36892dff1c" name="aed4fc61bc2d91bc44b936e36892dff1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4fc61bc2d91bc44b936e36892dff1c">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86e6907eb71719c21550de578bc3f1ae" name="a86e6907eb71719c21550de578bc3f1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e6907eb71719c21550de578bc3f1ae">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a223e00fe33173430eb29414b47d12dfa" name="a223e00fe33173430eb29414b47d12dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223e00fe33173430eb29414b47d12dfa">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b93d80d505efcfda82487b5cb025d7" name="ab8b93d80d505efcfda82487b5cb025d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b93d80d505efcfda82487b5cb025d7">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d9ebd06b19c2a372ed04fc5029d872d" name="a1d9ebd06b19c2a372ed04fc5029d872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9ebd06b19c2a372ed04fc5029d872d">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constant_interval_8h_source.html#l00144">144</a> of file <a class="el" href="_constant_interval_8h_source.html">ConstantInterval.h</a>.</p>

</div>
</div>
<a id="ad674d5fe674999b2287b27f750ea9f0c" name="ad674d5fe674999b2287b27f750ea9f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad674d5fe674999b2287b27f750ea9f0c">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constant_interval_8h_source.html#l00147">147</a> of file <a class="el" href="_constant_interval_8h_source.html">ConstantInterval.h</a>.</p>

</div>
</div>
<a id="a5a23f9536c013fd60d882aee7ca21383" name="a5a23f9536c013fd60d882aee7ca21383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a23f9536c013fd60d882aee7ca21383">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constant_interval_8h_source.html#l00150">150</a> of file <a class="el" href="_constant_interval_8h_source.html">ConstantInterval.h</a>.</p>

</div>
</div>
<a id="a4b2b7eed41d4ce4dfcccdf845a1662f2" name="a4b2b7eed41d4ce4dfcccdf845a1662f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2b7eed41d4ce4dfcccdf845a1662f2">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constant_interval_8h_source.html#l00153">153</a> of file <a class="el" href="_constant_interval_8h_source.html">ConstantInterval.h</a>.</p>

</div>
</div>
<a id="a805040b1b432becfb2fc18487b632473" name="a805040b1b432becfb2fc18487b632473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805040b1b432becfb2fc18487b632473">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constant_interval_8h_source.html#l00156">156</a> of file <a class="el" href="_constant_interval_8h_source.html">ConstantInterval.h</a>.</p>

</div>
</div>
<a id="adbacc8f24707096d3d98f6ea77a5f659" name="adbacc8f24707096d3d98f6ea77a5f659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbacc8f24707096d3d98f6ea77a5f659">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constant_interval_8h_source.html#l00159">159</a> of file <a class="el" href="_constant_interval_8h_source.html">ConstantInterval.h</a>.</p>

</div>
</div>
<a id="a9170638fdb8e1cb975e1ff7fb561a560" name="a9170638fdb8e1cb975e1ff7fb561a560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9170638fdb8e1cb975e1ff7fb561a560">&#9670;&#160;</a></span>cplusplus_function_mangled_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::cplusplus_function_mangled_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>namespaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>return_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mangled C++ name for a function. </p>
<p>The target parameter is used to decide on the C++ ABI/mangling style to use. </p>

</div>
</div>
<a id="a67d63fc361474a95f58c2839461cc7df" name="a67d63fc361474a95f58c2839461cc7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d63fc361474a95f58c2839461cc7df">&#9670;&#160;</a></span>cplusplus_mangle_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::cplusplus_mangle_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f2af44447b9269918e9d63d948ea8bd" name="a5f2af44447b9269918e9d63d948ea8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2af44447b9269918e9d63d948ea8bd">&#9670;&#160;</a></span>common_subexpression_elimination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lift_all</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> an example of a such a case, see test/code_explosion.cpp</p>
<p>The last parameter determines whether all common subexpressions are lifted, or only those that the simplifier would not subsitute back in (e.g. addition of a constant). </p>

</div>
</div>
<a id="ac03dcb48bcb8e81238a1c6cfea195e1a" name="ac03dcb48bcb8e81238a1c6cfea195e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03dcb48bcb8e81238a1c6cfea195e1a">&#9670;&#160;</a></span>common_subexpression_elimination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lift_all</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a id="a88cbc086e9926046bdb9f4ade681111a" name="a88cbc086e9926046bdb9f4ade681111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cbc086e9926046bdb9f4ade681111a">&#9670;&#160;</a></span>cse_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::cse_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab98f0a702bd775e67baed5bcd986ae27" name="ab98f0a702bd775e67baed5bcd986ae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98f0a702bd775e67baed5bcd986ae27">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a id="a029791644c90ea7a194d58fc87ab41bf" name="a029791644c90ea7a194d58fc87ab41bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029791644c90ea7a194d58fc87ab41bf">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> in a human readable format. </p>

</div>
</div>
<a id="acbba1897af954502671d8f3b831c8a6a" name="acbba1897af954502671d8f3b831c8a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbba1897af954502671d8f3b831c8a6a">&#9670;&#160;</a></span>PrintSpan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::PrintSpan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  PrintSpan&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad8dccc6a0450dc6d0acabbdd72f7b9" name="a0ad8dccc6a0450dc6d0acabbdd72f7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad8dccc6a0450dc6d0acabbdd72f7b9">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamT &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamT &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_print_span.html">PrintSpan</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_debug_8h_source.html#l00085">85</a> of file <a class="el" href="_debug_8h_source.html">Debug.h</a>.</p>

<p class="reference">References <a class="el" href="_debug_8h_source.html#l00075">Halide::Internal::PrintSpan&lt; T &gt;::span</a>.</p>

</div>
</div>
<a id="aa1021cbfec3656d88b8ef964c301d258" name="aa1021cbfec3656d88b8ef964c301d258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1021cbfec3656d88b8ef964c301d258">&#9670;&#160;</a></span>PrintSpanLn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::PrintSpanLn </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  PrintSpanLn&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4423b8304272bfe7d448d568ff80ebe1" name="a4423b8304272bfe7d448d568ff80ebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4423b8304272bfe7d448d568ff80ebe1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamT &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamT &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_print_span_ln.html">PrintSpanLn</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_debug_8h_source.html#l00119">119</a> of file <a class="el" href="_debug_8h_source.html">Debug.h</a>.</p>

<p class="reference">References <a class="el" href="_debug_8h_source.html#l00109">Halide::Internal::PrintSpanLn&lt; T &gt;::span</a>.</p>

</div>
</div>
<a id="a866d7f181b8a337d445a1df28de18384" name="a866d7f181b8a337d445a1df28de18384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866d7f181b8a337d445a1df28de18384">&#9670;&#160;</a></span>debug_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::debug_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> *</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects debug prints in a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> that describe the target and arguments. </p>
<p>Mutates the given func. </p>

</div>
</div>
<a id="aaea2b563fa94726a65b596979b9d2f85" name="aaea2b563fa94726a65b596979b9d2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea2b563fa94726a65b596979b9d2f85">&#9670;&#160;</a></span>debug_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::debug_to_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

</div>
</div>
<a id="a949dd909bf5d0b5aadc590c5dd2a61d0" name="a949dd909bf5d0b5aadc590c5dd2a61d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949dd909bf5d0b5aadc590c5dd2a61d0">&#9670;&#160;</a></span>extract_odd_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_odd_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a id="ad52cdf2d45822985407927e4a553dbe8" name="ad52cdf2d45822985407927e4a553dbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52cdf2d45822985407927e4a553dbe8">&#9670;&#160;</a></span>extract_even_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_even_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a id="a24fea986b372b2a3932ae617ca62116d" name="a24fea986b372b2a3932ae617ca62116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fea986b372b2a3932ae617ca62116d">&#9670;&#160;</a></span>extract_lane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_lane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lane</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a id="acba806ef5f80bcc7ad6905f7789906cd" name="acba806ef5f80bcc7ad6905f7789906cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba806ef5f80bcc7ad6905f7789906cd">&#9670;&#160;</a></span>rewrite_interleavings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_interleavings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a id="a8dc1b0ff156c8b0ca5fd26956ee482a9" name="a8dc1b0ff156c8b0ca5fd26956ee482a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc1b0ff156c8b0ca5fd26956ee482a9">&#9670;&#160;</a></span>deinterleave_vector_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::deinterleave_vector_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8d3c39b97b822e2c3e50a1c977441aa" name="aa8d3c39b97b822e2c3e50a1c977441aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d3c39b97b822e2c3e50a1c977441aa">&#9670;&#160;</a></span>remove_let_definitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::remove_let_definitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all let definitions of expr. </p>

</div>
</div>
<a id="a183d22fd92b955a2c3acba3667a98a71" name="a183d22fd92b955a2c3acba3667a98a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183d22fd92b955a2c3acba3667a98a71">&#9670;&#160;</a></span>gather_variables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Halide::Internal::gather_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of variables' indices that expr depends on and are in the filter. </p>

</div>
</div>
<a id="a56a098fb2be362edf25fbd143941d338" name="a56a098fb2be362edf25fbd143941d338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a098fb2be362edf25fbd143941d338">&#9670;&#160;</a></span>gather_variables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Halide::Internal::gather_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94009170105d2109c42128558cbb8025" name="a94009170105d2109c42128558cbb8025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94009170105d2109c42128558cbb8025">&#9670;&#160;</a></span>gather_rvariables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt; Halide::Internal::gather_rvariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad561cb6a78a9aee95f7f84f72b893fb3" name="ad561cb6a78a9aee95f7f84f72b893fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad561cb6a78a9aee95f7f84f72b893fb3">&#9670;&#160;</a></span>gather_rvariables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt; Halide::Internal::gather_rvariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b66032c9826d25bfa470c4c974081d5" name="a9b66032c9826d25bfa470c4c974081d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b66032c9826d25bfa470c4c974081d5">&#9670;&#160;</a></span>add_let_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::add_let_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>let_var_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>let_variables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> necessary let expressions to expr. </p>

</div>
</div>
<a id="a441d4dafa32011fb68745cf2dc0edd70" name="a441d4dafa32011fb68745cf2dc0edd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441d4dafa32011fb68745cf2dc0edd70">&#9670;&#160;</a></span>sort_expressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; Halide::Internal::sort_expressions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topologically sort the expression graph expressed by expr. </p>

</div>
</div>
<a id="a6f51d01b47fe0ae71fcae1c7f1751e5a" name="a6f51d01b47fe0ae71fcae1c7f1751e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f51d01b47fe0ae71fcae1c7f1751e5a">&#9670;&#160;</a></span>inference_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::inference_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>funcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bounds of funcs. </p>
<p>The bounds represent a conservative region that is used by the "consumers" of the function, except of itself. </p>

</div>
</div>
<a id="af16b7b3ca684e45e291f1aeaafa71d92" name="af16b7b3ca684e45e291f1aeaafa71d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16b7b3ca684e45e291f1aeaafa71d92">&#9670;&#160;</a></span>inference_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; Halide::Internal::inference_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ba9163fc25824f5bcd2600ca177ff64" name="a3ba9163fc25824f5bcd2600ca177ff64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba9163fc25824f5bcd2600ca177ff64">&#9670;&#160;</a></span>box_to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; Halide::Internal::box_to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> <a class="el" href="struct_halide_1_1_internal_1_1_box.html" title="Represents the bounds of a region of arbitrary dimension.">Box</a> to vector of (min, extent) </p>

</div>
</div>
<a id="a44d062e9354cd14001f47cd01e82b93a" name="a44d062e9354cd14001f47cd01e82b93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d062e9354cd14001f47cd01e82b93a">&#9670;&#160;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if bounds0 and bounds1 represent the same bounds. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00050">equal()</a>, <a class="el" href="_i_r_equality_8h_source.html#l00076">graph_equal()</a>, <a class="el" href="_i_r_match_8h_source.html#l00205">Halide::Internal::IRMatcher::SpecificExpr::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l00464">Halide::Internal::IRMatcher::Wild&lt; i &gt;::match()</a>, <a class="el" href="_associativity_8h_source.html#l00072">Halide::Internal::AssociativeOp::Replacement::operator==()</a>, and <a class="el" href="_associative_ops_table_8h_source.html#l00050">Halide::Internal::AssociativePattern::operator==()</a>.</p>

</div>
</div>
<a id="a2e106cdd351599c04f797fa4800e999c" name="a2e106cdd351599c04f797fa4800e999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e106cdd351599c04f797fa4800e999c">&#9670;&#160;</a></span>vars_to_strings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Halide::Internal::vars_to_strings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of variable names. </p>

</div>
</div>
<a id="a96c20a455c5f2aed48623d012438b99d" name="a96c20a455c5f2aed48623d012438b99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c20a455c5f2aed48623d012438b99d">&#9670;&#160;</a></span>extract_rdom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> Halide::Internal::extract_rdom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reduction domain used by expr. </p>

</div>
</div>
<a id="a8c7cb31887777df4c2dc43b245a1f212" name="a8c7cb31887777df4c2dc43b245a1f212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7cb31887777df4c2dc43b245a1f212">&#9670;&#160;</a></span>solve_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; Halide::Internal::solve_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>new_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expr is new_var == f(var), solve for var == g(new_var) if multiple new_var corresponds to same var, introduce a <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> </p>

</div>
</div>
<a id="a53a6aafa3b32bfb28cc454b60f96fe3a" name="a53a6aafa3b32bfb28cc454b60f96fe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a6aafa3b32bfb28cc454b60f96fe3a">&#9670;&#160;</a></span>find_buffer_param_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a> &gt; Halide::Internal::find_buffer_param_calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a602126292ec5996c54fee2442f89b" name="ab5a602126292ec5996c54fee2442f89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a602126292ec5996c54fee2442f89b">&#9670;&#160;</a></span>find_implicit_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; Halide::Internal::find_implicit_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all implicit variables in expr. </p>

</div>
</div>
<a id="aea7c0a6c9d1ffb171d4343876021f604" name="aea7c0a6c9d1ffb171d4343876021f604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7c0a6c9d1ffb171d4343876021f604">&#9670;&#160;</a></span>substitute_rdom_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_rdom_predicate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the variable. </p>
<p>Also replace all occurrences in rdom.where() predicates. </p>

</div>
</div>
<a id="a4b228248e212d4e140a3b7499f65a8c4" name="a4b228248e212d4e140a3b7499f65a8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b228248e212d4e140a3b7499f65a8c4">&#9670;&#160;</a></span>is_calling_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_calling_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>let_var_mapping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr contains call to func_name. </p>

</div>
</div>
<a id="add1be017ee388aad7a1cb19fa653e300" name="add1be017ee388aad7a1cb19fa653e300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1be017ee388aad7a1cb19fa653e300">&#9670;&#160;</a></span>is_calling_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_calling_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>let_var_mapping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr depends on any function or buffer. </p>

</div>
</div>
<a id="a038d35b4053c243832706da480e78f80" name="a038d35b4053c243832706da480e78f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038d35b4053c243832706da480e78f80">&#9670;&#160;</a></span>substitute_call_arg_with_pure_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_call_arg_with_pure_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>variable_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces call to <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f in <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e such that the call argument at variable_id is the pure argument. </p>

</div>
</div>
<a id="adb129e599eb08042ff95446b7e040233" name="adb129e599eb08042ff95446b7e040233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb129e599eb08042ff95446b7e040233">&#9670;&#160;</a></span>make_device_interface_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_device_interface_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a></td>          <td class="paramname"><span class="paramname"><em>device_api</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a></td>          <td class="paramname"><span class="paramname"><em>memory_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a06b9281e396db002010bde1de57262eb">MemoryType::Auto</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> which evaluates to the device interface for the given device api at runtime. </p>

</div>
</div>
<a id="add8c5e751e4ac4a80ab5d2cd4538ebdd" name="add8c5e751e4ac4a80ab5d2cd4538ebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8c5e751e4ac4a80ab5d2cd4538ebdd">&#9670;&#160;</a></span>distribute_shifts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::distribute_shifts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>multiply_adds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a4af08fdc8caf03891015c7dec4c8c9" name="a9a4af08fdc8caf03891015c7dec4c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4af08fdc8caf03891015c7dec4c8c9">&#9670;&#160;</a></span>inject_early_frees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_early_frees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> node. </p>

</div>
</div>
<a id="a371a9e04b6a14f9897b94bc78437023d" name="a371a9e04b6a14f9897b94bc78437023d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371a9e04b6a14f9897b94bc78437023d">&#9670;&#160;</a></span>eliminate_bool_vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8,
u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask intrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a> node. This also converts any intrinsics that operate on vectorized conditions to a *_mask equivalent (if_then_else, require). Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a id="a6320940955c9bdcced50b4f31ddd3f18" name="a6320940955c9bdcced50b4f31ddd3f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6320940955c9bdcced50b4f31ddd3f18">&#9670;&#160;</a></span>eliminate_bool_vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8,
u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask intrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a> node. This also converts any intrinsics that operate on vectorized conditions to a *_mask equivalent (if_then_else, require). Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a id="a0747a9e54d0da5a37c1530162121942f" name="a0747a9e54d0da5a37c1530162121942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0747a9e54d0da5a37c1530162121942f">&#9670;&#160;</a></span>eliminated_bool_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::eliminated_bool_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>bool_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>other_type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors. </p>

<p class="definition">Definition at line <a class="el" href="_eliminate_bool_vectors_8h_source.html#l00032">32</a> of file <a class="el" href="_eliminate_bool_vectors_8h_source.html">EliminateBoolVectors.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00349">Halide::Type::bits()</a>, <a class="el" href="_type_8h_source.html#l00291">Halide::Type::Int</a>, <a class="el" href="_type_8h_source.html#l00410">Halide::Type::is_vector()</a>, <a class="el" href="_type_8h_source.html#l00366">Halide::Type::with_bits()</a>, and <a class="el" href="_type_8h_source.html#l00360">Halide::Type::with_code()</a>.</p>

</div>
</div>
<a id="a860e1020025973b3e49f515e57e126d5" name="a860e1020025973b3e49f515e57e126d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e1020025973b3e49f515e57e126d5">&#9670;&#160;</a></span>is_float16_transcendental()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_float16_transcendental </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a call is a float16 transcendental (e.g. </p>
<p>sqrt_f16) </p>

</div>
</div>
<a id="a4cd9ff6cdf658b71397ad57ada686d8f" name="a4cd9ff6cdf658b71397ad57ada686d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9ff6cdf658b71397ad57ada686d8f">&#9670;&#160;</a></span>lower_float16_transcendental_to_float32_equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_float16_transcendental_to_float32_equivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement a float16 transcendental using the float32 equivalent. </p>

</div>
</div>
<a id="a7c0d9776355fa799b71816c0ab2e97e6" name="a7c0d9776355fa799b71816c0ab2e97e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d9776355fa799b71816c0ab2e97e6">&#9670;&#160;</a></span>float32_to_bfloat16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::float32_to_bfloat16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> to/from float and bfloat using bitwise math. </p>

</div>
</div>
<a id="aa8bc1fe74ae6a148b8e7ee57f26c994d" name="aa8bc1fe74ae6a148b8e7ee57f26c994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bc1fe74ae6a148b8e7ee57f26c994d">&#9670;&#160;</a></span>float32_to_float16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::float32_to_float16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a386f43e07f78c9b4be57358b183150ce" name="a386f43e07f78c9b4be57358b183150ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386f43e07f78c9b4be57358b183150ce">&#9670;&#160;</a></span>float16_to_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::float16_to_float32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfc4c96649e436c9f67531779788b077" name="adfc4c96649e436c9f67531779788b077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc4c96649e436c9f67531779788b077">&#9670;&#160;</a></span>bfloat16_to_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::bfloat16_to_float32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79be785c18917d142a0fa55c86ab3a87" name="a79be785c18917d142a0fa55c86ab3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79be785c18917d142a0fa55c86ab3a87">&#9670;&#160;</a></span>lower_float16_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_float16_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac2b07cc26c89acd41e49cdbacfd9a9f" name="aac2b07cc26c89acd41e49cdbacfd9a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b07cc26c89acd41e49cdbacfd9a9f">&#9670;&#160;</a></span>unhandled_exception_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a011fabf6af2c9c965cacaf866d579f8a">HALIDE_EXPORT_SYMBOL</a> void Halide::Internal::unhandled_exception_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#aac2b07cc26c89acd41e49cdbacfd9a9f">unhandled_exception_handler()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#aac2b07cc26c89acd41e49cdbacfd9a9f">unhandled_exception_handler()</a>.</p>

</div>
</div>
<a id="a7a2683940f0565aba5f12746c727dc9c" name="a7a2683940f0565aba5f12746c727dc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2683940f0565aba5f12746c727dc9c">&#9670;&#160;</a></span>ref_count&lt; IRNode &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp; <a class="el" href="#a5a81310ace17087de643bc9a31efeba1">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00117">117</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="ad3d80243a2f3de47f613df12b48475c3" name="ad3d80243a2f3de47f613df12b48475c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d80243a2f3de47f613df12b48475c3">&#9670;&#160;</a></span>destroy&lt; IRNode &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="#a11ca920b642ef490aeac2b4e864d6254">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00122">122</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="a89b46f80479d5e41ff7ebf80ced31267" name="a89b46f80479d5e41ff7ebf80ced31267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b46f80479d5e41ff7ebf80ced31267">&#9670;&#160;</a></span>is_unordered_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_unordered_parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a></td>          <td class="paramname"><span class="paramname"><em>for_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if for_type executes for loop iterations in parallel and unordered. </p>

<p class="reference">Referenced by <a class="el" href="_schedule_8h_source.html#l00478">Halide::Internal::Dim::is_unordered_parallel()</a>, and <a class="el" href="_i_r_8h_source.html#l00833">Halide::Internal::For::is_unordered_parallel()</a>.</p>

</div>
</div>
<a id="aa25b9bc3a80bac033c05e5178ab5a4c7" name="aa25b9bc3a80bac033c05e5178ab5a4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25b9bc3a80bac033c05e5178ab5a4c7">&#9670;&#160;</a></span>is_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a></td>          <td class="paramname"><span class="paramname"><em>for_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if for_type executes for loop iterations in parallel. </p>

<p class="reference">Referenced by <a class="el" href="_schedule_8h_source.html#l00486">Halide::Internal::Dim::is_parallel()</a>, and <a class="el" href="_i_r_8h_source.html#l00836">Halide::Internal::For::is_parallel()</a>.</p>

</div>
</div>
<a id="a7d2c029124d1533110e9f330f8e54918" name="a7d2c029124d1533110e9f330f8e54918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2c029124d1533110e9f330f8e54918">&#9670;&#160;</a></span>is_gpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a></td>          <td class="paramname"><span class="paramname"><em>for_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if for_type is GPUBlock, GPUThread, or GPULane. </p>

</div>
</div>
<a id="a16792c0d67cebb47fe0a30377c3e7212" name="a16792c0d67cebb47fe0a30377c3e7212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16792c0d67cebb47fe0a30377c3e7212">&#9670;&#160;</a></span>stmt_or_expr_uses_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">const StmtOrExpr &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00101">101</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_uses_var_8h_source.html#l00093">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

<p class="reference">Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00143">expr_uses_vars()</a>, <a class="el" href="_expr_uses_var_8h_source.html#l00113">stmt_or_expr_uses_var()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00153">stmt_uses_vars()</a>.</p>

</div>
</div>
<a id="a5d94fcb5a93f4d4ddc839dc3f7631e5e" name="a5d94fcb5a93f4d4ddc839dc3f7631e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d94fcb5a93f4d4ddc839dc3f7631e5e">&#9670;&#160;</a></span>stmt_or_expr_uses_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">const StmtOrExpr &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00113">113</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_scope_8h_source.html#l00223">Halide::Internal::Scope&lt; T &gt;::push()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00101">stmt_or_expr_uses_vars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00124">expr_uses_var()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00133">stmt_uses_var()</a>.</p>

</div>
</div>
<a id="af734ee6c4861fe4be70badd557199d84" name="af734ee6c4861fe4be70badd557199d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af734ee6c4861fe4be70badd557199d84">&#9670;&#160;</a></span>expr_uses_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00124">124</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_uses_var_8h_source.html#l00113">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a id="a0fdd19ef6ec57aee5d5bea413bed3452" name="a0fdd19ef6ec57aee5d5bea413bed3452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdd19ef6ec57aee5d5bea413bed3452">&#9670;&#160;</a></span>stmt_uses_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00133">133</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">Halide::stmt</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00113">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a id="ae31bec6d9fdbb014d4e6b82549452065" name="ae31bec6d9fdbb014d4e6b82549452065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31bec6d9fdbb014d4e6b82549452065">&#9670;&#160;</a></span>expr_uses_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00143">143</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_uses_var_8h_source.html#l00101">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a id="a3d8bcd8e6cf2ad8368c7f106f5852f1e" name="a3d8bcd8e6cf2ad8368c7f106f5852f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8bcd8e6cf2ad8368c7f106f5852f1e">&#9670;&#160;</a></span>stmt_uses_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_vars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00153">153</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa217ecb18a8f8e5f1889339c3fa093fc3">Halide::stmt</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00101">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a id="a45cb2bf360bb8b29ddbeb01605062fe8" name="a45cb2bf360bb8b29ddbeb01605062fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cb2bf360bb8b29ddbeb01605062fe8">&#9670;&#160;</a></span>extract_tile_operations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::extract_tile_operations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite any AMX tile operations that have been stored in the AMXTile memory type as intrinsic calls, to be used in the X86 backend. </p>

</div>
</div>
<a id="afc3ba4ff8fc8b6574e63c0457e396d97" name="afc3ba4ff8fc8b6574e63c0457e396d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3ba4ff8fc8b6574e63c0457e396d97">&#9670;&#160;</a></span>find_direct_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; Halide::Internal::find_direct_calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> extents. </p>
<p>This map <em>does not</em> include the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, unless it is called recursively by itself. </p>

</div>
</div>
<a id="a994c8afe69a4c81e58c463fc1f5836f9" name="a994c8afe69a4c81e58c463fc1f5836f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994c8afe69a4c81e58c463fc1f5836f9">&#9670;&#160;</a></span>find_transitive_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; Halide::Internal::find_transitive_calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, or indirectly in those functions' definitions, recursively. </p>
<p>This map always <em>includes</em> the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f. </p>

</div>
</div>
<a id="ac3f5192ac624544dd004e7e9b58baeed" name="ac3f5192ac624544dd004e7e9b58baeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f5192ac624544dd004e7e9b58baeed">&#9670;&#160;</a></span>build_environment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; Halide::Internal::build_environment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>funcs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all Functions transitively referenced by any <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> in <code>funcs</code> and return a map of them. </p>

</div>
</div>
<a id="ad2db5263e219c293da13bb1ccbddfbcc" name="ad2db5263e219c293da13bb1ccbddfbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2db5263e219c293da13bb1ccbddfbcc">&#9670;&#160;</a></span>called_funcs_in_order_found()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; Halide::Internal::called_funcs_in_order_found </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>funcs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the same Functions as build_environment, but returns a vector of Functions instead, where the order is the order in which the Functions were first encountered. </p>
<p>This is stable to changes in the names of the Functions. </p>

</div>
</div>
<a id="a2747e2381aa255e5e68c5da44e80c0f1" name="a2747e2381aa255e5e68c5da44e80c0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2747e2381aa255e5e68c5da44e80c0f1">&#9670;&#160;</a></span>lower_widen_right_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widen_right_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement intrinsics with non-intrinsic using equivalents. </p>

</div>
</div>
<a id="a7b1d7552c738220034a57048125449f4" name="a7b1d7552c738220034a57048125449f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1d7552c738220034a57048125449f4">&#9670;&#160;</a></span>lower_widen_right_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widen_right_mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77ca570db1c9d68fd46c628469b55486" name="a77ca570db1c9d68fd46c628469b55486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ca570db1c9d68fd46c628469b55486">&#9670;&#160;</a></span>lower_widen_right_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widen_right_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a543f298be9b8105946543dd390b374ff" name="a543f298be9b8105946543dd390b374ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543f298be9b8105946543dd390b374ff">&#9670;&#160;</a></span>lower_widening_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ae1b99eee51f16210b3d97effc25bd" name="ab8ae1b99eee51f16210b3d97effc25bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ae1b99eee51f16210b3d97effc25bd">&#9670;&#160;</a></span>lower_widening_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaac43abd869f41381772e6bb7d2c6e5d" name="aaac43abd869f41381772e6bb7d2c6e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac43abd869f41381772e6bb7d2c6e5d">&#9670;&#160;</a></span>lower_widening_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49839698df68c878972d04abb2f0c2e5" name="a49839698df68c878972d04abb2f0c2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49839698df68c878972d04abb2f0c2e5">&#9670;&#160;</a></span>lower_widening_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_shift_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72390cac65d124349c7e74677aa87167" name="a72390cac65d124349c7e74677aa87167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72390cac65d124349c7e74677aa87167">&#9670;&#160;</a></span>lower_widening_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1e70aeecd9a6473b07d533436feee25" name="ad1e70aeecd9a6473b07d533436feee25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e70aeecd9a6473b07d533436feee25">&#9670;&#160;</a></span>lower_rounding_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_shift_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c3c2f27463a8c2007fb94474a7d31e6" name="a8c3c2f27463a8c2007fb94474a7d31e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3c2f27463a8c2007fb94474a7d31e6">&#9670;&#160;</a></span>lower_rounding_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52903c4a764166671b47c1bee5972657" name="a52903c4a764166671b47c1bee5972657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52903c4a764166671b47c1bee5972657">&#9670;&#160;</a></span>lower_saturating_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_saturating_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc65673b59449764669bf6424de17481" name="acc65673b59449764669bf6424de17481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc65673b59449764669bf6424de17481">&#9670;&#160;</a></span>lower_saturating_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_saturating_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a665bcbdbb3b2749f1d5b263034c76fd3" name="a665bcbdbb3b2749f1d5b263034c76fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665bcbdbb3b2749f1d5b263034c76fd3">&#9670;&#160;</a></span>lower_saturating_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_saturating_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cb06df309ffae62a414ff80f298064c" name="a3cb06df309ffae62a414ff80f298064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb06df309ffae62a414ff80f298064c">&#9670;&#160;</a></span>lower_halving_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_halving_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ab3fa4ef1d631a29d7440487960a6e1" name="a3ab3fa4ef1d631a29d7440487960a6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab3fa4ef1d631a29d7440487960a6e1">&#9670;&#160;</a></span>lower_halving_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_halving_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a433d347c813cf72a9fff938583a277f0" name="a433d347c813cf72a9fff938583a277f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433d347c813cf72a9fff938583a277f0">&#9670;&#160;</a></span>lower_rounding_halving_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_halving_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cb394d68a7ad936ee9c6653aa493d4e" name="a0cb394d68a7ad936ee9c6653aa493d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb394d68a7ad936ee9c6653aa493d4e">&#9670;&#160;</a></span>lower_sorted_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_sorted_avg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34b142cb92430ccaabc491be73e179f1" name="a34b142cb92430ccaabc491be73e179f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b142cb92430ccaabc491be73e179f1">&#9670;&#160;</a></span>lower_mul_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_mul_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab576461c931a66fd08808afe8c9c4eb8" name="ab576461c931a66fd08808afe8c9c4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab576461c931a66fd08808afe8c9c4eb8">&#9670;&#160;</a></span>lower_rounding_mul_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_mul_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4767c0dccb944d87678d84e2eae8c7a" name="ab4767c0dccb944d87678d84e2eae8c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4767c0dccb944d87678d84e2eae8c7a">&#9670;&#160;</a></span>lower_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace one of the above ops with equivalent arithmetic. </p>

</div>
</div>
<a id="ab09931c2014b2d9371646a16e8f70040" name="ab09931c2014b2d9371646a16e8f70040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09931c2014b2d9371646a16e8f70040">&#9670;&#160;</a></span>find_intrinsics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::find_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace common arithmetic patterns with intrinsics. </p>

</div>
</div>
<a id="ac549d8172be01dcee56b59f1b78801ef" name="ac549d8172be01dcee56b59f1b78801ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac549d8172be01dcee56b59f1b78801ef">&#9670;&#160;</a></span>find_intrinsics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::find_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a771bb6d2ec214f749b0c1b294d5c5a90" name="a771bb6d2ec214f749b0c1b294d5c5a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771bb6d2ec214f749b0c1b294d5c5a90">&#9670;&#160;</a></span>lower_intrinsics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reverse of find_intrinsics. </p>

</div>
</div>
<a id="a24a93dc6272bd86b8d10c171d0c1e26d" name="a24a93dc6272bd86b8d10c171d0c1e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a93dc6272bd86b8d10c171d0c1e26d">&#9670;&#160;</a></span>lower_intrinsics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdf714a588746f3f1017dc77dad68a67" name="afdf714a588746f3f1017dc77dad68a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf714a588746f3f1017dc77dad68a67">&#9670;&#160;</a></span>flatten_nested_ramps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::flatten_nested_ramps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement/expression and replace nested ramps and broadcasts. </p>

</div>
</div>
<a id="a2729ffaedee0544f9b584f53bc91954b" name="a2729ffaedee0544f9b584f53bc91954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2729ffaedee0544f9b584f53bc91954b">&#9670;&#160;</a></span>flatten_nested_ramps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::flatten_nested_ramps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b98bf6f8f3475caaa691d7884a31d45" name="a4b98bf6f8f3475caaa691d7884a31d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b98bf6f8f3475caaa691d7884a31d45">&#9670;&#160;</a></span>check_types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02616">2616</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00572">Halide::type_of()</a>, and <a class="el" href="test_8h_source.html#l00010">user_assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02625">check_types()</a>, <a class="el" href="_func_8h_source.html#l02667">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l02718">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a id="abec0560d55ceb7384483f00da38ad73f" name="abec0560d55ceb7384483f00da38ad73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec0560d55ceb7384483f00da38ad73f">&#9670;&#160;</a></span>check_types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02625">2625</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l02616">check_types()</a>.</p>

</div>
</div>
<a id="a32bce2836846aa0286859b005b6aa015" name="a32bce2836846aa0286859b005b6aa015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bce2836846aa0286859b005b6aa015">&#9670;&#160;</a></span>assign_results() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02631">2631</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="#a0396411abf88410baf6a6e6e41ea1419a7e62bc342f41c946868f0ea6f0b712d8">Buffer</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02637">assign_results()</a>, <a class="el" href="_func_8h_source.html#l02667">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l02718">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a id="acdc822256984ddc07c031b230ce2b8ae" name="acdc822256984ddc07c031b230ce2b8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc822256984ddc07c031b230ce2b8ae">&#9670;&#160;</a></span>assign_results() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02637">2637</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l02631">assign_results()</a>.</p>

</div>
</div>
<a id="a1f9bfb55aa0058e51d72037fde785fb0" name="a1f9bfb55aa0058e51d72037fde785fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9bfb55aa0058e51d72037fde785fb0">&#9670;&#160;</a></span>schedule_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::schedule_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02684">2684</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">Halide::get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#af83e9ccd0de6fd575006ab04c220ece2">Halide::Func::gpu_single_thread()</a>, <a class="el" href="struct_halide_1_1_target.html#a512386389886e2fa0ec57383b0ed6af0">Halide::Target::has_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a22bf80aa6dc3a700c9732050d2341a80">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#ac5834ded586e70e65b93850d7cafed54">Halide::Func::hexagon()</a>, and <a class="el" href="_target_8h_source.html#l00121">Halide::Target::HVX</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02702">Halide::evaluate_may_gpu()</a>, and <a class="el" href="_func_8h_source.html#l02718">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a id="a2ba803e43297e957a7e469082d37d68c" name="a2ba803e43297e957a7e469082d37d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba803e43297e957a7e469082d37d68c">&#9670;&#160;</a></span>deep_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &gt; Halide::Internal::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copy an entire <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> DAG. </p>

</div>
</div>
<a id="a4235fdb540be5dde3f9942604be666f0" name="a4235fdb540be5dde3f9942604be666f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4235fdb540be5dde3f9942604be666f0">&#9670;&#160;</a></span>zero_gpu_loop_mins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::zero_gpu_loop_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all GPU loops to have a min of zero. </p>

</div>
</div>
<a id="a0081752824625e87b5e95bfae979499f" name="a0081752824625e87b5e95bfae979499f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0081752824625e87b5e95bfae979499f">&#9670;&#160;</a></span>fuse_gpu_thread_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuse_gpu_thread_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model. </p>
<p>Within every loop over gpu block indices, fuse the inner loops over thread indices into a single loop (with predication to turn off threads). Push if conditions between GPU blocks to the innermost GPU threads. Also injects synchronization points as needed, and hoists shared allocations at the block level out into a single shared memory array, and heap allocations into a slice of a global pool allocated outside the kernel. </p>

</div>
</div>
<a id="a5f235cf0feb61ceabb0ad10573d85f84" name="a5f235cf0feb61ceabb0ad10573d85f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f235cf0feb61ceabb0ad10573d85f84">&#9670;&#160;</a></span>fuzz_float_stores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuzz_float_stores </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On every store of a floating point value, mask off the least-significant-bit of the mantissa. </p>
<p>We've found that whether or not this dramatically changes the output of a pipeline correlates very well with whether or not a pipeline will produce very different outputs on different architectures (e.g. with and without FMA). It's also a useful way to detect bad tests, such as those that expect exact floating point equality across platforms. </p>

</div>
</div>
<a id="ac4be7daed1a8c6cd914be946f22ea4df" name="ac4be7daed1a8c6cd914be946f22ea4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4be7daed1a8c6cd914be946f22ea4df">&#9670;&#160;</a></span>generator_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::generator_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b454e42dc909eaf6be644f7d502d1a3" name="a4b454e42dc909eaf6be644f7d502d1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b454e42dc909eaf6be644f7d502d1a3">&#9670;&#160;</a></span>parameter_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; Halide::Internal::parameter_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_parameter.html">Parameter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b54f450e1cd03c240743907e45487ce" name="a9b54f450e1cd03c240743907e45487ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b54f450e1cd03c240743907e45487ce">&#9670;&#160;</a></span>enum_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string Halide::Internal::enum_to_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>enum_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00297">297</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00007">user_error</a>.</p>

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l00863">Halide::Internal::GeneratorParam_Enum&lt; T &gt;::get_default_value()</a>, and <a class="el" href="_generator_8h_source.html#l00315">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a id="afd2308d89d4a9b9eef0803e92c383b0c" name="afd2308d89d4a9b9eef0803e92c383b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2308d89d4a9b9eef0803e92c383b0c">&#9670;&#160;</a></span>enum_from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::enum_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>enum_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00308">308</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="test_8h_source.html#l00010">user_assert</a>.</p>

</div>
</div>
<a id="af487202db575c63bd3dbb93d93e4f5f3" name="af487202db575c63bd3dbb93d93e4f5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af487202db575c63bd3dbb93d93e4f5f3">&#9670;&#160;</a></span>get_halide_type_enum_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp; Halide::Internal::get_halide_type_enum_map </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l00315">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a id="a2cc7c793b324e02e15a109f1e8af548c" name="a2cc7c793b324e02e15a109f1e8af548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc7c793b324e02e15a109f1e8af548c">&#9670;&#160;</a></span>halide_type_to_enum_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_enum_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00315">315</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l00297">enum_to_string()</a>, and <a class="el" href="#af487202db575c63bd3dbb93d93e4f5f3">get_halide_type_enum_map()</a>.</p>

</div>
</div>
<a id="a600136fc73541f81f75ee07095a62025" name="a600136fc73541f81f75ee07095a62025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600136fc73541f81f75ee07095a62025">&#9670;&#160;</a></span>halide_type_to_c_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_c_source </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l00908">Halide::Internal::GeneratorParam_Type&lt; T &gt;::get_default_value()</a>.</p>

</div>
</div>
<a id="a9e8f71298de4ece7dc2e59ae811c3fd2" name="a9e8f71298de4ece7dc2e59ae811c3fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8f71298de4ece7dc2e59ae811c3fd2">&#9670;&#160;</a></span>halide_type_to_c_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_c_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l01675">Halide::Internal::GeneratorInput_Buffer&lt; T2 &gt;::get_c_type()</a>, and <a class="el" href="_generator_8h_source.html#l02575">Halide::Internal::GeneratorOutput_Buffer&lt; T &gt;::get_c_type()</a>.</p>

</div>
</div>
<a id="ad02c1bb6c77110ad47015ce36529775a" name="ad02c1bb6c77110ad47015ce36529775a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02c1bb6c77110ad47015ce36529775a">&#9670;&#160;</a></span>get_registered_generators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html">GeneratorFactoryProvider</a> &amp; Halide::Internal::get_registered_generators </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html" title="GeneratorFactoryProvider provides a way to customize the Generators that are visible to generate_filt...">GeneratorFactoryProvider</a> that knows about all the currently-registered C++ Generators. </p>

</div>
</div>
<a id="a239019adaa0b7ed8fb0c6c81a6f694d3" name="a239019adaa0b7ed8fb0c6c81a6f694d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239019adaa0b7ed8fb0c6c81a6f694d3">&#9670;&#160;</a></span>generate_filter_main() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::generate_filter_main </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a239019adaa0b7ed8fb0c6c81a6f694d3" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a2ffc5102a3af64eff76abddc80ee4a9b">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation. </p>

</div>
</div>
<a id="ae994b36c5b1464443ec692ee2f4b6015" name="ae994b36c5b1464443ec692ee2f4b6015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae994b36c5b1464443ec692ee2f4b6015">&#9670;&#160;</a></span>generate_filter_main() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::generate_filter_main </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html">GeneratorFactoryProvider</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>generator_factory_provider</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This overload of generate_filter_main lets you provide your own provider for how to enumerate and/or create the generators based on registration name; this is useful if you want to re-use the 'main' logic but avoid the global <a class="el" href="class_halide_1_1_generator.html">Generator</a> registry (e.g. </p>
<p>for bindings in languages other than C++). </p>

</div>
</div>
<a id="ae47fa4b8f49636c214b214f5d0f4ed34" name="ae47fa4b8f49636c214b214f5d0f4ed34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47fa4b8f49636c214b214f5d0f4ed34">&#9670;&#160;</a></span>parse_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::parse_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02882">2882</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l02882">parse_scalar()</a>, and <a class="el" href="test_8h_source.html#l00010">user_assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l02882">parse_scalar()</a>.</p>

</div>
</div>
<a id="a9e1ffda17ab474ae9e88062f2c486d7b" name="a9e1ffda17ab474ae9e88062f2c486d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1ffda17ab474ae9e88062f2c486d7b">&#9670;&#160;</a></span>parse_halide_type_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; Halide::Internal::parse_halide_type_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a9e1ffda17ab474ae9e88062f2c486d7b">parse_halide_type_list()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a9e1ffda17ab474ae9e88062f2c486d7b">parse_halide_type_list()</a>.</p>

</div>
</div>
<a id="ac8012ee5b0051705ecbc75a83ae6b465" name="ac8012ee5b0051705ecbc75a83ae6b465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8012ee5b0051705ecbc75a83ae6b465">&#9670;&#160;</a></span>execute_generator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::execute_generator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_execute_generator_args.html">ExecuteGeneratorArgs</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a <a class="el" href="class_halide_1_1_generator.html">Generator</a> for AOT compilation &ndash; this provides the implementation of the command-line <a class="el" href="class_halide_1_1_generator.html">Generator</a> interface <code><a class="el" href="#a239019adaa0b7ed8fb0c6c81a6f694d3" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a></code>, but with a structured API that is more suitable for calling directly from code (vs command line). </p>

<p class="reference">References <a class="el" href="#ac8012ee5b0051705ecbc75a83ae6b465">execute_generator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ac8012ee5b0051705ecbc75a83ae6b465">execute_generator()</a>.</p>

</div>
</div>
<a id="a8696c48228f0cb335255ae46954909e1" name="a8696c48228f0cb335255ae46954909e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8696c48228f0cb335255ae46954909e1">&#9670;&#160;</a></span>inject_hexagon_rpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_hexagon_rpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>host_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>module</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module. </p>

</div>
</div>
<a id="ada520284696ef879c882132d47d56575" name="ada520284696ef879c882132d47d56575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada520284696ef879c882132d47d56575">&#9670;&#160;</a></span>compile_module_to_hexagon_shared_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; Halide::Internal::compile_module_to_hexagon_shared_object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>device_code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9944b3d2cbfb0262a46b72ec515ab130" name="a9944b3d2cbfb0262a46b72ec515ab130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9944b3d2cbfb0262a46b72ec515ab130">&#9670;&#160;</a></span>optimize_hexagon_shuffles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_shuffles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lut_alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace indirect and other loads with simple loads + vlut calls. </p>

</div>
</div>
<a id="ad61e99863aa9fd2833e535440b632093" name="ad61e99863aa9fd2833e535440b632093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61e99863aa9fd2833e535440b632093">&#9670;&#160;</a></span>scatter_gather_generator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::scatter_gather_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2278e803f98fc7b6e2b382ace8052975" name="a2278e803f98fc7b6e2b382ace8052975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2278e803f98fc7b6e2b382ace8052975">&#9670;&#160;</a></span>optimize_hexagon_instructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_instructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations. </p>
<p>This pass rewrites widenings/narrowings to be explicit in the IR, and attempts to simplify away most of the interleaving/deinterleaving. </p>

</div>
</div>
<a id="a33a62ca468e067e12843e66cfa0fb33d" name="a33a62ca468e067e12843e66cfa0fb33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a62ca468e067e12843e66cfa0fb33d">&#9670;&#160;</a></span>native_deinterleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a id="ad90cfab6d9f71632c8e4b712c7c400e8" name="ad90cfab6d9f71632c8e4b712c7c400e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90cfab6d9f71632c8e4b712c7c400e8">&#9670;&#160;</a></span>native_interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_interleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf5ab59246b78ff782aceed334637e4c" name="aaf5ab59246b78ff782aceed334637e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5ab59246b78ff782aceed334637e4c">&#9670;&#160;</a></span>is_native_deinterleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_native_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa264f8cbd16a2062c62a731ef88a261" name="aaa264f8cbd16a2062c62a731ef88a261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa264f8cbd16a2062c62a731ef88a261">&#9670;&#160;</a></span>is_native_interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_native_interleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada5b91e32017e38df05ae28f39a8b78c" name="ada5b91e32017e38df05ae28f39a8b78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5b91e32017e38df05ae28f39a8b78c">&#9670;&#160;</a></span>type_suffix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>signed_variants</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6edb350d77a097d5b1dce8ba2a9890cf" name="a6edb350d77a097d5b1dce8ba2a9890cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edb350d77a097d5b1dce8ba2a9890cf">&#9670;&#160;</a></span>type_suffix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>signed_variants</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6b52d96bb5a9b758cbaf557e35f4695" name="af6b52d96bb5a9b758cbaf557e35f4695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b52d96bb5a9b758cbaf557e35f4695">&#9670;&#160;</a></span>type_suffix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>signed_variants</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93d49ddfaea99d3ddf07425940e67dd0" name="a93d49ddfaea99d3ddf07425940e67dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d49ddfaea99d3ddf07425940e67dd0">&#9670;&#160;</a></span>type_suffix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>signed_variants</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac100c7daa45cf5358113252833505ee8" name="ac100c7daa45cf5358113252833505ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac100c7daa45cf5358113252833505ee8">&#9670;&#160;</a></span>infer_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a> &gt; Halide::Internal::infer_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50f932b31fe791a7b2002b829c8e5364" name="a50f932b31fe791a7b2002b829c8e5364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f932b31fe791a7b2002b829c8e5364">&#9670;&#160;</a></span>call_extern_and_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::call_extern_and_assert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function to call an extern function, and assert that it returns 0. </p>

</div>
</div>
<a id="a9fa15ced2f13142e6c4b5e5f4649aa15" name="a9fa15ced2f13142e6c4b5e5f4649aa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa15ced2f13142e6c4b5e5f4649aa15">&#9670;&#160;</a></span>inject_host_dev_buffer_copies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_host_dev_buffer_copies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed. </p>

</div>
</div>
<a id="a983e110a8277167d2764e231d1dbebf5" name="a983e110a8277167d2764e231d1dbebf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e110a8277167d2764e231d1dbebf5">&#9670;&#160;</a></span>inline_function() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a id="a7114825936949569e0a72294236a775c" name="a7114825936949569e0a72294236a775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7114825936949569e0a72294236a775c">&#9670;&#160;</a></span>inline_function() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a720ad50bc88a71450138fcec77b3b73c" name="a720ad50bc88a71450138fcec77b3b73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720ad50bc88a71450138fcec77b3b73c">&#9670;&#160;</a></span>inline_function() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6883343b90964967cb0bafb2551f5c3" name="ab6883343b90964967cb0bafb2551f5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6883343b90964967cb0bafb2551f5c3">&#9670;&#160;</a></span>validate_schedule_inlined_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::validate_schedule_inlined_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the schedule of an inlined function is legal, throwing an error if it is not. </p>

</div>
</div>
<a id="a5a81310ace17087de643bc9a31efeba1" name="a5a81310ace17087de643bc9a31efeba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a81310ace17087de643bc9a31efeba1">&#9670;&#160;</a></span>ref_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp; Halide::Internal::ref_count </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) noexcept {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

<p class="reference">Referenced by <a class="el" href="_intrusive_ptr_8h_source.html#l00181">Halide::Internal::IntrusivePtr&lt; T &gt;::is_sole_reference()</a>.</p>

</div>
</div>
<a id="a11ca920b642ef490aeac2b4e864d6254" name="a11ca920b642ef490aeac2b4e864d6254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca920b642ef490aeac2b4e864d6254">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::destroy </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bafeb4c15a672e45dbec02785b93716" name="a7bafeb4c15a672e45dbec02785b93716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bafeb4c15a672e45dbec02785b93716">&#9670;&#160;</a></span>equal_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00038">equal()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00063">graph_equal()</a>.</p>

</div>
</div>
<a id="aa56589d680e47d47cb99043ee9040312" name="aa56589d680e47d47cb99043ee9040312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56589d680e47d47cb99043ee9040312">&#9670;&#160;</a></span>graph_equal_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::graph_equal_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b281bee331928a19675ab3947ec7be0" name="a8b281bee331928a19675ab3947ec7be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b281bee331928a19675ab3947ec7be0">&#9670;&#160;</a></span>less_than_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::less_than_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00089">less_than()</a>.</p>

</div>
</div>
<a id="a6f07e1ec3fcdbe94c6de092a705ecc9c" name="a6f07e1ec3fcdbe94c6de092a705ecc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f07e1ec3fcdbe94c6de092a705ecc9c">&#9670;&#160;</a></span>graph_less_than_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::graph_less_than_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00118">graph_less_than()</a>.</p>

</div>
</div>
<a id="aa13e686a28ec56a80633dd2f884a66fd" name="aa13e686a28ec56a80633dd2f884a66fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13e686a28ec56a80633dd2f884a66fd">&#9670;&#160;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> to an int literal. </p>
<p>This is a somewhat common use of equal in tests. Making this separate avoids constructing an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> out of the int literal just to check if it's equal to a. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00028">28</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_8h_source.html#l00205">Halide::Internal::IRHandle::as()</a>, <a class="el" href="_type_8h_source.html#l00541">Halide::Int()</a>, and <a class="el" href="_expr_8h_source.html#l00327">Halide::Expr::type()</a>.</p>

</div>
</div>
<a id="a4c05dd091f826bcce807e1be2b1bda22" name="a4c05dd091f826bcce807e1be2b1bda22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c05dd091f826bcce807e1be2b1bda22">&#9670;&#160;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two defined Stmts or Exprs are equal. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00038">38</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="#a7bafeb4c15a672e45dbec02785b93716">equal_impl()</a>, and <a class="el" href="_expr_8h_source.html#l00113">Halide::Internal::IRNode::node_type</a>.</p>

</div>
</div>
<a id="ada037871ad1de9ce6e77781a241aaea0" name="ada037871ad1de9ce6e77781a241aaea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada037871ad1de9ce6e77781a241aaea0">&#9670;&#160;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two possible-undefined Stmts or Exprs are equal. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00050">50</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00164">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="#a44d062e9354cd14001f47cd01e82b93a">equal()</a>, and <a class="el" href="_intrusive_ptr_8h_source.html#l00102">Halide::Internal::IntrusivePtr&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a id="ab949751502a795d7147cfa5200965837" name="ab949751502a795d7147cfa5200965837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab949751502a795d7147cfa5200965837">&#9670;&#160;</a></span>graph_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two defined Stmts or Exprs are equal. </p>
<p>Safe to call on Exprs that haven't been passed to common_subexpression_elimination. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00063">63</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="#a7bafeb4c15a672e45dbec02785b93716">equal_impl()</a>, and <a class="el" href="_expr_8h_source.html#l00113">Halide::Internal::IRNode::node_type</a>.</p>

</div>
</div>
<a id="a896dcb5b101600c38f4a962f1bb1554f" name="a896dcb5b101600c38f4a962f1bb1554f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896dcb5b101600c38f4a962f1bb1554f">&#9670;&#160;</a></span>graph_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two possibly-undefined Stmts or Exprs are equal. </p>
<p>Safe to call on Exprs that haven't been passed to common_subexpression_elimination. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00076">76</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00164">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="#a44d062e9354cd14001f47cd01e82b93a">equal()</a>, and <a class="el" href="_intrusive_ptr_8h_source.html#l00102">Halide::Internal::IntrusivePtr&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a id="ab11a59a2f31e593fb22349fc1f33b8aa" name="ab11a59a2f31e593fb22349fc1f33b8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11a59a2f31e593fb22349fc1f33b8aa">&#9670;&#160;</a></span>less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two defined Stmts or Exprs are in a lexicographic order. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> use in map keys. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00089">89</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="#a8b281bee331928a19675ab3947ec7be0">less_than_impl()</a>, and <a class="el" href="_expr_8h_source.html#l00113">Halide::Internal::IRNode::node_type</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00102">less_than()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00147">Halide::Internal::IRDeepCompare::operator()()</a>.</p>

</div>
</div>
<a id="a34e88e34c586a1b9a0d907e8411c8631" name="a34e88e34c586a1b9a0d907e8411c8631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e88e34c586a1b9a0d907e8411c8631">&#9670;&#160;</a></span>less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two possibly-undefined Stmts or Exprs are in a lexicographic order. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> use in map keys. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00102">102</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00164">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00102">Halide::Internal::IntrusivePtr&lt; T &gt;::get()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00089">less_than()</a>.</p>

</div>
</div>
<a id="a651465ccda8d4388bf2ae0651ef6f0c6" name="a651465ccda8d4388bf2ae0651ef6f0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651465ccda8d4388bf2ae0651ef6f0c6">&#9670;&#160;</a></span>graph_less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::graph_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two defined Stmts or Exprs are in a lexicographic order. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> use in map keys. Safe to use on Exprs that haven't been passed to common_subexpression_elimination. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00118">118</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="#a6f07e1ec3fcdbe94c6de092a705ecc9c">graph_less_than_impl()</a>, and <a class="el" href="_expr_8h_source.html#l00113">Halide::Internal::IRNode::node_type</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00132">graph_less_than()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00155">Halide::Internal::IRGraphDeepCompare::operator()()</a>.</p>

</div>
</div>
<a id="ae44671b17b544e30b42100c14a337704" name="ae44671b17b544e30b42100c14a337704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44671b17b544e30b42100c14a337704">&#9670;&#160;</a></span>graph_less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::graph_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two possibly-undefined Stmts or Exprs are in a lexicographic order. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> use in map keys. Safe to use on Exprs that haven't been passed to common_subexpression_elimination. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_equality_8h_source.html#l00132">132</a> of file <a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00164">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00102">Halide::Internal::IntrusivePtr&lt; T &gt;::get()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00118">graph_less_than()</a>.</p>

</div>
</div>
<a id="ac59065f04bcf4e664007d95affa7ce3f" name="ac59065f04bcf4e664007d95affa7ce3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59065f04bcf4e664007d95affa7ce3f">&#9670;&#160;</a></span>ir_equality_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::ir_equality_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad10452d8940fd9d44b657a915b7cea42" name="ad10452d8940fd9d44b657a915b7cea42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10452d8940fd9d44b657a915b7cea42">&#9670;&#160;</a></span>expr_match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p>Wildcards require the types to match. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the type bits and width, a 0 indicates "match anything". So an Int(8, 0) will match 8-bit integer vectors of any width (including scalars), and a UInt(0, 0) will match any unsigned integer type.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="struct_halide_1_1_expr.html">Expr</a> x = <a class="code hl_function" href="struct_halide_1_1_internal_1_1_variable.html#abf38bc7c87ec8fdc8dabad8eebf2939c">Variable::make</a>(<a class="code hl_function" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);</div>
<div class="line">match(x + x, 3 + (2*k), result)</div>
<div class="ttc" id="anamespace_halide_html_a70a0c034814a65d55bb848fe9c96653b"><div class="ttname"><a href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Halide::Int</a></div><div class="ttdeci">Type Int(int bits, int lanes=1)</div><div class="ttdoc">Constructing a signed integer type.</div><div class="ttdef"><b>Definition</b> <a href="_type_8h_source.html#l00541">Type.h:541</a></div></div>
<div class="ttc" id="astruct_halide_1_1_expr_html"><div class="ttname"><a href="struct_halide_1_1_expr.html">Halide::Expr</a></div><div class="ttdoc">A fragment of Halide syntax.</div><div class="ttdef"><b>Definition</b> <a href="_expr_8h_source.html#l00258">Expr.h:258</a></div></div>
<div class="ttc" id="astruct_halide_1_1_internal_1_1_variable_html_abf38bc7c87ec8fdc8dabad8eebf2939c"><div class="ttname"><a href="struct_halide_1_1_internal_1_1_variable.html#abf38bc7c87ec8fdc8dabad8eebf2939c">Halide::Internal::Variable::make</a></div><div class="ttdeci">static Expr make(Type type, const std::string &amp;name)</div><div class="ttdef"><b>Definition</b> <a href="_i_r_8h_source.html#l00785">IR.h:785</a></div></div>
</div><!-- fragment --><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a id="ad8d77cbd158befc1b58416319609f313" name="ad8d77cbd158befc1b58416319609f313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d77cbd158befc1b58416319609f313">&#9670;&#160;</a></span>expr_match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables are matched consistently. </p>
<p>The first time a variable is matched, it assumes the value of the matching part of the second expression. Subsequent matches must be equal to the first match.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_halide_1_1_var.html">Var</a> x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">match(x*(x + y), a*(a + b), result)</div>
<div class="ttc" id="aclass_halide_1_1_var_html"><div class="ttname"><a href="class_halide_1_1_var.html">Halide::Var</a></div><div class="ttdoc">A Halide variable, to be used when defining functions.</div><div class="ttdef"><b>Definition</b> <a href="_var_8h_source.html#l00019">Var.h:19</a></div></div>
</div><!-- fragment --><p> should return true, and set result["x"] = a, and result["y"] = b. </p>

</div>
</div>
<a id="abc7dcf498f892ed7052bf6f812fe8b90" name="abc7dcf498f892ed7052bf6f812fe8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7dcf498f892ed7052bf6f812fe8b90">&#9670;&#160;</a></span>with_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::with_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the expression x to have <code>lanes</code> lanes. </p>
<p>This is useful for substituting the results of expr_match into a pattern expression. </p>

</div>
</div>
<a id="a1eed932bc0eb3a15edcb20795bfb8c2f" name="a1eed932bc0eb3a15edcb20795bfb8c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eed932bc0eb3a15edcb20795bfb8c2f">&#9670;&#160;</a></span>expr_match_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::expr_match_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0512dbf6acb2e3ef16f95249e75117a" name="ad0512dbf6acb2e3ef16f95249e75117a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0512dbf6acb2e3ef16f95249e75117a">&#9670;&#160;</a></span>mutate_region()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a>, bool &gt; Halide::Internal::mutate_region </td>
          <td>(</td>
          <td class="paramtype">Mutator *</td>          <td class="paramname"><span class="paramname"><em>mutator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function for mutator-like things to mutate regions. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_mutator_8h_source.html#l00124">124</a> of file <a class="el" href="_i_r_mutator_8h_source.html">IRMutator.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00171">Halide::Internal::IntrusivePtr&lt; T &gt;::same_as()</a>.</p>

</div>
</div>
<a id="af11d0eaaf5222de9d1151bf81479beb9" name="af11d0eaaf5222de9d1151bf81479beb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11d0eaaf5222de9d1151bf81479beb9">&#9670;&#160;</a></span>is_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants.">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02344">Halide::Internal::IRMatcher::IsConst&lt; A &gt;::make_folded_const()</a>.</p>

</div>
</div>
<a id="ad0438766d0040aa39c5f420f1a92b01b" name="ad0438766d0040aa39c5f420f1a92b01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0438766d0040aa39c5f420f1a92b01b">&#9670;&#160;</a></span>is_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>

</div>
</div>
<a id="a04c8aa1b8748ca0958837f0ba0674bd2" name="a04c8aa1b8748ca0958837f0ba0674bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c8aa1b8748ca0958837f0ba0674bd2">&#9670;&#160;</a></span>as_const_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; Halide::Internal::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a its value. </p>
<p>Otherwise returns std::nullopt. </p>

</div>
</div>
<a id="a12a87fabe7e34ddc531f4b42a423f5f8" name="a12a87fabe7e34ddc531f4b42a423f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a87fabe7e34ddc531f4b42a423f5f8">&#9670;&#160;</a></span>as_const_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &gt; Halide::Internal::as_const_uint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a>, return its value. </p>
<p>Otherwise returns std::nullopt. </p>

</div>
</div>
<a id="a447a267df279f56f32fee9bcdc0a66a8" name="a447a267df279f56f32fee9bcdc0a66a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447a267df279f56f32fee9bcdc0a66a8">&#9670;&#160;</a></span>as_const_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; Halide::Internal::as_const_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return its value. </p>
<p>Otherwise returns std::nullopt. </p>

</div>
</div>
<a id="a5a71170ae43c163cec618d27391445be" name="a5a71170ae43c163cec618d27391445be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a71170ae43c163cec618d27391445be">&#9670;&#160;</a></span>is_const_power_of_two_integer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; Halide::Internal::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Returns log base two of the expression if it is, or std::nullopt if not. Also returns std::nullopt for non-integer types. </p>

</div>
</div>
<a id="a96f44339d0ca10a75d9e240ed916c34e" name="a96f44339d0ca10a75d9e240ed916c34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f44339d0ca10a75d9e240ed916c34e">&#9670;&#160;</a></span>is_const_power_of_two_integer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; Halide::Internal::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc1e8d7fbd26b5fa0aff1fbb4d1b157" name="a0fc1e8d7fbd26b5fa0aff1fbb4d1b157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc1e8d7fbd26b5fa0aff1fbb4d1b157">&#9670;&#160;</a></span>is_const_power_of_two_integer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; Halide::Internal::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f26b6233cff17bdbf097bfe981e096c" name="a5f26b6233cff17bdbf097bfe981e096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f26b6233cff17bdbf097bfe981e096c">&#9670;&#160;</a></span>is_positive_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a id="a0e57c1aaa1719ed42fac6dc6661ebe90" name="a0e57c1aaa1719ed42fac6dc6661ebe90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e57c1aaa1719ed42fac6dc6661ebe90">&#9670;&#160;</a></span>is_negative_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a id="a0eb4bb1c7164222794e270f58c428eb7" name="a0eb4bb1c7164222794e270f58c428eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb4bb1c7164222794e270f58c428eb7">&#9670;&#160;</a></span>is_undef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_undef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an undef. </p>

</div>
</div>
<a id="a0490ee622445eeba11163a7a936177d7" name="a0490ee622445eeba11163a7a936177d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0490ee622445eeba11163a7a936177d7">&#9670;&#160;</a></span>is_const_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01970">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::match()</a>.</p>

</div>
</div>
<a id="a3534f733e8b7b7c617fd03714ccca697" name="a3534f733e8b7b7c617fd03714ccca697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3534f733e8b7b7c617fd03714ccca697">&#9670;&#160;</a></span>is_const_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02395">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;::make_folded_const()</a>.</p>

</div>
</div>
<a id="a916dccb9f4ad5763ce86721ab3187cfc" name="a916dccb9f4ad5763ce86721ab3187cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916dccb9f4ad5763ce86721ab3187cfc">&#9670;&#160;</a></span>is_no_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> node of a constant) </p>

</div>
</div>
<a id="a8325254f314a3811cc5ebebf4497466d" name="a8325254f314a3811cc5ebebf4497466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8325254f314a3811cc5ebebf4497466d">&#9670;&#160;</a></span>is_pure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_pure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, and 2) Evaluating it has no side-effects. </p>

</div>
</div>
<a id="a5a057ef6ceb8462dbca18eb9020bc297" name="a5a057ef6ceb8462dbca18eb9020bc297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a057ef6ceb8462dbca18eb9020bc297">&#9670;&#160;</a></span>make_const() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02710">Halide::Internal::IRMatcher::fuzz_test_rule()</a>, <a class="el" href="_i_r_match_8h_source.html#l00532">Halide::Internal::IRMatcher::IntLiteral::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00103">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00106">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00109">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00091">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00085">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00097">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00094">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00088">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00100">make_const()</a>, <a class="el" href="_generator_8h_source.html#l00520">Halide::Internal::GeneratorParamImpl&lt; T &gt;::operator Expr()</a>, <a class="el" href="_i_r_match_8h_source.html#l02933">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;::operator()()</a>, and <a class="el" href="_i_r_match_8h_source.html#l03010">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;::operator()()</a>.</p>

</div>
</div>
<a id="a69927d11c0fe7c6cf4092a811f6676d7" name="a69927d11c0fe7c6cf4092a811f6676d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69927d11c0fe7c6cf4092a811f6676d7">&#9670;&#160;</a></span>make_const() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3a72bc2d5b95e6a43e803a9f7c4acea" name="ad3a72bc2d5b95e6a43e803a9f7c4acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a72bc2d5b95e6a43e803a9f7c4acea">&#9670;&#160;</a></span>make_const() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae8ca905f0ce9cde74cc0897a61c4e7" name="aaae8ca905f0ce9cde74cc0897a61c4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae8ca905f0ce9cde74cc0897a61c4e7">&#9670;&#160;</a></span>make_const() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00085">85</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a70b64c00a450c92807011cdc02f8b29b" name="a70b64c00a450c92807011cdc02f8b29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b64c00a450c92807011cdc02f8b29b">&#9670;&#160;</a></span>make_const() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00088">88</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a4df9ef655a78f9fb233fa0322525496c" name="a4df9ef655a78f9fb233fa0322525496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df9ef655a78f9fb233fa0322525496c">&#9670;&#160;</a></span>make_const() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00091">91</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="af14e2dade91eb04482b4b5ffdfc920dd" name="af14e2dade91eb04482b4b5ffdfc920dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14e2dade91eb04482b4b5ffdfc920dd">&#9670;&#160;</a></span>make_const() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00094">94</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a5231b80b8e1a7904cdd4fcac7b89a98d" name="a5231b80b8e1a7904cdd4fcac7b89a98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5231b80b8e1a7904cdd4fcac7b89a98d">&#9670;&#160;</a></span>make_const() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00097">97</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="ae9a1ece36d20a64a59c92bf7f8c4e9aa" name="ae9a1ece36d20a64a59c92bf7f8c4e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a1ece36d20a64a59c92bf7f8c4e9aa">&#9670;&#160;</a></span>make_const() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00100">100</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="addbd965eccbcfc1f5b80eaa0607f698c" name="addbd965eccbcfc1f5b80eaa0607f698c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbd965eccbcfc1f5b80eaa0607f698c">&#9670;&#160;</a></span>make_const() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00103">103</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="aa90929bcfb18413ffd527152bb8580de" name="aa90929bcfb18413ffd527152bb8580de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90929bcfb18413ffd527152bb8580de">&#9670;&#160;</a></span>make_const() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00106">106</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a6592ef00a06a1d8f017b48359099c16d" name="a6592ef00a06a1d8f017b48359099c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592ef00a06a1d8f017b48359099c16d">&#9670;&#160;</a></span>make_const() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1float16__t.html">float16_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00109">109</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="aee83b2e74ffd9ee144d046aebbf87cca" name="aee83b2e74ffd9ee144d046aebbf87cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee83b2e74ffd9ee144d046aebbf87cca">&#9670;&#160;</a></span>make_signed_integer_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_signed_integer_overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a unique signed_integer_overflow <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00149">Halide::Internal::IRMatcher::make_const_special_expr()</a>.</p>

</div>
</div>
<a id="a68abd1ad9ed8a6e22cb63c19bfc89695" name="a68abd1ad9ed8a6e22cb63c19bfc89695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68abd1ad9ed8a6e22cb63c19bfc89695">&#9670;&#160;</a></span>is_signed_integer_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_signed_integer_overflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an expression is a signed_integer_overflow. </p>

</div>
</div>
<a id="a2de10096d923cdc0f02582981b718854" name="a2de10096d923cdc0f02582981b718854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de10096d923cdc0f02582981b718854">&#9670;&#160;</a></span>check_representable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_representable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a constant value can be correctly represented as the given type. </p>

</div>
</div>
<a id="ace2aa7992959c35ebe5895999b762b34" name="ace2aa7992959c35ebe5895999b762b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2aa7992959c35ebe5895999b762b34">&#9670;&#160;</a></span>make_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_bool </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

</div>
</div>
<a id="a0e4b9c03c76d9a19a0d7a7de2036f1b6" name="a0e4b9c03c76d9a19a0d7a7de2036f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4b9c03c76d9a19a0d7a7de2036f1b6">&#9670;&#160;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01985">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::make()</a>.</p>

</div>
</div>
<a id="a01e5ab6b1524fd81132823c77c35d717" name="a01e5ab6b1524fd81132823c77c35d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e5ab6b1524fd81132823c77c35d717">&#9670;&#160;</a></span>make_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of one in the given type. </p>

</div>
</div>
<a id="a14bdd8230cefd6bf9f84ac909311d87e" name="a14bdd8230cefd6bf9f84ac909311d87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bdd8230cefd6bf9f84ac909311d87e">&#9670;&#160;</a></span>make_two()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_two </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of two in the given type. </p>

</div>
</div>
<a id="a5fb413640f7f46493733fa33d95ea9fc" name="a5fb413640f7f46493733fa33d95ea9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb413640f7f46493733fa33d95ea9fc">&#9670;&#160;</a></span>const_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_true </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a lanes argument is given. </p>

</div>
</div>
<a id="ab94c84e726218144cf4c5d3a08b38f8d" name="ab94c84e726218144cf4c5d3a08b38f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94c84e726218144cf4c5d3a08b38f8d">&#9670;&#160;</a></span>const_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_false </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lanes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a lanes argument is given. </p>

</div>
</div>
<a id="aca3801143ed91f421de409bb02a23590" name="aca3801143ed91f421de409bb02a23590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3801143ed91f421de409bb02a23590">&#9670;&#160;</a></span>lossless_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lossless_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>, <a class="el" href="struct_halide_1_1_expr_compare.html">ExprCompare</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cache</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to cast an expression to a smaller type while provably not losing information. </p>
<p>If it can't be done, return an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>.</p>
<p>Optionally accepts a map that gives the constant bounds of exprs already analyzed to avoid redoing work across many calls to lossless_cast. It is not safe to use this optional map in contexts where the same <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> object may take on a different value. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: (let x = 4 in some_expr_object) + (let x = 5 in the_same_expr_object)). It is safe to use it after uniquify_variable_names has been run. </p>

</div>
</div>
<a id="aa626e40f7f540859a774c59d38a673bd" name="aa626e40f7f540859a774c59d38a673bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa626e40f7f540859a774c59d38a673bd">&#9670;&#160;</a></span>lossless_negate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lossless_negate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to negate x without introducing new IR and without overflow. </p>
<p>If it can't be done, return an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

</div>
</div>
<a id="a365bfad96972abe9e008bb1b601223f9" name="a365bfad96972abe9e008bb1b601223f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365bfad96972abe9e008bb1b601223f9">&#9670;&#160;</a></span>match_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::match_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

</div>
</div>
<a id="addfdcef00b83af48e34920fd58d1da84" name="addfdcef00b83af48e34920fd58d1da84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfdcef00b83af48e34920fd58d1da84">&#9670;&#160;</a></span>match_types_bitwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::match_types_bitwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>op_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that both expressions are integer types and are either both signed or both unsigned. </p>
<p>If one argument is scalar and the other a vector, the scalar is broadcasted to have the same number of lanes as the vector. If one expression is of narrower type than the other, it is widened to the bit width of the wider. </p>

</div>
</div>
<a id="a81818fbb02804a8e8f9056a0a24e0f56" name="a81818fbb02804a8e8f9056a0a24e0f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81818fbb02804a8e8f9056a0a24e0f56">&#9670;&#160;</a></span>halide_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s vectorizable transcendentals. </p>

</div>
</div>
<a id="a4f176922ae87268701a0234b48ead883" name="a4f176922ae87268701a0234b48ead883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f176922ae87268701a0234b48ead883">&#9670;&#160;</a></span>halide_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30907ab1fd2dfde808351ed05d262548" name="a30907ab1fd2dfde808351ed05d262548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30907ab1fd2dfde808351ed05d262548">&#9670;&#160;</a></span>halide_erf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec662f503947166115071493eaa00780" name="aec662f503947166115071493eaa00780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec662f503947166115071493eaa00780">&#9670;&#160;</a></span>raise_to_integer_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::raise_to_integer_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

</div>
</div>
<a id="a839473cf858ba53326b678db072411d2" name="a839473cf858ba53326b678db072411d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839473cf858ba53326b678db072411d2">&#9670;&#160;</a></span>split_into_ands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::split_into_ands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs. </p>
<p>If 'cond' is undefined, return an empty vector. </p>

</div>
</div>
<a id="aa6f512f02bfc12c8a4d1d87ab77bc0b6" name="aa6f512f02bfc12c8a4d1d87ab77bc0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f512f02bfc12c8a4d1d87ab77bc0b6">&#9670;&#160;</a></span>strided_ramp_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::strided_ramp_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stride</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If e is a ramp expression with stride, default 1, return the base, otherwise undefined. </p>

</div>
</div>
<a id="a6cd3908859c82249a2c7f10158883a97" name="a6cd3908859c82249a2c7f10158883a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd3908859c82249a2c7f10158883a97">&#9670;&#160;</a></span>mod_imp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::mod_imp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code when b != 0, (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode</p>
<p>Additionally, mod by zero returns zero, and div by zero returns zero. This makes mod and div total functions. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00252">252</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00423">Halide::Type::is_float()</a>, <a class="el" href="_type_8h_source.html#l00435">Halide::Type::is_int()</a>, and <a class="el" href="_type_8h_source.html#l00572">Halide::type_of()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_simplify___internal_8h_source.html#l00083">Halide::Internal::Simplify::ExprInfo::cast_to()</a>, <a class="el" href="_i_r_match_8h_source.html#l01055">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;()</a>, <a class="el" href="_i_r_match_8h_source.html#l01045">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;()</a>, <a class="el" href="_i_r_match_8h_source.html#l01050">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;()</a>, and <a class="el" href="_simplify___internal_8h_source.html#l00045">Halide::Internal::Simplify::ExprInfo::trim_bounds_using_alignment()</a>.</p>

</div>
</div>
<a id="a0442f9a0450f45683938a69ce0273974" name="a0442f9a0450f45683938a69ce0273974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0442f9a0450f45683938a69ce0273974">&#9670;&#160;</a></span>div_imp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::div_imp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00273">273</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00423">Halide::Type::is_float()</a>, <a class="el" href="_type_8h_source.html#l00435">Halide::Type::is_int()</a>, and <a class="el" href="_type_8h_source.html#l00572">Halide::type_of()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01026">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;()</a>, <a class="el" href="_i_r_match_8h_source.html#l01016">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;()</a>, and <a class="el" href="_i_r_match_8h_source.html#l01021">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;()</a>.</p>

</div>
</div>
<a id="adff5495089b812474881ee939c4701c4" name="adff5495089b812474881ee939c4701c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff5495089b812474881ee939c4701c4">&#9670;&#160;</a></span>mod_imp&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00298">298</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="ac9a60708c880da445554b8eeb778c034" name="ac9a60708c880da445554b8eeb778c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a60708c880da445554b8eeb778c034">&#9670;&#160;</a></span>mod_imp&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00304">304</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="aa13a82f37fe6336c154122f66d294523" name="aa13a82f37fe6336c154122f66d294523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13a82f37fe6336c154122f66d294523">&#9670;&#160;</a></span>div_imp&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00310">310</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a3965c871f086a60fda2cc31e678d050a" name="a3965c871f086a60fda2cc31e678d050a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965c871f086a60fda2cc31e678d050a">&#9670;&#160;</a></span>div_imp&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00314">314</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="af7df709582bdb9d7844efa9cd6b69625" name="af7df709582bdb9d7844efa9cd6b69625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7df709582bdb9d7844efa9cd6b69625">&#9670;&#160;</a></span>remove_likelies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::remove_likelies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed. </p>

</div>
</div>
<a id="a1bcf82ffcc64c0c61b7cb7fc6ac7c916" name="a1bcf82ffcc64c0c61b7cb7fc6ac7c916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">&#9670;&#160;</a></span>remove_likelies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_likelies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed. </p>

</div>
</div>
<a id="aa743928f81a0671c4ebc2cd2be4821f7" name="aa743928f81a0671c4ebc2cd2be4821f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa743928f81a0671c4ebc2cd2be4821f7">&#9670;&#160;</a></span>remove_promises() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::remove_promises </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="#a90683a918dfa5840b97406468fef7501" title="FOR INTERNAL USE ONLY.">promise_clamped()</a> and <a class="el" href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17" title="Create an Expr that that promises another Expr is clamped but do not generate code to check the asser...">unsafe_promise_clamped()</a> removed. </p>

</div>
</div>
<a id="a72fb7ba79c8a67a1ce85a0b8d78d4ada" name="a72fb7ba79c8a67a1ce85a0b8d78d4ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fb7ba79c8a67a1ce85a0b8d78d4ada">&#9670;&#160;</a></span>remove_promises() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_promises </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="#a90683a918dfa5840b97406468fef7501" title="FOR INTERNAL USE ONLY.">promise_clamped()</a> and <a class="el" href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17" title="Create an Expr that that promises another Expr is clamped but do not generate code to check the asser...">unsafe_promise_clamped()</a> removed. </p>

</div>
</div>
<a id="a9d42146de36c1cbc7633214f80795ad9" name="a9d42146de36c1cbc7633214f80795ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d42146de36c1cbc7633214f80795ad9">&#9670;&#160;</a></span>unwrap_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::unwrap_tags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the expression is a tag helper call, remove it and return the tagged expression. </p>
<p>If not, returns the expression. </p>

</div>
</div>
<a id="acf7ed2ca593eca53111eaf753a7fc9bf" name="acf7ed2ca593eca53111eaf753a7fc9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7ed2ca593eca53111eaf753a7fc9bf">&#9670;&#160;</a></span>collect_print_args() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00348">348</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_pipeline_8h_source.html#l00487">Halide::Pipeline::add_requirement()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00352">collect_print_args()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00358">collect_print_args()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01274">Halide::print()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01287">Halide::print_when()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01320">Halide::require()</a>.</p>

</div>
</div>
<a id="a4d7c2f51029190ae224290688b7c4c3b" name="a4d7c2f51029190ae224290688b7c4c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7c2f51029190ae224290688b7c4c3b">&#9670;&#160;</a></span>collect_print_args() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>more_args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00352">352</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00348">collect_print_args()</a>.</p>

</div>
</div>
<a id="adda140fdf727dfa11f6f3151fc4f7661" name="adda140fdf727dfa11f6f3151fc4f7661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda140fdf727dfa11f6f3151fc4f7661">&#9670;&#160;</a></span>collect_print_args() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>more_args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00358">358</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00348">collect_print_args()</a>.</p>

</div>
</div>
<a id="a12da582526c949b1bd11ede8f20bce2e" name="a12da582526c949b1bd11ede8f20bce2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da582526c949b1bd11ede8f20bce2e">&#9670;&#160;</a></span>requirement_failed_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::requirement_failed_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a082d3bda0d60128ae127d0879e7e38c9" name="a082d3bda0d60128ae127d0879e7e38c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082d3bda0d60128ae127d0879e7e38c9">&#9670;&#160;</a></span>memoize_tag_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::memoize_tag_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cache_key_values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01395">Halide::memoize_tag()</a>.</p>

</div>
</div>
<a id="a7c1a5b9726e5efce554d5d4dcdf90257" name="a7c1a5b9726e5efce554d5d4dcdf90257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1a5b9726e5efce554d5d4dcdf90257">&#9670;&#160;</a></span>reset_random_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::reset_random_counters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the counters used for random-number seeds in random_float/int/uint. </p>
<p>(Note that the counters are incremented for each call, even if a seed is passed in.) This is used for multitarget compilation to ensure that each subtarget gets the same sequence of random numbers. </p>

</div>
</div>
<a id="a2ac69b419fd1f9624e9513d53b80671e" name="a2ac69b419fd1f9624e9513d53b80671e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac69b419fd1f9624e9513d53b80671e">&#9670;&#160;</a></span>unreachable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::unreachable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32)</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that should never be evaluated. </p>
<p>Expressions that depend on unreachabale values are also unreachable, and statements that execute unreachable expressions are also considered unreachable. </p>

</div>
</div>
<a id="a1f17e150d50c8c4cad84a9b003c62f41" name="a1f17e150d50c8c4cad84a9b003c62f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f17e150d50c8c4cad84a9b003c62f41">&#9670;&#160;</a></span>unreachable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::unreachable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01361">1361</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00572">Halide::type_of()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01361">unreachable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01361">unreachable()</a>.</p>

</div>
</div>
<a id="a90683a918dfa5840b97406468fef7501" name="a90683a918dfa5840b97406468fef7501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90683a918dfa5840b97406468fef7501">&#9670;&#160;</a></span>promise_clamped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::promise_clamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FOR INTERNAL USE ONLY. </p>
<p>An entirely unchecked version of unsafe_promise_clamped, used inside the compiler as an annotation of the known bounds of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> when it has proved something is bounded and wants to record that fact for later passes (notably bounds inference) to exploit. This gets introduced by GuardWithIf tail strategies, because the bounds machinery has a hard time exploiting if statement conditions.</p>
<p>Unlike unsafe_promise_clamped, this expression is context-dependent, because 'value' might be statically bounded at some point in the IR (e.g. due to a containing if statement), but not elsewhere.</p>
<p>This intrinsic always evaluates to its first argument. If this value is used by a side-effecting operation and it is outside the range specified by its second and third arguments, behavior is undefined. The compiler can therefore assume that the value is within the range given and optimize accordingly. Note that this permits promise_clamped to evaluate to something outside of the range, provided that this value is not used.</p>
<p>Note that this produces an intrinsic that is marked as 'pure' and thus is allowed to be hoisted, etc.; thus, extra care must be taken with its use. </p>

</div>
</div>
<a id="a4a2a400fa1e1be0e5b629fdaddc3fef2" name="a4a2a400fa1e1be0e5b629fdaddc3fef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2a400fa1e1be0e5b629fdaddc3fef2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide node type on an output stream (such as std::cout) in human-readable form. </p>

</div>
</div>
<a id="ab484ec2f86cc767a395f35fa69eb1b8b" name="ab484ec2f86cc767a395f35fa69eb1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab484ec2f86cc767a395f35fa69eb1b8b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide associative pattern on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a id="af7e184dac97733cb81db3d44c4475c41" name="af7e184dac97733cb81db3d44c4475c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e184dac97733cb81db3d44c4475c41">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide associative op on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a id="a1bdc87d74601a359729f465add4a57c5" name="a1bdc87d74601a359729f465add4a57c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdc87d74601a359729f465add4a57c5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a id="ac5c84fe3f99dd05b0ffa69af2f042ff5" name="ac5c84fe3f99dd05b0ffa69af2f042ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c84fe3f99dd05b0ffa69af2f042ff5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27">VectorReduce::Operator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a horizontal vector reduction op in human-readable form. </p>

</div>
</div>
<a id="a10a9502cb7a58446fa468b44bfc4b6d1" name="a10a9502cb7a58446fa468b44bfc4b6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a9502cb7a58446fa468b44bfc4b6d1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide name mangling value in a human readable format. </p>

</div>
</div>
<a id="a1a977b805b5c8efe49a00e5c294253e4" name="a1a977b805b5c8efe49a00e5c294253e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a977b805b5c8efe49a00e5c294253e4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide linkage value in a human readable format. </p>

</div>
</div>
<a id="a18a7fc654d26338936dd99a9fb50949a" name="a18a7fc654d26338936dd99a9fb50949a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a7fc654d26338936dd99a9fb50949a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5b8c72fcb8800b47e313c62f5416a4fe">DimType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide dimension type in human-readable format. </p>

</div>
</div>
<a id="a84711b7fb71c0151bdf4cdff0274203a" name="a84711b7fb71c0151bdf4cdff0274203a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84711b7fb71c0151bdf4cdff0274203a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures.">Closure</a> in human-readable form. </p>

</div>
</div>
<a id="a523ae8336558d8709f4510731bd2a298" name="a523ae8336558d8709f4510731bd2a298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523ae8336558d8709f4510731bd2a298">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="struct_halide_1_1_internal_1_1_interval.html" title="A class to represent ranges of Exprs.">Interval</a> in human-readable form. </p>

</div>
</div>
<a id="a79ed3ae16af25caf69d9a03ec9aaf9c3" name="a79ed3ae16af25caf69d9a03ec9aaf9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ed3ae16af25caf69d9a03ec9aaf9c3">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html" title="A class to represent ranges of integers.">ConstantInterval</a> in human-readable form. </p>

</div>
</div>
<a id="a819144ed78ee773e7fbcd5271c9d1253" name="a819144ed78ee773e7fbcd5271c9d1253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819144ed78ee773e7fbcd5271c9d1253">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html" title="The result of modulus_remainder analysis.">ModulusRemainder</a> in human-readable form. </p>

</div>
</div>
<a id="aba8a7f7d4b6a6e27fcd31efcce988328" name="aba8a7f7d4b6a6e27fcd31efcce988328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8a7f7d4b6a6e27fcd31efcce988328">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_indentation.html">Indentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa99b1b712f2a914dfbcabeb1f7777857" name="aa99b1b712f2a914dfbcabeb1f7777857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99b1b712f2a914dfbcabeb1f7777857">&#9670;&#160;</a></span>lldb_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::lldb_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging helpers for LLDB. </p>

</div>
</div>
<a id="a0538675339647d35ffaadca9ad09283f" name="a0538675339647d35ffaadca9ad09283f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0538675339647d35ffaadca9ad09283f">&#9670;&#160;</a></span>lldb_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::lldb_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">Internal::BaseExprNode</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging helpers for LLDB. </p>

</div>
</div>
<a id="aefe53c86fe52500bdca596f46e8fb0d0" name="aefe53c86fe52500bdca596f46e8fb0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe53c86fe52500bdca596f46e8fb0d0">&#9670;&#160;</a></span>lldb_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::lldb_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging helpers for LLDB. </p>

</div>
</div>
<a id="a3c051d2259a5836298986de038a3e110" name="a3c051d2259a5836298986de038a3e110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c051d2259a5836298986de038a3e110">&#9670;&#160;</a></span>get_symbol_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Halide::Internal::get_symbol_address </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a151b37ef92bd2ae4f11005143282ce67" name="a151b37ef92bd2ae4f11005143282ce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151b37ef92bd2ae4f11005143282ce67">&#9670;&#160;</a></span>lower_lerp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>final_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>zero_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>one_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. The lerp is done in the type of the zero value. The final_type is a cast that should occur after the lerp. It's included because in some cases you can incorporate a final cast into the lerp math. </p>

</div>
</div>
<a id="a4933314cbff0bf637e348d5efc0a1499" name="a4933314cbff0bf637e348d5efc0a1499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4933314cbff0bf637e348d5efc0a1499">&#9670;&#160;</a></span>hoist_loop_invariant_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::hoist_loop_invariant_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariants out of inner loops. </p>
<p>This is especially important in cases where LLVM would not do it for us automatically. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, it hoists loop invariants out of cuda kernels. </p>

</div>
</div>
<a id="a3de2b04122d0ac7aba914d93c97b2589" name="a3de2b04122d0ac7aba914d93c97b2589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de2b04122d0ac7aba914d93c97b2589">&#9670;&#160;</a></span>hoist_loop_invariant_if_statements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::hoist_loop_invariant_if_statements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just hoist loop-invariant if statements as far up as possible. </p>
<p>Does not lift other values. It's useful to run this earlier in lowering to simplify the IR. </p>

</div>
</div>
<a id="a6e9d2c57ff18ef709b6a4e444f4af5ff" name="a6e9d2c57ff18ef709b6a4e444f4af5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9d2c57ff18ef709b6a4e444f4af5ff">&#9670;&#160;</a></span>iterator_to_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::iterator_to_pointer </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td> -&gt; decltype(&amp;*std::declval&lt;T&gt;()) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00119">119</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="a880810f84064e696c65e574223e8170a" name="a880810f84064e696c65e574223e8170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880810f84064e696c65e574223e8170a">&#9670;&#160;</a></span>get_llvm_function_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_llvm_function_name </td>
          <td>(</td>
          <td class="paramtype">const llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00123">123</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="ae2e2fec06de5b48f541b7a7b18d7bfb1" name="ae2e2fec06de5b48f541b7a7b18d7bfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e2fec06de5b48f541b7a7b18d7bfb1">&#9670;&#160;</a></span>get_llvm_function_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_llvm_function_name </td>
          <td>(</td>
          <td class="paramtype">const llvm::Function &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00127">127</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="a19498b7ba32a1bddbafd858d07b402a5" name="a19498b7ba32a1bddbafd858d07b402a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19498b7ba32a1bddbafd858d07b402a5">&#9670;&#160;</a></span>get_llvm_struct_type_by_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType * Halide::Internal::get_llvm_struct_type_by_name </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00131">131</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="a496ad11988df981c987a2557c3cd2d8c" name="a496ad11988df981c987a2557c3cd2d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496ad11988df981c987a2557c3cd2d8c">&#9670;&#160;</a></span>get_triple_for_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Triple Halide::Internal::get_triple_for_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="ad04027d1e41197c21cc803367b612e08" name="ad04027d1e41197c21cc803367b612e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04027d1e41197c21cc803367b612e08">&#9670;&#160;</a></span>get_initial_module_for_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; Halide::Internal::get_initial_module_for_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>for_shared_jit_runtime</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>just_gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a id="a67f50077affbb1487e3680d0d879e243" name="a67f50077affbb1487e3680d0d879e243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f50077affbb1487e3680d0d879e243">&#9670;&#160;</a></span>get_initial_module_for_ptx_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; Halide::Internal::get_initial_module_for_ptx_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a id="af5c2253813b438bcb811778d84b98e94" name="af5c2253813b438bcb811778d84b98e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c2253813b438bcb811778d84b98e94">&#9670;&#160;</a></span>add_bitcode_to_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::add_bitcode_to_module </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bitcode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a block of llvm bitcode into an llvm module. </p>

</div>
</div>
<a id="a7f7830b669a6e68edeeb27c58d65e55a" name="a7f7830b669a6e68edeeb27c58d65e55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7830b669a6e68edeeb27c58d65e55a">&#9670;&#160;</a></span>link_with_wasm_jit_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; Halide::Internal::link_with_wasm_jit_runtime </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;</td>          <td class="paramname"><span class="paramname"><em>extra_module</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the llvm::Module(s) in extra_modules (if any), add the runtime modules needed for the WASM JIT, and link into a single llvm::Module. </p>

</div>
</div>
<a id="a1fc91c3863b2f3b6afe3902a717ff68b" name="a1fc91c3863b2f3b6afe3902a717ff68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc91c3863b2f3b6afe3902a717ff68b">&#9670;&#160;</a></span>loop_carry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::loop_carry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_carried_values</em></span><span class="paramdefsep"> = </span><span class="paramdefval">8</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load. </p>
<p>If the loads are predicated, the predicates need to match. Can be an optimization or pessimization depending on how good the L1 cache is on the architecture and how many memory issue slots there are. Currently only intended for Hexagon. </p>

</div>
</div>
<a id="a3120dac0bea3e48403dd0d63420e929c" name="a3120dac0bea3e48403dd0d63420e929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3120dac0bea3e48403dd0d63420e929c">&#9670;&#160;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_module.html">Module</a> Halide::Internal::lower </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_funcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a></td>          <td class="paramname"><span class="paramname"><em>linkage_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>requirements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trace_pipeline</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>custom_passes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a>&#160;*&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of scheduled halide functions, create a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. The <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> may contain submodules for computation offloaded to another execution engine or API as well as buffers that are used in the passed in <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>. </p>

</div>
</div>
<a id="aa6912ab26d3b04864d43af52502ebeb7" name="aa6912ab26d3b04864d43af52502ebeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6912ab26d3b04864d43af52502ebeb7">&#9670;&#160;</a></span>lower_main_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_main_stmt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_funcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>requirements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trace_pipeline</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>custom_passes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a>&#160;*&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. Mostly used as a convenience function in tests that wish to assert some property of the lowered IR. </p>

</div>
</div>
<a id="a4d3bfe43201bab68cf4820993fe1469b" name="a4d3bfe43201bab68cf4820993fe1469b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3bfe43201bab68cf4820993fe1469b">&#9670;&#160;</a></span>lower_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::lower_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac932a9ede73796baeeb77ff860e97472" name="ac932a9ede73796baeeb77ff860e97472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac932a9ede73796baeeb77ff860e97472">&#9670;&#160;</a></span>lower_parallel_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_parallel_tasks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>closure_implementations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b7df44ea516ceb85971b6d8bcd9b1e0" name="a8b7df44ea516ceb85971b6d8bcd9b1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7df44ea516ceb85971b6d8bcd9b1e0">&#9670;&#160;</a></span>lower_warp_shuffles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_warp_shuffles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite access to things stored outside the loop over GPU lanes to use nvidia's warp shuffle instructions. </p>

</div>
</div>
<a id="ac66d64dd9cb646535816aff25b0d38ad" name="ac66d64dd9cb646535816aff25b0d38ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66d64dd9cb646535816aff25b0d38ad">&#9670;&#160;</a></span>inject_memoization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_memoization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache. </p>
<p>Should leave non-memoized Funcs unchanged. </p>

</div>
</div>
<a id="af597feabae6ec97802ee2f800667a0f7" name="af597feabae6ec97802ee2f800667a0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af597feabae6ec97802ee2f800667a0f7">&#9670;&#160;</a></span>rewrite_memoized_allocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_memoized_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This should be called after Storage Flattening has added Allocation IR nodes. </p>
<p>It connects the memoization cache lookups to the Allocations so they point to the buffers from the memoization cache and those buffers are released when no longer used. Should not affect allocations for non-memoized Funcs. </p>

</div>
</div>
<a id="aa7bea6a35a3aba9e68cda72e574560b9" name="aa7bea6a35a3aba9e68cda72e574560b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bea6a35a3aba9e68cda72e574560b9">&#9670;&#160;</a></span>get_output_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2af">OutputFileType</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_output_info.html">OutputInfo</a> &gt; Halide::Internal::get_output_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00158">Halide::SimdOpCheckTest::compile_and_check()</a>.</p>

</div>
</div>
<a id="a4287e047c221ec0bd503eca610e59cd1" name="a4287e047c221ec0bd503eca610e59cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4287e047c221ec0bd503eca610e59cd1">&#9670;&#160;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade4ed3e58311ee5699c067d4a6c53c2d" name="ade4ed3e58311ee5699c067d4a6c53c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4ed3e58311ee5699c067d4a6c53c2d">&#9670;&#160;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fc51636317f397ae70e341f81805f8e" name="a4fc51636317f397ae70e341f81805f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc51636317f397ae70e341f81805f8e">&#9670;&#160;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae26d56ea77b1fc65e72abc6025d15e2e" name="ae26d56ea77b1fc65e72abc6025d15e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26d56ea77b1fc65e72abc6025d15e2e">&#9670;&#160;</a></span>operator/() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42bc141be36f0586ef2dd5080befce47" name="a42bc141be36f0586ef2dd5080befce47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc141be36f0586ef2dd5080befce47">&#9670;&#160;</a></span>operator%() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad920f0d7b02a7331b8211d84e3f10208" name="ad920f0d7b02a7331b8211d84e3f10208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad920f0d7b02a7331b8211d84e3f10208">&#9670;&#160;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f39c3da5f8430464ac63973af1737ae" name="a9f39c3da5f8430464ac63973af1737ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f39c3da5f8430464ac63973af1737ae">&#9670;&#160;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e40311152e94d1bf520fa0a8eadafa9" name="a7e40311152e94d1bf520fa0a8eadafa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e40311152e94d1bf520fa0a8eadafa9">&#9670;&#160;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ad30409f49c922a7b536de49b50abfa" name="a5ad30409f49c922a7b536de49b50abfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad30409f49c922a7b536de49b50abfa">&#9670;&#160;</a></span>operator/() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5bf538dd23287f4a506afbe601b4a2" name="abe5bf538dd23287f4a506afbe601b4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5bf538dd23287f4a506afbe601b4a2">&#9670;&#160;</a></span>operator%() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b0244f4d3e877af92bb3326b5ba74d2" name="a1b0244f4d3e877af92bb3326b5ba74d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0244f4d3e877af92bb3326b5ba74d2">&#9670;&#160;</a></span>modulus_remainder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

</div>
</div>
<a id="aef9e014546d86033dd6c81f699891267" name="aef9e014546d86033dd6c81f699891267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9e014546d86033dd6c81f699891267">&#9670;&#160;</a></span>modulus_remainder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a id="ada0590e00c28750a1308739e988f82ab" name="ada0590e00c28750a1308739e988f82ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0590e00c28750a1308739e988f82ab">&#9670;&#160;</a></span>reduce_expr_modulo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>modulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remainder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a id="a92c5878a79c89558798237c40d7b54f3" name="a92c5878a79c89558798237c40d7b54f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c5878a79c89558798237c40d7b54f3">&#9670;&#160;</a></span>reduce_expr_modulo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>modulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remainder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a id="a789149daec96e933f8758f71f8474dd6" name="a789149daec96e933f8758f71f8474dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789149daec96e933f8758f71f8474dd6">&#9670;&#160;</a></span>modulus_remainder_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::modulus_remainder_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3383c51a3621854507bf149283901fd8" name="a3383c51a3621854507bf149283901fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3383c51a3621854507bf149283901fd8">&#9670;&#160;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::gcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest common divisor of two integers. </p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_function_d_a_g_8h_source.html#l00044">Halide::Internal::Autoscheduler::OptionalRational::operator+=()</a>.</p>

</div>
</div>
<a id="aea6d5d650979fec41ce02d02ac0b7c20" name="aea6d5d650979fec41ce02d02ac0b7c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6d5d650979fec41ce02d02ac0b7c20">&#9670;&#160;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::lcm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least common multiple of two integers. </p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_function_d_a_g_8h_source.html#l00044">Halide::Internal::Autoscheduler::OptionalRational::operator+=()</a>.</p>

</div>
</div>
<a id="a0301c6ab3540d1ce4c678d7f625d23b0" name="a0301c6ab3540d1ce4c678d7f625d23b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0301c6ab3540d1ce4c678d7f625d23b0">&#9670;&#160;</a></span>derivative_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> Halide::Internal::derivative_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the bounds of the derivative of an expression. </p>
<p>The scope gives the bounds on the derivatives of any variables found. </p>

</div>
</div>
<a id="a51a4b2947237a60faeb58784f49818c7" name="a51a4b2947237a60faeb58784f49818c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4b2947237a60faeb58784f49818c7">&#9670;&#160;</a></span>is_monotonic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> Halide::Internal::is_monotonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_constant_interval.html">ConstantInterval</a>&#160;&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86052cc97eb7a7774977da430b03274b" name="a86052cc97eb7a7774977da430b03274b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86052cc97eb7a7774977da430b03274b">&#9670;&#160;</a></span>is_monotonic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> Halide::Internal::is_monotonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecd75538cec762a0ec020c81708260b6" name="aecd75538cec762a0ec020c81708260b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd75538cec762a0ec020c81708260b6">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the monotonic class in human-readable form for debugging. </p>

</div>
</div>
<a id="af6de4b237eafb498206aa2eb0c94b4ad" name="af6de4b237eafb498206aa2eb0c94b4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de4b237eafb498206aa2eb0c94b4ad">&#9670;&#160;</a></span>is_monotonic_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::is_monotonic_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad273923c5480df0e3753e3a70d240e6" name="aad273923c5480df0e3753e3a70d240e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad273923c5480df0e3753e3a70d240e6">&#9670;&#160;</a></span>inject_gpu_offload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_gpu_offload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>host_target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull loops marked with GPU device APIs to a separate module, and call them through the appropriate host runtime module. </p>

</div>
</div>
<a id="a0e6355b1954c20cf3e39d376f6dd17c5" name="a0e6355b1954c20cf3e39d376f6dd17c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6355b1954c20cf3e39d376f6dd17c5">&#9670;&#160;</a></span>optimize_shuffles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_shuffles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lut_alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a87590be371b78913eaab20e563f335" name="a9a87590be371b78913eaab20e563f335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a87590be371b78913eaab20e563f335">&#9670;&#160;</a></span>can_parallelize_rvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_parallelize_rvar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>rvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable. </p>
<p>If this returns true, it's definitely safe. If this returns false, it may still be safe, but <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> couldn't prove it. </p>

</div>
</div>
<a id="a0ce66817377fbb1918bbe7510ab47b29" name="a0ce66817377fbb1918bbe7510ab47b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce66817377fbb1918bbe7510ab47b29">&#9670;&#160;</a></span>check_call_arg_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_call_arg_types </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate arguments to a call to a func, image or imageparam. </p>

</div>
</div>
<a id="abc76f59b0d70ea1055186a7098feef3b" name="abc76f59b0d70ea1055186a7098feef3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc76f59b0d70ea1055186a7098feef3b">&#9670;&#160;</a></span>has_uncaptured_likely_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_uncaptured_likely_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if an expression uses a likely tag that isn't captured by an enclosing <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a>, <a class="el" href="struct_halide_1_1_internal_1_1_min.html" title="The lesser of two values.">Min</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a>. </p>
<p>The scope contains all vars that should be considered to have uncaptured likelies. </p>

</div>
</div>
<a id="a0074d04170e6df774a2a0982b5ba78b5" name="a0074d04170e6df774a2a0982b5ba78b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0074d04170e6df774a2a0982b5ba78b5">&#9670;&#160;</a></span>has_likely_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_likely_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if an expression uses a likely tag. </p>
<p>The scope contains all vars in scope that should be considered to have likely tags. </p>

</div>
</div>
<a id="a3d00fe3db9030d30827191d78c36fda5" name="a3d00fe3db9030d30827191d78c36fda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d00fe3db9030d30827191d78c36fda5">&#9670;&#160;</a></span>partition_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::partition_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions loop bodies into a prologue, a steady state, and an epilogue. </p>
<p>Finds the steady state by hunting for use of clamped ramps, or the 'likely' intrinsic. </p>

</div>
</div>
<a id="a9d9e0c79704de005e7e9ca2283da97c6" name="a9d9e0c79704de005e7e9ca2283da97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e0c79704de005e7e9ca2283da97c6">&#9670;&#160;</a></span>inject_placeholder_prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_placeholder_prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefetches</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject placeholder prefetches to 's'. </p>
<p>This placholder prefetch does not have explicit region to be prefetched yet. It will be computed during call to <a class="el" href="#ab1427ae551e1c2cce79b7042c3fa4620">inject_prefetch</a>. </p>

</div>
</div>
<a id="ab1427ae551e1c2cce79b7042c3fa4620" name="ab1427ae551e1c2cce79b7042c3fa4620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1427ae551e1c2cce79b7042c3fa4620">&#9670;&#160;</a></span>inject_prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the actual region to be prefetched and place it to the placholder prefetch. </p>
<p>Wrap the prefetch call with condition when applicable. </p>

</div>
</div>
<a id="a23cbede92a4cd09354b032a40829a9d1" name="a23cbede92a4cd09354b032a40829a9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cbede92a4cd09354b032a40829a9d1">&#9670;&#160;</a></span>reduce_prefetch_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::reduce_prefetch_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a multi-dimensional prefetch into a prefetch of lower dimension (max dimension of the prefetch is specified by target architecture). </p>
<p>This keeps the 'max_dim' innermost dimensions and adds loops for the rest of the dimensions. If maximum prefetched-byte-size is specified (depending on the architecture), this also adds an outer loops that tile the prefetches. </p>

</div>
</div>
<a id="ae4cb2c3d2c016e1eb6e6621599f9d731" name="ae4cb2c3d2c016e1eb6e6621599f9d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cb2c3d2c016e1eb6e6621599f9d731">&#9670;&#160;</a></span>hoist_prefetches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::hoist_prefetches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist all the prefetches in a <a class="el" href="struct_halide_1_1_internal_1_1_block.html" title="A sequence of statements to be executed in-order.">Block</a> to the beginning of the <a class="el" href="struct_halide_1_1_internal_1_1_block.html" title="A sequence of statements to be executed in-order.">Block</a>. </p>
<p>This generally only happens when a loop with prefetches is unrolled; in some cases, LLVM's code generation can be suboptimal (unnecessary register spills) when prefetches are scattered through the loop. Hoisting to the top of the loop is a good way to mitigate this, at the cost of the prefetch calls possibly being less useful due to distance from use point. (This is a bit experimental and may need revisiting.) See also <a href="https://bugs.llvm.org/show_bug.cgi?id=51172">https://bugs.llvm.org/show_bug.cgi?id=51172</a> </p>

</div>
</div>
<a id="aa35ddfd891459204fae6afbcbdb6bac6" name="aa35ddfd891459204fae6afbcbdb6bac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35ddfd891459204fae6afbcbdb6bac6">&#9670;&#160;</a></span>print_loop_nest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::print_loop_nest </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_funcs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses. </p>

</div>
</div>
<a id="ae902f8e74df2649f97a92da9edd25d01" name="ae902f8e74df2649f97a92da9edd25d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae902f8e74df2649f97a92da9edd25d01">&#9670;&#160;</a></span>inject_profiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_profiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a id="a875f0768e69428144a610e591c7d9796" name="a875f0768e69428144a610e591c7d9796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875f0768e69428144a610e591c7d9796">&#9670;&#160;</a></span>purify_index_math()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::purify_index_math </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bounds inference and related stages can lift integer bounds expressions out of if statements that guard against those integer expressions doing side-effecty things like dividing or modding by zero. </p>
<p>In those cases, if the lowering passes are functional, the value resulting from the division or mod is evaluated but not used. This mutator rewrites divs and mods in such expressions to fail silently (evaluate to undef) when the denominator is zero. </p>

</div>
</div>
<a id="aac0f12f161a6ba2a7b3476dbb1dbf809" name="aac0f12f161a6ba2a7b3476dbb1dbf809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f12f161a6ba2a7b3476dbb1dbf809">&#9670;&#160;</a></span>qualify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::qualify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix all variable names in the given expression with the prefix string. </p>

</div>
</div>
<a id="a795f343747d7f716a33198907c3e7d25" name="a795f343747d7f716a33198907c3e7d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795f343747d7f716a33198907c3e7d25">&#9670;&#160;</a></span>random_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_float </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random floating-point number between zero and one that varies deterministically based on the input expressions. </p>

</div>
</div>
<a id="ae4e64539c6d89123f6200b919ec28fbb" name="ae4e64539c6d89123f6200b919ec28fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e64539c6d89123f6200b919ec28fbb">&#9670;&#160;</a></span>random_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers). </p>

</div>
</div>
<a id="af6c33f7c870e8bd885383ccdc626112e" name="af6c33f7c870e8bd885383ccdc626112e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c33f7c870e8bd885383ccdc626112e">&#9670;&#160;</a></span>lower_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>free_vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> calls to random() to IR generated by random_float and random_int. </p>
<p>Tags all calls with the variables in free_vars, and the integer given as the last argument. </p>

</div>
</div>
<a id="a16182ff30077d1ecfc92f992ff2faccc" name="a16182ff30077d1ecfc92f992ff2faccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16182ff30077d1ecfc92f992ff2faccc">&#9670;&#160;</a></span>realization_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::vector&lt; std::string &gt; &gt; &gt; Halide::Internal::realization_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine an order in which to do the scheduling. </p>
<p>This in turn influences the order in which stages are computed when there's no strict dependency between them. Currently just some arbitrary depth-first traversal of the call graph. In addition, determine grouping of functions with fused computation loops. The functions within the fused groups are sorted based on realization order. There should not be any dependencies among functions within a fused group. This pass will also populate the 'fused_pairs' list in the function's schedule. Return a pair of the realization order and the fused groups in that order. </p>

</div>
</div>
<a id="a070fbe2943a2ab08b480fb4672e1617d" name="a070fbe2943a2ab08b480fb4672e1617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070fbe2943a2ab08b480fb4672e1617d">&#9670;&#160;</a></span>topological_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Halide::Internal::topological_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine a topological order which stays constant regardless of the schedule. </p>
<p>This ordering adheres to the producer-consumer dependencies, i.e. producer will come before its consumers in that order </p>

</div>
</div>
<a id="aa9d1cbe18a4f88b265c955be144a5bd6" name="aa9d1cbe18a4f88b265c955be144a5bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d1cbe18a4f88b265c955be144a5bd6">&#9670;&#160;</a></span>rebase_loops_to_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rebase_loops_to_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the mins of most loops to 0. </p>

</div>
</div>
<a id="aedcc74570e61290111488ef861e03d0f" name="aedcc74570e61290111488ef861e03d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcc74570e61290111488ef861e03d0f">&#9670;&#160;</a></span>split_predicate_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::split_predicate_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b8bfb7d84886e922f43c911740f2b1e" name="a6b8bfb7d84886e922f43c911740f2b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8bfb7d84886e922f43c911740f2b1e">&#9670;&#160;</a></span>is_func_trivial_to_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_func_trivial_to_inline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the cost of inlining a function is equivalent to the cost of calling the function directly. </p>

</div>
</div>
<a id="af5f341c9e3b9dd03353afdeacd6092db" name="af5f341c9e3b9dd03353afdeacd6092db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f341c9e3b9dd03353afdeacd6092db">&#9670;&#160;</a></span>remove_dead_allocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_dead_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>. </p>
<p>This doesn't touch Realize/Call nodes and so must be called after storage_flattening. </p>

</div>
</div>
<a id="a7966c5570f5dfae1e45df7995c34a762" name="a7966c5570f5dfae1e45df7995c34a762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7966c5570f5dfae1e45df7995c34a762">&#9670;&#160;</a></span>remove_extern_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_extern_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes placeholder loops for extern stages. </p>

</div>
</div>
<a id="a078fe646230de310959c4506c76de02e" name="a078fe646230de310959c4506c76de02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078fe646230de310959c4506c76de02e">&#9670;&#160;</a></span>remove_undef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_undef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes stores that depend on undef values, and statements that only contain such stores. </p>

</div>
</div>
<a id="abe516bcacc2d5ea4d657228f8a8b49ad" name="abe516bcacc2d5ea4d657228f8a8b49ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe516bcacc2d5ea4d657228f8a8b49ad">&#9670;&#160;</a></span>schedule_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::schedule_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fused_groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>any_memoized</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> realizations at the appropriate places using the schedule. </p>
<p>Returns a flag indicating whether memoization passes need to be run. </p>

</div>
</div>
<a id="a15a75e74ba61493371c211e87046c189" name="a15a75e74ba61493371c211e87046c189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a75e74ba61493371c211e87046c189">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_scope_8h_source.html#l00307">307</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p class="reference">References <a class="el" href="_scope_8h_source.html#l00292">Halide::Internal::Scope&lt; T &gt;::cbegin()</a>, <a class="el" href="_scope_8h_source.html#l00296">Halide::Internal::Scope&lt; T &gt;::cend()</a>, and <a class="el" href="_scope_8h_source.html#l00277">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a id="a3c068fc071822f5554d35e8cce582f54" name="a3c068fc071822f5554d35e8cce582f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c068fc071822f5554d35e8cce582f54">&#9670;&#160;</a></span>select_gpu_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::select_gpu_api </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target. </p>
<p>Choose the first of the following: opencl, cuda </p>

</div>
</div>
<a id="ae8e925c5d658d689e0798106019bc083" name="ae8e925c5d658d689e0798106019bc083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e925c5d658d689e0798106019bc083">&#9670;&#160;</a></span>simplify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_dead_code</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assumptions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. Can optionally be passed known bounds of any variables, known alignment properties, and any other Exprs that should be assumed to be true. </p>

</div>
</div>
<a id="ab7ad0375ba62ff83d5d5a2ed88610989" name="ab7ad0375ba62ff83d5d5a2ed88610989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ad0375ba62ff83d5d5a2ed88610989">&#9670;&#160;</a></span>simplify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_dead_code</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;&gt;::empty_scope()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assumptions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5068393c9b9f8b58f7e1c164bee99f0b" name="a5068393c9b9f8b58f7e1c164bee99f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5068393c9b9f8b58f7e1c164bee99f0b">&#9670;&#160;</a></span>can_prove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_prove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to statically prove an expression is true using the simplifier. </p>

</div>
</div>
<a id="a0918e7154f0624c9f1a15d34f4776c54" name="a0918e7154f0624c9f1a15d34f4776c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0918e7154f0624c9f1a15d34f4776c54">&#9670;&#160;</a></span>simplify_exprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_exprs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_halide_1_1_internal_1_1_simplify.html">Simplify</a> expressions found in a statement, but don't simplify across different statements. </p>
<p>This is safe to perform at an earlier stage in lowering than full simplification of a stmt. </p>

</div>
</div>
<a id="a9145896c0b84da47b601412c7f451cb4" name="a9145896c0b84da47b601412c7f451cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145896c0b84da47b601412c7f451cb4">&#9670;&#160;</a></span>simplify_correlated_differences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_correlated_differences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolic interval arithmetic can be extremely conservative in cases where we analyze the difference between two correlated expressions. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, consider:</p>
<p>for x in [0, 10]: let y = x + 3 let z = y - x</p>
<p>x lies within [0, 10]. <a class="el" href="struct_halide_1_1_internal_1_1_interval.html" title="A class to represent ranges of Exprs.">Interval</a> arithmetic will correctly determine that y lies within [3, 13]. When z is encountered, it is treated as a difference of two independent variables, and gives [3 - 10, 13 - 0] = [-7, 13] instead of the tighter interval [3, 3]. It doesn't understand that y and x are correlated.</p>
<p>In practice, this problem causes problems for unrolling, and arbitrarily-bad overconservative behavior in bounds inference (e.g. <a href="https://github.com/halide/Halide/issues/3697">https://github.com/halide/Halide/issues/3697</a> )</p>
<p>The function below attempts to address this by walking the IR, remembering whether each let variable is monotonic increasing, decreasing, unknown, or constant w.r.t each loop var. When it encounters a subtract node where both sides have the same monotonicity it substitutes, solves, and attempts to generally simplify as aggressively as possible to try to cancel out the repeated dependence on the loop var. The same is done for addition nodes with arguments of opposite monotonicity.</p>
<p>Bounds inference is particularly sensitive to these false dependencies, but removing false dependencies also helps other lowering passes. E.g. if this simplification means a value no longer depends on a loop variable, it can remain scalar during vectorization of that loop, or we can lift it out as a loop invariant, or it might avoid some of the complex paths in GPU codegen that trigger when values depend on the block index (e.g. warp shuffles).</p>
<p>This pass is safe to use on code with repeated instances of the same variable name (it must be, because we want to run it before allocation bounds inference). </p>

</div>
</div>
<a id="a0bee2a544c782fdc8ca228e53c43845e" name="a0bee2a544c782fdc8ca228e53c43845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bee2a544c782fdc8ca228e53c43845e">&#9670;&#160;</a></span>bound_correlated_differences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::bound_correlated_differences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refactor the expression to remove correlated differences or rewrite them in a form that is more amenable to bounds inference. </p>
<p>Performs a subset of what <code>simplify_correlated_differences</code> does. Can increase <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> size (i.e. does not follow the simplifier's reduction order). </p>

</div>
</div>
<a id="af4259425c64a0a9b25760e1c38123c13" name="af4259425c64a0a9b25760e1c38123c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4259425c64a0a9b25760e1c38123c13">&#9670;&#160;</a></span>simplify_specializations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::simplify_specializations </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the RHS/LHS of a function's definition based on its specializations. </p>

</div>
</div>
<a id="ab9fa9eb646f186793b4dd4a8e994b6c9" name="ab9fa9eb646f186793b4dd4a8e994b6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fa9eb646f186793b4dd4a8e994b6c9">&#9670;&#160;</a></span>skip_stages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::skip_stages </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used. </p>
<p>Does this by analyzing all reads of each buffer allocated, and inferring some condition that tells us if the reads occur. If the condition is non-trivial, inject ifs that guard the production. </p>

</div>
</div>
<a id="a6e3db85e95026207aa687c6f56c53cba" name="a6e3db85e95026207aa687c6f56c53cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3db85e95026207aa687c6f56c53cba">&#9670;&#160;</a></span>sliding_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::sliding_window </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a id="a285ed8a60a9ef19bd666e8f12a11f269" name="a285ed8a60a9ef19bd666e8f12a11f269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285ed8a60a9ef19bd666e8f12a11f269">&#9670;&#160;</a></span>solve_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a> Halide::Internal::solve_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>variable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scope</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;&gt;::empty_scope()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e. </p>
<p>outside most parentheses). If the expression is an equality or comparison, this 'solves' the equation. Returns a pair of <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and bool. The <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> is the mutated expression, and the bool indicates whether there is a single instance of the variable in the result. If it is false, the expression has only been partially solved, and there are still multiple instances of the variable. </p>

</div>
</div>
<a id="a01aa500a3f20519d9a27d718f77e1c1e" name="a01aa500a3f20519d9a27d718f77e1c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aa500a3f20519d9a27d718f77e1c1e">&#9670;&#160;</a></span>solve_for_outer_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_outer_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>variable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it. </p>
<p>Never returns undefined Exprs, instead it uses variables called "pos_inf" and "neg_inf" to represent positive and negative infinity. </p>

</div>
</div>
<a id="a6af37b4f0075b3dcd203546133878d54" name="a6af37b4f0075b3dcd203546133878d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af37b4f0075b3dcd203546133878d54">&#9670;&#160;</a></span>solve_for_inner_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_inner_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>variable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it. </p>

</div>
</div>
<a id="a1fe4e051947dc094f3136a7b1e69a1e1" name="a1fe4e051947dc094f3136a7b1e69a1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4e051947dc094f3136a7b1e69a1e1">&#9670;&#160;</a></span>and_condition_over_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::and_condition_over_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>varying</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables. </p>
<p>Formally, the output expr implies the input expr.</p>
<p>The condition may be a vector condition, in which case we also 'and' over the vector lanes, and return a scalar result. </p>

</div>
</div>
<a id="a6e1e287e68d69ec35fd8a1e62d1c30ed" name="a6e1e287e68d69ec35fd8a1e62d1c30ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1e287e68d69ec35fd8a1e62d1c30ed">&#9670;&#160;</a></span>solve_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::solve_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7de0d574c401a3e0b47ae9b677181f15" name="a7de0d574c401a3e0b47ae9b677181f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de0d574c401a3e0b47ae9b677181f15">&#9670;&#160;</a></span>spirv_ir_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::spirv_ir_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html">Internal</a> test for SPIR-V IR. </p>

</div>
</div>
<a id="a1e8dbe6ebbf9e99beda91f45eead442f" name="a1e8dbe6ebbf9e99beda91f45eead442f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8dbe6ebbf9e99beda91f45eead442f">&#9670;&#160;</a></span>split_tuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::split_tuples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all tuple-valued Realizations, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a> nodes, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes into several scalar-valued ones, so that later lowering passes only need to think about scalar-valued productions. </p>

</div>
</div>
<a id="a7043faa4b3ad9b3a4898c0eb9974fbcd" name="a7043faa4b3ad9b3a4898c0eb9974fbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7043faa4b3ad9b3a4898c0eb9974fbcd">&#9670;&#160;</a></span>stage_strided_loads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::stage_strided_loads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> all unpredicated strided loads in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> into dense loads followed by shuffles. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> a stride of two, the trick is to do a dense load of twice the size, and then extract either the even or odd lanes. This was previously done in codegen, where it was challenging, because it's not easy to know there if it's safe to do the double-sized load, as it either loads one element beyond or before the original load. We used the alignment of the ramp base to try to tell if it was safe to shift backwards, and we added padding to internal allocations so that for those at least it was safe to shift forwards. Unfortunately the alignment of the ramp base is usually unknown if you don't know anything about the strides of the input, and adding padding to allocations was a serious wart in our memory allocators.</p>
<p>This pass instead actively looks for evidence elsewhere in the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> (at some location which definitely executes whenever the load being transformed executes) that it's safe to read further forwards or backwards in memory. The evidence is in the form of a load at the same base address with a different constant offset. It also clusters groups of these loads so that they do the same dense load and extract the appropriate slice of lanes. If it fails to find any evidence, for loads from external buffers it does two overlapping half-sized dense loads and shuffles out the desired lanes, and for loads from internal allocations it adds padding to the allocation explicitly, by setting the padding field on <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> nodes. </p>

</div>
</div>
<a id="a6e1f44f72e9adf92ab081eec58cb67c4" name="a6e1f44f72e9adf92ab081eec58cb67c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1f44f72e9adf92ab081eec58cb67c4">&#9670;&#160;</a></span>print_to_stmt_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::print_to_stmt_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>html_output_filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>assembly_input_filename</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted visualization of a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> to filename. </p>
<p>If assembly_input_filename is not empty, it is expected to be the path to assembly output. If empty, the code will attempt to find such a file based on output_filename (replacing ".stmt.html" with ".s"), and will assert-fail if no such file is found. </p>

</div>
</div>
<a id="a237581902c246cec8b1a5d62ccd7596f" name="a237581902c246cec8b1a5d62ccd7596f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237581902c246cec8b1a5d62ccd7596f">&#9670;&#160;</a></span>print_to_conceptual_stmt_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::print_to_conceptual_stmt_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>html_output_filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>assembly_input_filename</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted visualization of a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a>'s conceptual <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> code to filename. </p>
<p>If assembly_input_filename is not empty, it is expected to be the path to assembly output. If empty, the code will attempt to find such a file based on output_filename (replacing ".stmt.html" with ".s"), and will assert-fail if no such file is found. </p>

</div>
</div>
<a id="ac8cb6fe2cb6171bf79124c2c1b1e867f" name="ac8cb6fe2cb6171bf79124c2c1b1e867f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cb6fe2cb6171bf79124c2c1b1e867f">&#9670;&#160;</a></span>storage_flattening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_flattening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true.">Load</a> nodes respectively. </p>

</div>
</div>
<a id="a328a1d6d3f0c78ffdc58ac5df812f05a" name="a328a1d6d3f0c78ffdc58ac5df812f05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328a1d6d3f0c78ffdc58ac5df812f05a">&#9670;&#160;</a></span>storage_folding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_folding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><div class="line">f(x) = ...</div>
<div class="line">g(x) = f(x-1) + f(x)</div>
<div class="line">f.store_root().compute_at(g, x);</div>
</div><!-- fragment --><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a id="ad8a5dab8c12346254d9348060878045c" name="ad8a5dab8c12346254d9348060878045c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a5dab8c12346254d9348060878045c">&#9670;&#160;</a></span>strictify_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::strictify_float </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate strict_float intrinisics such that they immediately wrap all floating-point expressions. </p>
<p>This makes the IR nodes context independent. If the <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6e99d2e5d2365e4b2cf9fb7dbe1671c4">Target::StrictFloat</a> flag is specified in target, starts in strict_float mode so all floating-point type Exprs in the compilation will be marked with strict_float. Returns whether any strict floating-point is used in any function in the passed in env. </p>

</div>
</div>
<a id="a984524908e4478131a952e4a9230f0cb" name="a984524908e4478131a952e4a9230f0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984524908e4478131a952e4a9230f0cb">&#9670;&#160;</a></span>strip_asserts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::strip_asserts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab77fafc3670bd07362c388820dd10c11" name="ab77fafc3670bd07362c388820dd10c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77fafc3670bd07362c388820dd10c11">&#9670;&#160;</a></span>substitute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

</div>
</div>
<a id="a953484f8812539e108a6c4e137ebfc62" name="a953484f8812539e108a6c4e137ebfc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953484f8812539e108a6c4e137ebfc62">&#9670;&#160;</a></span>substitute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a id="a92d044309ede4782cabce475570934a8" name="a92d044309ede4782cabce475570934a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d044309ede4782cabce475570934a8">&#9670;&#160;</a></span>substitute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a id="a14ebb6536c3233e6466073757f0e59e7" name="a14ebb6536c3233e6466073757f0e59e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ebb6536c3233e6466073757f0e59e7">&#9670;&#160;</a></span>substitute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07967ab74e22a0103d6af67ec62cc3b7" name="a07967ab74e22a0103d6af67ec62cc3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07967ab74e22a0103d6af67ec62cc3b7">&#9670;&#160;</a></span>substitute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>find</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a id="ae1b12ab6ef3f59e897315145d1e996e2" name="ae1b12ab6ef3f59e897315145d1e996e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b12ab6ef3f59e897315145d1e996e2">&#9670;&#160;</a></span>substitute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>find</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a457e67268c787fe55a7bc5e3559f43cc" name="a457e67268c787fe55a7bc5e3559f43cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457e67268c787fe55a7bc5e3559f43cc">&#9670;&#160;</a></span>graph_substitute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a id="a95627cc6470e3f8975ab3b1fa2048e3e" name="a95627cc6470e3f8975ab3b1fa2048e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95627cc6470e3f8975ab3b1fa2048e3e">&#9670;&#160;</a></span>graph_substitute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8219abd8f63bb237e29a7b878a445836" name="a8219abd8f63bb237e29a7b878a445836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8219abd8f63bb237e29a7b878a445836">&#9670;&#160;</a></span>graph_substitute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>find</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d8e9db71fa11a9eb45590a8fd5ff774" name="a1d8e9db71fa11a9eb45590a8fd5ff774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8e9db71fa11a9eb45590a8fd5ff774">&#9670;&#160;</a></span>graph_substitute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>find</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaafce6d574b476cf9c9acd5f622450ab" name="aaafce6d574b476cf9c9acd5f622450ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafce6d574b476cf9c9acd5f622450ab">&#9670;&#160;</a></span>substitute_in_all_lets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute in all let Exprs in a piece of IR. </p>
<p>Doesn't substitute in let stmts, as this may change the meaning of the IR (e.g. by moving a load after a store). Produces graphs of IR, so don't use non-graph-aware visitors or mutators on it until you've CSE'd the result. </p>

</div>
</div>
<a id="a6a57aa0cf600e63ac832ea799f354acc" name="a6a57aa0cf600e63ac832ea799f354acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a57aa0cf600e63ac832ea799f354acc">&#9670;&#160;</a></span>substitute_in_all_lets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stmt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0ca85eaf8baf3957bda33b83b20c694" name="ae0ca85eaf8baf3957bda33b83b20c694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ca85eaf8baf3957bda33b83b20c694">&#9670;&#160;</a></span>target_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::target_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a245b1ad737987567e573697e339729b2" name="a245b1ad737987567e573697e339729b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245b1ad737987567e573697e339729b2">&#9670;&#160;</a></span>lower_target_query_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::lower_target_query_ops </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a402f1bcce3709f5f726b4a791d555a99" name="a402f1bcce3709f5f726b4a791d555a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402f1bcce3709f5f726b4a791d555a99">&#9670;&#160;</a></span>inject_tracing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_tracing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trace_pipeline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a id="aae7fd6fdb5eb7b96d5dcf4a9d52985f7" name="aae7fd6fdb5eb7b96d5dcf4a9d52985f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">&#9670;&#160;</a></span>trim_no_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::trim_no_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate loop bounds to the region over which they actually do something. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> examples see test/correctness/trim_no_ops.cpp </p>

</div>
</div>
<a id="a8803d2593422e45d64b2d15429cfde0d" name="a8803d2593422e45d64b2d15429cfde0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8803d2593422e45d64b2d15429cfde0d">&#9670;&#160;</a></span>unify_duplicate_lets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unify_duplicate_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones. </p>

</div>
</div>
<a id="a400b238529ddcab092d8bfa88ad33880" name="a400b238529ddcab092d8bfa88ad33880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400b238529ddcab092d8bfa88ad33880">&#9670;&#160;</a></span>uniquify_variable_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::uniquify_variable_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a id="a60ff22da036ee4307f0963aadc7fa9fe" name="a60ff22da036ee4307f0963aadc7fa9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ff22da036ee4307f0963aadc7fa9fe">&#9670;&#160;</a></span>uniquify_variable_names_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::uniquify_variable_names_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49ffc3710f4a568f3e626e253bc758c2" name="a49ffc3710f4a568f3e626e253bc758c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ffc3710f4a568f3e626e253bc758c2">&#9670;&#160;</a></span>unpack_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unpack_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates let stmts for the various buffer components (e.g. </p>
<p>foo.extent.0) in any referenced concrete buffers or buffer parameters. After this pass, the only undefined symbols should scalar parameters and the buffers themselves (e.g. foo.buffer). </p>

</div>
</div>
<a id="ada0f57de73c898a70875fff4fad5cbf3" name="ada0f57de73c898a70875fff4fad5cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f57de73c898a70875fff4fad5cbf3">&#9670;&#160;</a></span>unroll_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unroll_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a id="a0b7ac6d7399bf2ba00640fe7aa794f7f" name="a0b7ac6d7399bf2ba00640fe7aa794f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7ac6d7399bf2ba00640fe7aa794f7f">&#9670;&#160;</a></span>lower_unsafe_promises()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_unsafe_promises </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower all unsafe promises into either assertions or unchecked code, depending on the target. </p>

</div>
</div>
<a id="aa0d28d6c47ed91864a2f92e8b2868128" name="aa0d28d6c47ed91864a2f92e8b2868128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d28d6c47ed91864a2f92e8b2868128">&#9670;&#160;</a></span>lower_safe_promises()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_safe_promises </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower all safe promises by just stripping them. </p>
<p>This is a good idea once no more lowering stages are going to use boxes_touched. </p>

</div>
</div>
<a id="ab7501900efa7660edf445ed1b14c020c" name="ab7501900efa7660edf445ed1b14c020c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7501900efa7660edf445ed1b14c020c">&#9670;&#160;</a></span>safe_numeric_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DST Halide::Internal::safe_numeric_cast </td>
          <td>(</td>
          <td class="paramtype">SRC</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00099">99</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a94816d6979fdadb6e206a5d0a668e008" name="a94816d6979fdadb6e206a5d0a668e008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94816d6979fdadb6e206a5d0a668e008">&#9670;&#160;</a></span>reinterpret_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType Halide::Internal::reinterpret_bits </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00135">135</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="runtime__internal_8h.html#a8dd199a21f8bb436dd739413fb3b9ff3">memcpy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02710">Halide::Internal::IRMatcher::fuzz_test_rule()</a>.</p>

</div>
</div>
<a id="a8c7c63ee87658cd904e2f4a0ba78b78b" name="a8c7c63ee87658cd904e2f4a0ba78b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7c63ee87658cd904e2f4a0ba78b78b">&#9670;&#160;</a></span>get_env_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_env_variable </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>env_var_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of an environment variable. </p>
<p>Returns its value is defined in the environment. If the var is not defined, an empty string is returned. </p>

</div>
</div>
<a id="ab4b793745b048fa1fd344907ec4ec9aa" name="ab4b793745b048fa1fd344907ec4ec9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b793745b048fa1fd344907ec4ec9aa">&#9670;&#160;</a></span>running_program_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::running_program_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the currently running executable. </p>
<p>Platform-specific. If program name cannot be retrieved, function returns an empty string. </p>

</div>
</div>
<a id="aabd490221160a7206bb151d6eae65624" name="aabd490221160a7206bb151d6eae65624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd490221160a7206bb151d6eae65624">&#9670;&#160;</a></span>unique_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given prefix. </p>
<p>It's unique relative to all other strings returned by unique_name in this process.</p>
<p>The single-character version always appends a numeric suffix to the character.</p>
<p>The string version will either return the input as-is (with high probability on the first time it is called with that input), or replace any existing '$' characters with underscores, then add a '$' sign and a numeric suffix to it.</p>
<p>Note that unique_name('f') therefore differs from unique_name("f"). The former returns something like f123, and the latter returns either f or f$123. </p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00195">Halide::Buffer&lt; T, Dims &gt;::Buffer()</a>.</p>

</div>
</div>
<a id="a7ec0bd73d997ddc50f3523a21448471f" name="a7ec0bd73d997ddc50f3523a21448471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec0bd73d997ddc50f3523a21448471f">&#9670;&#160;</a></span>unique_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af26ca52c958b993ebd766f4b83de2cf9" name="af26ca52c958b993ebd766f4b83de2cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26ca52c958b993ebd766f4b83de2cf9">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string starts with the second string. </p>

</div>
</div>
<a id="a290fb244405de2c014ebdc3cd1fc8f08" name="a290fb244405de2c014ebdc3cd1fc8f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290fb244405de2c014ebdc3cd1fc8f08">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string ends with the second string. </p>

</div>
</div>
<a id="a9c06bf852ad18eb3e9014495f5816c1f" name="a9c06bf852ad18eb3e9014495f5816c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c06bf852ad18eb3e9014495f5816c1f">&#9670;&#160;</a></span>replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>find</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>replace</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches of the second string in the first string with the last string. </p>

</div>
</div>
<a id="aa393afcc0cc51743eee04899674d90c0" name="aa393afcc0cc51743eee04899674d90c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa393afcc0cc51743eee04899674d90c0">&#9670;&#160;</a></span>split_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Halide::Internal::split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider. </p>

</div>
</div>
<a id="a4c90bc6b6e38d6f8cc725a3b54b66183" name="a4c90bc6b6e38d6f8cc725a3b54b66183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c90bc6b6e38d6f8cc725a3b54b66183">&#9670;&#160;</a></span>join_strings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::join_strings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sources</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join the source vector using 'delim' as the divider. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00187">187</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="aaaee1bb2b0dc659851899df7c12437ba" name="aaaee1bb2b0dc659851899df7c12437ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaee1bb2b0dc659851899df7c12437ba">&#9670;&#160;</a></span>fold_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_left </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a left fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. Similar to std::accumulate but with a less clunky syntax. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00212">212</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="afedfcf82469516f0f05eb5a4699f480a" name="afedfcf82469516f0f05eb5a4699f480a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedfcf82469516f0f05eb5a4699f480a">&#9670;&#160;</a></span>fold_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_right </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a right fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00227">227</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a93192a2ea0afe58664e69232595ae08e" name="a93192a2ea0afe58664e69232595ae08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93192a2ea0afe58664e69232595ae08e">&#9670;&#160;</a></span>extract_namespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::extract_namespaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>namespaces</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns base name and fills in namespaces, outermost one first in vector. </p>

<p class="reference">Referenced by <a class="el" href="_type_8h_source.html#l00200">halide_handle_cplusplus_type::make()</a>.</p>

</div>
</div>
<a id="afbf75f489ee0a40366b6374ff9113260" name="afbf75f489ee0a40366b6374ff9113260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf75f489ee0a40366b6374ff9113260">&#9670;&#160;</a></span>strip_namespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::strip_namespaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="#a93192a2ea0afe58664e69232595ae08e" title="Returns base name and fills in namespaces, outermost one first in vector.">extract_namespaces()</a>, but strip and discard the namespaces, returning base name only. </p>

</div>
</div>
<a id="a4f8aad349dd3bfc69483b792fcab0f96" name="a4f8aad349dd3bfc69483b792fcab0f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8aad349dd3bfc69483b792fcab0f96">&#9670;&#160;</a></span>file_make_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::file_make_temp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed. </p>
<p>(Note that the exact form of the file name may vary; in particular, the suffix may be ignored on Windows.) The file is created (but not opened), thus this can be called from different threads (or processes, e.g. when building with parallel make) without risking collision. Note that if this file is used as a temporary file, the caller is responsibly for deleting it. Neither the prefix nor suffix may contain a directory separator. </p>

</div>
</div>
<a id="abaf8a5ee39d2b222d8a0be57894a2f75" name="abaf8a5ee39d2b222d8a0be57894a2f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf8a5ee39d2b222d8a0be57894a2f75">&#9670;&#160;</a></span>dir_make_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::dir_make_temp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed. </p>
<p>The directory will be empty (i.e., this will never return /tmp itself, but rather a new directory inside /tmp). The caller is responsible for removing the directory after use. </p>

</div>
</div>
<a id="aff2a323363444e3d16237848f6f8715b" name="aff2a323363444e3d16237848f6f8715b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2a323363444e3d16237848f6f8715b">&#9670;&#160;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for access(). </p>
<p>Quietly ignores errors. </p>

</div>
</div>
<a id="a034796c3683c3301a09c0102c6adb8b0" name="a034796c3683c3301a09c0102c6adb8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034796c3683c3301a09c0102c6adb8b0">&#9670;&#160;</a></span>assert_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assert_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assert-fail if the file doesn't exist. </p>
<p>useful primarily for testing purposes. </p>

</div>
</div>
<a id="ab8356033bf440e2f990bdc9f27cdcdcf" name="ab8356033bf440e2f990bdc9f27cdcdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8356033bf440e2f990bdc9f27cdcdcf">&#9670;&#160;</a></span>assert_no_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assert_no_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assert-fail if the file DOES exist. </p>
<p>useful primarily for testing purposes. </p>

</div>
</div>
<a id="a05dd8ec86534a0e22d1ab4f2037bc562" name="a05dd8ec86534a0e22d1ab4f2037bc562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd8ec86534a0e22d1ab4f2037bc562">&#9670;&#160;</a></span>file_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::file_unlink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for unlink(). </p>
<p>Asserts upon error.</p>
<p>Quietly ignores errors. </p>

<p class="reference">Referenced by <a class="el" href="_util_8h_source.html#l00340">Halide::Internal::TemporaryFile::~TemporaryFile()</a>.</p>

</div>
</div>
<a id="a947c611b7403f5613f08fb701ea6eed6" name="a947c611b7403f5613f08fb701ea6eed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c611b7403f5613f08fb701ea6eed6">&#9670;&#160;</a></span>ensure_no_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::ensure_no_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that no file with this path exists. </p>
<p>If such a file exists and cannot be removed, assert-fail. </p>

</div>
</div>
<a id="a710588d377ce398aa366fc00f6d436aa" name="a710588d377ce398aa366fc00f6d436aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710588d377ce398aa366fc00f6d436aa">&#9670;&#160;</a></span>dir_rmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::dir_rmdir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for rmdir(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a id="aa0f41b4199ab2236fb4056661f20cc11" name="aa0f41b4199ab2236fb4056661f20cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f41b4199ab2236fb4056661f20cc11">&#9670;&#160;</a></span>file_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a> Halide::Internal::file_stat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for stat(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a id="a4b13a717252cb9bda0e37b585d5f65ef" name="a4b13a717252cb9bda0e37b585d5f65ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b13a717252cb9bda0e37b585d5f65ef">&#9670;&#160;</a></span>read_entire_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; char &gt; Halide::Internal::read_entire_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pathname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entire contents of a file into a vector&lt;char&gt;. </p>
<p>The file is read in binary mode. Errors trigger an assertion failure. </p>

</div>
</div>
<a id="a4a0a74e2116e6583961430bb9f96dc64" name="a4a0a74e2116e6583961430bb9f96dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0a74e2116e6583961430bb9f96dc64">&#9670;&#160;</a></span>write_entire_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::write_entire_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pathname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a></td>          <td class="paramname"><span class="paramname"><em>source_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create or replace the contents of a file with a given pointer-and-length of memory. </p>
<p>If the file doesn't exist, it is created; if it does exist, it is completely overwritten. Any error triggers an assertion failure. </p>

<p class="reference">Referenced by <a class="el" href="_util_8h_source.html#l00322">write_entire_file()</a>.</p>

</div>
</div>
<a id="a687a41c09f705e2859eea67df0e04501" name="a687a41c09f705e2859eea67df0e04501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687a41c09f705e2859eea67df0e04501">&#9670;&#160;</a></span>write_entire_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::write_entire_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pathname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00322">322</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="#a4a0a74e2116e6583961430bb9f96dc64">write_entire_file()</a>.</p>

</div>
</div>
<a id="a8cc678d669d07fdd15685b87e3b8b620" name="a8cc678d669d07fdd15685b87e3b8b620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc678d669d07fdd15685b87e3b8b620">&#9670;&#160;</a></span>add_would_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::add_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00919">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;()</a>.</p>

</div>
</div>
<a id="a82c64641e261b5596a2ab6d7da7f8ef8" name="a82c64641e261b5596a2ab6d7da7f8ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c64641e261b5596a2ab6d7da7f8ef8">&#9670;&#160;</a></span>sub_would_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::sub_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00952">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;()</a>.</p>

</div>
</div>
<a id="a9aaa735c9ff93372dce25222fb551b67" name="a9aaa735c9ff93372dce25222fb551b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaa735c9ff93372dce25222fb551b67">&#9670;&#160;</a></span>mul_would_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::mul_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00985">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;()</a>.</p>

</div>
</div>
<a id="a7ddf0741f1360ab02ae2c5871a50e5c9" name="a7ddf0741f1360ab02ae2c5871a50e5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddf0741f1360ab02ae2c5871a50e5c9">&#9670;&#160;</a></span>add_with_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool Halide::Internal::add_with_overflow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to perform arithmetic on signed types without triggering signed overflow. </p>
<p>If overflow would occur, sets result to zero, and returns false. Otherwise set result to the correct value, and returns true. </p>

<p class="reference">Referenced by <a class="el" href="_simplify___internal_8h_source.html#l00045">Halide::Internal::Simplify::ExprInfo::trim_bounds_using_alignment()</a>.</p>

</div>
</div>
<a id="adc6eced9ecc08886e52cb8df1aee61b2" name="adc6eced9ecc08886e52cb8df1aee61b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6eced9ecc08886e52cb8df1aee61b2">&#9670;&#160;</a></span>sub_with_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool Halide::Internal::sub_with_overflow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_simplify___internal_8h_source.html#l00045">Halide::Internal::Simplify::ExprInfo::trim_bounds_using_alignment()</a>.</p>

</div>
</div>
<a id="a94090aac2902ca0d3861c9eb80d39a47" name="a94090aac2902ca0d3861c9eb80d39a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94090aac2902ca0d3861c9eb80d39a47">&#9670;&#160;</a></span>mul_with_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool Halide::Internal::mul_with_overflow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae342a753f8441a0b29418b0d22cbda86" name="ae342a753f8441a0b29418b0d22cbda86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae342a753f8441a0b29418b0d22cbda86">&#9670;&#160;</a></span>halide_tic_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::halide_tic_impl </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c23694d45bd4c42ec1dc97a17bb78f6" name="a7c23694d45bd4c42ec1dc97a17bb78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c23694d45bd4c42ec1dc97a17bb78f6">&#9670;&#160;</a></span>halide_toc_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::halide_toc_impl </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b578ca36f6632806a5f37bc631f801c" name="a2b578ca36f6632806a5f37bc631f801c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b578ca36f6632806a5f37bc631f801c">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00467">467</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00463">Halide::Internal::reverse_adaptor&lt; T &gt;::range</a>.</p>

<p class="reference">Referenced by <a class="el" href="_elf_8h_source.html#l00332">Halide::Internal::Elf::Section::append_contents()</a>, <a class="el" href="_elf_8h_source.html#l00337">Halide::Internal::Elf::Section::prepend_contents()</a>, <a class="el" href="_elf_8h_source.html#l00327">Halide::Internal::Elf::Section::set_contents()</a>, and <a class="el" href="_elf_8h_source.html#l00395">Halide::Internal::Elf::Section::set_relocations()</a>.</p>

</div>
</div>
<a id="ae1d9c9be1aaf01be6d77cd6f83a0f591" name="ae1d9c9be1aaf01be6d77cd6f83a0f591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d9c9be1aaf01be6d77cd6f83a0f591">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00472">472</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00463">Halide::Internal::reverse_adaptor&lt; T &gt;::range</a>.</p>

<p class="reference">Referenced by <a class="el" href="_elf_8h_source.html#l00332">Halide::Internal::Elf::Section::append_contents()</a>, <a class="el" href="_elf_8h_source.html#l00337">Halide::Internal::Elf::Section::prepend_contents()</a>, <a class="el" href="_elf_8h_source.html#l00327">Halide::Internal::Elf::Section::set_contents()</a>, and <a class="el" href="_elf_8h_source.html#l00395">Halide::Internal::Elf::Section::set_relocations()</a>.</p>

</div>
</div>
<a id="ab1c98c7054db881ad405869df25669c9" name="ab1c98c7054db881ad405869df25669c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c98c7054db881ad405869df25669c9">&#9670;&#160;</a></span>reverse_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt; Halide::Internal::reverse_view </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse-order adaptor for range-based for-loops. </p>
<p>TODO: Replace with std::ranges::reverse_view when upgrading to C++20. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00481">481</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a7465fda53b7318463f0f45f6511dc075" name="a7465fda53b7318463f0f45f6511dc075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7465fda53b7318463f0f45f6511dc075">&#9670;&#160;</a></span>c_print_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::c_print_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prefix_underscore</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a version of a string that is a valid identifier in C (. </p>
<p>is replaced with _) If prefix_underscore is true (the default), an underscore will be prepended if the input starts with an alphabetic character to avoid reserved word clashes. </p>

</div>
</div>
<a id="a591746c6ae0cd3e8d24c2c2420772d8a" name="a591746c6ae0cd3e8d24c2c2420772d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591746c6ae0cd3e8d24c2c2420772d8a">&#9670;&#160;</a></span>get_llvm_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::get_llvm_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVM_VERSION against which this libHalide is compiled. </p>
<p>This is provided only for internal tests which need to verify behavior; please don't use this outside of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> tests. </p>

</div>
</div>
<a id="a45fe57f2ce9ba5592659449fccd5c1c6" name="a45fe57f2ce9ba5592659449fccd5c1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fe57f2ce9ba5592659449fccd5c1c6">&#9670;&#160;</a></span>run_with_large_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::run_with_large_stack </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> the given action in a platform-specific context that provides at least the stack space returned by get_compiler_stack_size. </p>
<p>If that value is zero, just calls the function on the calling thread. Otherwise on Windows this uses a Fiber, and on other platforms it uses swapcontext. </p>

</div>
</div>
<a id="ac117f9e0b3bbb544807e9ddb1f6c49d9" name="ac117f9e0b3bbb544807e9ddb1f6c49d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac117f9e0b3bbb544807e9ddb1f6c49d9">&#9670;&#160;</a></span>popcount64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::popcount64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable versions of popcount, count-leading-zeros, and count-trailing-zeros. </p>

</div>
</div>
<a id="a77c27f5abba4dce3848962690f15c0ac" name="a77c27f5abba4dce3848962690f15c0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c27f5abba4dce3848962690f15c0ac">&#9670;&#160;</a></span>clz64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::clz64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04b0b4593680c5fcfc77b72f709a69cb" name="a04b0b4593680c5fcfc77b72f709a69cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b0b4593680c5fcfc77b72f709a69cb">&#9670;&#160;</a></span>ctz64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::ctz64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbca40dc6f536bd853f878af922df261" name="acbca40dc6f536bd853f878af922df261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbca40dc6f536bd853f878af922df261">&#9670;&#160;</a></span>next_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::next_power_of_two </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an integer 2^n, for some n, which is &gt;= x. </p>
<p><a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> x must be &gt; 0. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00556">556</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a043f5eea16013aba7cc1c195fa251dd7" name="a043f5eea16013aba7cc1c195fa251dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043f5eea16013aba7cc1c195fa251dd7">&#9670;&#160;</a></span>align_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::align_up </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00561">561</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a2e581c9e4b9559106c4f2b5b89b1f7c6" name="a2e581c9e4b9559106c4f2b5b89b1f7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e581c9e4b9559106c4f2b5b89b1f7c6">&#9670;&#160;</a></span>make_argument_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; Halide::Internal::make_argument_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimensionality</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a list of unique arguments for definitions with unnamed arguments. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01164">Halide::Func::define_extern()</a>, <a class="el" href="_func_8h_source.html#l01172">Halide::Func::define_extern()</a>, and <a class="el" href="_func_8h_source.html#l01154">Halide::Func::define_extern()</a>.</p>

</div>
</div>
<a id="a44132e8c163a34a201c29a8e525038a4" name="a44132e8c163a34a201c29a8e525038a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44132e8c163a34a201c29a8e525038a4">&#9670;&#160;</a></span>vectorize_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::vectorize_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
<a id="ae687a3d73d31063267f01aeac9a46884" name="ae687a3d73d31063267f01aeac9a46884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae687a3d73d31063267f01aeac9a46884">&#9670;&#160;</a></span>wrap_func_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; Halide::Internal::wrap_func_calls </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions. </p>

</div>
</div>
<a id="abb9d57ef08d50b32cd0f947c699a7508" name="abb9d57ef08d50b32cd0f947c699a7508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9d57ef08d50b32cd0f947c699a7508">&#9670;&#160;</a></span>get_test_tmp_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_test_tmp_dir </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the path to a directory that can be safely written to when running tests; the contents directory may or may not outlast the lifetime of test itself (ie, the files may be cleaned up after test execution). </p>
<p>The path is guaranteed to be an absolute path and end in a directory separator, so a leaf filename can simply be appended. It is not guaranteed that this directory will be empty. If the path cannot be created, the function will assert-fail and return an invalid path. </p>

<p class="definition">Definition at line <a class="el" href="halide__test__dirs_8h_source.html#l00076">76</a> of file <a class="el" href="halide__test__dirs_8h_source.html">halide_test_dirs.h</a>.</p>

<p class="reference">References <a class="el" href="halide__test__dirs_8h_source.html#l00046">Halide::Internal::Test::get_current_directory()</a>, and <a class="el" href="halide__test__dirs_8h_source.html#l00027">Halide::Internal::Test::get_env_variable()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac4e8d52841afa71f1f7bac7ce9611159" name="ac4e8d52841afa71f1f7bac7ce9611159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e8d52841afa71f1f7bac7ce9611159">&#9670;&#160;</a></span>unknown</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::unknown = std::numeric_limits&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt;<a class="el" href="#a41d5010a34ae900ef4f855ee5420a923">::min</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00022">22</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

</div>
</div>
<a id="a4bf1a96be9fadff5521559de5f72935c" name="a4bf1a96be9fadff5521559de5f72935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf1a96be9fadff5521559de5f72935c">&#9670;&#160;</a></span>StrongestExprNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> Halide::Internal::StrongestExprNodeType = <a class="el" href="#aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5">IRNodeType::VectorReduce</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00081">81</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="acf4a67af6498244e055c3e0ec8f69990" name="acf4a67af6498244e055c3e0ec8f69990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a67af6498244e055c3e0ec8f69990">&#9670;&#160;</a></span>random_variable_counter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;int&gt; Halide::Internal::random_variable_counter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
