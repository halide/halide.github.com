<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: Halide::Internal Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespace_halide_1_1_internal.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen.html">CodeGen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html">CodeGen_ARM</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits ARM code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html">CodeGen_GPU_Host</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_c_l___dev.html">CodeGen_OpenCL_Dev</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html">CodeGen_PTX_Dev</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___x86.html">CodeGen_X86</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits x86 code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___x86.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> optional debugging during codegen, use the debug class as follows:  <a href="struct_halide_1_1_internal_1_1debug.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_contents.html">FunctionContents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself...">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node_type.html">IRNodeType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a type of IR node (e.g.  <a href="struct_halide_1_1_internal_1_1_i_r_node_type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a> a node from one type to another.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> a value from a named buffer.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'width' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then bail out printing the 'message' to stderr.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_pipeline.html">Pipeline</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_pipeline.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a> a 'value' to the buffer called 'name' at a given 'index'.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer.">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-dimensional span.  <a href="struct_halide_1_1_internal_1_1_range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_deep_compare.html">ExprDeepCompare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that uses the ordering defined by deep_compare.  <a href="struct_halide_1_1_internal_1_1_expr_deep_compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_deep_compare.html">StmtDeepCompare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that uses the ordering defined by deep_compare.  <a href="struct_halide_1_1_internal_1_1_stmt_deep_compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html">JITCompiledModule</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> pointers into a compiled halide module.  <a href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_parameter_contents.html">ParameterContents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a parameter to a halide pipeline.  <a href="class_halide_1_1_internal_1_1_parameter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_domain_contents.html">ReductionDomainContents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain.">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_schedule.html">Schedule</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a halide function, which defines where, when, and how it should be evaluated.  <a href="struct_halide_1_1_internal_1_1_schedule.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_array.html">SmallArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stmt_compiler.html">StmtCompiler</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional box.  <a href="#abd1b9521b6f1f513178f281d8f395335"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a> { <a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335">Constant</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637">MonotonicIncreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3">MonotonicDecreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf">Unknown</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown.  <a href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a973e652b8c042a8a92e4bc97a280d22a">bounds_of_expr_in_scope</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <a href="#a973e652b8c042a8a92e4bc97a280d22a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40b55308c8b42bac49b691c9276a10f0">regions_called</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement.  <a href="#a40b55308c8b42bac49b691c9276a10f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a498694c483a2f521859553cfcfea4b1e">regions_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>'s to each function that occur within a given statement.  <a href="#a498694c483a2f521859553cfcfea4b1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abcb5c51d9e0d95c7e6f1ff9f2c82c39b">regions_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all Calls and Provides to each function that occurs within a given statement.  <a href="#abcb5c51d9e0d95c7e6f1ff9f2c82c39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a614969a57432098981fa3a1f49e9c4fb">region_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rectangular domain large enough to cover all Calls and Provides to a given function.  <a href="#a614969a57432098981fa3a1f49e9c4fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f219ebf3c591ed06938016d6d4a1488">region_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rectangular domain large enough to cover all Provides to a given function.  <a href="#a0f219ebf3c591ed06938016d6d4a1488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a53385b9156a5a1dd0990fc181fef8edd">region_called</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rectangular domain large enough to cover all Calls to a given function.  <a href="#a53385b9156a5a1dd0990fc181fef8edd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae99f8f7aa2b3734a88dd0e0ebb24459d">region_union</a> (const <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> &amp;, const <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest bounding box that contains two regions.  <a href="#ae99f8f7aa2b3734a88dd0e0ebb24459d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">bounds_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4a2800ce2145f769127b19a5d03d5d05">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; std::string &gt; &amp;realization_order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <a href="#a4a2800ce2145f769127b19a5d03d5d05"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01f39487c6fb408b97f403201cd74701">ref_count&lt; BufferContents &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a> *p)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab5f5f155c9dd7f1464c5ef665d100029">destroy&lt; BufferContents &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">llvm_type_of</a> (llvm::LLVMContext *context, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <a href="#a71f10140e29131153c3be98d2899b090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8e29c6b91cae0cfa7734ff1e13e82ca4">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <a href="#a8e29c6b91cae0cfa7734ff1e13e82ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a86003b87f257d83c080b54bcc6dce216">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <a href="#a86003b87f257d83c080b54bcc6dce216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0694c89a8349199080a71443202acd43">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string output, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered.  <a href="#a0694c89a8349199080a71443202acd43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa9b678f3916b022dd8b8415c9ca0750">extract_odd_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <a href="#aaa9b678f3916b022dd8b8415c9ca0750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a017315ab942e526e9915325f05d406a0">extract_even_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <a href="#a017315ab942e526e9915325f05d406a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a750c306ff019e4f332238799979c9345">extract_lane</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a>, int lane)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <a href="#a750c306ff019e4f332238799979c9345"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">rewrite_interleavings</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <a href="#ac1233a717a83d74121106b95245ce81a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8dc1b0ff156c8b0ca5fd26956ee482a9">deinterleave_vector_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a534a3b8f52a0441dbb0fb7ab2aed3341">finite_difference</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const std::string &amp;var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the analytic derivative of the expression with respect to the variable.  <a href="#a534a3b8f52a0441dbb0fb7ab2aed3341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7ad39c95e126e3cdfe7ce5a72fa5f51">is_monotonic</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;var)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">inject_early_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <a href="#a5aedffca433bdfab639e4956779040e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc591095a8e56d4d6f6587c66239fdb3">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e3867f02d52edd32b4cfe38e5ee55a1">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af22936be5f74cc50d73a4e478bd9271e">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="#af22936be5f74cc50d73a4e478bd9271e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">expr_match_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="#ab370d99a882a8163ae91d43b94d79d02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b709fdbc5a6944248187216b5df5b2e">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="#a4b709fdbc5a6944248187216b5df5b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">as_const_int</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value.  <a href="#a68b76ccfb1d4e7cc35ff65f15f9b0077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">as_const_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value.  <a href="#af2a9edb743eaf6d8074867314247a970"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2399da4e027488064c4d14a2469f9fc3">is_const_power_of_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int *bits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#a2399da4e027488064c4d14a2469f9fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">is_positive_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#ad050aaa17987fa4cbb8fd4d41c952e04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">is_negative_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#acc39652dfc1d64fb82d02dc4064185d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">is_zero</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#a1a521ef987e7964954b997e6dcc5e65b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">is_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a940b37091a8f16bf1e4a78db7764274e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">is_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#abeed2f66190d11ee6e56e4089a1f441b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a225fbecd4560e77ea24cb16541fe6b15">int_cast_constant</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, int val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integer value, cast it into a designated integer type and return the bits as int.  <a href="#a225fbecd4560e77ea24cb16541fe6b15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab48739c460778f7af77999cfd251d5af">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, int val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const of the given type.  <a href="#ab48739c460778f7af77999cfd251d5af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e258c84149c36aad7d93cced54cd173">make_bool</a> (bool val, int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#a1e258c84149c36aad7d93cced54cd173"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a57fedf535d58f8900f8b7c00aa15ece8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#ace305dbdd7fed2cf9d5057d4c02067c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#afc35f0dc3562ffb5bb777021679435e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f8e27a136a9facf0e97e6ac6bd71c23">const_true</a> (int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a0f8e27a136a9facf0e97e6ac6bd71c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6c5d4e90106e92aa21840547b6588eb3">const_false</a> (int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#a6c5d4e90106e92aa21840547b6588eb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#ab40a26aac941b763435e9915851cd073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#ac5890bd4a8aae2f1f6a2c43496d8ddae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abe0706bb3eb3383817dc1ae7ce204ad0">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <a href="#abe0706bb3eb3383817dc1ae7ce204ad0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa67dad74ce8739ca7773f6032e51d5c6">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_for.html#a58f191c4b166630d13829e4f1840d5c6">For::ForType</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <a href="#aa67dad74ce8739ca7773f6032e51d5c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2c00a579c3d86ae40920d5fc4ffe64cf">lower_lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html">Halide</a> IR that computes a lerp.  <a href="#a2c00a579c3d86ae40920d5fc4ffe64cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0cf146bb38588a04ea0c9491c56c4e11">lower</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <a href="#a0cf146bb38588a04ea0c9491c56c4e11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a552b2c330fdb1275badc27cc1e92cd6a">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <a href="#a552b2c330fdb1275badc27cc1e92cd6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489fb5b4449835f26313a57e856c4b3">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <a href="#a8489fb5b4449835f26313a57e856c4b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af210d0f6ae102d704259f49bb32adc2f">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#af210d0f6ae102d704259f49bb32adc2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">modulus_remainder_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a50891465f948d4f9b30b9253ce1640b1">gcd</a> (int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <a href="#a50891465f948d4f9b30b9253ce1640b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8adb5f4e1a135f0570023d7d086918e7">move_broadcasts_inside_casts</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move broadcast nodes inside of cast nodes in preparation for peephole optimizations.  <a href="#a8adb5f4e1a135f0570023d7d086918e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a36620e2156363b215b17fae00eec44ea">is_one_to_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservatively determine whether an integer expression is one-to-one in its variables.  <a href="#a36620e2156363b215b17fae00eec44ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd3b8d6aeed9a003fe228ad1aba7322f">is_one_to_one_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">inject_profiling</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, and (depending on the environment variable HL_PROFILE), insert high-resolution timing into the generated code; summaries of execution times and counts will be logged at the end.  <a href="#a568a0554db6866ee8560c3f599bceadd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae828a911751c5115cb503d05afb1dcbe">profiling_level</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current profiling level (by reading HL_PROFILE)  <a href="#ae828a911751c5115cb503d05afb1dcbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">remove_trivial_for_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes, which allows for further simplification.  <a href="#a445fa778b28abf135eb1b1d0c8389efc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2cde29d4c9c4bc41d8474be2d94d6687">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html">Halide</a>.  <a href="#a6cd3908859c82249a2c7f10158883a97"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7feea16442755d0a73ec2de1b8889106">simplify_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">sliding_window</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <a href="#a07bde9012b280aad21a569ea008ed296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a36bbe2f07f16d251525ee4beaa68c102">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> nodes respectively.  <a href="#a36bbe2f07f16d251525ee4beaa68c102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9eefd272612c586d9c3e4dba31d1c215">storage_folding</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <a href="#a9eefd272612c586d9c3e4dba31d1c215"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <a href="#a9cec67b9b23c3f0047874cc432591ae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5f3a31a571b877aeff8804b204b78ec">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <a href="#aa5f3a31a571b877aeff8804b204b78ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a320fa7575718308bc5b1e7a1b6d42d31">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <a href="#a320fa7575718308bc5b1e7a1b6d42d31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa9f98b98cbded4d63028df71771ca835">get_initial_module_for_ptx_device</a> (llvm::LLVMContext *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <a href="#aa9f98b98cbded4d63028df71771ca835"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3cd3f1d683bcca49a2df7179d42245d0">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <a href="#a3cd3f1d683bcca49a2df7179d42245d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">uniquify_variable_names</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <a href="#abf197e316b7d0a6adb96c25976612c1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">unroll_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <a href="#adc1c49e552297672b3751ac988bf70c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0aeffeff26578021bc780e1506bfa448">int_to_string</a> (int x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string.  <a href="#a0aeffeff26578021bc780e1506bfa448"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="#a94816d6979fdadb6e206a5d0a668e008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">unique_name</a> (char prefix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given character.  <a href="#acd575ab182df12cc793dba4aa241c1a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a22aa5e173f0154dbdbc9efc4c6cfb8c4">unique_name</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given string.  <a href="#a22aa5e173f0154dbdbc9efc4c6cfb8c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa7703083cfe592de68f37796533724ed">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string starts with the second string.  <a href="#aa7703083cfe592de68f37796533724ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a230079281175545b9b90b2285106ab28">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string ends with the second string.  <a href="#a230079281175545b9b90b2285106ab28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a771a564a2b084a26b0ebd88bbe1261c4">base_name</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the final token of the name string, assuming a fully qualified name delimited by '.  <a href="#a771a564a2b084a26b0ebd88bbe1261c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abe70c3a9d0ecd59908b1837a11d01de0">vectorize_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <a href="#abe70c3a9d0ecd59908b1837a11d01de0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add5bcb9d6d286355a3cb9b8f289e0985">remove_lets</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all lets from a statement or expression by substituting them in.  <a href="#add5bcb9d6d286355a3cb9b8f289e0985"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7f56ee3ea320c3c0b452722edab42470">remove_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all lets from a statement or expression by substituting them in.  <a href="#a7f56ee3ea320c3c0b452722edab42470"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">ref_count</a> (const T *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#a9ff5beef3c5a4ec908d9c2bbe99a71f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">destroy</a> (const T *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#ada37ff426984f7459fe0bbe38b9e11f0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">equal</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a31dc49947eec58e14aab236c7b0182ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d404e95dced22ae673144c0351f186f">equal</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a4d404e95dced22ae673144c0351f186f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a65590b80d11a0b92f74cf17d9fa5cf49">deep_compare</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a lexical ordering on IR nodes.  <a href="#a65590b80d11a0b92f74cf17d9fa5cf49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a19c9545816a6a6e120b5681d20bf7055">deep_compare</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a lexical ordering on IR nodes.  <a href="#a19c9545816a6a6e120b5681d20bf7055"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">halide_log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals.  <a href="#af36627bf7242718b1c73214296dc9090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">halide_exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals.  <a href="#a5688772a963296ea52d2bd9ac5913e79"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3db029a2e2b7723c118049072ff56da2">simplify</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a3db029a2e2b7723c118049072ff56da2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2f98a29cd4c461b996e81a77307c4ec9">simplify</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a2f98a29cd4c461b996e81a77307c4ec9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac546c55fe301504146a0ea9e19a4ac00">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#ac546c55fe301504146a0ea9e19a4ac00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9d3e92b9c76f56e57b4590f89d6cd073">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a9d3e92b9c76f56e57b4590f89d6cd073"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a> (T a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a1581b658edf919ea8aae58ad09b4f829"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a60049819a1e4ee7971c624c18a26210a">vec</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a60049819a1e4ee7971c624c18a26210a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57308fdf8df2d93ff56d7dc8d2f621b1">vec</a> (T a, T b, T c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a57308fdf8df2d93ff56d7dc8d2f621b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a643930ad0d00b2138183abfb01ba7083">vec</a> (T a, T b, T c, T d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a643930ad0d00b2138183abfb01ba7083"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a33cbb76cabe65d3b5fc27f6d4866ce0b">vec</a> (T a, T b, T c, T d, T e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a33cbb76cabe65d3b5fc27f6d4866ce0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac29a0bceb82c876dc7b2d9d15ea0f5b7">vec</a> (T a, T b, T c, T d, T e, T f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#ac29a0bceb82c876dc7b2d9d15ea0f5b7"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="abd1b9521b6f1f513178f281d8f395335"></a><!-- doxytag: member="Halide::Internal::Region" ref="abd1b9521b6f1f513178f281d8f395335" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Halide::Internal::Region</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A multi-dimensional box. </p>
<p>The outer product of the elements </p>

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00831">831</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3ea"></a><!-- doxytag: member="Halide::Internal::MonotonicResult" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">Halide::Internal::MonotonicResult</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<p>Returns -1, 0, or 1 for decreasing, unknown, and increasing. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335"></a><!-- doxytag: member="Constant" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335" args="" -->Constant</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637"></a><!-- doxytag: member="MonotonicIncreasing" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637" args="" -->MonotonicIncreasing</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3"></a><!-- doxytag: member="MonotonicDecreasing" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3" args="" -->MonotonicDecreasing</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf"></a><!-- doxytag: member="Unknown" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf" args="" -->Unknown</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_derivative_8h_source.html#l00041">41</a> of file <a class="el" href="_derivative_8h_source.html">Derivative.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a973e652b8c042a8a92e4bc97a280d22a"></a><!-- doxytag: member="Halide::Internal::bounds_of_expr_in_scope" ref="a973e652b8c042a8a92e4bc97a280d22a" args="(Expr expr, const Scope&lt; Interval &gt; &amp;scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> <a class="el" href="namespace_halide_1_1_internal.html#a973e652b8c042a8a92e4bc97a280d22a">Halide::Internal::bounds_of_expr_in_scope</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a> or min may be undefined expressions if the value is not bounded above or below.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a class="anchor" id="a40b55308c8b42bac49b691c9276a10f0"></a><!-- doxytag: member="Halide::Internal::regions_called" ref="a40b55308c8b42bac49b691c9276a10f0" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a40b55308c8b42bac49b691c9276a10f0">Halide::Internal::regions_called</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="a498694c483a2f521859553cfcfea4b1e"></a><!-- doxytag: member="Halide::Internal::regions_provided" ref="a498694c483a2f521859553cfcfea4b1e" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a498694c483a2f521859553cfcfea4b1e">Halide::Internal::regions_provided</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>'s to each function that occur within a given statement. </p>
<p>This is useful for figuring out what region of a function a scattering reduction (e.g. a histogram) might touch. </p>

</div>
</div>
<a class="anchor" id="abcb5c51d9e0d95c7e6f1ff9f2c82c39b"></a><!-- doxytag: member="Halide::Internal::regions_touched" ref="abcb5c51d9e0d95c7e6f1ff9f2c82c39b" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abcb5c51d9e0d95c7e6f1ff9f2c82c39b">Halide::Internal::regions_touched</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all Calls and Provides to each function that occurs within a given statement. </p>

</div>
</div>
<a class="anchor" id="a614969a57432098981fa3a1f49e9c4fb"></a><!-- doxytag: member="Halide::Internal::region_touched" ref="a614969a57432098981fa3a1f49e9c4fb" args="(Stmt s, const std::string &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> <a class="el" href="namespace_halide_1_1_internal.html#a614969a57432098981fa3a1f49e9c4fb">Halide::Internal::region_touched</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a rectangular domain large enough to cover all Calls and Provides to a given function. </p>

</div>
</div>
<a class="anchor" id="a0f219ebf3c591ed06938016d6d4a1488"></a><!-- doxytag: member="Halide::Internal::region_provided" ref="a0f219ebf3c591ed06938016d6d4a1488" args="(Stmt s, const std::string &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> <a class="el" href="namespace_halide_1_1_internal.html#a0f219ebf3c591ed06938016d6d4a1488">Halide::Internal::region_provided</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a rectangular domain large enough to cover all Provides to a given function. </p>

</div>
</div>
<a class="anchor" id="a53385b9156a5a1dd0990fc181fef8edd"></a><!-- doxytag: member="Halide::Internal::region_called" ref="a53385b9156a5a1dd0990fc181fef8edd" args="(Stmt s, const std::string &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> <a class="el" href="namespace_halide_1_1_internal.html#a53385b9156a5a1dd0990fc181fef8edd">Halide::Internal::region_called</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a rectangular domain large enough to cover all Calls to a given function. </p>

</div>
</div>
<a class="anchor" id="ae99f8f7aa2b3734a88dd0e0ebb24459d"></a><!-- doxytag: member="Halide::Internal::region_union" ref="ae99f8f7aa2b3734a88dd0e0ebb24459d" args="(const Region &amp;, const Region &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a> <a class="el" href="namespace_halide_1_1_internal.html#ae99f8f7aa2b3734a88dd0e0ebb24459d">Halide::Internal::region_union</a> </td>
          <td>(</td>
          <td class="paramtype">const Region &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Region &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the smallest bounding box that contains two regions. </p>

</div>
</div>
<a class="anchor" id="a439ef9127bf30f5e2a67963eb8db0323"></a><!-- doxytag: member="Halide::Internal::bounds_test" ref="a439ef9127bf30f5e2a67963eb8db0323" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">Halide::Internal::bounds_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4a2800ce2145f769127b19a5d03d5d05"></a><!-- doxytag: member="Halide::Internal::bounds_inference" ref="a4a2800ce2145f769127b19a5d03d5d05" args="(Stmt, const std::vector&lt; std::string &gt; &amp;realization_order, const std::map&lt; std::string, Function &gt; &amp;environment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a4a2800ce2145f769127b19a5d03d5d05">Halide::Internal::bounds_inference</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realization_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>environment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a class="anchor" id="a01f39487c6fb408b97f403201cd74701"></a><!-- doxytag: member="Halide::Internal::ref_count&lt; BufferContents &gt;" ref="a01f39487c6fb408b97f403201cd74701" args="(const BufferContents *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const BufferContents *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00294">294</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab5f5f155c9dd7f1464c5ef665d100029"></a><!-- doxytag: member="Halide::Internal::destroy&lt; BufferContents &gt;" ref="ab5f5f155c9dd7f1464c5ef665d100029" args="(const BufferContents *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const BufferContents *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00299">299</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a71f10140e29131153c3be98d2899b090"></a><!-- doxytag: member="Halide::Internal::llvm_type_of" ref="a71f10140e29131153c3be98d2899b090" args="(llvm::LLVMContext *context, Halide::Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* <a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">Halide::Internal::llvm_type_of</a> </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>

</div>
</div>
<a class="anchor" id="a8e29c6b91cae0cfa7734ff1e13e82ca4"></a><!-- doxytag: member="Halide::Internal::common_subexpression_elimination" ref="a8e29c6b91cae0cfa7734ff1e13e82ca4" args="(Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a8e29c6b91cae0cfa7734ff1e13e82ca4">Halide::Internal::common_subexpression_elimination</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> an example of a such a case, see test/code_explosion.cpp </p>

</div>
</div>
<a class="anchor" id="a86003b87f257d83c080b54bcc6dce216"></a><!-- doxytag: member="Halide::Internal::common_subexpression_elimination" ref="a86003b87f257d83c080b54bcc6dce216" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a8e29c6b91cae0cfa7734ff1e13e82ca4">Halide::Internal::common_subexpression_elimination</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a class="anchor" id="add5bcb9d6d286355a3cb9b8f289e0985"></a><!-- doxytag: member="Halide::Internal::remove_lets" ref="add5bcb9d6d286355a3cb9b8f289e0985" args="(Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#add5bcb9d6d286355a3cb9b8f289e0985">Halide::Internal::remove_lets</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all lets from a statement or expression by substituting them in. </p>
<p>All sub-expressions will exist once in memory, but may have many pointers to them, so this doesn't cause a combinatorial explosion. If you walk over this as if it were a tree, however, you're going to have a bad time. </p>

</div>
</div>
<a class="anchor" id="a7f56ee3ea320c3c0b452722edab42470"></a><!-- doxytag: member="Halide::Internal::remove_lets" ref="a7f56ee3ea320c3c0b452722edab42470" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#add5bcb9d6d286355a3cb9b8f289e0985">Halide::Internal::remove_lets</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all lets from a statement or expression by substituting them in. </p>
<p>All sub-expressions will exist once in memory, but may have many pointers to them, so this doesn't cause a combinatorial explosion. If you walk over this as if it were a tree, however, you're going to have a bad time. </p>

</div>
</div>
<a class="anchor" id="a0694c89a8349199080a71443202acd43"></a><!-- doxytag: member="Halide::Internal::debug_to_file" ref="a0694c89a8349199080a71443202acd43" args="(Stmt s, std::string output, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a0694c89a8349199080a71443202acd43">Halide::Internal::debug_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

</div>
</div>
<a class="anchor" id="aaa9b678f3916b022dd8b8415c9ca0750"></a><!-- doxytag: member="Halide::Internal::extract_odd_lanes" ref="aaa9b678f3916b022dd8b8415c9ca0750" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#aaa9b678f3916b022dd8b8415c9ca0750">Halide::Internal::extract_odd_lanes</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a017315ab942e526e9915325f05d406a0"></a><!-- doxytag: member="Halide::Internal::extract_even_lanes" ref="a017315ab942e526e9915325f05d406a0" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a017315ab942e526e9915325f05d406a0">Halide::Internal::extract_even_lanes</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a750c306ff019e4f332238799979c9345"></a><!-- doxytag: member="Halide::Internal::extract_lane" ref="a750c306ff019e4f332238799979c9345" args="(Expr vec, int lane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a750c306ff019e4f332238799979c9345">Halide::Internal::extract_lane</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a class="anchor" id="ac1233a717a83d74121106b95245ce81a"></a><!-- doxytag: member="Halide::Internal::rewrite_interleavings" ref="ac1233a717a83d74121106b95245ce81a" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">Halide::Internal::rewrite_interleavings</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a class="anchor" id="a8dc1b0ff156c8b0ca5fd26956ee482a9"></a><!-- doxytag: member="Halide::Internal::deinterleave_vector_test" ref="a8dc1b0ff156c8b0ca5fd26956ee482a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a8dc1b0ff156c8b0ca5fd26956ee482a9">Halide::Internal::deinterleave_vector_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a534a3b8f52a0441dbb0fb7ab2aed3341"></a><!-- doxytag: member="Halide::Internal::finite_difference" ref="a534a3b8f52a0441dbb0fb7ab2aed3341" args="(Expr expr, const std::string &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a534a3b8f52a0441dbb0fb7ab2aed3341">Halide::Internal::finite_difference</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the analytic derivative of the expression with respect to the variable. </p>
<p>May returned an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> if it's non-differentiable. Compute the finite difference version of the derivative: expr(var+1) - expr(var). The reason to do this as a derivative, instead of just explicitly constructing expr(var+1) - expr(var), is so that we don't have to do so much simplification later. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, the finite-difference derivative of 2*x is trivially 2, whereas 2*(x+1) - 2*x may or may not simplify down to 2, depending on the quality of our simplification routine.</p>
<p>Most rules for the finite difference and the true derivative are the same. The quotient and product rules are not. </p>

</div>
</div>
<a class="anchor" id="af7ad39c95e126e3cdfe7ce5a72fa5f51"></a><!-- doxytag: member="Halide::Internal::is_monotonic" ref="af7ad39c95e126e3cdfe7ce5a72fa5f51" args="(Expr e, const std::string &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a> <a class="el" href="namespace_halide_1_1_internal.html#af7ad39c95e126e3cdfe7ce5a72fa5f51">Halide::Internal::is_monotonic</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5aedffca433bdfab639e4956779040e6"></a><!-- doxytag: member="Halide::Internal::inject_early_frees" ref="a5aedffca433bdfab639e4956779040e6" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">Halide::Internal::inject_early_frees</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> node. </p>

</div>
</div>
<a class="anchor" id="a9ff5beef3c5a4ec908d9c2bbe99a71f9"></a><!-- doxytag: member="Halide::Internal::ref_count" ref="a9ff5beef3c5a4ec908d9c2bbe99a71f9" args="(const T *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="ada37ff426984f7459fe0bbe38b9e11f0"></a><!-- doxytag: member="Halide::Internal::destroy" ref="ada37ff426984f7459fe0bbe38b9e11f0" args="(const T *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="acc591095a8e56d4d6f6587c66239fdb3"></a><!-- doxytag: member="Halide::Internal::ref_count&lt; IRNode &gt;" ref="acc591095a8e56d4d6f6587c66239fdb3" args="(const IRNode *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00052">52</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3867f02d52edd32b4cfe38e5ee55a1"></a><!-- doxytag: member="Halide::Internal::destroy&lt; IRNode &gt;" ref="a7e3867f02d52edd32b4cfe38e5ee55a1" args="(const IRNode *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00055">55</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31dc49947eec58e14aab236c7b0182ee"></a><!-- doxytag: member="Halide::Internal::equal" ref="a31dc49947eec58e14aab236c7b0182ee" args="(Expr a, Expr b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">Halide::Internal::equal</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a> </p>

</div>
</div>
<a class="anchor" id="a4d404e95dced22ae673144c0351f186f"></a><!-- doxytag: member="Halide::Internal::equal" ref="a4d404e95dced22ae673144c0351f186f" args="(Stmt a, Stmt b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">Halide::Internal::equal</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a> </p>

</div>
</div>
<a class="anchor" id="a65590b80d11a0b92f74cf17d9fa5cf49"></a><!-- doxytag: member="Halide::Internal::deep_compare" ref="a65590b80d11a0b92f74cf17d9fa5cf49" args="(Expr a, Expr b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="namespace_halide_1_1_internal.html#a65590b80d11a0b92f74cf17d9fa5cf49">Halide::Internal::deep_compare</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a lexical ordering on IR nodes. </p>
<p>Returns -1 if the first expression is before the second, 0 if they're equal, and 1 if the first expression is after the second. </p>

<p>Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00031">Halide::Internal::ExprDeepCompare::operator()()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00039">Halide::Internal::StmtDeepCompare::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a19c9545816a6a6e120b5681d20bf7055"></a><!-- doxytag: member="Halide::Internal::deep_compare" ref="a19c9545816a6a6e120b5681d20bf7055" args="(Stmt a, Stmt b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="namespace_halide_1_1_internal.html#a65590b80d11a0b92f74cf17d9fa5cf49">Halide::Internal::deep_compare</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a lexical ordering on IR nodes. </p>
<p>Returns -1 if the first expression is before the second, 0 if they're equal, and 1 if the first expression is after the second. </p>

</div>
</div>
<a class="anchor" id="af22936be5f74cc50d73a4e478bd9271e"></a><!-- doxytag: member="Halide::Internal::expr_match" ref="af22936be5f74cc50d73a4e478bd9271e" args="(Expr pattern, Expr expr, std::vector&lt; Expr &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#af22936be5f74cc50d73a4e478bd9271e">Halide::Internal::expr_match</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: </p>
<div class="fragment"><pre class="fragment"> Expr x = <span class="keyword">new</span> Variable(<a class="code" href="namespace_halide.html#acf59f500385c448b26d0d245f55b23f4" title="Constructing a signed integer type.">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);
 match(x + x, 3 + (2*k), result) 
</pre></div><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a class="anchor" id="a1eed932bc0eb3a15edcb20795bfb8c2f"></a><!-- doxytag: member="Halide::Internal::expr_match_test" ref="a1eed932bc0eb3a15edcb20795bfb8c2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">Halide::Internal::expr_match_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab370d99a882a8163ae91d43b94d79d02"></a><!-- doxytag: member="Halide::Internal::is_const" ref="ab370d99a882a8163ae91d43b94d79d02" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00245">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00226">Halide::operator/()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00236">Halide::operator/=()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b709fdbc5a6944248187216b5df5b2e"></a><!-- doxytag: member="Halide::Internal::is_const" ref="a4b709fdbc5a6944248187216b5df5b2e" args="(Expr e, int v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>

</div>
</div>
<a class="anchor" id="a68b76ccfb1d4e7cc35ff65f15f9b0077"></a><!-- doxytag: member="Halide::Internal::as_const_int" ref="a68b76ccfb1d4e7cc35ff65f15f9b0077" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int* <a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns NULL. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00645">Halide::fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00860">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00613">Halide::pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00376">Halide::select()</a>.</p>

</div>
</div>
<a class="anchor" id="af2a9edb743eaf6d8074867314247a970"></a><!-- doxytag: member="Halide::Internal::as_const_float" ref="af2a9edb743eaf6d8074867314247a970" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float* <a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">Halide::Internal::as_const_float</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value. </p>
<p>Otherwise returns NULL. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00860">Halide::lerp()</a>.</p>

</div>
</div>
<a class="anchor" id="a2399da4e027488064c4d14a2469f9fc3"></a><!-- doxytag: member="Halide::Internal::is_const_power_of_two" ref="a2399da4e027488064c4d14a2469f9fc3" args="(Expr e, int *bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a2399da4e027488064c4d14a2469f9fc3">Halide::Internal::is_const_power_of_two</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Also returns log base two of the expression if it is. </p>

</div>
</div>
<a class="anchor" id="ad050aaa17987fa4cbb8fd4d41c952e04"></a><!-- doxytag: member="Halide::Internal::is_positive_const" ref="ad050aaa17987fa4cbb8fd4d41c952e04" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">Halide::Internal::is_positive_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="acc39652dfc1d64fb82d02dc4064185d7"></a><!-- doxytag: member="Halide::Internal::is_negative_const" ref="acc39652dfc1d64fb82d02dc4064185d7" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">Halide::Internal::is_negative_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a1a521ef987e7964954b997e6dcc5e65b"></a><!-- doxytag: member="Halide::Internal::is_zero" ref="a1a521ef987e7964954b997e6dcc5e65b" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">Halide::Internal::is_zero</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a940b37091a8f16bf1e4a78db7764274e"></a><!-- doxytag: member="Halide::Internal::is_one" ref="a940b37091a8f16bf1e4a78db7764274e" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">Halide::Internal::is_one</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="abeed2f66190d11ee6e56e4089a1f441b"></a><!-- doxytag: member="Halide::Internal::is_two" ref="abeed2f66190d11ee6e56e4089a1f441b" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">Halide::Internal::is_two</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a225fbecd4560e77ea24cb16541fe6b15"></a><!-- doxytag: member="Halide::Internal::int_cast_constant" ref="a225fbecd4560e77ea24cb16541fe6b15" args="(Type t, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="namespace_halide_1_1_internal.html#a225fbecd4560e77ea24cb16541fe6b15">Halide::Internal::int_cast_constant</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an integer value, cast it into a designated integer type and return the bits as int. </p>
<p>Unsigned types are returned as bits in the int and should be cast to unsigned int for comparison. int_cast_constant implements bit manipulations to wrap val into the value range of the <a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> t. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, int_cast_constant(UInt(16), -1) returns 65535 int_cast_constant(Int(8), 128) returns -128 </p>

</div>
</div>
<a class="anchor" id="ab48739c460778f7af77999cfd251d5af"></a><!-- doxytag: member="Halide::Internal::make_const" ref="ab48739c460778f7af77999cfd251d5af" args="(Type t, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ab48739c460778f7af77999cfd251d5af">Halide::Internal::make_const</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a const of the given type. </p>

</div>
</div>
<a class="anchor" id="a1e258c84149c36aad7d93cced54cd173"></a><!-- doxytag: member="Halide::Internal::make_bool" ref="a1e258c84149c36aad7d93cced54cd173" args="(bool val, int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a1e258c84149c36aad7d93cced54cd173">Halide::Internal::make_bool</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

</div>
</div>
<a class="anchor" id="a57fedf535d58f8900f8b7c00aa15ece8"></a><!-- doxytag: member="Halide::Internal::make_zero" ref="a57fedf535d58f8900f8b7c00aa15ece8" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">Halide::Internal::make_zero</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00193">Halide::operator-()</a>.</p>

</div>
</div>
<a class="anchor" id="ace305dbdd7fed2cf9d5057d4c02067c9"></a><!-- doxytag: member="Halide::Internal::make_one" ref="ace305dbdd7fed2cf9d5057d4c02067c9" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">Halide::Internal::make_one</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the representation of one in the given type. </p>

</div>
</div>
<a class="anchor" id="afc35f0dc3562ffb5bb777021679435e2"></a><!-- doxytag: member="Halide::Internal::make_two" ref="afc35f0dc3562ffb5bb777021679435e2" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">Halide::Internal::make_two</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the representation of two in the given type. </p>

</div>
</div>
<a class="anchor" id="a0f8e27a136a9facf0e97e6ac6bd71c23"></a><!-- doxytag: member="Halide::Internal::const_true" ref="a0f8e27a136a9facf0e97e6ac6bd71c23" args="(int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a0f8e27a136a9facf0e97e6ac6bd71c23">Halide::Internal::const_true</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a width argument is given. </p>

</div>
</div>
<a class="anchor" id="a6c5d4e90106e92aa21840547b6588eb3"></a><!-- doxytag: member="Halide::Internal::const_false" ref="a6c5d4e90106e92aa21840547b6588eb3" args="(int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a6c5d4e90106e92aa21840547b6588eb3">Halide::Internal::const_false</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a width argument is given. </p>

</div>
</div>
<a class="anchor" id="ab40a26aac941b763435e9915851cd073"></a><!-- doxytag: member="Halide::Internal::match_types" ref="ab40a26aac941b763435e9915851cd073" args="(Expr &amp;a, Expr &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types</a> </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if neither is a float but one of the two is a constant, the constant is cast to match the non-const type and we're done. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, e has type UInt(8), then (e*32) also has type UInt(8), despite the overflow that may occur. Note that this also means that (e*(-1)) is positive, and is equivalent to (e*255) - i.e. the (-1) is cast to a UInt(8) before the multiplication.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00326">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00336">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00301">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00245">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00209">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00165">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00182">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00226">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00264">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00770">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00273">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00292">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00255">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00283">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00786">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="af36627bf7242718b1c73214296dc9090"></a><!-- doxytag: member="Halide::Internal::halide_log" ref="af36627bf7242718b1c73214296dc9090" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">Halide::Internal::halide_log</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00597">Halide::log()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00613">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="a5688772a963296ea52d2bd9ac5913e79"></a><!-- doxytag: member="Halide::Internal::halide_exp" ref="a5688772a963296ea52d2bd9ac5913e79" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">Halide::Internal::halide_exp</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00580">Halide::exp()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00613">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5890bd4a8aae2f1f6a2c43496d8ddae"></a><!-- doxytag: member="Halide::Internal::raise_to_integer_power" ref="ac5890bd4a8aae2f1f6a2c43496d8ddae" args="(Expr a, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">Halide::Internal::raise_to_integer_power</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00645">Halide::fast_pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00613">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="abe0706bb3eb3383817dc1ae7ce204ad0"></a><!-- doxytag: member="Halide::Internal::operator&lt;&lt;" ref="abe0706bb3eb3383817dc1ae7ce204ad0" args="(std::ostream &amp;stream, Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="aa67dad74ce8739ca7773f6032e51d5c6"></a><!-- doxytag: member="Halide::Internal::operator&lt;&lt;" ref="aa67dad74ce8739ca7773f6032e51d5c6" args="(std::ostream &amp;stream, const For::ForType &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const For::ForType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a class="anchor" id="a2c00a579c3d86ae40920d5fc4ffe64cf"></a><!-- doxytag: member="Halide::Internal::lower_lerp" ref="a2c00a579c3d86ae40920d5fc4ffe64cf" args="(Expr zero_val, Expr one_val, Expr weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="namespace_halide_1_1_internal.html#a2c00a579c3d86ae40920d5fc4ffe64cf">Halide::Internal::lower_lerp</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. </p>

</div>
</div>
<a class="anchor" id="a0cf146bb38588a04ea0c9491c56c4e11"></a><!-- doxytag: member="Halide::Internal::lower" ref="a0cf146bb38588a04ea0c9491c56c4e11" args="(Function f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a0cf146bb38588a04ea0c9491c56c4e11">Halide::Internal::lower</a> </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on </p>

</div>
</div>
<a class="anchor" id="a4d3bfe43201bab68cf4820993fe1469b"></a><!-- doxytag: member="Halide::Internal::lower_test" ref="a4d3bfe43201bab68cf4820993fe1469b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">Halide::Internal::lower_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a552b2c330fdb1275badc27cc1e92cd6a"></a><!-- doxytag: member="Halide::Internal::modulus_remainder" ref="a552b2c330fdb1275badc27cc1e92cd6a" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> <a class="el" href="namespace_halide_1_1_internal.html#a552b2c330fdb1275badc27cc1e92cd6a">Halide::Internal::modulus_remainder</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

</div>
</div>
<a class="anchor" id="a8489fb5b4449835f26313a57e856c4b3"></a><!-- doxytag: member="Halide::Internal::modulus_remainder" ref="a8489fb5b4449835f26313a57e856c4b3" args="(Expr e, const Scope&lt; ModulusRemainder &gt; &amp;scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> <a class="el" href="namespace_halide_1_1_internal.html#a552b2c330fdb1275badc27cc1e92cd6a">Halide::Internal::modulus_remainder</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a class="anchor" id="af210d0f6ae102d704259f49bb32adc2f"></a><!-- doxytag: member="Halide::Internal::reduce_expr_modulo" ref="af210d0f6ae102d704259f49bb32adc2f" args="(Expr e, int modulus, int *remainder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#af210d0f6ae102d704259f49bb32adc2f">Halide::Internal::reduce_expr_modulo</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a class="anchor" id="a789149daec96e933f8758f71f8474dd6"></a><!-- doxytag: member="Halide::Internal::modulus_remainder_test" ref="a789149daec96e933f8758f71f8474dd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">Halide::Internal::modulus_remainder_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a50891465f948d4f9b30b9253ce1640b1"></a><!-- doxytag: member="Halide::Internal::gcd" ref="a50891465f948d4f9b30b9253ce1640b1" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_halide_1_1_internal.html#a50891465f948d4f9b30b9253ce1640b1">Halide::Internal::gcd</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The greatest common divisor of two integers. </p>

</div>
</div>
<a class="anchor" id="a8adb5f4e1a135f0570023d7d086918e7"></a><!-- doxytag: member="Halide::Internal::move_broadcasts_inside_casts" ref="a8adb5f4e1a135f0570023d7d086918e7" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a8adb5f4e1a135f0570023d7d086918e7">Halide::Internal::move_broadcasts_inside_casts</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move broadcast nodes inside of cast nodes in preparation for peephole optimizations. </p>

</div>
</div>
<a class="anchor" id="a36620e2156363b215b17fae00eec44ea"></a><!-- doxytag: member="Halide::Internal::is_one_to_one" ref="a36620e2156363b215b17fae00eec44ea" args="(Expr expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#a36620e2156363b215b17fae00eec44ea">Halide::Internal::is_one_to_one</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conservatively determine whether an integer expression is one-to-one in its variables. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> now this means it contains a single variable and its derivative is provably strictly positive or strictly negative. </p>

</div>
</div>
<a class="anchor" id="acd3b8d6aeed9a003fe228ad1aba7322f"></a><!-- doxytag: member="Halide::Internal::is_one_to_one_test" ref="acd3b8d6aeed9a003fe228ad1aba7322f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#acd3b8d6aeed9a003fe228ad1aba7322f">Halide::Internal::is_one_to_one_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a568a0554db6866ee8560c3f599bceadd"></a><!-- doxytag: member="Halide::Internal::inject_profiling" ref="a568a0554db6866ee8560c3f599bceadd" args="(Stmt, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">Halide::Internal::inject_profiling</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement representing a halide pipeline, and (depending on the environment variable HL_PROFILE), insert high-resolution timing into the generated code; summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. Use util/HalideProf to analyze the output.</p>
<p>NOTE: this makes no effort to provide accurate or useful information when parallelization is scheduled; more work would need to be done to safely record data from multiple threads.</p>
<p>NOTE: this makes no effort to account for overhead from the profiling instructions inserted; profile-enabled runtimes will be slower, and inner loops will be more profoundly affected. </p>

</div>
</div>
<a class="anchor" id="ae828a911751c5115cb503d05afb1dcbe"></a><!-- doxytag: member="Halide::Internal::profiling_level" ref="ae828a911751c5115cb503d05afb1dcbe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_halide_1_1_internal.html#ae828a911751c5115cb503d05afb1dcbe">Halide::Internal::profiling_level</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current profiling level (by reading HL_PROFILE) </p>

</div>
</div>
<a class="anchor" id="a445fa778b28abf135eb1b1d0c8389efc"></a><!-- doxytag: member="Halide::Internal::remove_trivial_for_loops" ref="a445fa778b28abf135eb1b1d0c8389efc" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">Halide::Internal::remove_trivial_for_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes, which allows for further simplification. </p>
<p>Done during a late stage of lowering. </p>

</div>
</div>
<a class="anchor" id="a2cde29d4c9c4bc41d8474be2d94d6687"></a><!-- doxytag: member="Halide::Internal::operator&lt;&lt;" ref="a2cde29d4c9c4bc41d8474be2d94d6687" args="(std::ostream &amp;stream, Scope&lt; T &gt; &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_scope_8h_source.html#l00202">202</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00141">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a class="anchor" id="a3db029a2e2b7723c118049072ff56da2"></a><!-- doxytag: member="Halide::Internal::simplify" ref="a3db029a2e2b7723c118049072ff56da2" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a3db029a2e2b7723c118049072ff56da2">Halide::Internal::simplify</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>

</div>
</div>
<a class="anchor" id="a2f98a29cd4c461b996e81a77307c4ec9"></a><!-- doxytag: member="Halide::Internal::simplify" ref="a2f98a29cd4c461b996e81a77307c4ec9" args="(Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a3db029a2e2b7723c118049072ff56da2">Halide::Internal::simplify</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>

</div>
</div>
<a class="anchor" id="a6cd3908859c82249a2c7f10158883a97"></a><!-- doxytag: member="Halide::Internal::mod_imp" ref="a6cd3908859c82249a2c7f10158883a97" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html">Halide</a> expressions. </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00027">27</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00049">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="adff5495089b812474881ee939c4701c4"></a><!-- doxytag: member="Halide::Internal::mod_imp&lt; float &gt;" ref="adff5495089b812474881ee939c4701c4" args="(float a, float b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00036">36</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a60708c880da445554b8eeb778c034"></a><!-- doxytag: member="Halide::Internal::mod_imp&lt; double &gt;" ref="ac9a60708c880da445554b8eeb778c034" args="(double a, double b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00041">41</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00659">Halide::floor()</a>.</p>

</div>
</div>
<a class="anchor" id="a0442f9a0450f45683938a69ce0273974"></a><!-- doxytag: member="Halide::Internal::div_imp" ref="a0442f9a0450f45683938a69ce0273974" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00048">48</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00028">Halide::Type::bits</a>, and <a class="el" href="_type_8h_source.html#l00049">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="a7feea16442755d0a73ec2de1b8889106"></a><!-- doxytag: member="Halide::Internal::simplify_test" ref="a7feea16442755d0a73ec2de1b8889106" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a7feea16442755d0a73ec2de1b8889106">Halide::Internal::simplify_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07bde9012b280aad21a569ea008ed296"></a><!-- doxytag: member="Halide::Internal::sliding_window" ref="a07bde9012b280aad21a569ea008ed296" args="(Stmt s, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">Halide::Internal::sliding_window</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a class="anchor" id="a36bbe2f07f16d251525ee4beaa68c102"></a><!-- doxytag: member="Halide::Internal::storage_flattening" ref="a36bbe2f07f16d251525ee4beaa68c102" args="(Stmt s, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a36bbe2f07f16d251525ee4beaa68c102">Halide::Internal::storage_flattening</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> nodes respectively. </p>

</div>
</div>
<a class="anchor" id="a9eefd272612c586d9c3e4dba31d1c215"></a><!-- doxytag: member="Halide::Internal::storage_folding" ref="a9eefd272612c586d9c3e4dba31d1c215" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9eefd272612c586d9c3e4dba31d1c215">Halide::Internal::storage_folding</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><pre class="fragment"> f(x) = ...
 g(x) = f(x-1) + f(x)
 f.store_root().compute_at(g, x);
</pre></div><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a class="anchor" id="a9cec67b9b23c3f0047874cc432591ae6"></a><!-- doxytag: member="Halide::Internal::substitute" ref="a9cec67b9b23c3f0047874cc432591ae6" args="(std::string name, Expr replacement, Expr expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

</div>
</div>
<a class="anchor" id="aa5f3a31a571b877aeff8804b204b78ec"></a><!-- doxytag: member="Halide::Internal::substitute" ref="aa5f3a31a571b877aeff8804b204b78ec" args="(std::string name, Expr replacement, Stmt stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a class="anchor" id="ac546c55fe301504146a0ea9e19a4ac00"></a><!-- doxytag: member="Halide::Internal::substitute" ref="ac546c55fe301504146a0ea9e19a4ac00" args="(const std::map&lt; std::string, Expr &gt; &amp;replacements, Expr expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a9d3e92b9c76f56e57b4590f89d6cd073"></a><!-- doxytag: member="Halide::Internal::substitute" ref="a9d3e92b9c76f56e57b4590f89d6cd073" args="(const std::map&lt; std::string, Expr &gt; &amp;replacements, Stmt stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a320fa7575718308bc5b1e7a1b6d42d31"></a><!-- doxytag: member="Halide::Internal::get_initial_module_for_target" ref="a320fa7575718308bc5b1e7a1b6d42d31" args="(Target, llvm::LLVMContext *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module* <a class="el" href="namespace_halide_1_1_internal.html#a320fa7575718308bc5b1e7a1b6d42d31">Halide::Internal::get_initial_module_for_target</a> </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a class="anchor" id="aa9f98b98cbded4d63028df71771ca835"></a><!-- doxytag: member="Halide::Internal::get_initial_module_for_ptx_device" ref="aa9f98b98cbded4d63028df71771ca835" args="(llvm::LLVMContext *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module* <a class="el" href="namespace_halide_1_1_internal.html#aa9f98b98cbded4d63028df71771ca835">Halide::Internal::get_initial_module_for_ptx_device</a> </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a class="anchor" id="a3cd3f1d683bcca49a2df7179d42245d0"></a><!-- doxytag: member="Halide::Internal::inject_tracing" ref="a3cd3f1d683bcca49a2df7179d42245d0" args="(Stmt, const std::map&lt; std::string, Function &gt; &amp;env, Function output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a3cd3f1d683bcca49a2df7179d42245d0">Halide::Internal::inject_tracing</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="abf197e316b7d0a6adb96c25976612c1b"></a><!-- doxytag: member="Halide::Internal::uniquify_variable_names" ref="abf197e316b7d0a6adb96c25976612c1b" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">Halide::Internal::uniquify_variable_names</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a class="anchor" id="adc1c49e552297672b3751ac988bf70c3"></a><!-- doxytag: member="Halide::Internal::unroll_loops" ref="adc1c49e552297672b3751ac988bf70c3" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">Halide::Internal::unroll_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a class="anchor" id="a1581b658edf919ea8aae58ad09b4f829"></a><!-- doxytag: member="Halide::Internal::vec" ref="a1581b658edf919ea8aae58ad09b4f829" args="(T a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00039">39</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00354">Halide::abs()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00433">Halide::acos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00521">Halide::acosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00409">Halide::asin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00497">Halide::asinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00457">Halide::atan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00469">Halide::atan2()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00545">Halide::atanh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00672">Halide::ceil()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00421">Halide::cos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00509">Halide::cosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00580">Halide::exp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00659">Halide::floor()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00860">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00597">Halide::log()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00709">Halide::operator&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00770">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00786">Halide::operator&gt;&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00743">Halide::operator^()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00726">Halide::operator|()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00758">Halide::operator~()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00613">Halide::pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00695">Halide::reinterpret()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00685">Halide::round()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00397">Halide::sin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00485">Halide::sinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00557">Halide::sqrt()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00445">Halide::tan()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00533">Halide::tanh()</a>.</p>

</div>
</div>
<a class="anchor" id="a60049819a1e4ee7971c624c18a26210a"></a><!-- doxytag: member="Halide::Internal::vec" ref="a60049819a1e4ee7971c624c18a26210a" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00046">46</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a57308fdf8df2d93ff56d7dc8d2f621b1"></a><!-- doxytag: member="Halide::Internal::vec" ref="a57308fdf8df2d93ff56d7dc8d2f621b1" args="(T a, T b, T c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00054">54</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a643930ad0d00b2138183abfb01ba7083"></a><!-- doxytag: member="Halide::Internal::vec" ref="a643930ad0d00b2138183abfb01ba7083" args="(T a, T b, T c, T d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00063">63</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33cbb76cabe65d3b5fc27f6d4866ce0b"></a><!-- doxytag: member="Halide::Internal::vec" ref="a33cbb76cabe65d3b5fc27f6d4866ce0b" args="(T a, T b, T c, T d, T e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00073">73</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac29a0bceb82c876dc7b2d9d15ea0f5b7"></a><!-- doxytag: member="Halide::Internal::vec" ref="ac29a0bceb82c876dc7b2d9d15ea0f5b7" args="(T a, T b, T c, T d, T e, T f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00084">84</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0aeffeff26578021bc780e1506bfa448"></a><!-- doxytag: member="Halide::Internal::int_to_string" ref="a0aeffeff26578021bc780e1506bfa448" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#a0aeffeff26578021bc780e1506bfa448">Halide::Internal::int_to_string</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert an integer to a string. </p>

</div>
</div>
<a class="anchor" id="a94816d6979fdadb6e206a5d0a668e008"></a><!-- doxytag: member="Halide::Internal::reinterpret_bits" ref="a94816d6979fdadb6e206a5d0a668e008" args="(const SrcType &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType <a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">Halide::Internal::reinterpret_bits</a> </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00101">101</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd575ab182df12cc793dba4aa241c1a9"></a><!-- doxytag: member="Halide::Internal::unique_name" ref="acd575ab182df12cc793dba4aa241c1a9" args="(char prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a unique name starting with the given character. </p>
<p>It's unique relative to all other calls to unique_name done by this process. <a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false.">Not</a> thread-safe. </p>

<p>Referenced by <a class="el" href="_lambda_8h_source.html#l00017">Halide::lambda()</a>.</p>

</div>
</div>
<a class="anchor" id="a22aa5e173f0154dbdbc9efc4c6cfb8c4"></a><!-- doxytag: member="Halide::Internal::unique_name" ref="a22aa5e173f0154dbdbc9efc4c6cfb8c4" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a unique name starting with the given string. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false.">Not</a> thread-safe. </p>

</div>
</div>
<a class="anchor" id="aa7703083cfe592de68f37796533724ed"></a><!-- doxytag: member="Halide::Internal::starts_with" ref="aa7703083cfe592de68f37796533724ed" args="(const std::string &amp;str, const std::string &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#aa7703083cfe592de68f37796533724ed">Halide::Internal::starts_with</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the first string starts with the second string. </p>

<p>Referenced by <a class="el" href="_var_8h_source.html#l00124">Halide::Var::is_implicit()</a>, and <a class="el" href="_schedule_8h_source.html#l00050">Halide::Internal::Schedule::LoopLevel::match()</a>.</p>

</div>
</div>
<a class="anchor" id="a230079281175545b9b90b2285106ab28"></a><!-- doxytag: member="Halide::Internal::ends_with" ref="a230079281175545b9b90b2285106ab28" args="(const std::string &amp;str, const std::string &amp;suffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a230079281175545b9b90b2285106ab28">Halide::Internal::ends_with</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the first string ends with the second string. </p>

<p>Referenced by <a class="el" href="_schedule_8h_source.html#l00050">Halide::Internal::Schedule::LoopLevel::match()</a>.</p>

</div>
</div>
<a class="anchor" id="a771a564a2b084a26b0ebd88bbe1261c4"></a><!-- doxytag: member="Halide::Internal::base_name" ref="a771a564a2b084a26b0ebd88bbe1261c4" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#a771a564a2b084a26b0ebd88bbe1261c4">Halide::Internal::base_name</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the final token of the name string, assuming a fully qualified name delimited by '. </p>
<p>' </p>

</div>
</div>
<a class="anchor" id="abe70c3a9d0ecd59908b1837a11d01de0"></a><!-- doxytag: member="Halide::Internal::vectorize_loops" ref="abe70c3a9d0ecd59908b1837a11d01de0" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#abe70c3a9d0ecd59908b1837a11d01de0">Halide::Internal::vectorize_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a>      </li>
      <li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a>      </li>

    <li class="footer">Generated on Mon Nov 4 2013 15:36:33 for Halide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
