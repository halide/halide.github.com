<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: WebAssembly Support for Halide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_2_web_assembly.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">WebAssembly Support for Halide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="webassembly-support-for-halide"></a></p>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> supports WebAssembly (Wasm) code generation from <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> using the LLVM backend.</p>
<p>As WebAssembly itself is still under active development, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s support has some limitations. Some of the most important:</p>
<ul>
<li>Sign-extension operations are enabled by default (but can be avoided via Target::WasmMvpOnly).</li>
<li>Non-trapping float-to-int conversions are enabled by default (but can be avoided via Target::WasmMvpOnly).</li>
<li>Fixed-width SIMD (128 bit) can be enabled via Target::WasmSimd128.</li>
<li>Threads have very limited support via Target::WasmThreads; see <a class="el" href="#using-threads">below</a> for more details.</li>
<li><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s JIT for Wasm is extremely limited and really useful only for internal testing purposes.</li>
</ul>
<h1><a class="anchor" id="additional-tooling-requirements"></a>
Additional Tooling Requirements:</h1>
<ul>
<li>In additional to the usual install of LLVM and clang, you'll need lld.</li>
<li>Locally-installed version of Emscripten, 1.39.19+</li>
</ul>
<p>Note that for all of the above, earlier versions might work, but have not been tested.</p>
<h1><a class="anchor" id="aot-limitations"></a>
AOT Limitations</h1>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> outputs a Wasm object (.o) or static library (.a) file, much like any other architecture; to use it, of course, you must link it to suitable calling code. Additionally, you must link to something that provides an implementation of <code>libc</code>; as a practical matter, this means using the Emscripten tool to do your linking, as it provides the most complete such implementation we're aware of at this time.</p>
<ul>
<li><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> ahead-of-time tests assume/require that you have Emscripten installed and available on your system, with the <code>EMSDK</code> environment variable set properly.</li>
</ul>
<h1><a class="anchor" id="jit-limitations"></a>
JIT Limitations</h1>
<p>It's important to reiterate that the WebAssembly JIT mode is not (and will never be) appropriate for anything other than limited self tests, for a number of reasons:</p>
<ul>
<li>It actually uses an interpreter (from the WABT toolkit [<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>]) to execute wasm bytecode; not surprisingly, this can be <em>very</em> slow.</li>
<li>Wasm effectively runs in a private, 32-bit memory address space; while the host has access to that entire space, the reverse is not true, and thus any <code>define_extern</code> calls require copying all <code><a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a></code> data across the Wasm&lt;-&gt;host boundary in both directions. This has severe implications for existing benchmarks, which don't currently attempt to account for this extra overhead. (This could possibly be improved by modeling the Wasm JIT's buffer support as a <code>device</code> model that would allow lazy copy-on-demand.)</li>
<li>Host functions used via <code>define_extern</code> or <code>HalideExtern</code> cannot accept or return values that are pointer types or 64-bit integer types; this includes things like <code>const char *</code> and <code>user_context</code>. Fixing this is tractable, but is currently omitted as the fix is nontrivial and the tests that are affected are mostly non-critical. (Note that <code>halide_buffer_t*</code> is explicitly supported as a special case, however.)</li>
<li>Threading isn't supported at all (yet); all <code>parallel()</code> schedules will be run serially.</li>
<li>The <code>.async()</code> directive isn't supported at all, not even in serial-emulation mode.</li>
<li>You can't use <code>Param&lt;void *&gt;</code> (or any other arbitrary pointer type) with the Wasm jit.</li>
<li>You can't use <code>Func.debug_to_file()</code>, <code>Func.set_custom_do_par_for()</code>, <code>Func.set_custom_do_task()</code>, or <code>Func.set_custom_allocator()</code>.</li>
<li>The implementation of <code><a class="el" href="runtime__internal_8h.html#a52abbdf8792edbd1e34d4ca8d061f840">malloc()</a></code> used by the JIT is incredibly simpleminded and unsuitable for anything other than the most basic of tests.</li>
<li>GPU usage (or any buffer usage that isn't 100% host-memory) isn't supported at all yet. (This should be doable, just omitted for now.)</li>
</ul>
<p>Note that while some of these limitations may be improved in the future, some are effectively intrinsic to the nature of this problem. Realistically, this JIT implementation is intended solely for running <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> self-tests (and even then, a number of them are fundamentally impractical to support in a hosted-Wasm environment and are disabled).</p>
<p>In sum: don't plan on using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> JIT mode with Wasm unless you are working on the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> library itself.</p>
<h2><a class="anchor" id="using-v8-as-the-interpreter"></a>
Using V8 as the interpreter</h2>
<p>There is experimental support for using V8 as the interpreter in JIT mode, rather than WABT. This is enabled by the CMake command line options <code>-DWITH_V8=ON -DWITH_WABT=OFF</code> (only one of them can be used at a time). You must build V8 locally V8, then specify the path to the library and headers as CMake options. This is currently only tested on x86-64-Linux and requires v8 version 9.8.177 as a minimum.</p>
<p>The canonical instructions to build V8 are at <a href="https://v8.dev/docs/build">v8.dev</a>, and <a href="https://v8.dev/docs/embed">there are examples for embedding v8</a>. The process for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> is summarized below.</p>
<ul>
<li>Install <a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up"><code>depot_tools</code></a></li>
<li>Fetch v8 source code (and install required dependencies): <div class="fragment"><div class="line">$ gclient</div>
<div class="line">$ mkdir ~/v8 &amp;&amp; cd ~/v8</div>
<div class="line">$ fetch v8</div>
<div class="line">$ cd ~/v8/v8</div>
<div class="line">$ git checkout origin/9.8.177</div>
</div><!-- fragment --></li>
<li>Create a build configuration: <code>tools/dev/v8gen.py x64.release.sample</code></li>
<li>Turn off pointer compression: &lsquo;echo 'v8_enable_pointer_compression = false&rsquo; &gt;&gt; out.gn/x64.release.sample/args.gn<code></code></li>
<li><code>Disable the GDB-JIT interface (conflicts with LLVM):</code>echo 'v8_enable_gdbjit = false' &gt;&gt; out.gn/x64.release.sample/args.gn<code></code></li>
<li><code>Build the static library:</code>autoninja -C out.gn/x64.release.sample v8_monolith`</li>
</ul>
<p>With V8 built, we can pass the CMake options:</p>
<ul>
<li><code>V8_INCLUDE_DIR</code>, path to V8 includes, e.g. <code>$HOME/v8/v8/include</code></li>
<li><code>V8_LIBRARY</code>, path to V8 static library, e.g. <code>$HOME/v8/v8/out.gn/x64.release.sample/obj/libv8_monolith.a</code></li>
</ul>
<p>An example to configure <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> with V8 support, build and run an example test:</p>
<div class="fragment"><div class="line">$ cd /path/to/halide</div>
<div class="line">$ export HL_TARGET=wasm-32-wasmrt-wasm_simd128</div>
<div class="line">$ export HL_JIT_TARGET=${HL_TARGET}</div>
<div class="line">$ cmake -G Ninja \</div>
<div class="line">      -DWITH_WABT=OFF \</div>
<div class="line">      -DWITH_V8=ON \</div>
<div class="line">      -DV8_INCLUDE_DIR=$HOME/v8/v8/include \</div>
<div class="line">      -DV8_LIBRARY=$HOME/v8/v8/out.gn/x64.release.sample/obj/libv8_monolith.a \</div>
<div class="line">      -DHalide_TARGET=${HL_TARGET} \</div>
<div class="line">      /* other cmake settings here as appropriate */</div>
<div class="line"> </div>
<div class="line">$ cmake --build .</div>
<div class="line">$ ctest -L &quot;correctness|generator&quot; -j</div>
</div><!-- fragment --><h1><a class="anchor" id="to-use-halide-for-webassembly"></a>
To Use Halide For WebAssembly:</h1>
<ul>
<li>Ensure WebAssembly is in LLVM_TARGETS_TO_BUILD; if you use the default (<code>"all"</code>) then it's already present, but otherwise, add it explicitly:</li>
</ul>
<div class="fragment"><div class="line">-DLLVM_TARGETS_TO_BUILD=&quot;X86;ARM;NVPTX;AArch64;PowerPC;Hexagon;WebAssembly</div>
</div><!-- fragment --><h2><a class="anchor" id="enabling-wasm-jit"></a>
Enabling wasm JIT</h2>
<p>If you want to run <code>test_correctness</code> and other interesting parts of the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> test suite (and you almost certainly will), you'll need to ensure that LLVM is built with wasm-ld:</p>
<ul>
<li>Ensure that you have lld in LVM_ENABLE_PROJECTS:</li>
</ul>
<div class="fragment"><div class="line">cmake -DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot; ...</div>
</div><!-- fragment --><ul>
<li>To run the JIT tests, set <code>HL_JIT_TARGET=wasm-32-wasmrt</code> (possibly adding <code>wasm_simd128</code>) and run CMake/CTest normally. Note that wasm testing is only supported under CMake (not via Make).</li>
</ul>
<h2><a class="anchor" id="enabling-wasm-aot"></a>
Enabling wasm AOT</h2>
<p>If you want to test ahead-of-time code generation (and you almost certainly will), you need to install Emscripten locally.</p>
<ul>
<li>The simplest way to install is probably via the Emscripten emsdk (<a href="https://emscripten.org/docs/getting_started/downloads.html">https://emscripten.org/docs/getting_started/downloads.html</a>).</li>
<li>To run the AOT tests, set <code>HL_TARGET=wasm-32-wasmrt</code> (possibly adding <code>wasm_simd128</code>) and run CMake/CTest normally. Note that wasm testing is only supported under CMake (not via Make).</li>
</ul>
<h1><a class="anchor" id="running-benchmarks"></a>
Running benchmarks</h1>
<p>The <code>test_performance</code> benchmarks are misleading (and thus useless) for Wasm, as they include JIT overhead as described elsewhere. Suitable benchmarks for Wasm will be provided at a later date. (See <a href="https://github.com/halide/Halide/issues/5119">https://github.com/halide/Halide/issues/5119</a> and <a href="https://github.com/halide/Halide/issues/5047">https://github.com/halide/Halide/issues/5047</a> to track progress.)</p>
<h1><a class="anchor" id="using-threads"></a>
Using Threads</h1>
<p>You can use the <code>wasm_threads</code> feature to enable use of a normal pthread-based thread pool in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code, but with some careful caveats:</p>
<ul>
<li>This requires that you use a wasm runtime environment that provides pthread-compatible wrappers. At this time of this writing, the only environment known to support this well is Emscripten (when using the <code>-pthread</code> flag, and compiling for a Web environment). In this configuration, Emscripten goes to great lengths to make WebWorkers available via the pthreads API. (You can see an example of this usage in apps/HelloWasm.) Note that not all wasm runtimes support WebWorkers; generally, you need a full browser environment to make this work (though some versions of some shell tools may also support this, e.g. nodejs).</li>
<li>There is currently no support for using threads in a WASI environment, due to current limitations in the WASI specification. (We hope that this will improve in the future.)</li>
<li>There is no support for using threads in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> JIT environment, and no plans to add them anytime in the near-term future.</li>
</ul>
<h1><a class="anchor" id="known-limitations-and-caveats"></a>
Known Limitations And Caveats</h1>
<ul>
<li>Current trunk LLVM (as of July 2020) doesn't reliably generate all of the Wasm SIMD ops that are available; see <a href="https://github.com/halide/Halide/issues/5130">https://github.com/halide/Halide/issues/5130</a> for tracking information as these are fixed.</li>
<li>Using the JIT requires that we link the <code>wasm-ld</code> tool into libHalide; with some work this need could possibly be eliminated.</li>
<li>OSX and Linux-x64 have been tested. Windows hasn't; it should be supportable with some work. (Patches welcome.)</li>
<li>None of the <code>apps/</code> folder has been investigated yet. Many of them should be supportable with some work. (Patches welcome.)</li>
<li>We currently use v8/d8 as a test environment for AOT code; we may want to consider using Node or (better yet) headless Chrome instead (which is probably required to allow for using threads in AOT code).</li>
</ul>
<h1><a class="anchor" id="known-todo-1"></a>
Known TODO:</h1>
<ul>
<li>There's some invasive hackiness in Codgen_LLVM to support the JIT trampolines; this really should be refactored to be less hacky.</li>
<li>Can we rework JIT to avoid the need to link in wasm-ld? This might be doable, as the wasm object files produced by the LLVM backend are close enough to an executable form that we could likely make it work with some massaging on our side, but it's not clear whether this would be a bad idea or not (i.e., would it be unreasonably fragile).</li>
<li>Buffer-copying overhead in the JIT could possibly be dramatically improved by modeling the copy as a "device" (i.e. <code>copy_to_device()</code> would copy from host -&gt; wasm); this would make the performance benchmarks much more useful.</li>
<li>Can we support threads in the JIT without an unreasonable amount of work? Unknown at this point. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
