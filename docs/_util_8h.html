<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: src/Util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_util_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Util.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Various utility functions used internally <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_halide_runtime_8h_source.html">runtime/HalideRuntime.h</a>&quot;</code><br />
</div>
<p><a href="_util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">Halide::Internal::meta_and&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_01_4.html">Halide::Internal::meta_and&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or.html">Halide::Internal::meta_or&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or_3_01_t1_00_01_args_8_8_8_01_4.html">Halide::Internal::meta_or&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Halide::Internal::all_are_convertible&lt; To, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">Halide::Internal::FileStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_temporary_file.html">Halide::Internal::TemporaryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class that creates a temporary file in its ctor and deletes that file in its dtor; this is useful for temporary files that you want to ensure are deleted when exiting a certain scope.  <a href="class_halide_1_1_internal_1_1_temporary_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_value.html">Halide::Internal::ScopedValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for saving/restoring variable values on the stack, to allow for early-exit that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_static_cast.html">Halide::Internal::StaticCast&lt; TO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_roundtrippable.html">Halide::Internal::IsRoundtrippable&lt; TO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">Halide::Internal::reverse_adaptor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aac993690e0d967c2392f24ce0d3ebf24" id="r_aac993690e0d967c2392f24ce0d3ebf24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac993690e0d967c2392f24ce0d3ebf24">HALIDE_EXPORT</a>&#160;&#160;&#160;__attribute__((visibility(&quot;default&quot;)))</td></tr>
<tr class="separator:aac993690e0d967c2392f24ce0d3ebf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53da0047a6b6ce91b46f76c018d63931" id="r_a53da0047a6b6ce91b46f76c018d63931"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a>&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a></td></tr>
<tr class="separator:a53da0047a6b6ce91b46f76c018d63931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682b56d8790910625ab95dda91d682de" id="r_a682b56d8790910625ab95dda91d682de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a682b56d8790910625ab95dda91d682de">HALIDE_TIC</a>&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">Halide::Internal::halide_tic_impl</a>(__FILE__, __LINE__)</td></tr>
<tr class="separator:a682b56d8790910625ab95dda91d682de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22c5f724721f543aaec81962555b6fd" id="r_ad22c5f724721f543aaec81962555b6fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad22c5f724721f543aaec81962555b6fd">HALIDE_TOC</a>&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">Halide::Internal::halide_toc_impl</a>(__FILE__, __LINE__)</td></tr>
<tr class="separator:ad22c5f724721f543aaec81962555b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abdb3bac86d5020a2fc5c0fad5eba8592" id="r_abdb3bac86d5020a2fc5c0fad5eba8592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abdb3bac86d5020a2fc5c0fad5eba8592">Halide::load_plugin</a> (const std::string &amp;lib_name)</td></tr>
<tr class="memdesc:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin in the form of a dynamic library (e.g.  <br /></td></tr>
<tr class="separator:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c" id="r_ab7501900efa7660edf445ed1b14c020c"><td class="memTemplParams" colspan="2">template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplItemLeft" align="right" valign="top">DST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c">Halide::Internal::safe_numeric_cast</a> (SRC s)</td></tr>
<tr class="memdesc:ab7501900efa7660edf445ed1b14c020c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible.  <br /></td></tr>
<tr class="separator:ab7501900efa7660edf445ed1b14c020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008" id="r_a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">Halide::Internal::reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <br /></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c63ee87658cd904e2f4a0ba78b78b" id="r_a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">Halide::Internal::get_env_variable</a> (char const *env_var_name)</td></tr>
<tr class="memdesc:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of an environment variable.  <br /></td></tr>
<tr class="separator:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b793745b048fa1fd344907ec4ec9aa" id="r_ab4b793745b048fa1fd344907ec4ec9aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">Halide::Internal::running_program_name</a> ()</td></tr>
<tr class="memdesc:ab4b793745b048fa1fd344907ec4ec9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the currently running executable.  <br /></td></tr>
<tr class="separator:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd490221160a7206bb151d6eae65624" id="r_aabd490221160a7206bb151d6eae65624"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">Halide::Internal::unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:aabd490221160a7206bb151d6eae65624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <br /></td></tr>
<tr class="separator:aabd490221160a7206bb151d6eae65624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0bd73d997ddc50f3523a21448471f" id="r_a7ec0bd73d997ddc50f3523a21448471f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7ec0bd73d997ddc50f3523a21448471f">Halide::Internal::unique_name</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a7ec0bd73d997ddc50f3523a21448471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ca52c958b993ebd766f4b83de2cf9" id="r_af26ca52c958b993ebd766f4b83de2cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">Halide::Internal::starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af26ca52c958b993ebd766f4b83de2cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string starts with the second string.  <br /></td></tr>
<tr class="separator:af26ca52c958b993ebd766f4b83de2cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290fb244405de2c014ebdc3cd1fc8f08" id="r_a290fb244405de2c014ebdc3cd1fc8f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">Halide::Internal::ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a290fb244405de2c014ebdc3cd1fc8f08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string ends with the second string.  <br /></td></tr>
<tr class="separator:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06bf852ad18eb3e9014495f5816c1f" id="r_a9c06bf852ad18eb3e9014495f5816c1f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">Halide::Internal::replace_all</a> (const std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a9c06bf852ad18eb3e9014495f5816c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <br /></td></tr>
<tr class="separator:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa393afcc0cc51743eee04899674d90c0" id="r_aa393afcc0cc51743eee04899674d90c0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa393afcc0cc51743eee04899674d90c0">Halide::Internal::split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aa393afcc0cc51743eee04899674d90c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <br /></td></tr>
<tr class="separator:aa393afcc0cc51743eee04899674d90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90bc6b6e38d6f8cc725a3b54b66183" id="r_a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4c90bc6b6e38d6f8cc725a3b54b66183">Halide::Internal::join_strings</a> (const std::vector&lt; T &gt; &amp;sources, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the source vector using 'delim' as the divider.  <br /></td></tr>
<tr class="separator:a4c90bc6b6e38d6f8cc725a3b54b66183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba" id="r_aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">Halide::Internal::fold_left</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:aaaee1bb2b0dc659851899df7c12437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold of a vector.  <br /></td></tr>
<tr class="separator:aaaee1bb2b0dc659851899df7c12437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a" id="r_afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">Halide::Internal::fold_right</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:afedfcf82469516f0f05eb5a4699f480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right fold of a vector.  <br /></td></tr>
<tr class="separator:afedfcf82469516f0f05eb5a4699f480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93192a2ea0afe58664e69232595ae08e" id="r_a93192a2ea0afe58664e69232595ae08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">Halide::Internal::extract_namespaces</a> (const std::string &amp;name, std::vector&lt; std::string &gt; &amp;namespaces)</td></tr>
<tr class="memdesc:a93192a2ea0afe58664e69232595ae08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns base name and fills in namespaces, outermost one first in vector.  <br /></td></tr>
<tr class="separator:a93192a2ea0afe58664e69232595ae08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf75f489ee0a40366b6374ff9113260" id="r_afbf75f489ee0a40366b6374ff9113260"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afbf75f489ee0a40366b6374ff9113260">Halide::Internal::strip_namespaces</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:afbf75f489ee0a40366b6374ff9113260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e" title="Returns base name and fills in namespaces, outermost one first in vector.">extract_namespaces()</a>, but strip and discard the namespaces, returning base name only.  <br /></td></tr>
<tr class="separator:afbf75f489ee0a40366b6374ff9113260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8aad349dd3bfc69483b792fcab0f96" id="r_a4f8aad349dd3bfc69483b792fcab0f96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f8aad349dd3bfc69483b792fcab0f96">Halide::Internal::file_make_temp</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a4f8aad349dd3bfc69483b792fcab0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed.  <br /></td></tr>
<tr class="separator:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf8a5ee39d2b222d8a0be57894a2f75" id="r_abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abaf8a5ee39d2b222d8a0be57894a2f75">Halide::Internal::dir_make_temp</a> ()</td></tr>
<tr class="memdesc:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed.  <br /></td></tr>
<tr class="separator:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a323363444e3d16237848f6f8715b" id="r_aff2a323363444e3d16237848f6f8715b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2a323363444e3d16237848f6f8715b">Halide::Internal::file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aff2a323363444e3d16237848f6f8715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for access().  <br /></td></tr>
<tr class="separator:aff2a323363444e3d16237848f6f8715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034796c3683c3301a09c0102c6adb8b0" id="r_a034796c3683c3301a09c0102c6adb8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a034796c3683c3301a09c0102c6adb8b0">Halide::Internal::assert_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a034796c3683c3301a09c0102c6adb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file doesn't exist.  <br /></td></tr>
<tr class="separator:a034796c3683c3301a09c0102c6adb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8356033bf440e2f990bdc9f27cdcdcf" id="r_ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab8356033bf440e2f990bdc9f27cdcdcf">Halide::Internal::assert_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file DOES exist.  <br /></td></tr>
<tr class="separator:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd8ec86534a0e22d1ab4f2037bc562" id="r_a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a05dd8ec86534a0e22d1ab4f2037bc562">Halide::Internal::file_unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for unlink().  <br /></td></tr>
<tr class="separator:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c611b7403f5613f08fb701ea6eed6" id="r_a947c611b7403f5613f08fb701ea6eed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a947c611b7403f5613f08fb701ea6eed6">Halide::Internal::ensure_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a947c611b7403f5613f08fb701ea6eed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that no file with this path exists.  <br /></td></tr>
<tr class="separator:a947c611b7403f5613f08fb701ea6eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710588d377ce398aa366fc00f6d436aa" id="r_a710588d377ce398aa366fc00f6d436aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a710588d377ce398aa366fc00f6d436aa">Halide::Internal::dir_rmdir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a710588d377ce398aa366fc00f6d436aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rmdir().  <br /></td></tr>
<tr class="separator:a710588d377ce398aa366fc00f6d436aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f41b4199ab2236fb4056661f20cc11" id="r_aa0f41b4199ab2236fb4056661f20cc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0f41b4199ab2236fb4056661f20cc11">Halide::Internal::file_stat</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa0f41b4199ab2236fb4056661f20cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for stat().  <br /></td></tr>
<tr class="separator:aa0f41b4199ab2236fb4056661f20cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b13a717252cb9bda0e37b585d5f65ef" id="r_a4b13a717252cb9bda0e37b585d5f65ef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b13a717252cb9bda0e37b585d5f65ef">Halide::Internal::read_entire_file</a> (const std::string &amp;pathname)</td></tr>
<tr class="memdesc:a4b13a717252cb9bda0e37b585d5f65ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire contents of a file into a vector&lt;char&gt;.  <br /></td></tr>
<tr class="separator:a4b13a717252cb9bda0e37b585d5f65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a74e2116e6583961430bb9f96dc64" id="r_a4a0a74e2116e6583961430bb9f96dc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4a0a74e2116e6583961430bb9f96dc64">Halide::Internal::write_entire_file</a> (const std::string &amp;pathname, const void *source, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> source_len)</td></tr>
<tr class="memdesc:a4a0a74e2116e6583961430bb9f96dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or replace the contents of a file with a given pointer-and-length of memory.  <br /></td></tr>
<tr class="separator:a4a0a74e2116e6583961430bb9f96dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a41c09f705e2859eea67df0e04501" id="r_a687a41c09f705e2859eea67df0e04501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a687a41c09f705e2859eea67df0e04501">Halide::Internal::write_entire_file</a> (const std::string &amp;pathname, const std::vector&lt; char &gt; &amp;source)</td></tr>
<tr class="separator:a687a41c09f705e2859eea67df0e04501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc678d669d07fdd15685b87e3b8b620" id="r_a8cc678d669d07fdd15685b87e3b8b620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">Halide::Internal::add_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a8cc678d669d07fdd15685b87e3b8b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <br /></td></tr>
<tr class="separator:a8cc678d669d07fdd15685b87e3b8b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c64641e261b5596a2ab6d7da7f8ef8" id="r_a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a82c64641e261b5596a2ab6d7da7f8ef8">Halide::Internal::sub_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa735c9ff93372dce25222fb551b67" id="r_a9aaa735c9ff93372dce25222fb551b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9aaa735c9ff93372dce25222fb551b67">Halide::Internal::mul_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9aaa735c9ff93372dce25222fb551b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddf0741f1360ab02ae2c5871a50e5c9" id="r_a7ddf0741f1360ab02ae2c5871a50e5c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7ddf0741f1360ab02ae2c5871a50e5c9">Halide::Internal::add_with_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *result)</td></tr>
<tr class="memdesc:a7ddf0741f1360ab02ae2c5871a50e5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to perform arithmetic on signed types without triggering signed overflow.  <br /></td></tr>
<tr class="separator:a7ddf0741f1360ab02ae2c5871a50e5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6eced9ecc08886e52cb8df1aee61b2" id="r_adc6eced9ecc08886e52cb8df1aee61b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc6eced9ecc08886e52cb8df1aee61b2">Halide::Internal::sub_with_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *result)</td></tr>
<tr class="separator:adc6eced9ecc08886e52cb8df1aee61b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94090aac2902ca0d3861c9eb80d39a47" id="r_a94090aac2902ca0d3861c9eb80d39a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94090aac2902ca0d3861c9eb80d39a47">Halide::Internal::mul_with_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *result)</td></tr>
<tr class="separator:a94090aac2902ca0d3861c9eb80d39a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342a753f8441a0b29418b0d22cbda86" id="r_ae342a753f8441a0b29418b0d22cbda86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">Halide::Internal::halide_tic_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:ae342a753f8441a0b29418b0d22cbda86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23694d45bd4c42ec1dc97a17bb78f6" id="r_a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">Halide::Internal::halide_toc_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b578ca36f6632806a5f37bc631f801c" id="r_a2b578ca36f6632806a5f37bc631f801c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b578ca36f6632806a5f37bc631f801c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2b578ca36f6632806a5f37bc631f801c">Halide::Internal::begin</a> (<a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt; i)</td></tr>
<tr class="separator:a2b578ca36f6632806a5f37bc631f801c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9c9be1aaf01be6d77cd6f83a0f591" id="r_ae1d9c9be1aaf01be6d77cd6f83a0f591"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1d9c9be1aaf01be6d77cd6f83a0f591"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1d9c9be1aaf01be6d77cd6f83a0f591">Halide::Internal::end</a> (<a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt; i)</td></tr>
<tr class="separator:ae1d9c9be1aaf01be6d77cd6f83a0f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c98c7054db881ad405869df25669c9" id="r_ab1c98c7054db881ad405869df25669c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1c98c7054db881ad405869df25669c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1reverse__adaptor.html">reverse_adaptor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab1c98c7054db881ad405869df25669c9">Halide::Internal::reverse_view</a> (T &amp;&amp;range)</td></tr>
<tr class="memdesc:ab1c98c7054db881ad405869df25669c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-order adaptor for range-based for-loops.  <br /></td></tr>
<tr class="separator:ab1c98c7054db881ad405869df25669c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7465fda53b7318463f0f45f6511dc075" id="r_a7465fda53b7318463f0f45f6511dc075"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7465fda53b7318463f0f45f6511dc075">Halide::Internal::c_print_name</a> (const std::string &amp;name, bool prefix_underscore=true)</td></tr>
<tr class="memdesc:a7465fda53b7318463f0f45f6511dc075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a version of a string that is a valid identifier in C (.  <br /></td></tr>
<tr class="separator:a7465fda53b7318463f0f45f6511dc075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591746c6ae0cd3e8d24c2c2420772d8a" id="r_a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a591746c6ae0cd3e8d24c2c2420772d8a">Halide::Internal::get_llvm_version</a> ()</td></tr>
<tr class="memdesc:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVM_VERSION against which this libHalide is compiled.  <br /></td></tr>
<tr class="separator:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3376a79a765ed443399cf7cb2bcd9b" id="r_acb3376a79a765ed443399cf7cb2bcd9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb3376a79a765ed443399cf7cb2bcd9b">Halide::set_compiler_stack_size</a> (<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)</td></tr>
<tr class="memdesc:acb3376a79a765ed443399cf7cb2bcd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much stack the compiler should use for compilation in bytes.  <br /></td></tr>
<tr class="separator:acb3376a79a765ed443399cf7cb2bcd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e5b5cea7a51cb753cb55994d160bc1" id="r_a78e5b5cea7a51cb753cb55994d160bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a78e5b5cea7a51cb753cb55994d160bc1">Halide::get_compiler_stack_size</a> ()</td></tr>
<tr class="memdesc:a78e5b5cea7a51cb753cb55994d160bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how much stack size the compiler should use for calls that go through run_with_large_stack below.  <br /></td></tr>
<tr class="separator:a78e5b5cea7a51cb753cb55994d160bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe57f2ce9ba5592659449fccd5c1c6" id="r_a45fe57f2ce9ba5592659449fccd5c1c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a45fe57f2ce9ba5592659449fccd5c1c6">Halide::Internal::run_with_large_stack</a> (const std::function&lt; void()&gt; &amp;action)</td></tr>
<tr class="memdesc:a45fe57f2ce9ba5592659449fccd5c1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> the given action in a platform-specific context that provides at least the stack space returned by get_compiler_stack_size.  <br /></td></tr>
<tr class="separator:a45fe57f2ce9ba5592659449fccd5c1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac117f9e0b3bbb544807e9ddb1f6c49d9" id="r_ac117f9e0b3bbb544807e9ddb1f6c49d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac117f9e0b3bbb544807e9ddb1f6c49d9">Halide::Internal::popcount64</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> x)</td></tr>
<tr class="memdesc:ac117f9e0b3bbb544807e9ddb1f6c49d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable versions of popcount, count-leading-zeros, and count-trailing-zeros.  <br /></td></tr>
<tr class="separator:ac117f9e0b3bbb544807e9ddb1f6c49d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c27f5abba4dce3848962690f15c0ac" id="r_a77c27f5abba4dce3848962690f15c0ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a77c27f5abba4dce3848962690f15c0ac">Halide::Internal::clz64</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> x)</td></tr>
<tr class="separator:a77c27f5abba4dce3848962690f15c0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0b4593680c5fcfc77b72f709a69cb" id="r_a04b0b4593680c5fcfc77b72f709a69cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a04b0b4593680c5fcfc77b72f709a69cb">Halide::Internal::ctz64</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> x)</td></tr>
<tr class="separator:a04b0b4593680c5fcfc77b72f709a69cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbca40dc6f536bd853f878af922df261" id="r_acbca40dc6f536bd853f878af922df261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acbca40dc6f536bd853f878af922df261">Halide::Internal::next_power_of_two</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> x)</td></tr>
<tr class="memdesc:acbca40dc6f536bd853f878af922df261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer 2^n, for some n, which is &gt;= x.  <br /></td></tr>
<tr class="separator:acbca40dc6f536bd853f878af922df261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f5eea16013aba7cc1c195fa251dd7" id="r_a043f5eea16013aba7cc1c195fa251dd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a043f5eea16013aba7cc1c195fa251dd7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a043f5eea16013aba7cc1c195fa251dd7">Halide::Internal::align_up</a> (T x, int n)</td></tr>
<tr class="separator:a043f5eea16013aba7cc1c195fa251dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a36cab614624e4a021138635c794fd8c4" id="r_a36cab614624e4a021138635c794fd8c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a36cab614624e4a021138635c794fd8c4">Halide::default_compiler_stack_size</a> = 32 * 1024 * 1024</td></tr>
<tr class="memdesc:a36cab614624e4a021138635c794fd8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default amount of stack used for lowering and codegen.  <br /></td></tr>
<tr class="separator:a36cab614624e4a021138635c794fd8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Various utility functions used internally <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. </p>

<p class="definition">Definition in file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aac993690e0d967c2392f24ce0d3ebf24" name="aac993690e0d967c2392f24ce0d3ebf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac993690e0d967c2392f24ce0d3ebf24">&#9670;&#160;</a></span>HALIDE_EXPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_EXPORT&#160;&#160;&#160;__attribute__((visibility(&quot;default&quot;)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00039">39</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a53da0047a6b6ce91b46f76c018d63931" name="a53da0047a6b6ce91b46f76c018d63931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53da0047a6b6ce91b46f76c018d63931">&#9670;&#160;</a></span>HALIDE_NO_USER_CODE_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_NO_USER_CODE_INLINE&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00047">47</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a682b56d8790910625ab95dda91d682de" name="a682b56d8790910625ab95dda91d682de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682b56d8790910625ab95dda91d682de">&#9670;&#160;</a></span>HALIDE_TIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_TIC&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">Halide::Internal::halide_tic_impl</a>(__FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00416">416</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ad22c5f724721f543aaec81962555b6fd" name="ad22c5f724721f543aaec81962555b6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22c5f724721f543aaec81962555b6fd">&#9670;&#160;</a></span>HALIDE_TOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_TOC&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">Halide::Internal::halide_toc_impl</a>(__FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00417">417</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_util_8h.html">Util.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
