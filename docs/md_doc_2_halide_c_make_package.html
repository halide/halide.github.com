<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Using Halide from your CMake build</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_2_halide_c_make_package.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Using Halide from your CMake build</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="using-halide-from-your-cmake-build"></a></p>
<p>This is a detailed guide to building your own <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> programs with the official CMake package. If you need directions for building <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, see <a class="el" href="md_doc_2_building_halide_with_c_make.html">BuildingHalideWithCMake.md</a>. If you are looking for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s CMake coding guidelines, see <a class="el" href="md_doc_2_code_style_c_make.html">CodeStyleCMake.md</a>.</p>
<p>This document assumes some basic familiarity with CMake but tries to be explicit in all its examples. To learn more about CMake, consult the <a href="https://cmake.org/cmake/help/latest/">documentation</a> and engage with the community on the <a href="https://discourse.cmake.org/">CMake Discourse</a>.</p>
<ul>
<li><a class="el" href="#using-halide-from-your-cmake-build">Using Halide from your CMake build</a></li>
<li><a class="el" href="#a-basic-cmake-project">A basic CMake project</a><ul>
<li><a class="el" href="#jit-mode">JIT mode</a></li>
<li><a class="el" href="#aot-mode">AOT mode</a><ul>
<li><a class="el" href="#autoschedulers">Autoschedulers</a></li>
<li><a class="el" href="#rungenmain">RunGenMain</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="#halide-package-documentation">Halide package documentation</a><ul>
<li><a class="el" href="#components">Components</a></li>
<li><a class="el" href="#variables">Variables</a></li>
<li><a class="el" href="#imported-targets">Imported targets</a></li>
<li><a class="el" href="#functions">Functions</a><ul>
<li><a class="el" href="#add_halide_generator">`add_halide_generator`</a></li>
<li><a class="el" href="#add_halide_library">`add_halide_library`</a></li>
<li><a class="el" href="#add_halide_python_extension_library">`add_halide_python_extension_library`</a></li>
<li><a class="el" href="#add_halide_runtime">`add_halide_runtime`</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="#cross-compiling">Cross compiling</a><ul>
<li><a class="el" href="#use-add_halide_generator">Use `add_halide_generator`</a></li>
<li><a class="el" href="#use-a-super-build">Use a super-build</a></li>
<li><a class="el" href="#use-externalproject-directly">Use `ExternalProject` directly</a></li>
<li><a class="el" href="#use-an-emulator-or-run-on-device">Use an emulator or run on device</a></li>
<li><a class="el" href="#bypass-cmake">Bypass CMake</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="a-basic-cmake-project"></a>
A basic CMake project</h1>
<p>There are two main ways to use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> in your application: as a <b>JIT compiler</b> for dynamic pipelines or an <b>ahead-of-time (AOT) compiler</b> for static pipelines. CMake provides robust support for both use cases.</p>
<p>No matter how you intend to use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, you will need some basic CMake boilerplate.</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.28)</div>
<div class="line">project(HalideExample)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 17)  # or newer</div>
<div class="line">set(CMAKE_CXX_STANDARD_REQUIRED YES)</div>
<div class="line">set(CMAKE_CXX_EXTENSIONS NO)</div>
<div class="line"> </div>
<div class="line">find_package(Halide REQUIRED)</div>
</div><!-- fragment --><p>The <a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html"><code>cmake_minimum_required</code></a> command is required to be the first command executed in a CMake program. It disables all the deprecated behavior ("policies" in CMake lingo) from earlier versions. The <a href="https://cmake.org/cmake/help/latest/command/project.html"><code>project</code></a> command sets the name of the project (and accepts arguments for versioning, language support, etc.) and is required by CMake to be called immediately after setting the minimum version.</p>
<p>The next three variables set the project-wide C++ standard. The first, <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_STANDARD.html"><code>CMAKE_CXX_STANDARD</code></a>, simply sets the standard version. <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> requires at least C++17. The second, <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_STANDARD_REQUIRED.html"><code>CMAKE_CXX_STANDARD_REQUIRED</code></a>, tells CMake to fail if the compiler cannot provide the requested standard version. Lastly, <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_EXTENSIONS.html"><code>CMAKE_CXX_EXTENSIONS</code></a> tells CMake to disable vendor-specific extensions to C++. This is not necessary to simply use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, but we do not allow such extensions in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> repo.</p>
<p>Finally, we use <a href="https://cmake.org/cmake/help/latest/command/find_package.html"><code>find_package</code></a> to locate <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> on your system. When using the pip package on Linux and macOS, CMake's <code>find_package</code> command should find <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> as long as you're in the same virtual environment you installed it in. On Windows, you will need to add the virtual environment root directory to <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html"><code>CMAKE_PREFIX_PATH</code></a>:</p>
<div class="fragment"><div class="line">$ cmake -G Ninja -S . -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=%VIRTUAL_ENV%</div>
</div><!-- fragment --><p>If <code>find_package</code> cannot find <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, set <code>CMAKE_PREFIX_PATH</code> to the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> installation directory.</p>
<h2><a class="anchor" id="jit-mode"></a>
JIT mode</h2>
<p>To use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> in JIT mode (like the <a href="https://halide-lang.org/tutorials/tutorial_introduction.html">tutorials</a> do, for example), you can simply link to <code>Halide::Halide</code>.</p>
<div class="fragment"><div class="line"># ... same project setup as before ...</div>
<div class="line">add_executable(my_halide_app main.cpp)</div>
<div class="line">target_link_libraries(my_halide_app PRIVATE Halide::Halide)</div>
</div><!-- fragment --><p>Then <code>Halide.h</code> will be available to your code and everything should just work. That's it!</p>
<h2><a class="anchor" id="aot-mode"></a>
AOT mode</h2>
<p>Using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> in AOT mode is more complicated so we'll walk through it step by step. Note that this only applies to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> generators, so it might be useful to re-read the <a href="https://halide-lang.org/tutorials/tutorial_lesson_15_generators.html">tutorial on generators</a>. Assume (like in the tutorial) that you have a source file named <code>my_generators.cpp</code> and that in it, you have generator classes <code>MyFirstGenerator</code> and <code>MySecondGenerator</code> with registered names <code>my_first_generator</code> and <code>my_second_generator</code> respectively.</p>
<p>Then the first step is to add a <b>generator executable</b> to your build:</p>
<div class="fragment"><div class="line"># ... same project setup as before ...</div>
<div class="line">add_halide_generator(my_generators SOURCES my_generators.cpp)</div>
</div><!-- fragment --><p>Using the generator executable, we can add a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> library corresponding to <code>MyFirstGenerator</code>.</p>
<div class="fragment"><div class="line"># ... continuing from above</div>
<div class="line">add_halide_library(my_first_generator FROM my_generators)</div>
</div><!-- fragment --><p>This will create a static library target in CMake that corresponds to the output of running your generator. The second generator in the file requires generator parameters to be passed to it. These are also easy to handle:</p>
<div class="fragment"><div class="line"># ... continuing from above</div>
<div class="line">add_halide_library(my_second_generator FROM my_generators</div>
<div class="line">                   PARAMS parallel=false scale=3.0 rotation=ccw output.type=uint16)</div>
</div><!-- fragment --><p>Adding multiple configurations is easy, too:</p>
<div class="fragment"><div class="line"># ... continuing from above</div>
<div class="line">add_halide_library(my_second_generator_2 FROM my_generators</div>
<div class="line">                   GENERATOR my_second_generator</div>
<div class="line">                   PARAMS scale=9.0 rotation=ccw output.type=float32)</div>
<div class="line"> </div>
<div class="line">add_halide_library(my_second_generator_3 FROM my_generators</div>
<div class="line">                   GENERATOR my_second_generator</div>
<div class="line">                   PARAMS parallel=false output.type=float64)</div>
</div><!-- fragment --><p>Here, we had to specify which generator to use (<code>my_second_generator</code>) since it uses the target name by default. The functions in these libraries will be named after the target names, <code>my_second_generator_2</code> and <code>my_second_generator_3</code>, by default, but it is possible to control this via the <code>FUNCTION_NAME</code> parameter.</p>
<p>Each one of these targets, <code>&lt;GEN&gt;</code>, carries an associated <code>&lt;GEN&gt;.runtime</code> target, which is also a static library containing the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime. It is transitively linked through <code>&lt;GEN&gt;</code> to targets that link to <code>&lt;GEN&gt;</code>. On an operating system like Linux, where weak linking is available, this is not an issue. However, on Windows, this can fail due to symbol redefinitions. In these cases, you must declare that two <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> libraries share a runtime, like so:</p>
<div class="fragment"><div class="line"># ... updating above</div>
<div class="line">add_halide_library(my_second_generator_2 FROM my_generators</div>
<div class="line">                   GENERATOR my_second_generator</div>
<div class="line">                   USE_RUNTIME my_first_generator.runtime</div>
<div class="line">                   PARAMS scale=9.0 rotation=ccw output.type=float32)</div>
<div class="line"> </div>
<div class="line">add_halide_library(my_second_generator_3 FROM my_generators</div>
<div class="line">                   GENERATOR my_second_generator</div>
<div class="line">                   USE_RUNTIME my_first_generator.runtime</div>
<div class="line">                   PARAMS parallel=false output.type=float64)</div>
</div><!-- fragment --><p>This will even work correctly when different combinations of targets are specified for each halide library. A "greatest common denominator" target will be chosen that is compatible with all of them (or the build will fail).</p>
<h3><a class="anchor" id="autoschedulers"></a>
Autoschedulers</h3>
<p>When the autoschedulers are included in the release package, they are very simple to apply to your own generators. For example, we could update the definition of the <code>my_first_generator</code> library above to use the <code>Adams2019</code> autoscheduler:</p>
<div class="fragment"><div class="line">add_halide_library(my_second_generator FROM my_generators</div>
<div class="line">                   AUTOSCHEDULER Halide::Adams2019)</div>
</div><!-- fragment --><h3><a class="anchor" id="rungenmain"></a>
RunGenMain</h3>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> provides a generic driver for generators to be used during development for benchmarking and debugging. Suppose you have a generator executable called <code>my_gen</code> and a generator within called <code>my_filter</code>. Then you can pass a variable name to the <code>REGISTRATION</code> parameter of <code>add_halide_library</code> which will contain the name of a generated C++ source that should be linked to <code>Halide::RunGenMain</code> and <code>my_filter</code>.</p>
<p>For example:</p>
<div class="fragment"><div class="line">add_halide_library(my_filter FROM my_gen</div>
<div class="line">                   REGISTRATION filter_reg_cpp)</div>
<div class="line">add_executable(runner ${filter_reg_cpp})</div>
<div class="line">target_link_libraries(runner PRIVATE my_filter Halide::RunGenMain)</div>
</div><!-- fragment --><p>Then you can run, debug, and benchmark your generator through the <code>runner</code> executable. Learn how to interact with these executables in <a class="el" href="md_doc_2_run_gen.html">RunGen.md</a>.</p>
<h1><a class="anchor" id="halide-package-documentation"></a>
Halide package documentation</h1>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> provides a CMake <em>package configuration</em> module. The intended way to use the CMake build is to run <code>find_package(Halide ...)</code> in your <code>CMakeLists.txt</code> file. Closely read the <a href="https://cmake.org/cmake/help/latest/command/find_package.html"><code>find_package</code> documentation</a> before proceeding.</p>
<h2><a class="anchor" id="components"></a>
Components</h2>
<p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package script understands a handful of optional components when loading the package.</p>
<p>First, if you plan to use the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Image IO library, you will want to include the <code>png</code> and <code>jpeg</code> components when loading <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.</p>
<p>Second, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> releases can contain a variety of configurations: static, shared, debug, release, etc. CMake handles Debug/Release configurations automatically, but generally only allows one type of library to be loaded.</p>
<p>The package understands two components, <code>static</code> and <code>shared</code>, that specify which type of library you would like to load. For example, if you want to make sure that you link against shared <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, you can write:</p>
<div class="fragment"><div class="line">find_package(Halide REQUIRED COMPONENTS shared)</div>
</div><!-- fragment --><p>If the shared libraries are not available, this will result in a failure.</p>
<p>If no component is specified, then the <code>Halide_SHARED_LIBS</code> variable is checked. If it is defined and set to true, then the shared libraries will be loaded or the package loading will fail. Similarly, if it is defined and set to false, the static libraries will be loaded.</p>
<p>If no component is specified and <code>Halide_SHARED_LIBS</code> is <em>not</em> defined, then the <a href="https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html"><code>BUILD_SHARED_LIBS</code></a> variable will be inspected. If it is <b>not defined</b> or <b>defined and set to true</b>, then it will attempt to load the shared libs and fall back to the static libs if they are not available. Similarly, if <code>BUILD_SHARED_LIBS</code> is <b>defined and set to false</b>, then it will try the static libs first then fall back to the shared libs.</p>
<p>To ensure that the Python bindings are available, include the <code>Python</code> component.</p>
<h2><a class="anchor" id="variables"></a>
Variables</h2>
<p>Variables that control package loading:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_SHARED_LIBS</code>   </td><td class="markdownTableBodyNone">override <code>BUILD_SHARED_LIBS</code> when loading the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package via <code>find_package</code>. Has no effect when using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> via <code>add_subdirectory</code> as a Git or <code>FetchContent</code> submodule.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide_RUNTIME_NO_THREADS</code>   </td><td class="markdownTableBodyNone">skip linking of Threads library to runtime. Should be set if your toolchain does not support it (e.g. baremetal).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_RUNTIME_NO_DL_LIBS</code>   </td><td class="markdownTableBodyNone">skip linking of DL library to runtime. Should be set if your toolchain does not support it (e.g. baremetal).   </td></tr>
</table>
<p>Variables set by the package:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_VERSION</code>   </td><td class="markdownTableBodyNone">The full version string of the loaded <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide_VERSION_MAJOR</code>   </td><td class="markdownTableBodyNone">The major version of the loaded <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_VERSION_MINOR</code>   </td><td class="markdownTableBodyNone">The minor version of the loaded <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide_VERSION_PATCH</code>   </td><td class="markdownTableBodyNone">The patch version of the loaded <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_VERSION_TWEAK</code>   </td><td class="markdownTableBodyNone">The tweak version of the loaded <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide_HOST_TARGET</code>   </td><td class="markdownTableBodyNone">The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> target triple corresponding to "host" for this build.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_CMAKE_TARGET</code>   </td><td class="markdownTableBodyNone">The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> target triple corresponding to the active CMake target.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide_ENABLE_EXCEPTIONS</code>   </td><td class="markdownTableBodyNone">Whether <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> was compiled with exception support    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_ENABLE_RTTI</code>   </td><td class="markdownTableBodyNone">Whether <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> was compiled with RTTI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>WITH_AUTOSCHEDULERS</code>   </td><td class="markdownTableBodyNone">Whether the autoschedulers are available   </td></tr>
</table>
<p>Variables that control package behavior:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide_PYTHON_LAUNCHER</code>   </td><td class="markdownTableBodyNone">Semicolon separated list containing a command to launch the Python interpreter. Can be used to set environment variables for Python generators.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide_NO_DEFAULT_FLAGS</code>   </td><td class="markdownTableBodyNone">Off by default. When enabled, suppresses recommended compiler flags that would be added by <code>add_halide_generator</code>   </td></tr>
</table>
<h2><a class="anchor" id="imported-targets"></a>
Imported targets</h2>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> defines the following targets that are available to users:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Imported target   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide::Halide</code>   </td><td class="markdownTableBodyNone">this is the JIT-mode library to use when using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> from C++.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="class_halide_1_1_generator.html">Halide::Generator</a></code>   </td><td class="markdownTableBodyNone">this is the target to use when manually defining a generator executable. It supplies a <code>main()</code> function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="namespace_halide_1_1_runtime.html">Halide::Runtime</a></code>   </td><td class="markdownTableBodyNone">adds include paths to the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime headers    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide::Tools</code>   </td><td class="markdownTableBodyNone">adds include paths to the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> tools, including the benchmarking utility.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide::ImageIO</code>   </td><td class="markdownTableBodyNone">adds include paths to the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> image IO utility. Depends on <code>PNG::PNG</code> and <code>JPEG::JPEG</code> if they exist or were loaded through the corresponding package components.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide::ThreadPool</code>   </td><td class="markdownTableBodyNone">adds include paths to the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <em>simple</em> thread pool utility library. This is not the same as the runtime's thread pool and is intended only for use by tests. Depends on <code>Threads::Threads</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide::RunGenMain</code>   </td><td class="markdownTableBodyNone">used with the <code>REGISTRATION</code> parameter of <code>add_halide_library</code> to create simple runners and benchmarking tools for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> libraries.   </td></tr>
</table>
<p>The following targets only guaranteed when requesting the <code>Python</code> component (<code>Halide_Python_FOUND</code> will be true):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Imported target   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide::Python</code>   </td><td class="markdownTableBodyNone">this is a Python 3 package that can be referenced as <code>$&lt;TARGET_FILE_DIR:Halide::Python&gt;/..</code> when setting up <code>PYTHONPATH</code> for Python tests or the like from CMake.   </td></tr>
</table>
<p>The following targets only guaranteed when <code>WITH_AUTOSCHEDULERS</code> is true:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Imported target   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide::Adams2019</code>   </td><td class="markdownTableBodyNone">the Adams et.al. 2019 autoscheduler (no GPU support)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide::Anderson2021</code>   </td><td class="markdownTableBodyNone">the Anderson, et.al. 2021 autoscheduler (full GPU support)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Halide::Li2018</code>   </td><td class="markdownTableBodyNone">the Li et.al. 2018 gradient autoscheduler (limited GPU support)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Halide::Mullapudi2016</code>   </td><td class="markdownTableBodyNone">the Mullapudi et.al. 2016 autoscheduler (no GPU support)   </td></tr>
</table>
<h2><a class="anchor" id="functions"></a>
Functions</h2>
<p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> package provides several useful functions for dealing with AOT compilation steps.</p>
<h3><a class="anchor" id="add_halide_generator"></a>
<code>add_halide_generator</code></h3>
<p>This function aids in creating cross-compilable builds that use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> generators.</p>
<div class="fragment"><div class="line">add_halide_generator(</div>
<div class="line">    target</div>
<div class="line">    [PACKAGE_NAME package-name]</div>
<div class="line">    [PACKAGE_NAMESPACE namespace]</div>
<div class="line">    [EXPORT_FILE export-file]</div>
<div class="line">    [PYSTUB generator-name]</div>
<div class="line">    [LINK_LIBRARIES lib1 ...]</div>
<div class="line">    [[SOURCES] source1 ...]</div>
<div class="line">)</div>
</div><!-- fragment --><p>Every named argument is optional, and the function uses the following default arguments:</p>
<ul>
<li>If <code>PACKAGE_NAME</code> is not provided, it defaults to <code>${PROJECT_NAME}-halide_generators</code>.</li>
<li>If <code>PACKAGE_NAMESPACE</code> is not provided, it defaults to <code>${PROJECT_NAME}::halide_generators::</code>.</li>
<li>If <code>EXPORT_FILE</code> is not provided, it defaults to <code>${PROJECT_BINARY_DIR}/cmake/${ARG_PACKAGE_NAME}-config.cmake</code></li>
</ul>
<p>This function guarantees that a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> generator target named <code>&lt;namespace&gt;&lt;target&gt;</code> is available. It will first search for a package named <code>&lt;package-name&gt;</code> using <code>find_package</code>; if it is found, it is assumed that it provides the target. Otherwise, it will create an executable target named <code>target</code> and an <code>ALIAS</code> target <code>&lt;namespace&gt;&lt;target&gt;</code>. This function also creates a custom target named <code>&lt;package-name&gt;</code> if it does not exist and <code>&lt;target&gt;</code> would exist. In this case, <code>&lt;package-name&gt;</code> will depend on <code>&lt;target&gt;</code>, this enables easy building of <em>just</em> the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> generators managed by this function.</p>
<p>After the call, <code>&lt;PACKAGE_NAME&gt;_FOUND</code> will be set to true if the host generators were imported (and hence won't be built). Otherwise, it will be set to false. This variable may be used to conditionally set properties on <code>&lt;target&gt;</code>.</p>
<p>Please see <a href="https://github.com/halide/Halide/tree/main/test/integration/xc">test/integration/xc</a> for a simple example and <a href="https://github.com/halide/Halide/tree/main/apps/hannk">apps/hannk</a> for a complete app that uses it extensively.</p>
<p>The <code>SOURCES</code> keyword marks the beginning of sources to be used to build <code>&lt;target&gt;</code>, if it is not loaded. All unparsed arguments will be interpreted as sources.</p>
<p>The <code>LINK_LIBRARIES</code> argument lists libraries that should be linked to <code>&lt;target&gt;</code> when it is being built in the present build system.</p>
<p>If <code>PYSTUB</code> is specified, then a Python Extension will be built that wraps the Generator with CPython glue to allow use of the Generator Python 3. The result will be a shared library of the form <code>&lt;target&gt;_pystub.&lt;soabi&gt;.so</code>, where <code>&lt;soabi&gt;</code> describes the specific Python version and platform (e.g., <code>cpython-310-darwin</code> for Python 3.10 on macOS). See <a class="el" href="md_doc_2_python.html">Python.md</a> for examples of use.</p>
<h3><a class="anchor" id="add_halide_library"></a>
<code>add_halide_library</code></h3>
<p>This is the main function for managing generators in AOT compilation. The full signature follows:</p>
<div class="fragment"><div class="line">add_halide_library(&lt;target&gt; FROM &lt;generator-target&gt;</div>
<div class="line">                   [GENERATOR generator-name]</div>
<div class="line">                   [FUNCTION_NAME function-name]</div>
<div class="line">                   [NAMESPACE cpp-namespace]</div>
<div class="line">                   [USE_RUNTIME hl-target]</div>
<div class="line">                   [PARAMS param1 [param2 ...]]</div>
<div class="line">                   [TARGETS target1 [target2 ...]]</div>
<div class="line">                   [FEATURES feature1 [feature2 ...]]</div>
<div class="line">                   [FEATURES[&lt;triple&gt;] feature1 [feature2 ...]]</div>
<div class="line">                   [PLUGINS plugin1 [plugin2 ...]]</div>
<div class="line">                   [AUTOSCHEDULER scheduler-name]</div>
<div class="line">                   [FUNCTION_INFO_HEADER OUTVAR]</div>
<div class="line">                   [HEADER OUTVAR]</div>
<div class="line">                   [REGISTRATION OUTVAR]</div>
<div class="line">                   [&lt;extra-output&gt; OUTVAR]</div>
<div class="line">                   [GRADIENT_DESCENT]</div>
<div class="line">                   [C_BACKEND]</div>
<div class="line">                   [NO_THREADS]</div>
<div class="line">                   [NO_DL_LIBS])</div>
<div class="line"> </div>
<div class="line">triple = &lt;arch&gt;-&lt;bits&gt;-&lt;os&gt;</div>
<div class="line">arch   = x86 | arm | powerpc | hexagon | wasm | riscv</div>
<div class="line">bits   = 32 | 64</div>
<div class="line">os     = linux | windows | osx | android | ios | qurt | noos | fuchsia | wasmrt</div>
<div class="line"> </div>
<div class="line">extra-output = ASSEMBLY | BITCODE | COMPILER_LOG | C_SOURCE | FEATURIZATION</div>
<div class="line">             | HLPIPE | LLVM_ASSEMBLY | PYTHON_EXTENSION | PYTORCH_WRAPPER</div>
<div class="line">             | SCHEDULE | STMT | STMT_HTML</div>
</div><!-- fragment --><p>This function creates a called <code>&lt;target&gt;</code> corresponding to running the <code>&lt;generator-target&gt;</code> (an executable target which links to <code><a class="el" href="class_halide_1_1_generator.html">Halide::Generator</a></code>) one time, using command line arguments derived from the other parameters.</p>
<p>The arguments <code>GENERATOR</code> and <code>FUNCTION_NAME</code> default to <code>&lt;target&gt;</code>. They correspond to the <code>-g</code> and <code>-f</code> command line flags, respectively.</p>
<p><code>NAMESPACE</code> is syntactic sugar to specify the C++ namespace (if any) of the generated function; you can also specify the C++ namespace (if any) directly in the <code>FUNCTION_NAME</code> argument, but for repeated declarations or very long namespaces, specifying this separately can provide more readable build files.</p>
<p>If <code>USE_RUNTIME</code> is not specified, this function will create another target called <code>&lt;target&gt;.runtime</code> which corresponds to running the generator with <code>-r</code> and a compatible list of targets. This runtime target is an <code>INTERFACE</code> dependency of <code>&lt;target&gt;</code>. If multiple runtime targets need to be linked together, setting <code>USE_RUNTIME</code> to another <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime library, <code>&lt;target2&gt;</code> will prevent the generation of <code>&lt;target&gt;.runtime</code> and instead use <code>&lt;target2&gt;.runtime</code>. This argument is most commonly used in conjunction with <a class="el" href="#add_halide_runtime">`add_halide_runtime`</a>.</p>
<p>Parameters can be passed to a generator via the <code>PARAMS</code> argument. Parameters should be space-separated. Similarly, <code>TARGETS</code> is a space-separated list of targets for which to generate code in a single function. They must all share the same platform/bits/os triple (e.g. <code>arm-32-linux</code>). Features that are in common among all targets, including device libraries (like <code>cuda</code>) should go in <code>FEATURES</code>. If <code>TARGETS</code> is not specified, the value of <code>Halide_TARGET</code> specified at configure time will be used.</p>
<p>Every element of <code>TARGETS</code> must begin with the same <code>arch-bits-os</code> triple. This function understands two <em>meta-triples</em>, <code>host</code> and <code>cmake</code>. The meta-triple <code>host</code> is equal to the <code>arch-bits-os</code> triple used to compile <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> along with all the supported instruction set extensions. On platforms that support running both 32 and 64-bit programs, this will not necessarily equal the platform the compiler is running on or that CMake is targeting.</p>
<p>The meta-triple <code>cmake</code> is equal to the <code>arch-bits-os</code> of the current CMake target. This is useful if you want to make sure you are not unintentionally cross-compiling, which would result in an <a href="https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets"><code>IMPORTED</code> target</a> being created. When <code>TARGETS</code> is empty and the <code>host</code> target would not cross-compile, then <code>host</code> will be used. Otherwise, <code>cmake</code> will be used and an author warning will be issued.</p>
<p>When <code>CMAKE_OSX_ARCHITECTURES</code> is set and the <code>TARGETS</code> argument resolves to <code>cmake</code>, the generator will be run once for each architecture and the results will be fused together using <code>lipo</code>. This behavior extends to runtime targets.</p>
<p>To use an autoscheduler, set the <code>AUTOSCHEDULER</code> argument to a target named like <code>Namespace::Scheduler</code>, for example <code>Halide::Adams2019</code>. This will set the <code>autoscheduler</code> GeneratorParam on the generator command line to <code>Scheduler</code> and add the target to the list of plugins. Additional plugins can be loaded by setting the <code>PLUGINS</code> argument. If the argument to <code>AUTOSCHEDULER</code> does not contain <code>::</code> or it does not name a target, it will be passed to the <code>-s</code> flag verbatim.</p>
<p>If <code>GRADIENT_DESCENT</code> is set, then the module will be built suitably for gradient descent calculation in TensorFlow or PyTorch. See <code>Generator::build_gradient_module()</code> for more documentation. This corresponds to passing <code>-d 1</code> at the generator command line.</p>
<p>If the <code>C_BACKEND</code> option is set, this command will invoke the configured C++ compiler on a generated source. Note that a <code>&lt;target&gt;.runtime</code> target is <em>not</em> created in this case, and the <code>USE_RUNTIME</code> option is ignored. Other options work as expected.</p>
<p>If <code>REGISTRATION</code> is set, the path (relative to <code>CMAKE_CURRENT_BINARY_DIR</code>) to the generated <code>.registration.cpp</code> file will be set in <code>OUTVAR</code>. This can be used to generate a runner for a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> library that is useful for benchmarking and testing, as documented above. This is equivalent to setting <code>-e registration</code> at the generator command line.</p>
<p>If <code>HEADER</code> is set, the path (relative to <code>CMAKE_CURRENT_BINARY_DIR</code>) to the generated <code>.h</code> header file will be set in <code>OUTVAR</code>. This can be used with <code>install(FILES)</code> to conveniently deploy the generated header along with your library.</p>
<p>If <code>FUNCTION_INFO_HEADER</code> is set, the path (relative to <code>CMAKE_CURRENT_BINARY_DIR</code>) to the generated <code>.function_info.h</code> header file will be set in <code>OUTVAR</code>. This produces a file that contains <code>constexpr</code> descriptions of information about the generated functions (e.g., argument type and information). It is generated separately from the normal <code>HEADER</code> file because <code>HEADER</code> is intended to work with basic <code>extern "C"</code> linkage, while <code>FUNCTION_INFO_HEADER</code> requires C++17 or later to use effectively. (This can be quite useful for advanced usages, such as producing automatic call wrappers, etc.) Examples of usage can be found in the generated file.</p>
<p>Each of the <code>extra-output</code> arguments directly correspond to an extra output (via <code>-e</code>) from the generator. The value <code>OUTVAR</code> names a variable into which a path (relative to <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_BINARY_DIR.html"><code>CMAKE_CURRENT_BINARY_DIR</code></a>) to the extra file will be written.</p>
<p>When <code>NO_THREADS</code> is passed, the library targets will not depend on <code>Threads::Threads</code>. It is your responsibility to link to an equivalent target.</p>
<p>When <code>NO_DL_LIBS</code> is passed, the library targets will not depend on <code>${CMAKE_DL_LIBS}</code>. It is your responsibility to link to an equivalent library.</p>
<h3><a class="anchor" id="add_halide_python_extension_library"></a>
<code>add_halide_python_extension_library</code></h3>
<p>This function wraps the outputs of one or more <code>add_halide_library</code> targets with glue code to produce a Python Extension library.</p>
<div class="fragment"><div class="line">add_halide_python_extension_library(</div>
<div class="line">    target</div>
<div class="line">    [MODULE_NAME module-name]</div>
<div class="line">    HALIDE_LIBRARIES library1 ...</div>
<div class="line">)</div>
</div><!-- fragment --><p><code>HALIDE_LIBRARIES</code> is a list of one of more <code>add_halide_library</code> targets. Each will be added to the extension as a callable method of the module. Note that every library specified must be built with the <code>PYTHON_EXTENSION</code> keyword specified, and all libraries must use the same <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime.</p>
<p>The result will be a shared library of the form <code>&lt;target&gt;.&lt;soabi&gt;.so</code>, where <code>&lt;soabi&gt;</code> describes the specific Python version and platform (e.g., <code>cpython-310-darwin</code> for Python 3.10 on macOS.)</p>
<h3><a class="anchor" id="add_halide_runtime"></a>
<code>add_halide_runtime</code></h3>
<p>This function generates a library containing a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime. Most user code will never need to use this, as <code>add_halide_library()</code> will call it for you if necessary. The most common use case is usually in conjunction with <code>add_halide_python_extension_library()</code>, as a way to ensure that all the halide libraries share an identical runtime.</p>
<div class="fragment"><div class="line">add_halide_runtime(</div>
<div class="line">    target</div>
<div class="line">    [TARGETS target1 [target2 ...]]</div>
<div class="line">    [NO_THREADS]</div>
<div class="line">    [NO_DL_LIBS]</div>
<div class="line">)</div>
</div><!-- fragment --><p>The <code>TARGETS</code>, <code>NO_THREADS</code>, and <code>NO_DL_LIBS</code> arguments have identical semantics to the argument of the same name for <a class="el" href="#add_halide_library">`add_halide_library`</a>.</p>
<h1><a class="anchor" id="cross-compiling"></a>
Cross compiling</h1>
<p>Cross-compiling in CMake can be tricky, since CMake doesn't easily support compiling for both the host platform and the cross platform within the same build. Unfortunately, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> generator executables are just about always designed to run on the host platform. Each project will be set up differently and have different requirements, but here are some suggestions for effective use of CMake in these scenarios.</p>
<h2><a class="anchor" id="use-add_halide_generator"></a>
Use <code>add_halide_generator</code></h2>
<p>If you are writing new programs that use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, you might wish to use <code>add_halide_generator</code>. When using this helper, you are expected to build your project twice: once for your build host and again for your intended target.</p>
<p>When building the host build, you can use the <code>&lt;package-name&gt;</code> (see the documentation above) target to build <em>just</em> the generators. Then, in the target build, set <code>&lt;package-name&gt;_ROOT</code> to the host build directory.</p>
<p>For example:</p>
<div class="fragment"><div class="line">$ cmake -G Ninja -S . -B build-host -DCMAKE_BUILD_TYPE=Release</div>
<div class="line">$ cmake --build build-host --target &lt;package-name&gt;</div>
<div class="line">$ cmake -G Ninja -S . -B build-target --toolchain /path/to/target-tc.cmake \</div>
<div class="line">    -DCMAKE_BUILD_TYPE=Release \</div>
<div class="line">    -D&lt;package-name&gt;_ROOT:FILEPATH=$PWD/build-host</div>
<div class="line">$ cmake --build build-target</div>
</div><!-- fragment --><h2><a class="anchor" id="use-a-super-build"></a>
Use a super-build</h2>
<p>A CMake super-build consists of breaking down a project into subprojects that are isolated by <a href="https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html">toolchain</a>. The basic structure is to have an outermost project that only coordinates the sub-builds via the <a href="https://cmake.org/cmake/help/latest/module/ExternalProject.html"><code>ExternalProject</code></a> module.</p>
<p>One would then use <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to build a generator executable in one self-contained project, then export that target to be used in a separate project. The second project would be configured with the target <a href="https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html">toolchain</a> and would call <code>add_halide_library</code> with no <code>TARGETS</code> option and set <code>FROM</code> equal to the name of the imported generator executable. Obviously, this is a significant increase in complexity over a typical CMake project.</p>
<p>This is very compatible with the <code>add_halide_generator</code> strategy above.</p>
<h2><a class="anchor" id="use-externalproject-directly"></a>
Use <code>ExternalProject</code> directly</h2>
<p>A lighter weight alternative to the above is to use <a href="https://cmake.org/cmake/help/latest/module/ExternalProject.html"><code>ExternalProject</code></a> directly in your parent build. Configure the parent build with the target <a href="https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html">toolchain</a>, and configure the inner project to use the host toolchain. Then, manually create an <a href="https://cmake.org/cmake/help/latest/command/add_executable.html#imported-executables"><code>IMPORTED</code> target</a> for your generator executable and call <code>add_halide_library</code> as described above.</p>
<p>The main drawback of this approach is that creating accurate <code>IMPORTED</code> targets is difficult since predicting the names and locations of your binaries across all possible platform and CMake project generators is difficult. In particular, it is hard to predict executable extensions in cross-OS builds.</p>
<h2><a class="anchor" id="use-an-emulator-or-run-on-device"></a>
Use an emulator or run on device</h2>
<p>The <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CROSSCOMPILING_EMULATOR.html"><code>CMAKE_CROSSCOMPILING_EMULATOR</code></a> variable allows one to specify a command <em>prefix</em> to run a target-system binary on the host machine. One could set this to a custom shell script that uploads the generator executable, runs it on the device and copies back the results.</p>
<p>Another option is to install <code>qemu-user-static</code> to transparently emulate the cross-built generator.</p>
<h2><a class="anchor" id="bypass-cmake"></a>
Bypass CMake</h2>
<p>The previous two options ensure that the targets generated by <code>add_halide_library</code> will be <em>normal</em> static libraries. This approach does not use <a href="https://cmake.org/cmake/help/latest/module/ExternalProject.html"><code>ExternalProject</code></a>, but instead produces <code>IMPORTED</code> targets. The main drawback of <code>IMPORTED</code> targets is that they are considered second-class in CMake. In particular, they cannot be installed with the typical <a href="https://cmake.org/cmake/help/latest/command/install.html#targets"><code>install(TARGETS)</code> command</a>. Instead, they must be installed using <a href="https://cmake.org/cmake/help/latest/command/install.html#files"><code>install(FILES)</code></a> and the <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#target-dependent-queries"><code>$&lt;TARGET_FILE:tgt&gt;</code></a> generator expression. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
