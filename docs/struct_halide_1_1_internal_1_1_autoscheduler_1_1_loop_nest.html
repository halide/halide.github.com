<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::Autoscheduler::LoopNest Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Halide::Internal::Autoscheduler::LoopNest Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_feature_intermediates.html">FeatureIntermediates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9891c9a1e72e40f6f019d6f55dad7fba" id="r_a9891c9a1e72e40f6f019d6f55dad7fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9891c9a1e72e40f6f019d6f55dad7fba">copy_from</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;n)</td></tr>
<tr class="separator:a9891c9a1e72e40f6f019d6f55dad7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3312b1d7aec8fa45390e4b0a6160387" id="r_ae3312b1d7aec8fa45390e4b0a6160387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3312b1d7aec8fa45390e4b0a6160387">structural_hash</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;h, int depth) const</td></tr>
<tr class="separator:ae3312b1d7aec8fa45390e4b0a6160387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ae3127de5ab1b893c399ddf68ef9f7" id="r_ae4ae3127de5ab1b893c399ddf68ef9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ae3127de5ab1b893c399ddf68ef9f7">funcs_realized_or_inlined</a> () const</td></tr>
<tr class="separator:ae4ae3127de5ab1b893c399ddf68ef9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e06d8f6a7a7d2d2edaec1b72997410" id="r_a63e06d8f6a7a7d2d2edaec1b72997410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63e06d8f6a7a7d2d2edaec1b72997410">get_sites</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *task=nullptr, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent=nullptr) const</td></tr>
<tr class="separator:a63e06d8f6a7a7d2d2edaec1b72997410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f033062ae5c95a80d26f38dc32ae46" id="r_a96f033062ae5c95a80d26f38dc32ae46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f033062ae5c95a80d26f38dc32ae46">set_working_set_at_task_feature</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> working_set, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:a96f033062ae5c95a80d26f38dc32ae46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682611abef2d38fa0b2a5e0184572df1" id="r_a682611abef2d38fa0b2a5e0184572df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a682611abef2d38fa0b2a5e0184572df1">compute_features</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g.html">FunctionDAG</a> &amp;dag, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;params, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> instances, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> parallelism, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *grandparent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *working_set, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>, bool use_cached_features) const</td></tr>
<tr class="separator:a682611abef2d38fa0b2a5e0184572df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a223dd58020296550794c6bf129da9" id="r_a10a223dd58020296550794c6bf129da9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a223dd58020296550794c6bf129da9">is_root</a> () const</td></tr>
<tr class="separator:a10a223dd58020296550794c6bf129da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3b304710f7dc062a900318c69232dd" id="r_a9b3b304710f7dc062a900318c69232dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3b304710f7dc062a900318c69232dd">set_bounds</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_bound_contents.html">BoundContents</a> *b) const</td></tr>
<tr class="separator:a9b3b304710f7dc062a900318c69232dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592c2d55886ea8830084a0b10a8ca1f" id="r_a6592c2d55886ea8830084a0b10a8ca1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6592c2d55886ea8830084a0b10a8ca1f">get_bounds</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:a6592c2d55886ea8830084a0b10a8ca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c1b1dafa34df1b0b7224cba4b51671" id="r_ab8c1b1dafa34df1b0b7224cba4b51671"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c1b1dafa34df1b0b7224cba4b51671">dump</a> (std::ostream &amp;os, string prefix, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent) const</td></tr>
<tr class="separator:ab8c1b1dafa34df1b0b7224cba4b51671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9956684575ca9b6fa66e07a4d66683" id="r_ace9956684575ca9b6fa66e07a4d66683"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9956684575ca9b6fa66e07a4d66683">calls</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:ace9956684575ca9b6fa66e07a4d66683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432ada24cc10cd43063f60d1efea0a4" id="r_ac432ada24cc10cd43063f60d1efea0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac432ada24cc10cd43063f60d1efea0a4">max_inlined_calls</a> () const</td></tr>
<tr class="separator:ac432ada24cc10cd43063f60d1efea0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6006fced11249a63ebf64feb92f93ed7" id="r_a6006fced11249a63ebf64feb92f93ed7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6006fced11249a63ebf64feb92f93ed7">accesses_input_buffer</a> () const</td></tr>
<tr class="separator:a6006fced11249a63ebf64feb92f93ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3efad3daf1cb27a5cb4bec6a6d36c6" id="r_a8b3efad3daf1cb27a5cb4bec6a6d36c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b3efad3daf1cb27a5cb4bec6a6d36c6">computes</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:a8b3efad3daf1cb27a5cb4bec6a6d36c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32389f73bb4534c1b403ee089dac4cea" id="r_a32389f73bb4534c1b403ee089dac4cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32389f73bb4534c1b403ee089dac4cea">inline_func</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f)</td></tr>
<tr class="separator:a32389f73bb4534c1b403ee089dac4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd757a3299ce06b58ce8ca83e2ddbaf0" id="r_acd757a3299ce06b58ce8ca83e2ddbaf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd757a3299ce06b58ce8ca83e2ddbaf0">compute_here</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, bool <a class="el" href="#a8f782ad834ede04dac6a52a66517c8bd">tileable</a>, int v, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;params)</td></tr>
<tr class="separator:acd757a3299ce06b58ce8ca83e2ddbaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ed488007b3f56cb0549b06db334859" id="r_a07ed488007b3f56cb0549b06db334859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07ed488007b3f56cb0549b06db334859">parallelize_in_tiles</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;params, const vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;tiling, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent) const</td></tr>
<tr class="separator:a07ed488007b3f56cb0549b06db334859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ce14da7ce52e8763d8c9eaeaac7f24" id="r_a38ce14da7ce52e8763d8c9eaeaac7f24"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38ce14da7ce52e8763d8c9eaeaac7f24">compute_in_tiles</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;params, int v, bool in_realization) const</td></tr>
<tr class="separator:a38ce14da7ce52e8763d8c9eaeaac7f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4811be739a11245904f980fa01fdbcd" id="r_af4811be739a11245904f980fa01fdbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4811be739a11245904f980fa01fdbcd">apply</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> here, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> &gt; &gt; &amp;state_map, double num_cores, int depth, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *compute_site) const</td></tr>
<tr class="separator:af4811be739a11245904f980fa01fdbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad643decc0e25f098daef58f5e0c9b31f" id="r_ad643decc0e25f098daef58f5e0c9b31f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad643decc0e25f098daef58f5e0c9b31f">copy_from_including_features</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;n)</td></tr>
<tr class="separator:ad643decc0e25f098daef58f5e0c9b31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f31b0d91691a9cc84494d1f936b57fb" id="r_a9f31b0d91691a9cc84494d1f936b57fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f31b0d91691a9cc84494d1f936b57fb">memoize_points_computed_minimum</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;memoized_features, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:a9f31b0d91691a9cc84494d1f936b57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae2ed076d3fc9c9d5eff1a8d41fb76d" id="r_a6ae2ed076d3fc9c9d5eff1a8d41fb76d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae2ed076d3fc9c9d5eff1a8d41fb76d">memoize_features</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;memoized_features, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *features_to_insert) const</td></tr>
<tr class="separator:a6ae2ed076d3fc9c9d5eff1a8d41fb76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1db0a086a53162594fdd921f6bd089" id="r_afd1db0a086a53162594fdd921f6bd089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd1db0a086a53162594fdd921f6bd089">compute_working_set_from_features</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *working_set, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:afd1db0a086a53162594fdd921f6bd089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317ccf53146ba48b5e0b182d3bbbc335" id="r_a317ccf53146ba48b5e0b182d3bbbc335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a317ccf53146ba48b5e0b182d3bbbc335">recompute_inlined_features</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:a317ccf53146ba48b5e0b182d3bbbc335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2409ae36da8ad0bdda29923e879886c" id="r_ac2409ae36da8ad0bdda29923e879886c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2409ae36da8ad0bdda29923e879886c">compute_hash_of_producers_stored_at_root</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites) const</td></tr>
<tr class="separator:ac2409ae36da8ad0bdda29923e879886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b1b755a91f6a55c611c49c9771414b" id="r_a99b1b755a91f6a55c611c49c9771414b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99b1b755a91f6a55c611c49c9771414b">collect_producers</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites) const</td></tr>
<tr class="separator:a99b1b755a91f6a55c611c49c9771414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c413022bf18c1383c94f236d77dff6a" id="r_a5c413022bf18c1383c94f236d77dff6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c413022bf18c1383c94f236d77dff6a">collect_stages</a> (std::set&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> * &gt; &amp;stages) const</td></tr>
<tr class="separator:a5c413022bf18c1383c94f236d77dff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad8422a7db0cf93d21b7da78a6693a2" id="r_aaad8422a7db0cf93d21b7da78a6693a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad8422a7db0cf93d21b7da78a6693a2">is_gpu_serial</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target) const</td></tr>
<tr class="separator:aaad8422a7db0cf93d21b7da78a6693a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0534ae25bf1bd615aacf5094c9ed4cd1" id="r_a0534ae25bf1bd615aacf5094c9ed4cd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0534ae25bf1bd615aacf5094c9ed4cd1">is_gpu_thread</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target) const</td></tr>
<tr class="separator:a0534ae25bf1bd615aacf5094c9ed4cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5246b78318047fa7f69ae47b26865c40" id="r_a5246b78318047fa7f69ae47b26865c40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5246b78318047fa7f69ae47b26865c40">is_gpu_block</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target) const</td></tr>
<tr class="separator:a5246b78318047fa7f69ae47b26865c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1276b8e4c24d8bebbcf4dbd044337557" id="r_a1276b8e4c24d8bebbcf4dbd044337557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1276b8e4c24d8bebbcf4dbd044337557">is_scalar</a> () const</td></tr>
<tr class="separator:a1276b8e4c24d8bebbcf4dbd044337557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a2f4b4b72bb0aa894eec23b2d80302" id="r_a73a2f4b4b72bb0aa894eec23b2d80302"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73a2f4b4b72bb0aa894eec23b2d80302">get_union_thread_counts</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:a73a2f4b4b72bb0aa894eec23b2d80302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac203ff91b6e245ae11350c2548c876e2" id="r_ac203ff91b6e245ae11350c2548c876e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac203ff91b6e245ae11350c2548c876e2">get_stage_sizes</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, vector&lt; vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &gt; &amp;stage_sizes, vector&lt; vector&lt; int &gt; &gt; &amp;pure_dims, vector&lt; int &gt; &amp;vectorized_indices) const</td></tr>
<tr class="separator:ac203ff91b6e245ae11350c2548c876e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37607b296331f08ff70a2c9907676435" id="r_a37607b296331f08ff70a2c9907676435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37607b296331f08ff70a2c9907676435">generate_vec_dim_serial_tilings</a> (vector&lt; int &gt; &amp;serial_sizes) const</td></tr>
<tr class="separator:a37607b296331f08ff70a2c9907676435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa244f26f42509d27b66b550c79a05eee" id="r_aa244f26f42509d27b66b550c79a05eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa244f26f42509d27b66b550c79a05eee">add_gpu_thread_tilings</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, int v, vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt; &amp;result, const vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;max_size)</td></tr>
<tr class="separator:aa244f26f42509d27b66b550c79a05eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9891c9a1e72e40f6f019d6f55dad7fba" id="r_a9891c9a1e72e40f6f019d6f55dad7fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9891c9a1e72e40f6f019d6f55dad7fba">copy_from</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;n)</td></tr>
<tr class="separator:a9891c9a1e72e40f6f019d6f55dad7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad643decc0e25f098daef58f5e0c9b31f" id="r_ad643decc0e25f098daef58f5e0c9b31f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad643decc0e25f098daef58f5e0c9b31f">copy_from_including_features</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;n)</td></tr>
<tr class="separator:ad643decc0e25f098daef58f5e0c9b31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3312b1d7aec8fa45390e4b0a6160387" id="r_ae3312b1d7aec8fa45390e4b0a6160387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3312b1d7aec8fa45390e4b0a6160387">structural_hash</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;h, int depth) const</td></tr>
<tr class="separator:ae3312b1d7aec8fa45390e4b0a6160387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ae3127de5ab1b893c399ddf68ef9f7" id="r_ae4ae3127de5ab1b893c399ddf68ef9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ae3127de5ab1b893c399ddf68ef9f7">funcs_realized_or_inlined</a> () const</td></tr>
<tr class="separator:ae4ae3127de5ab1b893c399ddf68ef9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4268fdf5086c903d74ce1bc1090aad" id="r_a6e4268fdf5086c903d74ce1bc1090aad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e4268fdf5086c903d74ce1bc1090aad">get_gpu_memory_type</a> (bool in_block, bool in_thread, bool is_inlined=false) const</td></tr>
<tr class="separator:a6e4268fdf5086c903d74ce1bc1090aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa777c6a7945824a84ac5ee4d9c57e7d2" id="r_aa777c6a7945824a84ac5ee4d9c57e7d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa777c6a7945824a84ac5ee4d9c57e7d2">unrolled_loops</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *grandparent) const</td></tr>
<tr class="separator:aa777c6a7945824a84ac5ee4d9c57e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae269e79f08d91abbe1880dfffd1dab42" id="r_ae269e79f08d91abbe1880dfffd1dab42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae269e79f08d91abbe1880dfffd1dab42">get_allocs_that_can_be_promoted_to_registers</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;can_be_promoted_to_registers, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *grandparent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent) const</td></tr>
<tr class="separator:ae269e79f08d91abbe1880dfffd1dab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bebc4f9dc5e46d377f58487886f783" id="r_a99bebc4f9dc5e46d377f58487886f783"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99bebc4f9dc5e46d377f58487886f783">promote_allocs_to_registers</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites) const</td></tr>
<tr class="separator:a99bebc4f9dc5e46d377f58487886f783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd60d15bdfd3e8bc2b7193cc30fb4c22" id="r_acd60d15bdfd3e8bc2b7193cc30fb4c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd60d15bdfd3e8bc2b7193cc30fb4c22">get_sites</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;shared_mem_alloc_sizes, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *task=nullptr, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent=nullptr, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *current_thread_loop=nullptr) const</td></tr>
<tr class="separator:acd60d15bdfd3e8bc2b7193cc30fb4c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f033062ae5c95a80d26f38dc32ae46" id="r_a96f033062ae5c95a80d26f38dc32ae46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f033062ae5c95a80d26f38dc32ae46">set_working_set_at_task_feature</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> working_set, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:a96f033062ae5c95a80d26f38dc32ae46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e320dc1f0154f77d144e5308baeb57" id="r_a54e320dc1f0154f77d144e5308baeb57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54e320dc1f0154f77d144e5308baeb57">exceeds_serial_extents_limit</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, bool in_threads_loop) const</td></tr>
<tr class="separator:a54e320dc1f0154f77d144e5308baeb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5334ea87cb1a1d64712d6d77262f75c8" id="r_a5334ea87cb1a1d64712d6d77262f75c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5334ea87cb1a1d64712d6d77262f75c8">node_has_dynamic_region_computed</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:a5334ea87cb1a1d64712d6d77262f75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f170065dad9ad30e21b29b786b7a5c3" id="r_a9f170065dad9ad30e21b29b786b7a5c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f170065dad9ad30e21b29b786b7a5c3">has_dynamic_allocation_inside_thread</a> (bool in_thread_loop) const</td></tr>
<tr class="separator:a9f170065dad9ad30e21b29b786b7a5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c42503f4359863596b8d7a77193f0a" id="r_ab7c42503f4359863596b8d7a77193f0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7c42503f4359863596b8d7a77193f0a">find_pure_stage_loop_nest</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>) const</td></tr>
<tr class="separator:ab7c42503f4359863596b8d7a77193f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd5b72dcb75f5e30b3f951914dae70d" id="r_a1dd5b72dcb75f5e30b3f951914dae70d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dd5b72dcb75f5e30b3f951914dae70d">get_pure_stage_vectorized_loop_index</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>) const</td></tr>
<tr class="separator:a1dd5b72dcb75f5e30b3f951914dae70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ada07b04c8f834ad9559e738d1cf29e" id="r_a8ada07b04c8f834ad9559e738d1cf29e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ada07b04c8f834ad9559e738d1cf29e">get_vectorized_loop_index_from_pure_stage</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root) const</td></tr>
<tr class="separator:a8ada07b04c8f834ad9559e738d1cf29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecd3040c89e4d475f9193d341f987b4" id="r_a8ecd3040c89e4d475f9193d341f987b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ecd3040c89e4d475f9193d341f987b4">storage_stride</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int innermost_storage_dim, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *storage_node, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;store_bounds, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root) const</td></tr>
<tr class="separator:a8ecd3040c89e4d475f9193d341f987b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1a408f42e193bd67683fbbf5a38f69" id="r_a8a1a408f42e193bd67683fbbf5a38f69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_strides.html">Strides</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a1a408f42e193bd67683fbbf5a38f69">compute_strides</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int innermost_storage_dim, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *storage_node, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;store_bounds, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *thread_info, bool verbose=false) const</td></tr>
<tr class="separator:a8a1a408f42e193bd67683fbbf5a38f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316d77e23131bb55355e211cd47bbf3d" id="r_a316d77e23131bb55355e211cd47bbf3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a316d77e23131bb55355e211cd47bbf3d">all_strides_exist</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *storage_node, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root) const</td></tr>
<tr class="separator:a316d77e23131bb55355e211cd47bbf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815d18005c10e4d74d46623206724ed3" id="r_a815d18005c10e4d74d46623206724ed3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a815d18005c10e4d74d46623206724ed3">get_actual_vector_dim</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;store_bounds) const</td></tr>
<tr class="separator:a815d18005c10e4d74d46623206724ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4981aed1ccfc3fabef7ebe005d40d533" id="r_a4981aed1ccfc3fabef7ebe005d40d533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4981aed1ccfc3fabef7ebe005d40d533">compute_gpu_store_features</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int consumer_innermost_dim, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;consumer_store_bounds, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;gpu_loop_info, const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;inner_serial_loop_extents, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &amp;consumer_site, <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;feat, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae3fadf36552c27ce324664469a78a571">GlobalMemInfo</a> &amp;global_mem_loads, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a0dee49c8d37a03171b297c441a5d9be4">SharedMemInfo</a> &amp;shared_mem_loads, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ac8c19182b805ba107298469e242cb4ca">LocalMemInfo</a> &amp;local_mem_loads, bool verbose=false) const</td></tr>
<tr class="separator:a4981aed1ccfc3fabef7ebe005d40d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74cf9acca55831316de26c9dd83398f" id="r_ad74cf9acca55831316de26c9dd83398f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad74cf9acca55831316de26c9dd83398f">can_vectorize_access_for_innermost_dim</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *accessed, int innermost_dim, int loop_index) const</td></tr>
<tr class="separator:ad74cf9acca55831316de26c9dd83398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9ecef6f243eb84b7de26d060d8ace9" id="r_add9ecef6f243eb84b7de26d060d8ace9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add9ecef6f243eb84b7de26d060d8ace9">can_vectorize_store_access</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *accessed, bool accessed_has_been_scheduled, int innermost_dim, int loop_index, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> &amp;mem_type) const</td></tr>
<tr class="separator:add9ecef6f243eb84b7de26d060d8ace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66da14860cbf0999dbbe2d749989839f" id="r_a66da14860cbf0999dbbe2d749989839f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66da14860cbf0999dbbe2d749989839f">vectorized_load_access_size</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *accessed, bool accessed_has_been_scheduled, int innermost_dim, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> &amp;mem_type, bool verbose=false) const</td></tr>
<tr class="separator:a66da14860cbf0999dbbe2d749989839f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6a176ceadde6bb4b77d2d9c6455001" id="r_afd6a176ceadde6bb4b77d2d9c6455001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6a176ceadde6bb4b77d2d9c6455001">vectorized_access_size</a> (<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> loop_index, bool verbose=false) const</td></tr>
<tr class="separator:afd6a176ceadde6bb4b77d2d9c6455001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59cc1fd5ebce95a84bd005f59743ff2" id="r_ae59cc1fd5ebce95a84bd005f59743ff2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae59cc1fd5ebce95a84bd005f59743ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae59cc1fd5ebce95a84bd005f59743ff2">compute_num_mem_accesses_per_block</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;store_bounds, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *thread_info, int innermost_dim, double num_requests_per_warp, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aba8d2094e45bc0cfdbceebbea56a46d9">MemInfoType</a>&lt; T &gt; &amp;mem_info, bool verbose=false) const</td></tr>
<tr class="separator:ae59cc1fd5ebce95a84bd005f59743ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661657ab456e469ef3b3087e41f11dd3" id="r_a661657ab456e469ef3b3087e41f11dd3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a661657ab456e469ef3b3087e41f11dd3">compute_local_mem_store_features</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int consumer_innermost_dim, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;consumer_store_bounds, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root, double serial_loop_extents) const</td></tr>
<tr class="separator:a661657ab456e469ef3b3087e41f11dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15edb58a0a4b438411fdca95f78a6f0" id="r_aa15edb58a0a4b438411fdca95f78a6f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa15edb58a0a4b438411fdca95f78a6f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aba8d2094e45bc0cfdbceebbea56a46d9">MemInfoType</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa15edb58a0a4b438411fdca95f78a6f0">compute_mem_store_info</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int consumer_innermost_dim, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;consumer_store_bounds, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *thread_info, double serial_loop_extents, bool verbose) const</td></tr>
<tr class="separator:aa15edb58a0a4b438411fdca95f78a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff8fb6c693507f1e3576fa938ad528e" id="r_adff8fb6c693507f1e3576fa938ad528e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adff8fb6c693507f1e3576fa938ad528e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adff8fb6c693507f1e3576fa938ad528e">compute_mem_load_features</a> (const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int producer_innermost_dim, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;producer_store_bounds, bool producer_has_been_scheduled, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *thread_info, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aba8d2094e45bc0cfdbceebbea56a46d9">MemInfoType</a>&lt; T &gt; &amp;mem_info, double serial_loop_extents, bool verbose=false) const</td></tr>
<tr class="separator:adff8fb6c693507f1e3576fa938ad528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c6e944adc1d2f6568bf4c7c24e5a4" id="r_aa04c6e944adc1d2f6568bf4c7c24e5a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa04c6e944adc1d2f6568bf4c7c24e5a4">compute_local_mem_stride</a> (double stride, double bytes) const</td></tr>
<tr class="separator:aa04c6e944adc1d2f6568bf4c7c24e5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fe9c73a8d90166b0e16003e5c02b07" id="r_a10fe9c73a8d90166b0e16003e5c02b07"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10fe9c73a8d90166b0e16003e5c02b07">get_enclosing_block</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *grandparent) const</td></tr>
<tr class="separator:a10fe9c73a8d90166b0e16003e5c02b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b36df5d4bcdad0a3571c0e1704f4a1d" id="r_a9b36df5d4bcdad0a3571c0e1704f4a1d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b36df5d4bcdad0a3571c0e1704f4a1d">get_block_and_serial_extents</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *block) const</td></tr>
<tr class="separator:a9b36df5d4bcdad0a3571c0e1704f4a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fb9c6fa101fe66bf7314e7bfc65220" id="r_a68fb9c6fa101fe66bf7314e7bfc65220"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68fb9c6fa101fe66bf7314e7bfc65220">all_paths_to_leaves_have_thread_loop</a> () const</td></tr>
<tr class="separator:a68fb9c6fa101fe66bf7314e7bfc65220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada154e1c7b3654511378e4d1b27a6dfd" id="r_ada154e1c7b3654511378e4d1b27a6dfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada154e1c7b3654511378e4d1b27a6dfd">has_thread_loop_descendant</a> () const</td></tr>
<tr class="separator:ada154e1c7b3654511378e4d1b27a6dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a8cc55353bc2f86bd68f94fc8d7b36" id="r_ae2a8cc55353bc2f86bd68f94fc8d7b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2a8cc55353bc2f86bd68f94fc8d7b36">compute_warp_features</a> (<a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;gpu_loop_info) const</td></tr>
<tr class="separator:ae2a8cc55353bc2f86bd68f94fc8d7b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f537b8dff50dbcb84fb03f9c312b185" id="r_a6f537b8dff50dbcb84fb03f9c312b185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f537b8dff50dbcb84fb03f9c312b185">compute_warp_and_block_occupancy</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;feat, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;gpu_loop_info) const</td></tr>
<tr class="separator:a6f537b8dff50dbcb84fb03f9c312b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e9c3947b5314f4ee2d087aaaf485eb" id="r_a83e9c3947b5314f4ee2d087aaaf485eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83e9c3947b5314f4ee2d087aaaf485eb">compute_shared_mem_occupancy</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> total_shared_mem_alloc_size, <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;feat) const</td></tr>
<tr class="separator:a83e9c3947b5314f4ee2d087aaaf485eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed854487d481d7be972e36b8bd2be989" id="r_aed854487d481d7be972e36b8bd2be989"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed854487d481d7be972e36b8bd2be989">find_innermost_and_parent</a> () const</td></tr>
<tr class="separator:aed854487d481d7be972e36b8bd2be989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a20f32a34d749395053cd5c771d0b45" id="r_a1a20f32a34d749395053cd5c771d0b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a20f32a34d749395053cd5c771d0b45">points_accessed_per_thread</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;gpu_loop_info, const std::vector&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_edge.html">FunctionDAG::Edge</a> * &gt; &amp;edge_chain, const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *grandparent, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> n, const <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;feat, const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;serial_jac, bool producer_has_been_scheduled, int producer_innermost_dim, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> &amp;mem_type, bool verbose) const</td></tr>
<tr class="separator:a1a20f32a34d749395053cd5c771d0b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1bca64273a1c2f7a5128c31f8d776a" id="r_a4f1bca64273a1c2f7a5128c31f8d776a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f1bca64273a1c2f7a5128c31f8d776a">compute_licm_amortization</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *<a class="el" href="#ac7da95f17badb497858c6a4ac2516ca3">innermost</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;feat, const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;jac, int producer_dims) const</td></tr>
<tr class="separator:a4f1bca64273a1c2f7a5128c31f8d776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f31b0d91691a9cc84494d1f936b57fb" id="r_a9f31b0d91691a9cc84494d1f936b57fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f31b0d91691a9cc84494d1f936b57fb">memoize_points_computed_minimum</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;memoized_features, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:a9f31b0d91691a9cc84494d1f936b57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044a85283c5c8a17d297c45845372f0b" id="r_a044a85283c5c8a17d297c45845372f0b"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044a85283c5c8a17d297c45845372f0b">collect_producers</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites) const</td></tr>
<tr class="separator:a044a85283c5c8a17d297c45845372f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2409ae36da8ad0bdda29923e879886c" id="r_ac2409ae36da8ad0bdda29923e879886c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2409ae36da8ad0bdda29923e879886c">compute_hash_of_producers_stored_at_root</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites) const</td></tr>
<tr class="separator:ac2409ae36da8ad0bdda29923e879886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c413022bf18c1383c94f236d77dff6a" id="r_a5c413022bf18c1383c94f236d77dff6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c413022bf18c1383c94f236d77dff6a">collect_stages</a> (std::set&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> * &gt; &amp;stages) const</td></tr>
<tr class="separator:a5c413022bf18c1383c94f236d77dff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36429ae4c9844b103b1e437c1ff6214" id="r_aa36429ae4c9844b103b1e437c1ff6214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa36429ae4c9844b103b1e437c1ff6214">memoize_features</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;memoized_features, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:aa36429ae4c9844b103b1e437c1ff6214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1db0a086a53162594fdd921f6bd089" id="r_afd1db0a086a53162594fdd921f6bd089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd1db0a086a53162594fdd921f6bd089">compute_working_set_from_features</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *working_set, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:afd1db0a086a53162594fdd921f6bd089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317ccf53146ba48b5e0b182d3bbbc335" id="r_a317ccf53146ba48b5e0b182d3bbbc335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a317ccf53146ba48b5e0b182d3bbbc335">recompute_inlined_features</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>) const</td></tr>
<tr class="separator:a317ccf53146ba48b5e0b182d3bbbc335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e355884d51b4a2002b6d577627046a" id="r_af2e355884d51b4a2002b6d577627046a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2e355884d51b4a2002b6d577627046a">compute_alloc_size_of_node_here</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:af2e355884d51b4a2002b6d577627046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd241530c06f439b697e6e0c6a48fef" id="r_acbd241530c06f439b697e6e0c6a48fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd241530c06f439b697e6e0c6a48fef">compute_features</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g.html">FunctionDAG</a> &amp;dag, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;sites, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> instances, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> parallelism, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *grandparent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;root, <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> gpu_loop_info, bool use_memoized_features, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;total_shared_mem_alloc_sizes, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *working_set, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *working_set_local_constant, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *working_set_local_dynamic, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *<a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a>, <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_statistics.html">Statistics</a> &amp;stats, bool verbose=false) const</td></tr>
<tr class="separator:acbd241530c06f439b697e6e0c6a48fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a223dd58020296550794c6bf129da9" id="r_a10a223dd58020296550794c6bf129da9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a223dd58020296550794c6bf129da9">is_root</a> () const</td></tr>
<tr class="separator:a10a223dd58020296550794c6bf129da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3b304710f7dc062a900318c69232dd" id="r_a9b3b304710f7dc062a900318c69232dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3b304710f7dc062a900318c69232dd">set_bounds</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_bound_contents.html">BoundContents</a> *b) const</td></tr>
<tr class="separator:a9b3b304710f7dc062a900318c69232dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592c2d55886ea8830084a0b10a8ca1f" id="r_a6592c2d55886ea8830084a0b10a8ca1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6592c2d55886ea8830084a0b10a8ca1f">get_bounds</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:a6592c2d55886ea8830084a0b10a8ca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61218f2bab05d6542da4ea7a4990caaa" id="r_a61218f2bab05d6542da4ea7a4990caaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61218f2bab05d6542da4ea7a4990caaa">get_bounds_along_edge_chain</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, const vector&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_edge.html">FunctionDAG::Edge</a> * &gt; &amp;edge_chain) const</td></tr>
<tr class="separator:a61218f2bab05d6542da4ea7a4990caaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbc3337efa1e23b13ce51456bdf9927" id="r_addbc3337efa1e23b13ce51456bdf9927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addbc3337efa1e23b13ce51456bdf9927">dump</a> () const</td></tr>
<tr class="separator:addbc3337efa1e23b13ce51456bdf9927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa980686372412b174e4e6126b112f9ba" id="r_aa980686372412b174e4e6126b112f9ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa980686372412b174e4e6126b112f9ba">to_string</a> () const</td></tr>
<tr class="separator:aa980686372412b174e4e6126b112f9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290e390e7fb6b77bb003dbd6e1a7041e" id="r_a290e390e7fb6b77bb003dbd6e1a7041e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a290e390e7fb6b77bb003dbd6e1a7041e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a290e390e7fb6b77bb003dbd6e1a7041e">dump</a> (T &amp;stream, string prefix, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent) const</td></tr>
<tr class="separator:a290e390e7fb6b77bb003dbd6e1a7041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9956684575ca9b6fa66e07a4d66683" id="r_ace9956684575ca9b6fa66e07a4d66683"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9956684575ca9b6fa66e07a4d66683">calls</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:ace9956684575ca9b6fa66e07a4d66683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432ada24cc10cd43063f60d1efea0a4" id="r_ac432ada24cc10cd43063f60d1efea0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac432ada24cc10cd43063f60d1efea0a4">max_inlined_calls</a> () const</td></tr>
<tr class="separator:ac432ada24cc10cd43063f60d1efea0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6006fced11249a63ebf64feb92f93ed7" id="r_a6006fced11249a63ebf64feb92f93ed7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6006fced11249a63ebf64feb92f93ed7">accesses_input_buffer</a> () const</td></tr>
<tr class="separator:a6006fced11249a63ebf64feb92f93ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3efad3daf1cb27a5cb4bec6a6d36c6" id="r_a8b3efad3daf1cb27a5cb4bec6a6d36c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b3efad3daf1cb27a5cb4bec6a6d36c6">computes</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f) const</td></tr>
<tr class="separator:a8b3efad3daf1cb27a5cb4bec6a6d36c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32389f73bb4534c1b403ee089dac4cea" id="r_a32389f73bb4534c1b403ee089dac4cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32389f73bb4534c1b403ee089dac4cea">inline_func</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f)</td></tr>
<tr class="separator:a32389f73bb4534c1b403ee089dac4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60d69c2598848b6e2dd6a14f1559659" id="r_af60d69c2598848b6e2dd6a14f1559659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af60d69c2598848b6e2dd6a14f1559659">compute_here</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, bool <a class="el" href="#a8f782ad834ede04dac6a52a66517c8bd">tileable</a>, int v, bool in_threads_loop, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:af60d69c2598848b6e2dd6a14f1559659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa325a13ccb33b57a8539c9c90bb6d2e9" id="r_aa325a13ccb33b57a8539c9c90bb6d2e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa325a13ccb33b57a8539c9c90bb6d2e9">parallelize_in_tiles</a> (const vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;tiling, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, bool inner_tiling, bool adjust_tiling, bool move_all_rvars_inward=true, const vector&lt; int &gt; &amp;rvars_to_move_inward={}) const</td></tr>
<tr class="separator:aa325a13ccb33b57a8539c9c90bb6d2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64fe08a48eef7bd38fca63e4a9d2138" id="r_af64fe08a48eef7bd38fca63e4a9d2138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af64fe08a48eef7bd38fca63e4a9d2138">get_total_local_mem_alloc_size</a> (bool constant_allocs_only=false, bool in_threads_loop=false) const</td></tr>
<tr class="separator:af64fe08a48eef7bd38fca63e4a9d2138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647e0a028d9a94f9f4e8ad80d14a8192" id="r_a647e0a028d9a94f9f4e8ad80d14a8192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a647e0a028d9a94f9f4e8ad80d14a8192">get_total_constant_local_mem_alloc_size</a> () const</td></tr>
<tr class="separator:a647e0a028d9a94f9f4e8ad80d14a8192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cbca9c1975632bd983a2e7e2699e66" id="r_a50cbca9c1975632bd983a2e7e2699e66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50cbca9c1975632bd983a2e7e2699e66">requires_dynamic_allocation</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, bool in_threads_loop) const</td></tr>
<tr class="separator:a50cbca9c1975632bd983a2e7e2699e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0906e3b97bc78facec998382a14b6c18" id="r_a0906e3b97bc78facec998382a14b6c18"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0906e3b97bc78facec998382a14b6c18">compute_in_tiles</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;params, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_search_space_options.html">SearchSpaceOptions</a> &amp;search_space_options, int v, bool in_realization, bool in_threads_loop, bool is_pre_pass, vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; union_counts=vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;()) const</td></tr>
<tr class="separator:a0906e3b97bc78facec998382a14b6c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4540b511e8256749b311a198847ef9" id="r_a9f4540b511e8256749b311a198847ef9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4540b511e8256749b311a198847ef9">has_constant_region_computed</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>) const</td></tr>
<tr class="separator:a9f4540b511e8256749b311a198847ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a411b818755a3a986dbe7b989c8af2b" id="r_a1a411b818755a3a986dbe7b989c8af2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a411b818755a3a986dbe7b989c8af2b">has_constant_region_required</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *<a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a>) const</td></tr>
<tr class="separator:a1a411b818755a3a986dbe7b989c8af2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c50018057e8e80ab28a651d1cfbb12" id="r_ac8c50018057e8e80ab28a651d1cfbb12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8c50018057e8e80ab28a651d1cfbb12">other_stage_has_same_producer</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *producer) const</td></tr>
<tr class="separator:ac8c50018057e8e80ab28a651d1cfbb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14300d753b33d15988b9d4e595c9a99f" id="r_a14300d753b33d15988b9d4e595c9a99f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14300d753b33d15988b9d4e595c9a99f">num_serial_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> *<a class="el" href="#ac451c4521ccf418a9e05a6d5d8b1e9e1">stage</a>) const</td></tr>
<tr class="separator:a14300d753b33d15988b9d4e595c9a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab93fe46df7741fd556514bd75f95a5" id="r_a1ab93fe46df7741fd556514bd75f95a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ab93fe46df7741fd556514bd75f95a5">num_serial_loops</a> () const</td></tr>
<tr class="separator:a1ab93fe46df7741fd556514bd75f95a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d455dc8d32e4b8b63e6869b86598bc" id="r_ad1d455dc8d32e4b8b63e6869b86598bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d455dc8d32e4b8b63e6869b86598bc">producer_computed_here_or_further_in</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *producer) const</td></tr>
<tr class="separator:ad1d455dc8d32e4b8b63e6869b86598bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92033c0099e44d37bb92cfb5f262cf9" id="r_ad92033c0099e44d37bb92cfb5f262cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad92033c0099e44d37bb92cfb5f262cf9">update_producers_to_be_staged</a> (<a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> &amp;state, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;all_inlined) const</td></tr>
<tr class="separator:ad92033c0099e44d37bb92cfb5f262cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a64e691432204114b166c433d277395" id="r_a3a64e691432204114b166c433d277395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a64e691432204114b166c433d277395">region_computed_shrinks</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *f, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent) const</td></tr>
<tr class="separator:a3a64e691432204114b166c433d277395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4f1df3d29823eec2ee113449ea20d" id="r_a7cd4f1df3d29823eec2ee113449ea20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd4f1df3d29823eec2ee113449ea20d">apply</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> here, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> &gt; &gt; &amp;state_map, double num_cores, int depth, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *parent, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *compute_site, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> * &gt; &amp;ancestors, const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;all_inlined) const</td></tr>
<tr class="separator:a7cd4f1df3d29823eec2ee113449ea20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafba95030bc7ef16c6cdacb912b17a41" id="r_aafba95030bc7ef16c6cdacb912b17a41"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafba95030bc7ef16c6cdacb912b17a41">max_idle_lane_wastage</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> gpu_loop_info) const</td></tr>
<tr class="separator:aafba95030bc7ef16c6cdacb912b17a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6e5a73c4f75b14d46012508cc8ac8b" id="r_a7b6e5a73c4f75b14d46012508cc8ac8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6e5a73c4f75b14d46012508cc8ac8b">has_valid_thread_extents</a> () const</td></tr>
<tr class="separator:a7b6e5a73c4f75b14d46012508cc8ac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a00676947afac86b2374c2736275bb7" id="r_a7a00676947afac86b2374c2736275bb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a00676947afac86b2374c2736275bb7">collect_nodes_that_should_be_inlined</a> (const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;nodes_to_freeze, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;inlined_nodes) const</td></tr>
<tr class="separator:a7a00676947afac86b2374c2736275bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ce33be4ac6505cf3cf84a1905f67cc" id="r_aa3ce33be4ac6505cf3cf84a1905f67cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3ce33be4ac6505cf3cf84a1905f67cc">collect_all_inlined</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;all_inlined) const</td></tr>
<tr class="separator:aa3ce33be4ac6505cf3cf84a1905f67cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffc82f121129811ad60af057510a7fc" id="r_a2ffc82f121129811ad60af057510a7fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ffc82f121129811ad60af057510a7fc">product_of_self_and_descendants</a> (int loop_index) const</td></tr>
<tr class="separator:a2ffc82f121129811ad60af057510a7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff6db1bbd8a477830f85795cc7745e4" id="r_a4ff6db1bbd8a477830f85795cc7745e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff6db1bbd8a477830f85795cc7745e4">product_of_descendants</a> (int loop_index) const</td></tr>
<tr class="separator:a4ff6db1bbd8a477830f85795cc7745e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7681449082af52126245bd01aafdc" id="r_ac8e7681449082af52126245bd01aafdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e7681449082af52126245bd01aafdc">get_stages_computed_in_each_compute_root_loop</a> (<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; bool &gt; &gt; &amp;descendants, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *compute_root_loop_nest=nullptr) const</td></tr>
<tr class="separator:ac8e7681449082af52126245bd01aafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab63adb13a6f625098c54555c2d5a6229" id="r_ab63adb13a6f625098c54555c2d5a6229"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab63adb13a6f625098c54555c2d5a6229">hash_combine</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;h, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> next)</td></tr>
<tr class="separator:ab63adb13a6f625098c54555c2d5a6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63adb13a6f625098c54555c2d5a6229" id="r_ab63adb13a6f625098c54555c2d5a6229"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab63adb13a6f625098c54555c2d5a6229">hash_combine</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;h, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> next)</td></tr>
<tr class="separator:ab63adb13a6f625098c54555c2d5a6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab9a1e0d893e5f721cb35e6bc347d74ae" id="r_ab9a1e0d893e5f721cb35e6bc347d74ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a1e0d893e5f721cb35e6bc347d74ae">ref_count</a></td></tr>
<tr class="separator:ab9a1e0d893e5f721cb35e6bc347d74ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ab63803a47071cb7d0bead75019ff6" id="r_a60ab63803a47071cb7d0bead75019ff6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60ab63803a47071cb7d0bead75019ff6">size</a></td></tr>
<tr class="separator:a60ab63803a47071cb7d0bead75019ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a1081e0362927e821532d09c492ffc" id="r_a95a1081e0362927e821532d09c492ffc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95a1081e0362927e821532d09c492ffc">children</a></td></tr>
<tr class="separator:a95a1081e0362927e821532d09c492ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa174b40f80ba38486c3dec1ef3808a0" id="r_afa174b40f80ba38486c3dec1ef3808a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa174b40f80ba38486c3dec1ef3808a0">inlined</a></td></tr>
<tr class="separator:afa174b40f80ba38486c3dec1ef3808a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb584f3dab343d643d76c925813ed07" id="r_aedb584f3dab343d643d76c925813ed07"><td class="memItemLeft" align="right" valign="top">std::set&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb584f3dab343d643d76c925813ed07">store_at</a></td></tr>
<tr class="separator:aedb584f3dab343d643d76c925813ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14b1dcccf2d067391be02f4306b2c97" id="r_ac14b1dcccf2d067391be02f4306b2c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14b1dcccf2d067391be02f4306b2c97">bounds</a></td></tr>
<tr class="separator:ac14b1dcccf2d067391be02f4306b2c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239a35e4125fe2c91cdcc2d0d5c2a1b6" id="r_a239a35e4125fe2c91cdcc2d0d5c2a1b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">node</a> = nullptr</td></tr>
<tr class="separator:a239a35e4125fe2c91cdcc2d0d5c2a1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac451c4521ccf418a9e05a6d5d8b1e9e1" id="r_ac451c4521ccf418a9e05a6d5d8b1e9e1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac451c4521ccf418a9e05a6d5d8b1e9e1">stage</a> = nullptr</td></tr>
<tr class="separator:ac451c4521ccf418a9e05a6d5d8b1e9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7da95f17badb497858c6a4ac2516ca3" id="r_ac7da95f17badb497858c6a4ac2516ca3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7da95f17badb497858c6a4ac2516ca3">innermost</a> = false</td></tr>
<tr class="separator:ac7da95f17badb497858c6a4ac2516ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f782ad834ede04dac6a52a66517c8bd" id="r_a8f782ad834ede04dac6a52a66517c8bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f782ad834ede04dac6a52a66517c8bd">tileable</a> = false</td></tr>
<tr class="separator:a8f782ad834ede04dac6a52a66517c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6549b94773e60c3d2e61a7b925a24a" id="r_ace6549b94773e60c3d2e61a7b925a24a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace6549b94773e60c3d2e61a7b925a24a">parallel</a> = false</td></tr>
<tr class="separator:ace6549b94773e60c3d2e61a7b925a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d5faa6e442d6e06b9d6a8af3ca9b90" id="r_a77d5faa6e442d6e06b9d6a8af3ca9b90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77d5faa6e442d6e06b9d6a8af3ca9b90">vector_dim</a> = -1</td></tr>
<tr class="separator:a77d5faa6e442d6e06b9d6a8af3ca9b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aed41f28aca14d26b722edd02d6be7a" id="r_a0aed41f28aca14d26b722edd02d6be7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aed41f28aca14d26b722edd02d6be7a">vectorized_loop_index</a> = -1</td></tr>
<tr class="separator:a0aed41f28aca14d26b722edd02d6be7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14ca27d131bf6cec47ac8677f294f1f" id="r_af14ca27d131bf6cec47ac8677f294f1f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_feature_intermediates.html">FeatureIntermediates</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14ca27d131bf6cec47ac8677f294f1f">feature_intermediates_cache</a></td></tr>
<tr class="separator:af14ca27d131bf6cec47ac8677f294f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877515df2909b8ce495cf7109cc1afcf" id="r_a877515df2909b8ce495cf7109cc1afcf"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877515df2909b8ce495cf7109cc1afcf">features_cache</a></td></tr>
<tr class="separator:a877515df2909b8ce495cf7109cc1afcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae322fdeca7f5d3b43074a1b7aff206f2" id="r_ae322fdeca7f5d3b43074a1b7aff206f2"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae322fdeca7f5d3b43074a1b7aff206f2">size</a></td></tr>
<tr class="separator:ae322fdeca7f5d3b43074a1b7aff206f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf750fc8ea75db7220e9fdc6a6ddc0c3" id="r_adf750fc8ea75db7220e9fdc6a6ddc0c3"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf750fc8ea75db7220e9fdc6a6ddc0c3">children</a></td></tr>
<tr class="separator:adf750fc8ea75db7220e9fdc6a6ddc0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30340933c8356bb7dc31cca05ade37e1" id="r_a30340933c8356bb7dc31cca05ade37e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eaf">GPU_parallelism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30340933c8356bb7dc31cca05ade37e1">gpu_label</a> = <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eafa6adf97f83acf6453d4a6a4b1070f3754">GPU_parallelism::None</a></td></tr>
<tr class="separator:a30340933c8356bb7dc31cca05ade37e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f051ddbddd686d87c59dec742ffcf1" id="r_a80f051ddbddd686d87c59dec742ffcf1"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_feature_intermediates.html">FeatureIntermediates</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80f051ddbddd686d87c59dec742ffcf1">feature_intermediates</a></td></tr>
<tr class="separator:a80f051ddbddd686d87c59dec742ffcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e98505d41561dd26dc62a4871a40e" id="r_a1b6e98505d41561dd26dc62a4871a40e"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6e98505d41561dd26dc62a4871a40e">features</a></td></tr>
<tr class="separator:a1b6e98505d41561dd26dc62a4871a40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00087">87</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9891c9a1e72e40f6f019d6f55dad7fba" name="a9891c9a1e72e40f6f019d6f55dad7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9891c9a1e72e40f6f019d6f55dad7fba">&#9670;&#160;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="anderson2021_2_state_8h_source.html#l00050">Halide::Internal::Autoscheduler::deep_copy_loop_nest()</a>.</p>

</div>
</div>
<a id="ab63adb13a6f625098c54555c2d5a6229" name="ab63adb13a6f625098c54555c2d5a6229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63adb13a6f625098c54555c2d5a6229">&#9670;&#160;</a></span>hash_combine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Halide::Internal::Autoscheduler::LoopNest::hash_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>next</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00079">79</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="ae3312b1d7aec8fa45390e4b0a6160387" name="ae3312b1d7aec8fa45390e4b0a6160387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3312b1d7aec8fa45390e4b0a6160387">&#9670;&#160;</a></span>structural_hash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::structural_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4ae3127de5ab1b893c399ddf68ef9f7" name="ae4ae3127de5ab1b893c399ddf68ef9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ae3127de5ab1b893c399ddf68ef9f7">&#9670;&#160;</a></span>funcs_realized_or_inlined() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> Halide::Internal::Autoscheduler::LoopNest::funcs_realized_or_inlined </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00091">91</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00042">children</a>, <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00046">inlined</a>, and <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00049">store_at</a>.</p>

</div>
</div>
<a id="a63e06d8f6a7a7d2d2edaec1b72997410" name="a63e06d8f6a7a7d2d2edaec1b72997410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e06d8f6a7a7d2d2edaec1b72997410">&#9670;&#160;</a></span>get_sites() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::get_sites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>task</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96f033062ae5c95a80d26f38dc32ae46" name="a96f033062ae5c95a80d26f38dc32ae46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f033062ae5c95a80d26f38dc32ae46">&#9670;&#160;</a></span>set_working_set_at_task_feature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::set_working_set_at_task_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>working_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00120">120</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00042">children</a>, and <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00146">features</a>.</p>

</div>
</div>
<a id="a682611abef2d38fa0b2a5e0184572df1" name="a682611abef2d38fa0b2a5e0184572df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682611abef2d38fa0b2a5e0184572df1">&#9670;&#160;</a></span>compute_features() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g.html">FunctionDAG</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>grandparent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>working_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_cached_features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10a223dd58020296550794c6bf129da9" name="a10a223dd58020296550794c6bf129da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a223dd58020296550794c6bf129da9">&#9670;&#160;</a></span>is_root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::is_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00141">141</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00057">node</a>.</p>

</div>
</div>
<a id="a9b3b304710f7dc062a900318c69232dd" name="a9b3b304710f7dc062a900318c69232dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3b304710f7dc062a900318c69232dd">&#9670;&#160;</a></span>set_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp; Halide::Internal::Autoscheduler::LoopNest::set_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_bound_contents.html">BoundContents</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00148">148</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00054">bounds</a>.</p>

</div>
</div>
<a id="a6592c2d55886ea8830084a0b10a8ca1f" name="a6592c2d55886ea8830084a0b10a8ca1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592c2d55886ea8830084a0b10a8ca1f">&#9670;&#160;</a></span>get_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp; Halide::Internal::Autoscheduler::LoopNest::get_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8c1b1dafa34df1b0b7224cba4b51671" name="ab8c1b1dafa34df1b0b7224cba4b51671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c1b1dafa34df1b0b7224cba4b51671">&#9670;&#160;</a></span>dump() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00695">Halide::Internal::Autoscheduler::Filter::Filter()</a>.</p>

</div>
</div>
<a id="ace9956684575ca9b6fa66e07a4d66683" name="ace9956684575ca9b6fa66e07a4d66683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9956684575ca9b6fa66e07a4d66683">&#9670;&#160;</a></span>calls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac432ada24cc10cd43063f60d1efea0a4" name="ac432ada24cc10cd43063f60d1efea0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac432ada24cc10cd43063f60d1efea0a4">&#9670;&#160;</a></span>max_inlined_calls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::max_inlined_calls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6006fced11249a63ebf64feb92f93ed7" name="a6006fced11249a63ebf64feb92f93ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6006fced11249a63ebf64feb92f93ed7">&#9670;&#160;</a></span>accesses_input_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::accesses_input_buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b3efad3daf1cb27a5cb4bec6a6d36c6" name="a8b3efad3daf1cb27a5cb4bec6a6d36c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3efad3daf1cb27a5cb4bec6a6d36c6">&#9670;&#160;</a></span>computes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::computes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32389f73bb4534c1b403ee089dac4cea" name="a32389f73bb4534c1b403ee089dac4cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32389f73bb4534c1b403ee089dac4cea">&#9670;&#160;</a></span>inline_func() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::inline_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd757a3299ce06b58ce8ca83e2ddbaf0" name="acd757a3299ce06b58ce8ca83e2ddbaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd757a3299ce06b58ce8ca83e2ddbaf0">&#9670;&#160;</a></span>compute_here() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_here </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tileable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07ed488007b3f56cb0549b06db334859" name="a07ed488007b3f56cb0549b06db334859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ed488007b3f56cb0549b06db334859">&#9670;&#160;</a></span>parallelize_in_tiles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; Halide::Internal::Autoscheduler::LoopNest::parallelize_in_tiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tiling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38ce14da7ce52e8763d8c9eaeaac7f24" name="a38ce14da7ce52e8763d8c9eaeaac7f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ce14da7ce52e8763d8c9eaeaac7f24">&#9670;&#160;</a></span>compute_in_tiles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt; Halide::Internal::Autoscheduler::LoopNest::compute_in_tiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_adams2019_params.html">Adams2019Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_realization</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4811be739a11245904f980fa01fdbcd" name="af4811be739a11245904f980fa01fdbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4811be739a11245904f980fa01fdbcd">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>here</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>state_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>num_cores</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>compute_site</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad643decc0e25f098daef58f5e0c9b31f" name="ad643decc0e25f098daef58f5e0c9b31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad643decc0e25f098daef58f5e0c9b31f">&#9670;&#160;</a></span>copy_from_including_features() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::copy_from_including_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f31b0d91691a9cc84494d1f936b57fb" name="a9f31b0d91691a9cc84494d1f936b57fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f31b0d91691a9cc84494d1f936b57fb">&#9670;&#160;</a></span>memoize_points_computed_minimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::memoize_points_computed_minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memoized_features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ae2ed076d3fc9c9d5eff1a8d41fb76d" name="a6ae2ed076d3fc9c9d5eff1a8d41fb76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae2ed076d3fc9c9d5eff1a8d41fb76d">&#9670;&#160;</a></span>memoize_features() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::memoize_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memoized_features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features_to_insert</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd1db0a086a53162594fdd921f6bd089" name="afd1db0a086a53162594fdd921f6bd089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1db0a086a53162594fdd921f6bd089">&#9670;&#160;</a></span>compute_working_set_from_features() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_working_set_from_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>working_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a317ccf53146ba48b5e0b182d3bbbc335" name="a317ccf53146ba48b5e0b182d3bbbc335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317ccf53146ba48b5e0b182d3bbbc335">&#9670;&#160;</a></span>recompute_inlined_features() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::recompute_inlined_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2409ae36da8ad0bdda29923e879886c" name="ac2409ae36da8ad0bdda29923e879886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2409ae36da8ad0bdda29923e879886c">&#9670;&#160;</a></span>compute_hash_of_producers_stored_at_root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> Halide::Internal::Autoscheduler::LoopNest::compute_hash_of_producers_stored_at_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99b1b755a91f6a55c611c49c9771414b" name="a99b1b755a91f6a55c611c49c9771414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b1b755a91f6a55c611c49c9771414b">&#9670;&#160;</a></span>collect_producers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; Halide::Internal::Autoscheduler::LoopNest::collect_producers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c413022bf18c1383c94f236d77dff6a" name="a5c413022bf18c1383c94f236d77dff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c413022bf18c1383c94f236d77dff6a">&#9670;&#160;</a></span>collect_stages() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::collect_stages </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>stages</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaad8422a7db0cf93d21b7da78a6693a2" name="aaad8422a7db0cf93d21b7da78a6693a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad8422a7db0cf93d21b7da78a6693a2">&#9670;&#160;</a></span>is_gpu_serial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::is_gpu_serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00148">148</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00131">gpu_label</a>, <a class="el" href="struct_halide_1_1_target.html#a22bf80aa6dc3a700c9732050d2341a80">Halide::Target::has_gpu_feature()</a>, and <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eafa5255d3daaa0a6276b844d61401e6f493">Halide::Internal::Autoscheduler::Serial</a>.</p>

</div>
</div>
<a id="a0534ae25bf1bd615aacf5094c9ed4cd1" name="a0534ae25bf1bd615aacf5094c9ed4cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0534ae25bf1bd615aacf5094c9ed4cd1">&#9670;&#160;</a></span>is_gpu_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::is_gpu_thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00152">152</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00131">gpu_label</a>, <a class="el" href="struct_halide_1_1_target.html#a22bf80aa6dc3a700c9732050d2341a80">Halide::Target::has_gpu_feature()</a>, and <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eafad97477d6d8a838ead9348185bb5b6742">Halide::Internal::Autoscheduler::Thread</a>.</p>

</div>
</div>
<a id="a5246b78318047fa7f69ae47b26865c40" name="a5246b78318047fa7f69ae47b26865c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5246b78318047fa7f69ae47b26865c40">&#9670;&#160;</a></span>is_gpu_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::is_gpu_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00156">156</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eafae1e4c8c9ccd9fc39c391da4bcd093fb2">Halide::Internal::Autoscheduler::Block</a>, <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00131">gpu_label</a>, and <a class="el" href="struct_halide_1_1_target.html#a22bf80aa6dc3a700c9732050d2341a80">Halide::Target::has_gpu_feature()</a>.</p>

</div>
</div>
<a id="a1276b8e4c24d8bebbcf4dbd044337557" name="a1276b8e4c24d8bebbcf4dbd044337557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1276b8e4c24d8bebbcf4dbd044337557">&#9670;&#160;</a></span>is_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::is_scalar </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00160">160</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00039">size</a>.</p>

</div>
</div>
<a id="a73a2f4b4b72bb0aa894eec23b2d80302" name="a73a2f4b4b72bb0aa894eec23b2d80302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a2f4b4b72bb0aa894eec23b2d80302">&#9670;&#160;</a></span>get_union_thread_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; Halide::Internal::Autoscheduler::LoopNest::get_union_thread_counts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac203ff91b6e245ae11350c2548c876e2" name="ac203ff91b6e245ae11350c2548c876e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac203ff91b6e245ae11350c2548c876e2">&#9670;&#160;</a></span>get_stage_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::get_stage_sizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>stage_sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pure_dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vectorized_indices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37607b296331f08ff70a2c9907676435" name="a37607b296331f08ff70a2c9907676435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37607b296331f08ff70a2c9907676435">&#9670;&#160;</a></span>generate_vec_dim_serial_tilings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::generate_vec_dim_serial_tilings </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>serial_sizes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa244f26f42509d27b66b550c79a05eee" name="aa244f26f42509d27b66b550c79a05eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa244f26f42509d27b66b550c79a05eee">&#9670;&#160;</a></span>add_gpu_thread_tilings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::add_gpu_thread_tilings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9891c9a1e72e40f6f019d6f55dad7fba" name="a9891c9a1e72e40f6f019d6f55dad7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9891c9a1e72e40f6f019d6f55dad7fba">&#9670;&#160;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad643decc0e25f098daef58f5e0c9b31f" name="ad643decc0e25f098daef58f5e0c9b31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad643decc0e25f098daef58f5e0c9b31f">&#9670;&#160;</a></span>copy_from_including_features() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::copy_from_including_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab63adb13a6f625098c54555c2d5a6229" name="ab63adb13a6f625098c54555c2d5a6229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63adb13a6f625098c54555c2d5a6229">&#9670;&#160;</a></span>hash_combine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Halide::Internal::Autoscheduler::LoopNest::hash_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>next</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00193">193</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="ae3312b1d7aec8fa45390e4b0a6160387" name="ae3312b1d7aec8fa45390e4b0a6160387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3312b1d7aec8fa45390e4b0a6160387">&#9670;&#160;</a></span>structural_hash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::structural_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4ae3127de5ab1b893c399ddf68ef9f7" name="ae4ae3127de5ab1b893c399ddf68ef9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ae3127de5ab1b893c399ddf68ef9f7">&#9670;&#160;</a></span>funcs_realized_or_inlined() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> Halide::Internal::Autoscheduler::LoopNest::funcs_realized_or_inlined </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00205">205</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00042">children</a>, <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00046">inlined</a>, and <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00049">store_at</a>.</p>

</div>
</div>
<a id="a6e4268fdf5086c903d74ce1bc1090aad" name="a6e4268fdf5086c903d74ce1bc1090aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4268fdf5086c903d74ce1bc1090aad">&#9670;&#160;</a></span>get_gpu_memory_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> Halide::Internal::Autoscheduler::LoopNest::get_gpu_memory_type </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_thread</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_inlined</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa777c6a7945824a84ac5ee4d9c57e7d2" name="aa777c6a7945824a84ac5ee4d9c57e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa777c6a7945824a84ac5ee4d9c57e7d2">&#9670;&#160;</a></span>unrolled_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Halide::Internal::Autoscheduler::LoopNest::unrolled_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>grandparent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae269e79f08d91abbe1880dfffd1dab42" name="ae269e79f08d91abbe1880dfffd1dab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae269e79f08d91abbe1880dfffd1dab42">&#9670;&#160;</a></span>get_allocs_that_can_be_promoted_to_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::get_allocs_that_can_be_promoted_to_registers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>can_be_promoted_to_registers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>grandparent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bebc4f9dc5e46d377f58487886f783" name="a99bebc4f9dc5e46d377f58487886f783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bebc4f9dc5e46d377f58487886f783">&#9670;&#160;</a></span>promote_allocs_to_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::promote_allocs_to_registers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd60d15bdfd3e8bc2b7193cc30fb4c22" name="acd60d15bdfd3e8bc2b7193cc30fb4c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd60d15bdfd3e8bc2b7193cc30fb4c22">&#9670;&#160;</a></span>get_sites() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::get_sites </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>shared_mem_alloc_sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>task</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>current_thread_loop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96f033062ae5c95a80d26f38dc32ae46" name="a96f033062ae5c95a80d26f38dc32ae46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f033062ae5c95a80d26f38dc32ae46">&#9670;&#160;</a></span>set_working_set_at_task_feature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::set_working_set_at_task_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>working_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00271">271</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00042">children</a>, and <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00146">features</a>.</p>

</div>
</div>
<a id="a54e320dc1f0154f77d144e5308baeb57" name="a54e320dc1f0154f77d144e5308baeb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e320dc1f0154f77d144e5308baeb57">&#9670;&#160;</a></span>exceeds_serial_extents_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::exceeds_serial_extents_limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_threads_loop</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5334ea87cb1a1d64712d6d77262f75c8" name="a5334ea87cb1a1d64712d6d77262f75c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5334ea87cb1a1d64712d6d77262f75c8">&#9670;&#160;</a></span>node_has_dynamic_region_computed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::node_has_dynamic_region_computed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f170065dad9ad30e21b29b786b7a5c3" name="a9f170065dad9ad30e21b29b786b7a5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f170065dad9ad30e21b29b786b7a5c3">&#9670;&#160;</a></span>has_dynamic_allocation_inside_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::has_dynamic_allocation_inside_thread </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_thread_loop</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7c42503f4359863596b8d7a77193f0a" name="ab7c42503f4359863596b8d7a77193f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c42503f4359863596b8d7a77193f0a">&#9670;&#160;</a></span>find_pure_stage_loop_nest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> * Halide::Internal::Autoscheduler::LoopNest::find_pure_stage_loop_nest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dd5b72dcb75f5e30b3f951914dae70d" name="a1dd5b72dcb75f5e30b3f951914dae70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd5b72dcb75f5e30b3f951914dae70d">&#9670;&#160;</a></span>get_pure_stage_vectorized_loop_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::get_pure_stage_vectorized_loop_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ada07b04c8f834ad9559e738d1cf29e" name="a8ada07b04c8f834ad9559e738d1cf29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ada07b04c8f834ad9559e738d1cf29e">&#9670;&#160;</a></span>get_vectorized_loop_index_from_pure_stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::get_vectorized_loop_index_from_pure_stage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ecd3040c89e4d475f9193d341f987b4" name="a8ecd3040c89e4d475f9193d341f987b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecd3040c89e4d475f9193d341f987b4">&#9670;&#160;</a></span>storage_stride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Halide::Internal::Autoscheduler::LoopNest::storage_stride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>innermost_storage_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>storage_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a1a408f42e193bd67683fbbf5a38f69" name="a8a1a408f42e193bd67683fbbf5a38f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1a408f42e193bd67683fbbf5a38f69">&#9670;&#160;</a></span>compute_strides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_strides.html">Strides</a> Halide::Internal::Autoscheduler::LoopNest::compute_strides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>innermost_storage_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>storage_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a316d77e23131bb55355e211cd47bbf3d" name="a316d77e23131bb55355e211cd47bbf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316d77e23131bb55355e211cd47bbf3d">&#9670;&#160;</a></span>all_strides_exist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::all_strides_exist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>storage_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a815d18005c10e4d74d46623206724ed3" name="a815d18005c10e4d74d46623206724ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815d18005c10e4d74d46623206724ed3">&#9670;&#160;</a></span>get_actual_vector_dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::get_actual_vector_dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>store_bounds</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4981aed1ccfc3fabef7ebe005d40d533" name="a4981aed1ccfc3fabef7ebe005d40d533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4981aed1ccfc3fabef7ebe005d40d533">&#9670;&#160;</a></span>compute_gpu_store_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_gpu_store_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>consumer_innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer_store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu_loop_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inner_serial_loop_extents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer_site</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>feat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae3fadf36552c27ce324664469a78a571">GlobalMemInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>global_mem_loads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a0dee49c8d37a03171b297c441a5d9be4">SharedMemInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shared_mem_loads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ac8c19182b805ba107298469e242cb4ca">LocalMemInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>local_mem_loads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad74cf9acca55831316de26c9dd83398f" name="ad74cf9acca55831316de26c9dd83398f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74cf9acca55831316de26c9dd83398f">&#9670;&#160;</a></span>can_vectorize_access_for_innermost_dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::can_vectorize_access_for_innermost_dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>accessed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loop_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add9ecef6f243eb84b7de26d060d8ace9" name="add9ecef6f243eb84b7de26d060d8ace9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9ecef6f243eb84b7de26d060d8ace9">&#9670;&#160;</a></span>can_vectorize_store_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::can_vectorize_store_access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>accessed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>accessed_has_been_scheduled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loop_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mem_type</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66da14860cbf0999dbbe2d749989839f" name="a66da14860cbf0999dbbe2d749989839f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66da14860cbf0999dbbe2d749989839f">&#9670;&#160;</a></span>vectorized_load_access_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::vectorized_load_access_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>accessed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>accessed_has_been_scheduled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mem_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd6a176ceadde6bb4b77d2d9c6455001" name="afd6a176ceadde6bb4b77d2d9c6455001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6a176ceadde6bb4b77d2d9c6455001">&#9670;&#160;</a></span>vectorized_access_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::vectorized_access_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a></td>          <td class="paramname"><span class="paramname"><em>loop_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae59cc1fd5ebce95a84bd005f59743ff2" name="ae59cc1fd5ebce95a84bd005f59743ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59cc1fd5ebce95a84bd005f59743ff2">&#9670;&#160;</a></span>compute_num_mem_accesses_per_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_num_mem_accesses_per_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>num_requests_per_warp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aba8d2094e45bc0cfdbceebbea56a46d9">MemInfoType</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mem_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a661657ab456e469ef3b3087e41f11dd3" name="a661657ab456e469ef3b3087e41f11dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661657ab456e469ef3b3087e41f11dd3">&#9670;&#160;</a></span>compute_local_mem_store_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; Halide::Internal::Autoscheduler::LoopNest::compute_local_mem_store_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>consumer_innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer_store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>serial_loop_extents</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa15edb58a0a4b438411fdca95f78a6f0" name="aa15edb58a0a4b438411fdca95f78a6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15edb58a0a4b438411fdca95f78a6f0">&#9670;&#160;</a></span>compute_mem_store_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aba8d2094e45bc0cfdbceebbea56a46d9">MemInfoType</a>&lt; T &gt; Halide::Internal::Autoscheduler::LoopNest::compute_mem_store_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>consumer_innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer_store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>serial_loop_extents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adff8fb6c693507f1e3576fa938ad528e" name="adff8fb6c693507f1e3576fa938ad528e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff8fb6c693507f1e3576fa938ad528e">&#9670;&#160;</a></span>compute_mem_load_features()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_mem_load_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>producer_innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer_store_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>producer_has_been_scheduled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_thread_info.html">ThreadInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aba8d2094e45bc0cfdbceebbea56a46d9">MemInfoType</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mem_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>serial_loop_extents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa04c6e944adc1d2f6568bf4c7c24e5a4" name="aa04c6e944adc1d2f6568bf4c7c24e5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04c6e944adc1d2f6568bf4c7c24e5a4">&#9670;&#160;</a></span>compute_local_mem_stride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Halide::Internal::Autoscheduler::LoopNest::compute_local_mem_stride </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10fe9c73a8d90166b0e16003e5c02b07" name="a10fe9c73a8d90166b0e16003e5c02b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fe9c73a8d90166b0e16003e5c02b07">&#9670;&#160;</a></span>get_enclosing_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> * Halide::Internal::Autoscheduler::LoopNest::get_enclosing_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>grandparent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b36df5d4bcdad0a3571c0e1704f4a1d" name="a9b36df5d4bcdad0a3571c0e1704f4a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b36df5d4bcdad0a3571c0e1704f4a1d">&#9670;&#160;</a></span>get_block_and_serial_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; Halide::Internal::Autoscheduler::LoopNest::get_block_and_serial_extents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68fb9c6fa101fe66bf7314e7bfc65220" name="a68fb9c6fa101fe66bf7314e7bfc65220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fb9c6fa101fe66bf7314e7bfc65220">&#9670;&#160;</a></span>all_paths_to_leaves_have_thread_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::all_paths_to_leaves_have_thread_loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada154e1c7b3654511378e4d1b27a6dfd" name="ada154e1c7b3654511378e4d1b27a6dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada154e1c7b3654511378e4d1b27a6dfd">&#9670;&#160;</a></span>has_thread_loop_descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::has_thread_loop_descendant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2a8cc55353bc2f86bd68f94fc8d7b36" name="ae2a8cc55353bc2f86bd68f94fc8d7b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a8cc55353bc2f86bd68f94fc8d7b36">&#9670;&#160;</a></span>compute_warp_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_warp_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu_loop_info</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f537b8dff50dbcb84fb03f9c312b185" name="a6f537b8dff50dbcb84fb03f9c312b185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f537b8dff50dbcb84fb03f9c312b185">&#9670;&#160;</a></span>compute_warp_and_block_occupancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_warp_and_block_occupancy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>feat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu_loop_info</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83e9c3947b5314f4ee2d087aaaf485eb" name="a83e9c3947b5314f4ee2d087aaaf485eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9c3947b5314f4ee2d087aaaf485eb">&#9670;&#160;</a></span>compute_shared_mem_occupancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_shared_mem_occupancy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>total_shared_mem_alloc_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>feat</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed854487d481d7be972e36b8bd2be989" name="aed854487d481d7be972e36b8bd2be989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed854487d481d7be972e36b8bd2be989">&#9670;&#160;</a></span>find_innermost_and_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *, const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> * &gt; Halide::Internal::Autoscheduler::LoopNest::find_innermost_and_parent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a20f32a34d749395053cd5c771d0b45" name="a1a20f32a34d749395053cd5c771d0b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a20f32a34d749395053cd5c771d0b45">&#9670;&#160;</a></span>points_accessed_per_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::points_accessed_per_thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu_loop_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_edge.html">FunctionDAG::Edge</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_chain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>grandparent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>feat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>serial_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>producer_has_been_scheduled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>producer_innermost_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#acc39d142f0727a4676f66e7f73be00a6">GPUMemoryType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mem_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f1bca64273a1c2f7a5128c31f8d776a" name="a4f1bca64273a1c2f7a5128c31f8d776a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1bca64273a1c2f7a5128c31f8d776a">&#9670;&#160;</a></span>compute_licm_amortization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::compute_licm_amortization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>innermost</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>feat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_autoscheduler_1_1_load_jacobian.html">LoadJacobian</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>producer_dims</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f31b0d91691a9cc84494d1f936b57fb" name="a9f31b0d91691a9cc84494d1f936b57fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f31b0d91691a9cc84494d1f936b57fb">&#9670;&#160;</a></span>memoize_points_computed_minimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::memoize_points_computed_minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memoized_features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a044a85283c5c8a17d297c45845372f0b" name="a044a85283c5c8a17d297c45845372f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044a85283c5c8a17d297c45845372f0b">&#9670;&#160;</a></span>collect_producers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, int &gt; &gt; Halide::Internal::Autoscheduler::LoopNest::collect_producers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2409ae36da8ad0bdda29923e879886c" name="ac2409ae36da8ad0bdda29923e879886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2409ae36da8ad0bdda29923e879886c">&#9670;&#160;</a></span>compute_hash_of_producers_stored_at_root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> Halide::Internal::Autoscheduler::LoopNest::compute_hash_of_producers_stored_at_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c413022bf18c1383c94f236d77dff6a" name="a5c413022bf18c1383c94f236d77dff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c413022bf18c1383c94f236d77dff6a">&#9670;&#160;</a></span>collect_stages() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::collect_stages </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>stages</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa36429ae4c9844b103b1e437c1ff6214" name="aa36429ae4c9844b103b1e437c1ff6214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36429ae4c9844b103b1e437c1ff6214">&#9670;&#160;</a></span>memoize_features() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::memoize_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memoized_features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd1db0a086a53162594fdd921f6bd089" name="afd1db0a086a53162594fdd921f6bd089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1db0a086a53162594fdd921f6bd089">&#9670;&#160;</a></span>compute_working_set_from_features() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_working_set_from_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>working_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a317ccf53146ba48b5e0b182d3bbbc335" name="a317ccf53146ba48b5e0b182d3bbbc335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317ccf53146ba48b5e0b182d3bbbc335">&#9670;&#160;</a></span>recompute_inlined_features() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::recompute_inlined_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2e355884d51b4a2002b6d577627046a" name="af2e355884d51b4a2002b6d577627046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e355884d51b4a2002b6d577627046a">&#9670;&#160;</a></span>compute_alloc_size_of_node_here()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, bool &gt; Halide::Internal::Autoscheduler::LoopNest::compute_alloc_size_of_node_here </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbd241530c06f439b697e6e0c6a48fef" name="acbd241530c06f439b697e6e0c6a48fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd241530c06f439b697e6e0c6a48fef">&#9670;&#160;</a></span>compute_features() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::compute_features </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g.html">FunctionDAG</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_sites.html">Sites</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>grandparent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a></td>          <td class="paramname"><span class="paramname"><em>gpu_loop_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_memoized_features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>total_shared_mem_alloc_sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>working_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>working_set_local_constant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>working_set_local_dynamic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_statistics.html">Statistics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10a223dd58020296550794c6bf129da9" name="a10a223dd58020296550794c6bf129da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a223dd58020296550794c6bf129da9">&#9670;&#160;</a></span>is_root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::is_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00477">477</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00057">node</a>.</p>

</div>
</div>
<a id="a9b3b304710f7dc062a900318c69232dd" name="a9b3b304710f7dc062a900318c69232dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3b304710f7dc062a900318c69232dd">&#9670;&#160;</a></span>set_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp; Halide::Internal::Autoscheduler::LoopNest::set_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_bound_contents.html">BoundContents</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00484">484</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">References <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00054">bounds</a>.</p>

</div>
</div>
<a id="a6592c2d55886ea8830084a0b10a8ca1f" name="a6592c2d55886ea8830084a0b10a8ca1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592c2d55886ea8830084a0b10a8ca1f">&#9670;&#160;</a></span>get_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &amp; Halide::Internal::Autoscheduler::LoopNest::get_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61218f2bab05d6542da4ea7a4990caaa" name="a61218f2bab05d6542da4ea7a4990caaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61218f2bab05d6542da4ea7a4990caaa">&#9670;&#160;</a></span>get_bounds_along_edge_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> Halide::Internal::Autoscheduler::LoopNest::get_bounds_along_edge_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_edge.html">FunctionDAG::Edge</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_chain</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addbc3337efa1e23b13ce51456bdf9927" name="addbc3337efa1e23b13ce51456bdf9927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbc3337efa1e23b13ce51456bdf9927">&#9670;&#160;</a></span>dump() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa980686372412b174e4e6126b112f9ba" name="aa980686372412b174e4e6126b112f9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa980686372412b174e4e6126b112f9ba">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::Autoscheduler::LoopNest::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a290e390e7fb6b77bb003dbd6e1a7041e" name="a290e390e7fb6b77bb003dbd6e1a7041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290e390e7fb6b77bb003dbd6e1a7041e">&#9670;&#160;</a></span>dump() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::dump </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace9956684575ca9b6fa66e07a4d66683" name="ace9956684575ca9b6fa66e07a4d66683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9956684575ca9b6fa66e07a4d66683">&#9670;&#160;</a></span>calls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac432ada24cc10cd43063f60d1efea0a4" name="ac432ada24cc10cd43063f60d1efea0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac432ada24cc10cd43063f60d1efea0a4">&#9670;&#160;</a></span>max_inlined_calls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::max_inlined_calls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6006fced11249a63ebf64feb92f93ed7" name="a6006fced11249a63ebf64feb92f93ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6006fced11249a63ebf64feb92f93ed7">&#9670;&#160;</a></span>accesses_input_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::accesses_input_buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b3efad3daf1cb27a5cb4bec6a6d36c6" name="a8b3efad3daf1cb27a5cb4bec6a6d36c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3efad3daf1cb27a5cb4bec6a6d36c6">&#9670;&#160;</a></span>computes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::computes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32389f73bb4534c1b403ee089dac4cea" name="a32389f73bb4534c1b403ee089dac4cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32389f73bb4534c1b403ee089dac4cea">&#9670;&#160;</a></span>inline_func() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::inline_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af60d69c2598848b6e2dd6a14f1559659" name="af60d69c2598848b6e2dd6a14f1559659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60d69c2598848b6e2dd6a14f1559659">&#9670;&#160;</a></span>compute_here() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::compute_here </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tileable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_threads_loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa325a13ccb33b57a8539c9c90bb6d2e9" name="aa325a13ccb33b57a8539c9c90bb6d2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa325a13ccb33b57a8539c9c90bb6d2e9">&#9670;&#160;</a></span>parallelize_in_tiles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; Halide::Internal::Autoscheduler::LoopNest::parallelize_in_tiles </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tiling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inner_tiling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>adjust_tiling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>move_all_rvars_inward</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rvars_to_move_inward</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af64fe08a48eef7bd38fca63e4a9d2138" name="af64fe08a48eef7bd38fca63e4a9d2138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64fe08a48eef7bd38fca63e4a9d2138">&#9670;&#160;</a></span>get_total_local_mem_alloc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::get_total_local_mem_alloc_size </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>constant_allocs_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_threads_loop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a647e0a028d9a94f9f4e8ad80d14a8192" name="a647e0a028d9a94f9f4e8ad80d14a8192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647e0a028d9a94f9f4e8ad80d14a8192">&#9670;&#160;</a></span>get_total_constant_local_mem_alloc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::get_total_constant_local_mem_alloc_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50cbca9c1975632bd983a2e7e2699e66" name="a50cbca9c1975632bd983a2e7e2699e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cbca9c1975632bd983a2e7e2699e66">&#9670;&#160;</a></span>requires_dynamic_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::requires_dynamic_allocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_threads_loop</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0906e3b97bc78facec998382a14b6c18" name="a0906e3b97bc78facec998382a14b6c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0906e3b97bc78facec998382a14b6c18">&#9670;&#160;</a></span>compute_in_tiles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> &gt; &gt; Halide::Internal::Autoscheduler::LoopNest::compute_in_tiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_anderson2021_params.html">Anderson2021Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_search_space_options.html">SearchSpaceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>search_space_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_realization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>in_threads_loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_pre_pass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>union_counts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">vector&lt;&#160;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;&gt;()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f4540b511e8256749b311a198847ef9" name="a9f4540b511e8256749b311a198847ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4540b511e8256749b311a198847ef9">&#9670;&#160;</a></span>has_constant_region_computed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::has_constant_region_computed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a411b818755a3a986dbe7b989c8af2b" name="a1a411b818755a3a986dbe7b989c8af2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a411b818755a3a986dbe7b989c8af2b">&#9670;&#160;</a></span>has_constant_region_required()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::has_constant_region_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8c50018057e8e80ab28a651d1cfbb12" name="ac8c50018057e8e80ab28a651d1cfbb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c50018057e8e80ab28a651d1cfbb12">&#9670;&#160;</a></span>other_stage_has_same_producer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::other_stage_has_same_producer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>producer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14300d753b33d15988b9d4e595c9a99f" name="a14300d753b33d15988b9d4e595c9a99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14300d753b33d15988b9d4e595c9a99f">&#9670;&#160;</a></span>num_serial_loops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::num_serial_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> *</td>          <td class="paramname"><span class="paramname"><em>stage</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ab93fe46df7741fd556514bd75f95a5" name="a1ab93fe46df7741fd556514bd75f95a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab93fe46df7741fd556514bd75f95a5">&#9670;&#160;</a></span>num_serial_loops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::num_serial_loops </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d455dc8d32e4b8b63e6869b86598bc" name="ad1d455dc8d32e4b8b63e6869b86598bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d455dc8d32e4b8b63e6869b86598bc">&#9670;&#160;</a></span>producer_computed_here_or_further_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::producer_computed_here_or_further_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>producer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad92033c0099e44d37bb92cfb5f262cf9" name="ad92033c0099e44d37bb92cfb5f262cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92033c0099e44d37bb92cfb5f262cf9">&#9670;&#160;</a></span>update_producers_to_be_staged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::update_producers_to_be_staged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>all_inlined</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a64e691432204114b166c433d277395" name="a3a64e691432204114b166c433d277395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a64e691432204114b166c433d277395">&#9670;&#160;</a></span>region_computed_shrinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::region_computed_shrinks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cd4f1df3d29823eec2ee113449ea20d" name="a7cd4f1df3d29823eec2ee113449ea20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd4f1df3d29823eec2ee113449ea20d">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td>          <td class="paramname"><span class="paramname"><em>here</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>state_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>num_cores</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>compute_site</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_stage_schedule_state.html">StageScheduleState</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ancestors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>all_inlined</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafba95030bc7ef16c6cdacb912b17a41" name="aafba95030bc7ef16c6cdacb912b17a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafba95030bc7ef16c6cdacb912b17a41">&#9670;&#160;</a></span>max_idle_lane_wastage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Halide::Internal::Autoscheduler::LoopNest::max_idle_lane_wastage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_g_p_u_loop_info.html">GPULoopInfo</a></td>          <td class="paramname"><span class="paramname"><em>gpu_loop_info</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b6e5a73c4f75b14d46012508cc8ac8b" name="a7b6e5a73c4f75b14d46012508cc8ac8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6e5a73c4f75b14d46012508cc8ac8b">&#9670;&#160;</a></span>has_valid_thread_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::has_valid_thread_extents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a00676947afac86b2374c2736275bb7" name="a7a00676947afac86b2374c2736275bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a00676947afac86b2374c2736275bb7">&#9670;&#160;</a></span>collect_nodes_that_should_be_inlined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::collect_nodes_that_should_be_inlined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes_to_freeze</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inlined_nodes</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3ce33be4ac6505cf3cf84a1905f67cc" name="aa3ce33be4ac6505cf3cf84a1905f67cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ce33be4ac6505cf3cf84a1905f67cc">&#9670;&#160;</a></span>collect_all_inlined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::collect_all_inlined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>all_inlined</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ffc82f121129811ad60af057510a7fc" name="a2ffc82f121129811ad60af057510a7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffc82f121129811ad60af057510a7fc">&#9670;&#160;</a></span>product_of_self_and_descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::product_of_self_and_descendants </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loop_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ff6db1bbd8a477830f85795cc7745e4" name="a4ff6db1bbd8a477830f85795cc7745e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff6db1bbd8a477830f85795cc7745e4">&#9670;&#160;</a></span>product_of_descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::Autoscheduler::LoopNest::product_of_descendants </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loop_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8e7681449082af52126245bd01aafdc" name="ac8e7681449082af52126245bd01aafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e7681449082af52126245bd01aafdc">&#9670;&#160;</a></span>get_stages_computed_in_each_compute_root_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Autoscheduler::LoopNest::get_stages_computed_in_each_compute_root_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt; bool &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>descendants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a> *</td>          <td class="paramname"><span class="paramname"><em>compute_root_loop_nest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab9a1e0d893e5f721cb35e6bc347d74ae" name="ab9a1e0d893e5f721cb35e6bc347d74ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a1e0d893e5f721cb35e6bc347d74ae">&#9670;&#160;</a></span>ref_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> Halide::Internal::Autoscheduler::LoopNest::ref_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00035">35</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a60ab63803a47071cb7d0bead75019ff6" name="a60ab63803a47071cb7d0bead75019ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ab63803a47071cb7d0bead75019ff6">&#9670;&#160;</a></span>size <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt; Halide::Internal::Autoscheduler::LoopNest::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00039">39</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00160">is_scalar()</a>.</p>

</div>
</div>
<a id="a95a1081e0362927e821532d09c492ffc" name="a95a1081e0362927e821532d09c492ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a1081e0362927e821532d09c492ffc">&#9670;&#160;</a></span>children <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt;const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a>&gt; &gt; Halide::Internal::Autoscheduler::LoopNest::children</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00042">42</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="anderson2021_2_state_8h_source.html#l00050">Halide::Internal::Autoscheduler::deep_copy_loop_nest()</a>, <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00091">funcs_realized_or_inlined()</a>, and <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00120">set_working_set_at_task_feature()</a>.</p>

</div>
</div>
<a id="afa174b40f80ba38486c3dec1ef3808a0" name="afa174b40f80ba38486c3dec1ef3808a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa174b40f80ba38486c3dec1ef3808a0">&#9670;&#160;</a></span>inlined</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> &gt; Halide::Internal::Autoscheduler::LoopNest::inlined</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00046">46</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00091">funcs_realized_or_inlined()</a>.</p>

</div>
</div>
<a id="aedb584f3dab343d643d76c925813ed07" name="aedb584f3dab343d643d76c925813ed07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb584f3dab343d643d76c925813ed07">&#9670;&#160;</a></span>store_at</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> * &gt; Halide::Internal::Autoscheduler::LoopNest::store_at</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00049">49</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00091">funcs_realized_or_inlined()</a>.</p>

</div>
</div>
<a id="ac14b1dcccf2d067391be02f4306b2c97" name="ac14b1dcccf2d067391be02f4306b2c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14b1dcccf2d067391be02f4306b2c97">&#9670;&#160;</a></span>bounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#aa43a24bcef0bbcffede120503306ca82">NodeMap</a>&lt; <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a2a011e42e84f52018eba5ee85308452b">Bound</a> &gt; Halide::Internal::Autoscheduler::LoopNest::bounds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00054">54</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00148">set_bounds()</a>.</p>

</div>
</div>
<a id="a239a35e4125fe2c91cdcc2d0d5c2a1b6" name="a239a35e4125fe2c91cdcc2d0d5c2a1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239a35e4125fe2c91cdcc2d0d5c2a1b6">&#9670;&#160;</a></span>node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node.html">FunctionDAG::Node</a> * Halide::Internal::Autoscheduler::LoopNest::node = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00057">57</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00141">is_root()</a>.</p>

</div>
</div>
<a id="ac451c4521ccf418a9e05a6d5d8b1e9e1" name="ac451c4521ccf418a9e05a6d5d8b1e9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac451c4521ccf418a9e05a6d5d8b1e9e1">&#9670;&#160;</a></span>stage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_function_d_a_g_1_1_node_1_1_stage.html">FunctionDAG::Node::Stage</a> * Halide::Internal::Autoscheduler::LoopNest::stage = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00060">60</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="ac7da95f17badb497858c6a4ac2516ca3" name="ac7da95f17badb497858c6a4ac2516ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7da95f17badb497858c6a4ac2516ca3">&#9670;&#160;</a></span>innermost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::innermost = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00063">63</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a8f782ad834ede04dac6a52a66517c8bd" name="a8f782ad834ede04dac6a52a66517c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f782ad834ede04dac6a52a66517c8bd">&#9670;&#160;</a></span>tileable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::tileable = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00066">66</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="ace6549b94773e60c3d2e61a7b925a24a" name="ace6549b94773e60c3d2e61a7b925a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6549b94773e60c3d2e61a7b925a24a">&#9670;&#160;</a></span>parallel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Autoscheduler::LoopNest::parallel = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00069">69</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a77d5faa6e442d6e06b9d6a8af3ca9b90" name="a77d5faa6e442d6e06b9d6a8af3ca9b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d5faa6e442d6e06b9d6a8af3ca9b90">&#9670;&#160;</a></span>vector_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::vector_dim = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00072">72</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a0aed41f28aca14d26b722edd02d6be7a" name="a0aed41f28aca14d26b722edd02d6be7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aed41f28aca14d26b722edd02d6be7a">&#9670;&#160;</a></span>vectorized_loop_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Autoscheduler::LoopNest::vectorized_loop_index = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00075">75</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="af14ca27d131bf6cec47ac8677f294f1f" name="af14ca27d131bf6cec47ac8677f294f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14ca27d131bf6cec47ac8677f294f1f">&#9670;&#160;</a></span>feature_intermediates_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt;<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_feature_intermediates.html">FeatureIntermediates</a>&gt; &gt; &gt; Halide::Internal::Autoscheduler::LoopNest::feature_intermediates_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00265">265</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a877515df2909b8ce495cf7109cc1afcf" name="a877515df2909b8ce495cf7109cc1afcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877515df2909b8ce495cf7109cc1afcf">&#9670;&#160;</a></span>features_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a>&gt; &gt; Halide::Internal::Autoscheduler::LoopNest::features_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00267">267</a> of file <a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="ae322fdeca7f5d3b43074a1b7aff206f2" name="ae322fdeca7f5d3b43074a1b7aff206f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae322fdeca7f5d3b43074a1b7aff206f2">&#9670;&#160;</a></span>size <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt; Halide::Internal::Autoscheduler::LoopNest::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00092">92</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="adf750fc8ea75db7220e9fdc6a6ddc0c3" name="adf750fc8ea75db7220e9fdc6a6ddc0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf750fc8ea75db7220e9fdc6a6ddc0c3">&#9670;&#160;</a></span>children <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt;const <a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a>&gt; &gt; Halide::Internal::Autoscheduler::LoopNest::children</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00095">95</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a30340933c8356bb7dc31cca05ade37e1" name="a30340933c8356bb7dc31cca05ade37e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30340933c8356bb7dc31cca05ade37e1">&#9670;&#160;</a></span>gpu_label</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eaf">GPU_parallelism</a> Halide::Internal::Autoscheduler::LoopNest::gpu_label = <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#ae063b91283459055973d70b2f8798eafa6adf97f83acf6453d4a6a4b1070f3754">GPU_parallelism::None</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00131">131</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00156">is_gpu_block()</a>, <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00148">is_gpu_serial()</a>, and <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00152">is_gpu_thread()</a>.</p>

</div>
</div>
<a id="a80f051ddbddd686d87c59dec742ffcf1" name="a80f051ddbddd686d87c59dec742ffcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f051ddbddd686d87c59dec742ffcf1">&#9670;&#160;</a></span>feature_intermediates</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt;<a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest_1_1_feature_intermediates.html">FeatureIntermediates</a>&gt; &gt; &gt; Halide::Internal::Autoscheduler::LoopNest::feature_intermediates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00145">145</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

</div>
</div>
<a id="a1b6e98505d41561dd26dc62a4871a40e" name="a1b6e98505d41561dd26dc62a4871a40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6e98505d41561dd26dc62a4871a40e">&#9670;&#160;</a></span>features</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html#a1c0e655e493b2c5c52843c426f7f2256">StageMap</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a>&gt; &gt; Halide::Internal::Autoscheduler::LoopNest::features</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="anderson2021_2_loop_nest_8h_source.html#l00146">146</a> of file <a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adams2019_2_loop_nest_8h_source.html#l00120">set_working_set_at_task_feature()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/autoschedulers/adams2019/<a class="el" href="adams2019_2_loop_nest_8h_source.html">LoopNest.h</a></li>
<li>src/autoschedulers/anderson2021/<a class="el" href="anderson2021_2_loop_nest_8h_source.html">LoopNest.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html">Autoscheduler</a></li><li class="navelem"><a class="el" href="struct_halide_1_1_internal_1_1_autoscheduler_1_1_loop_nest.html">LoopNest</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
