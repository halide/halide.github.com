<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: /Users/areinking/dev/Halide/src/runtime/HalideRuntime.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_halide_runtime_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">HalideRuntime.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file declares the routines used by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> internally in its runtime.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="_halide_runtime_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__mutex.html">halide_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform mutex.  <a href="structhalide__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__cond.html">halide_cond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross platform condition variable.  <a href="structhalide__cond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque struct representing a semaphore.  <a href="structhalide__semaphore__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__semaphore__acquire__t.html">halide_semaphore_acquire_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing a semaphore and a number of items that must be acquired from it.  <a href="structhalide__semaphore__acquire__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel task to be passed to halide_do_parallel_tasks.  <a href="structhalide__parallel__task__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__type__t.html">halide_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime tag for a type in the halide type system.  <a href="structhalide__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__trace__packet__t.html">halide_trace_packet_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header of a packet in a binary trace.  <a href="structhalide__trace__packet__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each GPU API provides a <a class="el" href="structhalide__device__interface__t.html" title="Each GPU API provides a halide_device_interface_t struct pointing to the code that manages device all...">halide_device_interface_t</a> struct pointing to the code that manages device allocations.  <a href="structhalide__device__interface__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code.  <a href="structhalide__buffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhalide__scalar__value__t.html" title="halide_scalar_value_t is a simple union able to represent all the well-known scalar values in a filte...">halide_scalar_value_t</a> is a simple union able to represent all the well-known scalar values in a filter argument.  <a href="structhalide__scalar__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__argument__t__v0.html">halide_filter_argument_t_v0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obsolete version of <a class="el" href="structhalide__filter__argument__t.html" title="halide_filter_argument_t is essentially a plain-C-struct equivalent to Halide::Argument; most user co...">halide_filter_argument_t</a>; only present in code that wrote <a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a> version 0.  <a href="structhalide__filter__argument__t__v0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__argument__t.html">halide_filter_argument_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhalide__filter__argument__t.html" title="halide_filter_argument_t is essentially a plain-C-struct equivalent to Halide::Argument; most user co...">halide_filter_argument_t</a> is essentially a plain-C-struct equivalent to <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Halide::Argument</a>; most user code will never need to create one.  <a href="structhalide__filter__argument__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global state of the profiler.  <a href="structhalide__profiler__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__device__allocation__pool.html">halide_device_allocation_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a216875cf28091f8e34d7528225e7a20a" id="r_a216875cf28091f8e34d7528225e7a20a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a216875cf28091f8e34d7528225e7a20a">HALIDE_VERSION_MAJOR</a>&#160;&#160;&#160;19</td></tr>
<tr class="separator:a216875cf28091f8e34d7528225e7a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0647c3b72552add6d9e1a3cf77505151" id="r_a0647c3b72552add6d9e1a3cf77505151"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0647c3b72552add6d9e1a3cf77505151">HALIDE_VERSION_MINOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a0647c3b72552add6d9e1a3cf77505151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a01eec46b85c91844f7a89a969a77d0" id="r_a1a01eec46b85c91844f7a89a969a77d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a01eec46b85c91844f7a89a969a77d0">HALIDE_VERSION_PATCH</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a1a01eec46b85c91844f7a89a969a77d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c2048ce1a292798d15d9dc3346de26" id="r_ac0c2048ce1a292798d15d9dc3346de26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a>&#160;&#160;&#160;inline __attribute__((always_inline))</td></tr>
<tr class="separator:ac0c2048ce1a292798d15d9dc3346de26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5c75e0994add0b42829f89d0bf3345" id="r_aaf5c75e0994add0b42829f89d0bf3345"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a>&#160;&#160;&#160;__attribute__((noinline))</td></tr>
<tr class="separator:aaf5c75e0994add0b42829f89d0bf3345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f587d17af0ba4c115547bcd9c873fd" id="r_ab4f587d17af0ba4c115547bcd9c873fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4f587d17af0ba4c115547bcd9c873fd">HALIDE_MUST_USE_RESULT</a></td></tr>
<tr class="separator:ab4f587d17af0ba4c115547bcd9c873fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83937d3cfac5d949807b5f9522cb7fde" id="r_a83937d3cfac5d949807b5f9522cb7fde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83937d3cfac5d949807b5f9522cb7fde">HALIDE_FUNCTION_ATTRS</a></td></tr>
<tr class="separator:a83937d3cfac5d949807b5f9522cb7fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011fabf6af2c9c965cacaf866d579f8a" id="r_a011fabf6af2c9c965cacaf866d579f8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a011fabf6af2c9c965cacaf866d579f8a">HALIDE_EXPORT_SYMBOL</a>&#160;&#160;&#160;__attribute__((visibility(&quot;default&quot;)))</td></tr>
<tr class="separator:a011fabf6af2c9c965cacaf866d579f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa0f73fc7954ac27a2c11020681cdf3" id="r_afaa0f73fc7954ac27a2c11020681cdf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa0f73fc7954ac27a2c11020681cdf3">HALIDE_ATTRIBUTE_ALIGN</a>(x)</td></tr>
<tr class="separator:afaa0f73fc7954ac27a2c11020681cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb1030f4a2614c18adb6d088529f911" id="r_a9bb1030f4a2614c18adb6d088529f911"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb1030f4a2614c18adb6d088529f911">HALIDE_ATTRIBUTE_DEPRECATED</a>(x)</td></tr>
<tr class="separator:a9bb1030f4a2614c18adb6d088529f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a95ff0cf917a42d9d94858d965f0cea70" id="r_a95ff0cf917a42d9d94858d965f0cea70"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ff0cf917a42d9d94858d965f0cea70">halide_print_t</a>) (void *, const char *)</td></tr>
<tr class="separator:a95ff0cf917a42d9d94858d965f0cea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ba9ee9334354b8b260138b464bdaac" id="r_a51ba9ee9334354b8b260138b464bdaac"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51ba9ee9334354b8b260138b464bdaac">halide_error_handler_t</a>) (void *, const char *)</td></tr>
<tr class="separator:a51ba9ee9334354b8b260138b464bdaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ad38bc9436040001a7fa8806e9a1a4" id="r_a44ad38bc9436040001a7fa8806e9a1a4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a>) (void *user_context, int task_number, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a44ad38bc9436040001a7fa8806e9a1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <br /></td></tr>
<tr class="separator:a44ad38bc9436040001a7fa8806e9a1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e17d010d9d296d3133f1b34060cda6" id="r_a35e17d010d9d296d3133f1b34060cda6"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a>) (void *, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a>, int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="memdesc:a35e17d010d9d296d3133f1b34060cda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom method for performing a parallel for loop.  <br /></td></tr>
<tr class="separator:a35e17d010d9d296d3133f1b34060cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af757a561193139295a85256e68135" id="r_ae0af757a561193139295a85256e68135"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0af757a561193139295a85256e68135">halide_semaphore_init_t</a>) (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int)</td></tr>
<tr class="separator:ae0af757a561193139295a85256e68135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187d0100ae8d267bbcb6e840433c0f72" id="r_a187d0100ae8d267bbcb6e840433c0f72"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a187d0100ae8d267bbcb6e840433c0f72">halide_semaphore_release_t</a>) (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int)</td></tr>
<tr class="separator:a187d0100ae8d267bbcb6e840433c0f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97edf37f8f01638b513e24f9173b489f" id="r_a97edf37f8f01638b513e24f9173b489f"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97edf37f8f01638b513e24f9173b489f">halide_semaphore_try_acquire_t</a>) (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int)</td></tr>
<tr class="separator:a97edf37f8f01638b513e24f9173b489f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33673c0e9af6749f566f32386b168c4" id="r_aa33673c0e9af6749f566f32386b168c4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a>) (void *user_context, int min, int extent, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure, void *task_parent)</td></tr>
<tr class="memdesc:aa33673c0e9af6749f566f32386b168c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task representing a serial for loop evaluated over some range.  <br /></td></tr>
<tr class="separator:aa33673c0e9af6749f566f32386b168c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc89fad6bf8607479e7643d17c973bd9" id="r_acc89fad6bf8607479e7643d17c973bd9"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a>) (void *, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="memdesc:acc89fad6bf8607479e7643d17c973bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the default do_par_for, you can still set a custom handler to perform each individual task.  <br /></td></tr>
<tr class="separator:acc89fad6bf8607479e7643d17c973bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98cafa58d17ab564e0783acb88c8bc" id="r_a7e98cafa58d17ab564e0783acb88c8bc"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a>) (void *, <a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a>, int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *, void *)</td></tr>
<tr class="memdesc:a7e98cafa58d17ab564e0783acb88c8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version of do_task called for loop tasks.  <br /></td></tr>
<tr class="separator:a7e98cafa58d17ab564e0783acb88c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd29e5ed7d54ed3d92cb745915ef8909" id="r_afd29e5ed7d54ed3d92cb745915ef8909"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd29e5ed7d54ed3d92cb745915ef8909">halide_do_parallel_tasks_t</a>) (void *, int, struct <a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a> *, void *task_parent)</td></tr>
<tr class="memdesc:afd29e5ed7d54ed3d92cb745915ef8909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an entire custom tasking runtime via function pointers.  <br /></td></tr>
<tr class="separator:afd29e5ed7d54ed3d92cb745915ef8909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4628363dd76e044feb9aa8280a1b84" id="r_aed4628363dd76e044feb9aa8280a1b84"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4628363dd76e044feb9aa8280a1b84">halide_malloc_t</a>) (void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)</td></tr>
<tr class="separator:aed4628363dd76e044feb9aa8280a1b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17654ef6deb96a3aef03126bd35221a" id="r_aa17654ef6deb96a3aef03126bd35221a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa17654ef6deb96a3aef03126bd35221a">halide_free_t</a>) (void *, void *)</td></tr>
<tr class="separator:aa17654ef6deb96a3aef03126bd35221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1424c74013b0adc86c02878c407fb5" id="r_a7a1424c74013b0adc86c02878c407fb5"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a1424c74013b0adc86c02878c407fb5">halide_get_symbol_t</a>) (const char *name)</td></tr>
<tr class="separator:a7a1424c74013b0adc86c02878c407fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169fd95ae0b4b9e080896cedc4adbd8e" id="r_a169fd95ae0b4b9e080896cedc4adbd8e"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a169fd95ae0b4b9e080896cedc4adbd8e">halide_load_library_t</a>) (const char *name)</td></tr>
<tr class="separator:a169fd95ae0b4b9e080896cedc4adbd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2788d811e1a39b30870b1d6b94d7826e" id="r_a2788d811e1a39b30870b1d6b94d7826e"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2788d811e1a39b30870b1d6b94d7826e">halide_get_library_symbol_t</a>) (void *lib, const char *name)</td></tr>
<tr class="separator:a2788d811e1a39b30870b1d6b94d7826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a57ef65fae60e9b7e3a1bc09f38c14" id="r_a64a57ef65fae60e9b7e3a1bc09f38c14"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a57ef65fae60e9b7e3a1bc09f38c14">halide_type_code_t</a></td></tr>
<tr class="memdesc:a64a57ef65fae60e9b7e3a1bc09f38c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <br /></td></tr>
<tr class="separator:a64a57ef65fae60e9b7e3a1bc09f38c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac84473600d9caee1f3ab634cb117ba" id="r_acac84473600d9caee1f3ab634cb117ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acac84473600d9caee1f3ab634cb117ba">halide_trace_t</a>) (void *user_context, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *)</td></tr>
<tr class="separator:acac84473600d9caee1f3ab634cb117ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215e0bf22f304152800a8e2d23ccee4c" id="r_a215e0bf22f304152800a8e2d23ccee4c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215e0bf22f304152800a8e2d23ccee4c">halide_target_feature_t</a></td></tr>
<tr class="memdesc:a215e0bf22f304152800a8e2d23ccee4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a compilation Target can have.  <br /></td></tr>
<tr class="separator:a215e0bf22f304152800a8e2d23ccee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7756790d1df276babe85759aecb9214e" id="r_a7756790d1df276babe85759aecb9214e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7756790d1df276babe85759aecb9214e">halide_can_use_target_features_t</a>) (int count, const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *features)</td></tr>
<tr class="separator:a7756790d1df276babe85759aecb9214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f13e7e8488c33a21bdfefb666823be0" id="r_a6f13e7e8488c33a21bdfefb666823be0"><td class="memItemLeft" align="right" valign="top">typedef struct halide_dimension_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f13e7e8488c33a21bdfefb666823be0">halide_dimension_t</a></td></tr>
<tr class="separator:a6f13e7e8488c33a21bdfefb666823be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80b56521d2a957df55d69ab81589a0" id="r_aff80b56521d2a957df55d69ab81589a0"><td class="memItemLeft" align="right" valign="top">typedef struct halide_buffer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff80b56521d2a957df55d69ab81589a0">halide_buffer_t</a></td></tr>
<tr class="memdesc:aff80b56521d2a957df55d69ab81589a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code.  <br /></td></tr>
<tr class="separator:aff80b56521d2a957df55d69ab81589a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9f4c40f298e91dea4f532774dc57a450" id="r_a9f4c40f298e91dea4f532774dc57a450"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a> { <br />
&#160;&#160;<a class="el" href="#a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa">halide_type_int</a> = 0
, <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d">halide_type_uint</a> = 1
, <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b">halide_type_float</a> = 2
, <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef">halide_type_handle</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a9f4c40f298e91dea4f532774dc57a450a33f41ea25f7f5bb3ed43a303d9787d1e">halide_type_bfloat</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a9f4c40f298e91dea4f532774dc57a450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="#a9f4c40f298e91dea4f532774dc57a450">More...</a><br /></td></tr>
<tr class="separator:a9f4c40f298e91dea4f532774dc57a450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485130f12eb8bb5fa5a9478eeb6b0dfa" id="r_a485130f12eb8bb5fa5a9478eeb6b0dfa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfa">halide_trace_event_code_t</a> { <br />
&#160;&#160;<a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaa2cbd3048c959f6d8def944097d8e21c9">halide_trace_load</a> = 0
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaa57b32d087e0862bd6ba748ce7743a851">halide_trace_store</a> = 1
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaad8657c19f6b2b9cc79fa3a438f39687b">halide_trace_begin_realization</a> = 2
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaacb0bdc3e4044609ab7fae05b921595ab">halide_trace_end_realization</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaac4047c93cd032261e8373e38944bf7a1">halide_trace_produce</a> = 4
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaac0c72771e1401fad47e3234caa121427">halide_trace_end_produce</a> = 5
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaa0dac17982d8ef6c404f94e5b7dd4de54">halide_trace_consume</a> = 6
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaac98849a734841652345dc3d37660c136">halide_trace_end_consume</a> = 7
, <br />
&#160;&#160;<a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaa7b9317d3544502c02e018db4bac2b97e">halide_trace_begin_pipeline</a> = 8
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaa92151c79c44b19ad2c1074fb6f113b1c">halide_trace_end_pipeline</a> = 9
, <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfaa30020f90f4631cab975d7afa75875f01">halide_trace_tag</a> = 10
<br />
 }</td></tr>
<tr class="separator:a485130f12eb8bb5fa5a9478eeb6b0dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba16e170cc9aa30b78ff703e101a448c" id="r_aba16e170cc9aa30b78ff703e101a448c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba16e170cc9aa30b78ff703e101a448c">halide_error_code_t</a> { <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04">halide_error_code_success</a> = 0
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05">halide_error_code_generic_error</a> = -1
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c">halide_error_code_explicit_bounds_too_small</a> = -2
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cac864d0a2ca831c3c757b6e410d8cdd3f">halide_error_code_bad_type</a> = -3
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea">halide_error_code_access_out_of_bounds</a> = -4
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6">halide_error_code_buffer_allocation_too_large</a> = -5
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b">halide_error_code_buffer_extents_too_large</a> = -6
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6">halide_error_code_constraints_make_required_region_smaller</a> = -7
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334">halide_error_code_constraint_violated</a> = -8
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8">halide_error_code_param_too_small</a> = -9
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c">halide_error_code_param_too_large</a> = -10
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0">halide_error_code_out_of_memory</a> = -11
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a">halide_error_code_buffer_argument_is_null</a> = -12
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff">halide_error_code_debug_to_file_failed</a> = -13
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636">halide_error_code_copy_to_host_failed</a> = -14
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54">halide_error_code_copy_to_device_failed</a> = -15
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb">halide_error_code_device_malloc_failed</a> = -16
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952">halide_error_code_device_sync_failed</a> = -17
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1">halide_error_code_device_free_failed</a> = -18
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956">halide_error_code_no_device_interface</a> = -19
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0fb6033e4cda78003a8e3e224fce8834">halide_error_code_unimplemented</a> = -20
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0218e9271bc4857117e70b86c326d6bf">halide_error_code_symbol_not_found</a> = -21
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867">halide_error_code_internal_error</a> = -22
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cacf7f17603b30be3f4df86d701df4ee2a">halide_error_code_device_run_failed</a> = -23
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448caf843735e0a784d64e56fcff6069cdb5d">halide_error_code_unaligned_host_ptr</a> = -24
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca07b8321ceede9444ea7bba637a9bb7c1">halide_error_code_bad_fold</a> = -25
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0a42d062cb8da32cf5158daab9c37c41">halide_error_code_fold_factor_too_small</a> = -26
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca180c55e696deec0e26fc4b82fadefd4c">halide_error_code_requirement_failed</a> = -27
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca2b91673e6f8ed8585e1571a03173ea22">halide_error_code_buffer_extents_negative</a> = -28
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448caa3fbac5e442e92463d4759bc05b013de">halide_error_code_gpu_device_error</a> = -29
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca636cfe40bc322d3404e7a2822e75585c">halide_error_code_trace_failed</a> = -30
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0e0b319ab036506ee80df45c1f5cdac0">halide_error_code_specialize_fail</a> = -31
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448caf62f07052c51fb9e472d4cf6c532a7c8">halide_error_code_device_wrap_native_failed</a> = -32
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cae266cbe94993fa5d35f132f9c328d2db">halide_error_code_device_detach_native_failed</a> = -33
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448caffcf78ff125063ab9c8e954abe567ace">halide_error_code_host_is_null</a> = -34
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca1d2cfff02490bcedfd20469214ad70c3">halide_error_code_bad_extern_fold</a> = -35
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0ad8cd419a295189b17c72c43ff84205">halide_error_code_device_interface_no_device</a> = -36
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca9b506d3be06437581c2cf134864e95d6">halide_error_code_host_and_device_dirty</a> = -37
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448caae50247da4279642e31717a47cf7a589">halide_error_code_buffer_is_null</a> = -38
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cab786372718ef27630f52aeed8c2e1d2b">halide_error_code_device_buffer_copy_failed</a> = -39
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448cab53498a31c13dc516a1b442b7f783b50">halide_error_code_device_crop_unsupported</a> = -40
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca4a191b004650bc15f04123288b21f6fc">halide_error_code_device_crop_failed</a> = -41
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca1f949dfbaa997c19b39d3ae50edb944f">halide_error_code_incompatible_device_interface</a> = -42
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca88b1fd3d786d212a1c91f93437682175">halide_error_code_bad_dimensions</a> = -43
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448cad2e9ab8945e949414ac0998e6992e2f3">halide_error_code_device_dirty_with_no_device_support</a> = -44
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448cae7d98644ac4b7070b8d5a02bd14dd63a">halide_error_code_storage_bound_too_small</a> = -45
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca0ab0a51167a93acec677fb6ec61aefce">halide_error_code_split_factor_not_positive</a> = -46
, <a class="el" href="#aba16e170cc9aa30b78ff703e101a448ca40d93e4618ce4b82fcce81025796c153">halide_error_code_vscale_invalid</a> = -47
, <br />
&#160;&#160;<a class="el" href="#aba16e170cc9aa30b78ff703e101a448cad62b19b86ea679d9f0a3f3d052ad228a">halide_error_code_cannot_profile_pipeline</a> = -48
<br />
 }</td></tr>
<tr class="memdesc:aba16e170cc9aa30b78ff703e101a448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error codes that may be returned by a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="#aba16e170cc9aa30b78ff703e101a448c">More...</a><br /></td></tr>
<tr class="separator:aba16e170cc9aa30b78ff703e101a448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb96b3d427fff8f1d68cc5f1e92f3a" id="r_a2ccb96b3d427fff8f1d68cc5f1e92f3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a> { <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aade7b43403349f5e8490128ec8a353ea0">halide_target_feature_jit</a> = 0
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa269192ac4c709ac4cd58a224aaa4ebed">halide_target_feature_debug</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1091af1b1f0fd0f65a4cf11d9465421b">halide_target_feature_no_asserts</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf66b5dc5721dc9d3437418d2af78218a">halide_target_feature_no_bounds_query</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa8efcb48a15fdbfeb9a80f4e4b47f6c35">halide_target_feature_sse41</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aae30ffae7b5e51bd142e5902c6b60d2a5">halide_target_feature_avx</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1b8d4c5f8ff39549eab349f8f9187f30">halide_target_feature_avx2</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa00ca2d6e033b225858ea63abb21123da">halide_target_feature_fma</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c4a3ac722a0f391a41809f4fe1fa5e9">halide_target_feature_fma4</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aac3f0411bb6041392120209d5eb97dd20">halide_target_feature_f16c</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5fa253bc01a2a59792fd5da6d351d35f">halide_target_feature_armv7s</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f1be27fa92915a8d2193f0bbeb9ada5">halide_target_feature_no_neon</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf10caf4d87b54ef2a1eeef0a1a9ef7a4">halide_target_feature_vsx</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa995a835a73267a3edd9822c6d1927c3a">halide_target_feature_power_arch_2_07</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aabaf8d7892508763403932f8e9e80b2e2">halide_target_feature_cuda</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5e16be3f2066021a8d24ee420d69b2a3">halide_target_feature_cuda_capability30</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aad6cf6481cb5a8f405115dd91a7d71987">halide_target_feature_cuda_capability32</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa72e1c9e35b9184f0a8b7157374c81e9b">halide_target_feature_cuda_capability35</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa45190927a84bdeab2a4195eae0b47f6">halide_target_feature_cuda_capability50</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f6ed2f96b52eaeae62dc1beb66b74de">halide_target_feature_cuda_capability61</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c41735e9ecaf6299b4ca4cde53995a5">halide_target_feature_cuda_capability70</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aae994285f8cf6741104fc36429de829f8">halide_target_feature_cuda_capability75</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aac0cce4a39a07985e9d3480ad9b9fecb0">halide_target_feature_cuda_capability80</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa510e0e93c604381bf7f5b6b374cce947">halide_target_feature_cuda_capability86</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa9af51d9a3d2a16a2053dee312567da3a">halide_target_feature_opencl</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa10dfd45f611103dce0fcdbf671b89e5a">halide_target_feature_cl_doubles</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa65d3ef99ab0c2a6347c9570cd78f2b57">halide_target_feature_cl_atomic64</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf353c2e40c697e29b86a4e51829735df">halide_target_feature_user_context</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa700fd7b1280a9175b7cb3d43fe2c1754">halide_target_feature_profile</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa23b4add23a16a3cfe633b90f2fd6d292">halide_target_feature_no_runtime</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa596a01105ce4f5896b14c69210899e35">halide_target_feature_metal</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1efec7b26946ba7f59cc887dcd45ea22">halide_target_feature_c_plus_plus_mangling</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa00aee1f2d9370a407522de5378d9901c">halide_target_feature_large_buffers</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5bbb70ba548793579bef24d7bd8ffd6a">halide_target_feature_hvx_128</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaac0b0401c077429c652dc5d2723756f0">halide_target_feature_hvx_v62</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf7f57223352cf39e7375d2e2af6004b2">halide_target_feature_fuzz_float_stores</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa484bc02e560762b1c51c0bf254b00a9f">halide_target_feature_soft_float_abi</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa068da87b16c87dd104d9720fec39ec42">halide_target_feature_msan</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa237eaab3cbd8d646c075b74f9958ba0">halide_target_feature_avx512</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa2779d4303538045aa9317c5cfefde48">halide_target_feature_avx512_knl</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa58fb5b7b5bc221459b800cc42930902f">halide_target_feature_avx512_skylake</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa591bbdef6ade866e52fa671d8ea2aed1">halide_target_feature_avx512_cannonlake</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa0966785198db800ffbc3a7f892c78614">halide_target_feature_avx512_zen4</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa8d0583967260da27df1648419d4717e5">halide_target_feature_avx512_sapphirerapids</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa0de323126eca04377e205b6a67b93970">halide_target_feature_trace_loads</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa9d6461b681abeeb0ff4c850cfe4e1eb4">halide_target_feature_trace_stores</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1cebf3f4e7137ca7f3a74b4c2049de4d">halide_target_feature_trace_realizations</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa62b1c56df255787c4888275f5f231fe8">halide_target_feature_trace_pipeline</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa24c82b9a47277314e22da121f1bd3afb">halide_target_feature_hvx_v65</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aafcc6d0b70a97d9745fa89939009c243d">halide_target_feature_hvx_v66</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa696ef920f911837226ad41932e4fa5f4">halide_target_feature_hvx_v68</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa7e62bc4f299a2ee506ecc9f9a4c2e1d8">halide_target_feature_cl_half</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa704512285d26323364e0ac4be27ea235">halide_target_feature_strict_float</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa04299a57d262e533d583341eb2ab95e6">halide_target_feature_tsan</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa79533b07197f576db25b29532086ec11">halide_target_feature_asan</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa50db832a52ac3e6e126dd7d0dbaff6a5">halide_target_feature_d3d12compute</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaefa8e582ca33d5f579fcff6633ef7f9d">halide_target_feature_check_unsafe_promises</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa0120c543cc8bedf464bac3db5d467b6">halide_target_feature_hexagon_dma</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa27059c7429ebfd330393abd1736c4b76">halide_target_feature_embed_bitcode</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa0e302d29180ab5ce1d40bea72c6e3877">halide_target_feature_enable_llvm_loop_opt</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aac3615ba04732ff64ade23461d4d6f98c">halide_target_feature_wasm_mvponly</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa34f213cb539ffca7cecaf2ab7b904c90">halide_target_feature_wasm_simd128</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa0b2e15f8dbc44bd792ffe2bf610a1c8d">halide_target_feature_wasm_threads</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa0426da0f7b2751316ec624928b83e3a2">halide_target_feature_wasm_bulk_memory</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aabdb7ee46fdbf8ae329b28c79902f5246">halide_target_feature_webgpu</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf96f6eed473e71596cf7a95e8fba4673">halide_target_feature_sve</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa4be4a8674e19695fea6f11b638d65d2d">halide_target_feature_sve2</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa69114eb66218ea947c31afc2e4c9a116">halide_target_feature_egl</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa8b4a2c1fe23f18c298a87abe7fc52603">halide_target_feature_arm_dot_prod</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa6a20768eb5e50aa54e93ff315f97425">halide_target_feature_arm_fp16</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa3b97d2d3ddd66f0802976b392f0e1a69">halide_llvm_large_code_model</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1315ae4adad1d3f3f982adb44dac6e99">halide_target_feature_rvv</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa7492575fe2a831253bf277de22e8d6ad">halide_target_feature_armv8a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aabb0e6df774584ada86b625a9b5b7078c">halide_target_feature_armv81a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa7ed89ae933c2a0f0ab5d2be73cdc7a6">halide_target_feature_armv82a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf1e76add3b61129215434c277b485835">halide_target_feature_armv83a</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaaeb9f2d79d23f44c760fab243f67f25e">halide_target_feature_armv84a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aad86c50f5f0248e29f37c13fa11fb77d3">halide_target_feature_armv85a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa2de72255092c6400fab771954cd8f78f">halide_target_feature_armv86a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa7b617ae94206c5ac0fc1340f48260392">halide_target_feature_armv87a</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa62b3268b6323b359be693a41693d6afd">halide_target_feature_armv88a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5573c708264903f88d01e0e9ee516129">halide_target_feature_armv89a</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aac09d31cf3a2ab1782ef02d8903e86f81">halide_target_feature_sanitizer_coverage</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa3d974776b5f7d6cddcd2e2038ed8aafe">halide_target_feature_profile_by_timer</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa61a757e404885163cc0a8a13a00fd83d">halide_target_feature_spirv</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa37aa234291cdced2fc7a967073ecf441">halide_target_feature_vulkan</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf1177e1606d2a3afe4e922168f1b5f72">halide_target_feature_vulkan_int8</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aac8e448d2d5be74e94288e21aaead3947">halide_target_feature_vulkan_int16</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf2af9762a2d78af22a95b982360fa937">halide_target_feature_vulkan_int64</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa22189b958831a81f8f21c8b59b2e9854">halide_target_feature_vulkan_float16</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa87991ab063bb3a4c3965ce77086e3f18">halide_target_feature_vulkan_float64</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf77e6816140418a1629229bc08fb763d">halide_target_feature_vulkan_version10</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa8e330952177a0646f0cb6d4b6e86dbd2">halide_target_feature_vulkan_version12</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa8dc7b8478aeba8540c70ab9ab7e89692">halide_target_feature_vulkan_version13</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa433f44f1eea39a3af05bf8591705234e">halide_target_feature_semihosting</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa69cbb0b6f1d5e15a44a70251b559add3">halide_target_feature_avx10_1</a>
, <br />
&#160;&#160;<a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aafc593f88c62bf63ba04ac0939dc79323">halide_target_feature_x86_apx</a>
, <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3aa3962d2fc2f69c69b85d29c4818d727c1">halide_target_feature_end</a>
<br />
 }</td></tr>
<tr class="memdesc:a2ccb96b3d427fff8f1d68cc5f1e92f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a compilation Target can have.  <a href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">More...</a><br /></td></tr>
<tr class="separator:a2ccb96b3d427fff8f1d68cc5f1e92f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c79a12e6121c7468cb203373e6afc" id="r_a320c79a12e6121c7468cb203373e6afc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a320c79a12e6121c7468cb203373e6afc">halide_buffer_flags</a> { <a class="el" href="#a320c79a12e6121c7468cb203373e6afca1b91e0ac0aba5891e4c7219878da7460">halide_buffer_flag_host_dirty</a> = 1
, <a class="el" href="#a320c79a12e6121c7468cb203373e6afca117e8a76112638ba6510e084e1dfb292">halide_buffer_flag_device_dirty</a> = 2
 }</td></tr>
<tr class="separator:a320c79a12e6121c7468cb203373e6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce5dc7a11fa96f39baa1aee2333745" id="r_afdce5dc7a11fa96f39baa1aee2333745"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdce5dc7a11fa96f39baa1aee2333745">halide_argument_kind_t</a> { <a class="el" href="#afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1">halide_argument_kind_input_scalar</a> = 0
, <a class="el" href="#afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b">halide_argument_kind_input_buffer</a> = 1
, <a class="el" href="#afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8">halide_argument_kind_output_buffer</a> = 2
 }</td></tr>
<tr class="separator:afdce5dc7a11fa96f39baa1aee2333745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96fe1dd85166a7f0da1b8f82f734296a" id="r_a96fe1dd85166a7f0da1b8f82f734296a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a> (void *user_context, const char *)</td></tr>
<tr class="memdesc:a96fe1dd85166a7f0da1b8f82f734296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to stderr.  <br /></td></tr>
<tr class="separator:a96fe1dd85166a7f0da1b8f82f734296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1ae09f6ef33a2508fc67ac50f2c207" id="r_a2c1ae09f6ef33a2508fc67ac50f2c207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1ae09f6ef33a2508fc67ac50f2c207">halide_default_print</a> (void *user_context, const char *)</td></tr>
<tr class="separator:a2c1ae09f6ef33a2508fc67ac50f2c207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3e4cf6c510fd8bc26420af06b7e4f3" id="r_a3d3e4cf6c510fd8bc26420af06b7e4f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a95ff0cf917a42d9d94858d965f0cea70">halide_print_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d3e4cf6c510fd8bc26420af06b7e4f3">halide_set_custom_print</a> (<a class="el" href="#a95ff0cf917a42d9d94858d965f0cea70">halide_print_t</a> print)</td></tr>
<tr class="separator:a3d3e4cf6c510fd8bc26420af06b7e4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28d04de54b94f0dd6ada140b7734d8" id="r_aea28d04de54b94f0dd6ada140b7734d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a> (void *user_context, const char *)</td></tr>
<tr class="memdesc:aea28d04de54b94f0dd6ada140b7734d8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls this function on runtime errors (for example bounds checking failures).  <br /></td></tr>
<tr class="separator:aea28d04de54b94f0dd6ada140b7734d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9ec52392edc2a7b65aab13183a2543" id="r_aaf9ec52392edc2a7b65aab13183a2543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf9ec52392edc2a7b65aab13183a2543">halide_default_error</a> (void *user_context, const char *)</td></tr>
<tr class="separator:aaf9ec52392edc2a7b65aab13183a2543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d18a3f649e46538666fb87ab3fb6ba" id="r_a02d18a3f649e46538666fb87ab3fb6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a51ba9ee9334354b8b260138b464bdaac">halide_error_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02d18a3f649e46538666fb87ab3fb6ba">halide_set_error_handler</a> (<a class="el" href="#a51ba9ee9334354b8b260138b464bdaac">halide_error_handler_t</a> handler)</td></tr>
<tr class="separator:a02d18a3f649e46538666fb87ab3fb6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479133225b3cdf7b931f3c44e878e4e8" id="r_a479133225b3cdf7b931f3c44e878e4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a479133225b3cdf7b931f3c44e878e4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion.  <br /></td></tr>
<tr class="separator:a479133225b3cdf7b931f3c44e878e4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9b62fd2c1d38e6f06100b827830377" id="r_a5e9b62fd2c1d38e6f06100b827830377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="separator:a5e9b62fd2c1d38e6f06100b827830377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbe46503840459907ff553296b6b4a7" id="r_a1bbe46503840459907ff553296b6b4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bbe46503840459907ff553296b6b4a7">halide_cond_signal</a> (struct <a class="el" href="structhalide__cond.html">halide_cond</a> *cond)</td></tr>
<tr class="separator:a1bbe46503840459907ff553296b6b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac302062bc1dc709a0a4f05e984a6a04f" id="r_ac302062bc1dc709a0a4f05e984a6a04f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac302062bc1dc709a0a4f05e984a6a04f">halide_cond_broadcast</a> (struct <a class="el" href="structhalide__cond.html">halide_cond</a> *cond)</td></tr>
<tr class="separator:ac302062bc1dc709a0a4f05e984a6a04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3491497aac052e84053ecca86c85866e" id="r_a3491497aac052e84053ecca86c85866e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3491497aac052e84053ecca86c85866e">halide_cond_wait</a> (struct <a class="el" href="structhalide__cond.html">halide_cond</a> *cond, struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="separator:a3491497aac052e84053ecca86c85866e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaef67a95017fee5d961b93f458c2ff4" id="r_adaef67a95017fee5d961b93f458c2ff4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhalide__mutex__array.html">halide_mutex_array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaef67a95017fee5d961b93f458c2ff4">halide_mutex_array_create</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> sz)</td></tr>
<tr class="separator:adaef67a95017fee5d961b93f458c2ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9910a72bd440a92da0890185f2a8e748" id="r_a9910a72bd440a92da0890185f2a8e748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9910a72bd440a92da0890185f2a8e748">halide_mutex_array_destroy</a> (void *user_context, void *array)</td></tr>
<tr class="separator:a9910a72bd440a92da0890185f2a8e748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2" id="r_aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2">halide_mutex_array_lock</a> (struct <a class="el" href="structhalide__mutex__array.html">halide_mutex_array</a> *array, int entry)</td></tr>
<tr class="separator:aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d98f433f488ad15e5c4b518e5ed56" id="r_a416d98f433f488ad15e5c4b518e5ed56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416d98f433f488ad15e5c4b518e5ed56">halide_mutex_array_unlock</a> (struct <a class="el" href="structhalide__mutex__array.html">halide_mutex_array</a> *array, int entry)</td></tr>
<tr class="separator:a416d98f433f488ad15e5c4b518e5ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f85711e52c707df2e484f69dfaf7c5" id="r_a15f85711e52c707df2e484f69dfaf7c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15f85711e52c707df2e484f69dfaf7c5">halide_do_par_for</a> (void *user_context, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a> task, int min, int size, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="separator:a15f85711e52c707df2e484f69dfaf7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e13f5910a047d1908532367ce0b21f" id="r_ab3e13f5910a047d1908532367ce0b21f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e13f5910a047d1908532367ce0b21f">halide_shutdown_thread_pool</a> (void)</td></tr>
<tr class="separator:ab3e13f5910a047d1908532367ce0b21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eb8b02091849cfbcbdf7d2f4177857" id="r_ab9eb8b02091849cfbcbdf7d2f4177857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9eb8b02091849cfbcbdf7d2f4177857">halide_set_custom_do_par_for</a> (<a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a> do_par_for)</td></tr>
<tr class="separator:ab9eb8b02091849cfbcbdf7d2f4177857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c6d91bcf45d8867e426b8c5a485642" id="r_a22c6d91bcf45d8867e426b8c5a485642"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22c6d91bcf45d8867e426b8c5a485642">halide_semaphore_init</a> (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int n)</td></tr>
<tr class="separator:a22c6d91bcf45d8867e426b8c5a485642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56d38727ba3516acefd55e00efe927" id="r_aff56d38727ba3516acefd55e00efe927"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff56d38727ba3516acefd55e00efe927">halide_semaphore_release</a> (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int n)</td></tr>
<tr class="separator:aff56d38727ba3516acefd55e00efe927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3131d49fedf2a43cfb57d567e275002e" id="r_a3131d49fedf2a43cfb57d567e275002e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3131d49fedf2a43cfb57d567e275002e">halide_semaphore_try_acquire</a> (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int n)</td></tr>
<tr class="separator:a3131d49fedf2a43cfb57d567e275002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed044f78166cb19092f9723f17953fab" id="r_aed044f78166cb19092f9723f17953fab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed044f78166cb19092f9723f17953fab">halide_do_parallel_tasks</a> (void *user_context, int num_tasks, struct <a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a> *tasks, void *task_parent)</td></tr>
<tr class="memdesc:aed044f78166cb19092f9723f17953fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue some number of the tasks described above and wait for them to complete.  <br /></td></tr>
<tr class="separator:aed044f78166cb19092f9723f17953fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece7417671894d7557b9e93ea0ebc0ae" id="r_aece7417671894d7557b9e93ea0ebc0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aece7417671894d7557b9e93ea0ebc0ae">halide_set_custom_do_task</a> (<a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a> do_task)</td></tr>
<tr class="separator:aece7417671894d7557b9e93ea0ebc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73ddae74b80251d2ffce9a624b6125" id="r_a4b73ddae74b80251d2ffce9a624b6125"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b73ddae74b80251d2ffce9a624b6125">halide_do_task</a> (void *user_context, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a> f, int idx, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="separator:a4b73ddae74b80251d2ffce9a624b6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae154f3f0e0e204226c2af24ac58ef016" id="r_ae154f3f0e0e204226c2af24ac58ef016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae154f3f0e0e204226c2af24ac58ef016">halide_set_custom_do_loop_task</a> (<a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a> do_task)</td></tr>
<tr class="separator:ae154f3f0e0e204226c2af24ac58ef016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e478ab191f59290de68e17d3f624da1" id="r_a1e478ab191f59290de68e17d3f624da1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e478ab191f59290de68e17d3f624da1">halide_do_loop_task</a> (void *user_context, <a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a> f, int min, int extent, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure, void *task_parent)</td></tr>
<tr class="separator:a1e478ab191f59290de68e17d3f624da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d1866f7cd8fe9cfc8d9f4603feaea2" id="r_a06d1866f7cd8fe9cfc8d9f4603feaea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d1866f7cd8fe9cfc8d9f4603feaea2">halide_set_custom_parallel_runtime</a> (<a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a>, <a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a>, <a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a>, <a class="el" href="#afd29e5ed7d54ed3d92cb745915ef8909">halide_do_parallel_tasks_t</a>, <a class="el" href="#ae0af757a561193139295a85256e68135">halide_semaphore_init_t</a>, <a class="el" href="#a97edf37f8f01638b513e24f9173b489f">halide_semaphore_try_acquire_t</a>, <a class="el" href="#a187d0100ae8d267bbcb6e840433c0f72">halide_semaphore_release_t</a>)</td></tr>
<tr class="separator:a06d1866f7cd8fe9cfc8d9f4603feaea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20aae4f3c690d66578775e1245ec22" id="r_a3a20aae4f3c690d66578775e1245ec22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a20aae4f3c690d66578775e1245ec22">halide_default_do_par_for</a> (void *user_context, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a> task, int min, int size, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a3a20aae4f3c690d66578775e1245ec22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default versions of the parallel runtime functions.  <br /></td></tr>
<tr class="separator:a3a20aae4f3c690d66578775e1245ec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad539efd611fada06fc5035162bd2d94d" id="r_ad539efd611fada06fc5035162bd2d94d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad539efd611fada06fc5035162bd2d94d">halide_default_do_parallel_tasks</a> (void *user_context, int num_tasks, struct <a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a> *tasks, void *task_parent)</td></tr>
<tr class="separator:ad539efd611fada06fc5035162bd2d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1529a6494b14d3a4f19b8080fdd77e31" id="r_a1529a6494b14d3a4f19b8080fdd77e31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1529a6494b14d3a4f19b8080fdd77e31">halide_default_do_task</a> (void *user_context, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a> f, int idx, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="separator:a1529a6494b14d3a4f19b8080fdd77e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422057cf799d8a82eb0d68889875615a" id="r_a422057cf799d8a82eb0d68889875615a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422057cf799d8a82eb0d68889875615a">halide_default_do_loop_task</a> (void *user_context, <a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a> f, int min, int extent, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure, void *task_parent)</td></tr>
<tr class="separator:a422057cf799d8a82eb0d68889875615a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae5d7a366b3ae0d875b18760e3a331" id="r_a4fae5d7a366b3ae0d875b18760e3a331"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fae5d7a366b3ae0d875b18760e3a331">halide_default_semaphore_init</a> (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int n)</td></tr>
<tr class="separator:a4fae5d7a366b3ae0d875b18760e3a331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4bb05550beaebe11ae30ee49ec9cf9" id="r_aae4bb05550beaebe11ae30ee49ec9cf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae4bb05550beaebe11ae30ee49ec9cf9">halide_default_semaphore_release</a> (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int n)</td></tr>
<tr class="separator:aae4bb05550beaebe11ae30ee49ec9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333094ead7caa2b27e1cd6c92e2367c7" id="r_a333094ead7caa2b27e1cd6c92e2367c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a333094ead7caa2b27e1cd6c92e2367c7">halide_default_semaphore_try_acquire</a> (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int n)</td></tr>
<tr class="separator:a333094ead7caa2b27e1cd6c92e2367c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c90ae80fd6658eaf1754c85fd732ab2" id="r_a6c90ae80fd6658eaf1754c85fd732ab2"><td class="memItemLeft" align="right" valign="top">struct halide_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c90ae80fd6658eaf1754c85fd732ab2">halide_spawn_thread</a> (void(*f)(void *), void *closure)</td></tr>
<tr class="memdesc:a6c90ae80fd6658eaf1754c85fd732ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a thread.  <br /></td></tr>
<tr class="separator:a6c90ae80fd6658eaf1754c85fd732ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba03c92519ed6b3df69caf08e8278720" id="r_aba03c92519ed6b3df69caf08e8278720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba03c92519ed6b3df69caf08e8278720">halide_join_thread</a> (struct halide_thread *)</td></tr>
<tr class="memdesc:aba03c92519ed6b3df69caf08e8278720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a thread.  <br /></td></tr>
<tr class="separator:aba03c92519ed6b3df69caf08e8278720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d93e0796319cf64432c511affba1a5" id="r_a36d93e0796319cf64432c511affba1a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36d93e0796319cf64432c511affba1a5">halide_set_num_threads</a> (int n)</td></tr>
<tr class="memdesc:a36d93e0796319cf64432c511affba1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads used by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s thread pool.  <br /></td></tr>
<tr class="separator:a36d93e0796319cf64432c511affba1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f08f75e6692df61c62b3a7a9e02fe4" id="r_a26f08f75e6692df61c62b3a7a9e02fe4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f08f75e6692df61c62b3a7a9e02fe4">halide_malloc</a> (void *user_context, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> x)</td></tr>
<tr class="memdesc:a26f08f75e6692df61c62b3a7a9e02fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls these functions to allocate and free memory.  <br /></td></tr>
<tr class="separator:a26f08f75e6692df61c62b3a7a9e02fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa49d775b9a20fab152a0650c4c936b" id="r_a2fa49d775b9a20fab152a0650c4c936b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a> (void *user_context, void *ptr)</td></tr>
<tr class="separator:a2fa49d775b9a20fab152a0650c4c936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64690021c26a5e8c9b9f127da447a55" id="r_aa64690021c26a5e8c9b9f127da447a55"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa64690021c26a5e8c9b9f127da447a55">halide_default_malloc</a> (void *user_context, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> x)</td></tr>
<tr class="separator:aa64690021c26a5e8c9b9f127da447a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab246841764b58f9675fdb27db0b4bd34" id="r_ab246841764b58f9675fdb27db0b4bd34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab246841764b58f9675fdb27db0b4bd34">halide_default_free</a> (void *user_context, void *ptr)</td></tr>
<tr class="separator:ab246841764b58f9675fdb27db0b4bd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0668aaae035f2f4f3132857acee4e3" id="r_a4d0668aaae035f2f4f3132857acee4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed4628363dd76e044feb9aa8280a1b84">halide_malloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d0668aaae035f2f4f3132857acee4e3">halide_set_custom_malloc</a> (<a class="el" href="#aed4628363dd76e044feb9aa8280a1b84">halide_malloc_t</a> user_malloc)</td></tr>
<tr class="separator:a4d0668aaae035f2f4f3132857acee4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd43bc97b2337e57fd6af03be17a5bb8" id="r_acd43bc97b2337e57fd6af03be17a5bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa17654ef6deb96a3aef03126bd35221a">halide_free_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd43bc97b2337e57fd6af03be17a5bb8">halide_set_custom_free</a> (<a class="el" href="#aa17654ef6deb96a3aef03126bd35221a">halide_free_t</a> user_free)</td></tr>
<tr class="separator:acd43bc97b2337e57fd6af03be17a5bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647186e912f5c3f52fb1c1e1a17d5af9" id="r_a647186e912f5c3f52fb1c1e1a17d5af9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a647186e912f5c3f52fb1c1e1a17d5af9">halide_get_symbol</a> (const char *name)</td></tr>
<tr class="memdesc:a647186e912f5c3f52fb1c1e1a17d5af9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls these functions to interact with the underlying system runtime functions.  <br /></td></tr>
<tr class="separator:a647186e912f5c3f52fb1c1e1a17d5af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc88316b939747585e937b3613d5fbf" id="r_abcc88316b939747585e937b3613d5fbf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc88316b939747585e937b3613d5fbf">halide_load_library</a> (const char *name)</td></tr>
<tr class="separator:abcc88316b939747585e937b3613d5fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106b2c865ee58d0831a054ad16dadc1" id="r_a5106b2c865ee58d0831a054ad16dadc1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5106b2c865ee58d0831a054ad16dadc1">halide_get_library_symbol</a> (void *lib, const char *name)</td></tr>
<tr class="separator:a5106b2c865ee58d0831a054ad16dadc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae490d646731f0c82c4fa652f61e17802" id="r_ae490d646731f0c82c4fa652f61e17802"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae490d646731f0c82c4fa652f61e17802">halide_default_get_symbol</a> (const char *name)</td></tr>
<tr class="separator:ae490d646731f0c82c4fa652f61e17802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa886f515ea8d068890f2bb9ced0c35f9" id="r_aa886f515ea8d068890f2bb9ced0c35f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa886f515ea8d068890f2bb9ced0c35f9">halide_default_load_library</a> (const char *name)</td></tr>
<tr class="separator:aa886f515ea8d068890f2bb9ced0c35f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d836778ce297e25b37e5fe62a781b75" id="r_a1d836778ce297e25b37e5fe62a781b75"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d836778ce297e25b37e5fe62a781b75">halide_default_get_library_symbol</a> (void *lib, const char *name)</td></tr>
<tr class="separator:a1d836778ce297e25b37e5fe62a781b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237a39b6dc5c4059539983984c3ef4f7" id="r_a237a39b6dc5c4059539983984c3ef4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7a1424c74013b0adc86c02878c407fb5">halide_get_symbol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237a39b6dc5c4059539983984c3ef4f7">halide_set_custom_get_symbol</a> (<a class="el" href="#a7a1424c74013b0adc86c02878c407fb5">halide_get_symbol_t</a> user_get_symbol)</td></tr>
<tr class="separator:a237a39b6dc5c4059539983984c3ef4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201fccb476f83105b06389a7701f5bef" id="r_a201fccb476f83105b06389a7701f5bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a169fd95ae0b4b9e080896cedc4adbd8e">halide_load_library_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a201fccb476f83105b06389a7701f5bef">halide_set_custom_load_library</a> (<a class="el" href="#a169fd95ae0b4b9e080896cedc4adbd8e">halide_load_library_t</a> user_load_library)</td></tr>
<tr class="separator:a201fccb476f83105b06389a7701f5bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d93a904e3a104ff12c4760aad458ef" id="r_ae6d93a904e3a104ff12c4760aad458ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2788d811e1a39b30870b1d6b94d7826e">halide_get_library_symbol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d93a904e3a104ff12c4760aad458ef">halide_set_custom_get_library_symbol</a> (<a class="el" href="#a2788d811e1a39b30870b1d6b94d7826e">halide_get_library_symbol_t</a> user_get_library_symbol)</td></tr>
<tr class="separator:ae6d93a904e3a104ff12c4760aad458ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686169d62735df48a614ccc48fed75a8" id="r_a686169d62735df48a614ccc48fed75a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a686169d62735df48a614ccc48fed75a8">halide_debug_to_file</a> (void *user_context, const char *filename, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf)</td></tr>
<tr class="memdesc:a686169d62735df48a614ccc48fed75a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when debug_to_file is used inside Halide code.  <br /></td></tr>
<tr class="separator:a686169d62735df48a614ccc48fed75a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d172a9f341a56bc9c5124d2c61a5aa" id="r_a83d172a9f341a56bc9c5124d2c61a5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d172a9f341a56bc9c5124d2c61a5aa">halide_trace</a> (void *user_context, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *event)</td></tr>
<tr class="memdesc:a83d172a9f341a56bc9c5124d2c61a5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when Funcs are marked as trace_load, trace_store, or trace_realization.  <br /></td></tr>
<tr class="separator:a83d172a9f341a56bc9c5124d2c61a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9983cd83d6ff3aae428080d20e2af680" id="r_a9983cd83d6ff3aae428080d20e2af680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9983cd83d6ff3aae428080d20e2af680">halide_default_trace</a> (void *user_context, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *event)</td></tr>
<tr class="separator:a9983cd83d6ff3aae428080d20e2af680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963a4ee1ed5d4c89b29eadca3a2e0236" id="r_a963a4ee1ed5d4c89b29eadca3a2e0236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acac84473600d9caee1f3ab634cb117ba">halide_trace_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a963a4ee1ed5d4c89b29eadca3a2e0236">halide_set_custom_trace</a> (<a class="el" href="#acac84473600d9caee1f3ab634cb117ba">halide_trace_t</a> trace)</td></tr>
<tr class="separator:a963a4ee1ed5d4c89b29eadca3a2e0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8761e708f878372e3201126e83d6f3b6" id="r_a8761e708f878372e3201126e83d6f3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8761e708f878372e3201126e83d6f3b6">halide_set_trace_file</a> (int fd)</td></tr>
<tr class="memdesc:a8761e708f878372e3201126e83d6f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file descriptor that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> should write binary trace events to.  <br /></td></tr>
<tr class="separator:a8761e708f878372e3201126e83d6f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee99b65dcbc81d91a0f22507eb7f8017" id="r_aee99b65dcbc81d91a0f22507eb7f8017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee99b65dcbc81d91a0f22507eb7f8017">halide_get_trace_file</a> (void *user_context)</td></tr>
<tr class="memdesc:aee99b65dcbc81d91a0f22507eb7f8017"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls this to retrieve the file descriptor to write binary trace events to.  <br /></td></tr>
<tr class="separator:aee99b65dcbc81d91a0f22507eb7f8017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bf251b013e6945c4ceefc34890b4cb" id="r_af1bf251b013e6945c4ceefc34890b4cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1bf251b013e6945c4ceefc34890b4cb">halide_shutdown_trace</a> (void)</td></tr>
<tr class="memdesc:af1bf251b013e6945c4ceefc34890b4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If tracing is writing to a file.  <br /></td></tr>
<tr class="separator:af1bf251b013e6945c4ceefc34890b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412b6569e456b0a85896d9afa986630" id="r_a5412b6569e456b0a85896d9afa986630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5412b6569e456b0a85896d9afa986630">halide_device_release</a> (void *user_context, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:a5412b6569e456b0a85896d9afa986630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all data associated with the given device interface, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  <br /></td></tr>
<tr class="separator:a5412b6569e456b0a85896d9afa986630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb9875eba947a4ef1f8e4ee19a7f5e" id="r_a37bb9875eba947a4ef1f8e4ee19a7f5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37bb9875eba947a4ef1f8e4ee19a7f5e">halide_copy_to_host</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf)</td></tr>
<tr class="memdesc:a37bb9875eba947a4ef1f8e4ee19a7f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from device memory to host memory.  <br /></td></tr>
<tr class="separator:a37bb9875eba947a4ef1f8e4ee19a7f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564c907ea0e5b5520e876ce28f29af9" id="r_ae564c907ea0e5b5520e876ce28f29af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae564c907ea0e5b5520e876ce28f29af9">halide_copy_to_device</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:ae564c907ea0e5b5520e876ce28f29af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from host memory to device memory.  <br /></td></tr>
<tr class="separator:ae564c907ea0e5b5520e876ce28f29af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87da62417a064c727dd93555efe899e3" id="r_a87da62417a064c727dd93555efe899e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87da62417a064c727dd93555efe899e3">halide_buffer_copy</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *src, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *dst_device_interface, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *dst)</td></tr>
<tr class="memdesc:a87da62417a064c727dd93555efe899e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one buffer to another.  <br /></td></tr>
<tr class="separator:a87da62417a064c727dd93555efe899e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204ba51137185e33cadbb11e5a1f8cc5" id="r_a204ba51137185e33cadbb11e5a1f8cc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a204ba51137185e33cadbb11e5a1f8cc5">halide_device_crop</a> (void *user_context, const struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *src, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *dst)</td></tr>
<tr class="memdesc:a204ba51137185e33cadbb11e5a1f8cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the destination buffer a device allocation which is an alias for the same coordinate range in the source buffer.  <br /></td></tr>
<tr class="separator:a204ba51137185e33cadbb11e5a1f8cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab036129c58b7829f3a15442d9d61d875" id="r_ab036129c58b7829f3a15442d9d61d875"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab036129c58b7829f3a15442d9d61d875">halide_device_slice</a> (void *user_context, const struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *src, int slice_dim, int slice_pos, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *dst)</td></tr>
<tr class="memdesc:ab036129c58b7829f3a15442d9d61d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the destination buffer a device allocation which is an alias for a similar coordinate range in the source buffer, but with one dimension sliced away in the dst.  <br /></td></tr>
<tr class="separator:ab036129c58b7829f3a15442d9d61d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0deb2630647ba1eb007090d7d54674" id="r_aeb0deb2630647ba1eb007090d7d54674"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb0deb2630647ba1eb007090d7d54674">halide_device_release_crop</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf)</td></tr>
<tr class="memdesc:aeb0deb2630647ba1eb007090d7d54674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any resources associated with a cropped/sliced view of another buffer.  <br /></td></tr>
<tr class="separator:aeb0deb2630647ba1eb007090d7d54674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dfb9b20f566b9221cbb883fd622595" id="r_a13dfb9b20f566b9221cbb883fd622595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13dfb9b20f566b9221cbb883fd622595">halide_device_sync</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf)</td></tr>
<tr class="memdesc:a13dfb9b20f566b9221cbb883fd622595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for current GPU operations to complete.  <br /></td></tr>
<tr class="separator:a13dfb9b20f566b9221cbb883fd622595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76963f0e4db67ac7c87b376484a4ba3" id="r_ac76963f0e4db67ac7c87b376484a4ba3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac76963f0e4db67ac7c87b376484a4ba3">halide_device_sync_global</a> (void *user_context, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:ac76963f0e4db67ac7c87b376484a4ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for current GPU operations to complete.  <br /></td></tr>
<tr class="separator:ac76963f0e4db67ac7c87b376484a4ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5dea3365145ef7bcda3df9c787d9bc" id="r_a9f5dea3365145ef7bcda3df9c787d9bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5dea3365145ef7bcda3df9c787d9bc">halide_device_malloc</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:a9f5dea3365145ef7bcda3df9c787d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate device memory to back a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a>.  <br /></td></tr>
<tr class="separator:a9f5dea3365145ef7bcda3df9c787d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac643953e77f882726d175d8bd9250c13" id="r_ac643953e77f882726d175d8bd9250c13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac643953e77f882726d175d8bd9250c13">halide_device_free</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf)</td></tr>
<tr class="memdesc:ac643953e77f882726d175d8bd9250c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free device memory.  <br /></td></tr>
<tr class="separator:ac643953e77f882726d175d8bd9250c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee10938953dddc5f12b9cf50169e3983" id="r_aee10938953dddc5f12b9cf50169e3983"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee10938953dddc5f12b9cf50169e3983">halide_device_wrap_native</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> handle, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:aee10938953dddc5f12b9cf50169e3983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap or detach a native device handle, setting the device field and device_interface field as appropriate for the given GPU API.  <br /></td></tr>
<tr class="separator:aee10938953dddc5f12b9cf50169e3983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a9eaadad05dcdc6a042aa3a1e53e25" id="r_ae2a9eaadad05dcdc6a042aa3a1e53e25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2a9eaadad05dcdc6a042aa3a1e53e25">halide_device_detach_native</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buf)</td></tr>
<tr class="separator:ae2a9eaadad05dcdc6a042aa3a1e53e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906fca5a688c26e0465a1b3da84ccfb" id="r_a9906fca5a688c26e0465a1b3da84ccfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9906fca5a688c26e0465a1b3da84ccfb">halide_set_gpu_device</a> (int n)</td></tr>
<tr class="memdesc:a9906fca5a688c26e0465a1b3da84ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects which gpu device to use.  <br /></td></tr>
<tr class="separator:a9906fca5a688c26e0465a1b3da84ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc511579a9ad82da9c1c611f008dd454" id="r_adc511579a9ad82da9c1c611f008dd454"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc511579a9ad82da9c1c611f008dd454">halide_get_gpu_device</a> (void *user_context)</td></tr>
<tr class="memdesc:adc511579a9ad82da9c1c611f008dd454"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls this to get the desired halide gpu device setting.  <br /></td></tr>
<tr class="separator:adc511579a9ad82da9c1c611f008dd454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf85692a77aec0b887f345d0d3ca6777" id="r_abf85692a77aec0b887f345d0d3ca6777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf85692a77aec0b887f345d0d3ca6777">halide_memoization_cache_set_size</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr class="memdesc:abf85692a77aec0b887f345d0d3ca6777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results.  <br /></td></tr>
<tr class="separator:abf85692a77aec0b887f345d0d3ca6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e828012fc956325101a835716f8ca22" id="r_a0e828012fc956325101a835716f8ca22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e828012fc956325101a835716f8ca22">halide_memoization_cache_lookup</a> (void *user_context, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **tuple_buffers)</td></tr>
<tr class="memdesc:a0e828012fc956325101a835716f8ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so.  <br /></td></tr>
<tr class="separator:a0e828012fc956325101a835716f8ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8795da8e9bbd6f19e8dcea37a277c110" id="r_a8795da8e9bbd6f19e8dcea37a277c110"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8795da8e9bbd6f19e8dcea37a277c110">halide_memoization_cache_store</a> (void *user_context, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **tuple_buffers, bool has_eviction_key, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> eviction_key)</td></tr>
<tr class="memdesc:a8795da8e9bbd6f19e8dcea37a277c110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup.  <br /></td></tr>
<tr class="separator:a8795da8e9bbd6f19e8dcea37a277c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a460aadc9868ee8c81a03adf6d65e7" id="r_ab9a460aadc9868ee8c81a03adf6d65e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a460aadc9868ee8c81a03adf6d65e7">halide_memoization_cache_evict</a> (void *user_context, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> eviction_key)</td></tr>
<tr class="memdesc:ab9a460aadc9868ee8c81a03adf6d65e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict all cache entries that were tagged with the given eviction_key in the memoize scheduling directive.  <br /></td></tr>
<tr class="separator:ab9a460aadc9868ee8c81a03adf6d65e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714f9e341f1d71baf8abc77bc50e1db5" id="r_a714f9e341f1d71baf8abc77bc50e1db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a714f9e341f1d71baf8abc77bc50e1db5">halide_memoization_cache_release</a> (void *user_context, void *host)</td></tr>
<tr class="memdesc:a714f9e341f1d71baf8abc77bc50e1db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If halide_memoization_cache_lookup succeeds, halide_memoization_cache_release must be called to signal the storage is no longer being used by the caller.  <br /></td></tr>
<tr class="separator:a714f9e341f1d71baf8abc77bc50e1db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5970d700c7006afcc34cc7298a4ca" id="r_ac6a5970d700c7006afcc34cc7298a4ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6a5970d700c7006afcc34cc7298a4ca">halide_memoization_cache_cleanup</a> (void)</td></tr>
<tr class="memdesc:ac6a5970d700c7006afcc34cc7298a4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory and resources associated with the memoization cache.  <br /></td></tr>
<tr class="separator:ac6a5970d700c7006afcc34cc7298a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2d62d86b65a105c91af9cd961e1993" id="r_a7c2d62d86b65a105c91af9cd961e1993"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2d62d86b65a105c91af9cd961e1993">halide_msan_check_memory_is_initialized</a> (void *user_context, const void *ptr, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> len, const char *name)</td></tr>
<tr class="memdesc:a7c2d62d86b65a105c91af9cd961e1993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a given range of memory has been initialized; only used when Target::MSAN is enabled.  <br /></td></tr>
<tr class="separator:a7c2d62d86b65a105c91af9cd961e1993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf83add6bd8d42819d610e03ea490d4" id="r_afbf83add6bd8d42819d610e03ea490d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf83add6bd8d42819d610e03ea490d4">halide_msan_check_buffer_is_initialized</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buffer, const char *buf_name)</td></tr>
<tr class="memdesc:afbf83add6bd8d42819d610e03ea490d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the data pointed to by the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> is initialized (but <em>not</em> the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> itself), using <a class="el" href="#a7c2d62d86b65a105c91af9cd961e1993" title="Verify that a given range of memory has been initialized; only used when Target::MSAN is enabled.">halide_msan_check_memory_is_initialized()</a> for checking.  <br /></td></tr>
<tr class="separator:afbf83add6bd8d42819d610e03ea490d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4c6def086b090a357530e794806a7" id="r_a3cb4c6def086b090a357530e794806a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cb4c6def086b090a357530e794806a7">halide_msan_annotate_memory_is_initialized</a> (void *user_context, const void *ptr, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> len)</td></tr>
<tr class="memdesc:a3cb4c6def086b090a357530e794806a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled.  <br /></td></tr>
<tr class="separator:a3cb4c6def086b090a357530e794806a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b09afc09e3a8781b8d3545c3799747f" id="r_a2b09afc09e3a8781b8d3545c3799747f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b09afc09e3a8781b8d3545c3799747f">halide_msan_annotate_buffer_is_initialized</a> (void *user_context, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buffer)</td></tr>
<tr class="memdesc:a2b09afc09e3a8781b8d3545c3799747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the data pointed to by the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> as initialized (but <em>not</em> the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> itself), using <a class="el" href="#a3cb4c6def086b090a357530e794806a7" title="Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled.">halide_msan_annotate_memory_is_initialized()</a> for marking.  <br /></td></tr>
<tr class="separator:a2b09afc09e3a8781b8d3545c3799747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506f6e93f28aa3a0a9af8cdd8f9039ec" id="r_a506f6e93f28aa3a0a9af8cdd8f9039ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a506f6e93f28aa3a0a9af8cdd8f9039ec">halide_msan_annotate_buffer_is_initialized_as_destructor</a> (void *user_context, void *buffer)</td></tr>
<tr class="separator:a506f6e93f28aa3a0a9af8cdd8f9039ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de7e95e571c442a05506a451318f00" id="r_a56de7e95e571c442a05506a451318f00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56de7e95e571c442a05506a451318f00">halide_error_bounds_inference_call_failed</a> (void *user_context, const char *extern_stage_name, int result)</td></tr>
<tr class="memdesc:a56de7e95e571c442a05506a451318f00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls the functions below on various error conditions.  <br /></td></tr>
<tr class="separator:a56de7e95e571c442a05506a451318f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ec7fcc618e1b0508a6f4f726a7bcae" id="r_a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83ec7fcc618e1b0508a6f4f726a7bcae">halide_error_extern_stage_failed</a> (void *user_context, const char *extern_stage_name, int result)</td></tr>
<tr class="memdesc:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to an extern stage failed.  <br /></td></tr>
<tr class="separator:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b03b398e934c740dd4905a02a9bb81" id="r_aa5b03b398e934c740dd4905a02a9bb81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5b03b398e934c740dd4905a02a9bb81">halide_error_explicit_bounds_too_small</a> (void *user_context, const char *func_name, const char *var_name, int min_bound, int max_bound, int min_required, int max_required)</td></tr>
<tr class="memdesc:aa5b03b398e934c740dd4905a02a9bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <br /></td></tr>
<tr class="separator:aa5b03b398e934c740dd4905a02a9bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0adc8cfcfb4ee5eeb7a3897e24e96b" id="r_aec0adc8cfcfb4ee5eeb7a3897e24e96b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec0adc8cfcfb4ee5eeb7a3897e24e96b">halide_error_bad_type</a> (void *user_context, const char *func_name, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> type_given, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> correct_type)</td></tr>
<tr class="separator:aec0adc8cfcfb4ee5eeb7a3897e24e96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145d6f03f261224d07004050d9bb004" id="r_a4145d6f03f261224d07004050d9bb004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4145d6f03f261224d07004050d9bb004">halide_error_bad_dimensions</a> (void *user_context, const char *func_name, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> dimensions_given, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> correct_dimensions)</td></tr>
<tr class="separator:a4145d6f03f261224d07004050d9bb004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c6e910c7b7feb2a51c7a0a549a9bd" id="r_aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa54c6e910c7b7feb2a51c7a0a549a9bd">halide_error_access_out_of_bounds</a> (void *user_context, const char *func_name, int dimension, int min_touched, int max_touched, int min_valid, int max_valid)</td></tr>
<tr class="separator:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fa368bf1d21414be0ab0a00e8ca7f6" id="r_a33fa368bf1d21414be0ab0a00e8ca7f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33fa368bf1d21414be0ab0a00e8ca7f6">halide_error_buffer_allocation_too_large</a> (void *user_context, const char *buffer_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> allocation_size, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> max_size)</td></tr>
<tr class="separator:a33fa368bf1d21414be0ab0a00e8ca7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d5408cb06758ec15b51de93d6772c" id="r_a5c0d5408cb06758ec15b51de93d6772c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c0d5408cb06758ec15b51de93d6772c">halide_error_buffer_extents_negative</a> (void *user_context, const char *buffer_name, int dimension, int extent)</td></tr>
<tr class="separator:a5c0d5408cb06758ec15b51de93d6772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d5f3810ffacdc2950743193411c6d4" id="r_a80d5f3810ffacdc2950743193411c6d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80d5f3810ffacdc2950743193411c6d4">halide_error_buffer_extents_too_large</a> (void *user_context, const char *buffer_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> actual_size, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_size)</td></tr>
<tr class="separator:a80d5f3810ffacdc2950743193411c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcbb3316d10d47471e9d74ba74d8e6b" id="r_a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fcbb3316d10d47471e9d74ba74d8e6b">halide_error_constraints_make_required_region_smaller</a> (void *user_context, const char *buffer_name, int dimension, int constrained_min, int constrained_extent, int required_min, int required_extent)</td></tr>
<tr class="separator:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a91525ca15c31958738cf7ec44e410" id="r_a41a91525ca15c31958738cf7ec44e410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41a91525ca15c31958738cf7ec44e410">halide_error_constraint_violated</a> (void *user_context, const char *var, int val, const char *constrained_var, int constrained_val)</td></tr>
<tr class="separator:a41a91525ca15c31958738cf7ec44e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc44166713b0e8fbef22542e4e0fe95" id="r_a9dc44166713b0e8fbef22542e4e0fe95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dc44166713b0e8fbef22542e4e0fe95">halide_error_param_too_small_i64</a> (void *user_context, const char *param_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> min_val)</td></tr>
<tr class="separator:a9dc44166713b0e8fbef22542e4e0fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fce86c8f8d93969bde686d502b4340" id="r_a93fce86c8f8d93969bde686d502b4340"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93fce86c8f8d93969bde686d502b4340">halide_error_param_too_small_u64</a> (void *user_context, const char *param_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> min_val)</td></tr>
<tr class="separator:a93fce86c8f8d93969bde686d502b4340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06e8302739a4a26bfa2b0113fc376d" id="r_a8d06e8302739a4a26bfa2b0113fc376d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d06e8302739a4a26bfa2b0113fc376d">halide_error_param_too_small_f64</a> (void *user_context, const char *param_name, double val, double min_val)</td></tr>
<tr class="separator:a8d06e8302739a4a26bfa2b0113fc376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f31f3a6a09ab3b5b798cecbd3f5e045" id="r_a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f31f3a6a09ab3b5b798cecbd3f5e045">halide_error_param_too_large_i64</a> (void *user_context, const char *param_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_val)</td></tr>
<tr class="separator:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca082a34f38e8657551128db3969f8af" id="r_aca082a34f38e8657551128db3969f8af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca082a34f38e8657551128db3969f8af">halide_error_param_too_large_u64</a> (void *user_context, const char *param_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> max_val)</td></tr>
<tr class="separator:aca082a34f38e8657551128db3969f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc42c90e0703c23c6f141fb476cfa04" id="r_a7bc42c90e0703c23c6f141fb476cfa04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bc42c90e0703c23c6f141fb476cfa04">halide_error_param_too_large_f64</a> (void *user_context, const char *param_name, double val, double max_val)</td></tr>
<tr class="separator:a7bc42c90e0703c23c6f141fb476cfa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64356948f9a36e16664585fff6f0949d" id="r_a64356948f9a36e16664585fff6f0949d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64356948f9a36e16664585fff6f0949d">halide_error_out_of_memory</a> (void *user_context)</td></tr>
<tr class="separator:a64356948f9a36e16664585fff6f0949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab974b4b7963cad8613c3825a5689086" id="r_aab974b4b7963cad8613c3825a5689086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab974b4b7963cad8613c3825a5689086">halide_error_buffer_argument_is_null</a> (void *user_context, const char *buffer_name)</td></tr>
<tr class="separator:aab974b4b7963cad8613c3825a5689086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d12212093b19b3c2ea2b83df15302e3" id="r_a6d12212093b19b3c2ea2b83df15302e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d12212093b19b3c2ea2b83df15302e3">halide_error_debug_to_file_failed</a> (void *user_context, const char *func, const char *filename, int error_code)</td></tr>
<tr class="separator:a6d12212093b19b3c2ea2b83df15302e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c72825991b91cbc68d0ee35b5dd6eb" id="r_af4c72825991b91cbc68d0ee35b5dd6eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c72825991b91cbc68d0ee35b5dd6eb">halide_error_unaligned_host_ptr</a> (void *user_context, const char *func_name, int alignment)</td></tr>
<tr class="separator:af4c72825991b91cbc68d0ee35b5dd6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86407c41832653562525f5699658e78e" id="r_a86407c41832653562525f5699658e78e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86407c41832653562525f5699658e78e">halide_error_host_is_null</a> (void *user_context, const char *func_name)</td></tr>
<tr class="separator:a86407c41832653562525f5699658e78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184d4a3242a700a5bfa984202d150058" id="r_a184d4a3242a700a5bfa984202d150058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a184d4a3242a700a5bfa984202d150058">halide_error_bad_fold</a> (void *user_context, const char *func_name, const char *var_name, const char *loop_name)</td></tr>
<tr class="separator:a184d4a3242a700a5bfa984202d150058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c89710ae1981e7ccad2e28eaecae49" id="r_a12c89710ae1981e7ccad2e28eaecae49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12c89710ae1981e7ccad2e28eaecae49">halide_error_bad_extern_fold</a> (void *user_context, const char *func_name, int dim, int min, int extent, int valid_min, int fold_factor)</td></tr>
<tr class="separator:a12c89710ae1981e7ccad2e28eaecae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc79be62fbe8dec0a9fe81880809d09" id="r_a8bc79be62fbe8dec0a9fe81880809d09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bc79be62fbe8dec0a9fe81880809d09">halide_error_fold_factor_too_small</a> (void *user_context, const char *func_name, const char *var_name, int fold_factor, const char *loop_name, int required_extent)</td></tr>
<tr class="separator:a8bc79be62fbe8dec0a9fe81880809d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2a64a173a5f8f76b77f495782bf3d0" id="r_a6f2a64a173a5f8f76b77f495782bf3d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2a64a173a5f8f76b77f495782bf3d0">halide_error_requirement_failed</a> (void *user_context, const char *condition, const char *message)</td></tr>
<tr class="separator:a6f2a64a173a5f8f76b77f495782bf3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b32bec5b0969e6c79bccb4f92fd295" id="r_aa4b32bec5b0969e6c79bccb4f92fd295"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4b32bec5b0969e6c79bccb4f92fd295">halide_error_specialize_fail</a> (void *user_context, const char *message)</td></tr>
<tr class="separator:aa4b32bec5b0969e6c79bccb4f92fd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab5d9defb54674dbb97c6b629d50358" id="r_a6ab5d9defb54674dbb97c6b629d50358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab5d9defb54674dbb97c6b629d50358">halide_error_no_device_interface</a> (void *user_context)</td></tr>
<tr class="separator:a6ab5d9defb54674dbb97c6b629d50358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7a1dd2fd8cec3b76da2c9b0bbf39b" id="r_aa4d7a1dd2fd8cec3b76da2c9b0bbf39b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d7a1dd2fd8cec3b76da2c9b0bbf39b">halide_error_device_interface_no_device</a> (void *user_context)</td></tr>
<tr class="separator:aa4d7a1dd2fd8cec3b76da2c9b0bbf39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f30607f12425475a81e3735a9d017a" id="r_aa4f30607f12425475a81e3735a9d017a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4f30607f12425475a81e3735a9d017a">halide_error_host_and_device_dirty</a> (void *user_context)</td></tr>
<tr class="separator:aa4f30607f12425475a81e3735a9d017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c42da47a5082bf52f62143c3e667c9f" id="r_a5c42da47a5082bf52f62143c3e667c9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c42da47a5082bf52f62143c3e667c9f">halide_error_buffer_is_null</a> (void *user_context, const char *routine)</td></tr>
<tr class="separator:a5c42da47a5082bf52f62143c3e667c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f373bfbd4135315a9ac195152fd0243" id="r_a4f373bfbd4135315a9ac195152fd0243"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f373bfbd4135315a9ac195152fd0243">halide_error_device_dirty_with_no_device_support</a> (void *user_context, const char *buffer_name)</td></tr>
<tr class="separator:a4f373bfbd4135315a9ac195152fd0243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa215552d657bc58c32cf4ccff6d24df3" id="r_aa215552d657bc58c32cf4ccff6d24df3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa215552d657bc58c32cf4ccff6d24df3">halide_error_storage_bound_too_small</a> (void *user_context, const char *func_name, const char *var_name, int provided_size, int required_size)</td></tr>
<tr class="separator:aa215552d657bc58c32cf4ccff6d24df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab199bb9f42e5a36069af2e8b08994eef" id="r_ab199bb9f42e5a36069af2e8b08994eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab199bb9f42e5a36069af2e8b08994eef">halide_error_device_crop_failed</a> (void *user_context)</td></tr>
<tr class="separator:ab199bb9f42e5a36069af2e8b08994eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb5e935878f0bce62df337bf057cc98" id="r_aebb5e935878f0bce62df337bf057cc98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebb5e935878f0bce62df337bf057cc98">halide_error_split_factor_not_positive</a> (void *user_context, const char *func_name, const char *orig, const char *outer, const char *inner, const char *factor_str, int factor)</td></tr>
<tr class="separator:aebb5e935878f0bce62df337bf057cc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b11f8a2ad06e387f2c31d1b34b524a0" id="r_a8b11f8a2ad06e387f2c31d1b34b524a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b11f8a2ad06e387f2c31d1b34b524a0">halide_error_vscale_invalid</a> (void *user_context, const char *func_name, int runtime_vscale, int compiletime_vscale)</td></tr>
<tr class="separator:a8b11f8a2ad06e387f2c31d1b34b524a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3de9758e5af340b55d91e929ea52be" id="r_aeb3de9758e5af340b55d91e929ea52be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3de9758e5af340b55d91e929ea52be">halide_can_use_target_features</a> (int count, const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *features)</td></tr>
<tr class="memdesc:aeb3de9758e5af340b55d91e929ea52be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called internally by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags.  <br /></td></tr>
<tr class="separator:aeb3de9758e5af340b55d91e929ea52be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d894ba76723de46670273e21186516" id="r_a85d894ba76723de46670273e21186516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7756790d1df276babe85759aecb9214e">halide_can_use_target_features_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85d894ba76723de46670273e21186516">halide_set_custom_can_use_target_features</a> (<a class="el" href="#a7756790d1df276babe85759aecb9214e">halide_can_use_target_features_t</a>)</td></tr>
<tr class="separator:a85d894ba76723de46670273e21186516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c82f395159cd26471734262410d5bb7" id="r_a9c82f395159cd26471734262410d5bb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c82f395159cd26471734262410d5bb7">halide_default_can_use_target_features</a> (int count, const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *features)</td></tr>
<tr class="memdesc:a9c82f395159cd26471734262410d5bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the default implementation of halide_can_use_target_features; it is provided for convenience of user code that may wish to extend halide_can_use_target_features but continue providing existing support, e.g.  <br /></td></tr>
<tr class="separator:a9c82f395159cd26471734262410d5bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78788323e55e51ca690d47957e8eb5f9" id="r_a78788323e55e51ca690d47957e8eb5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78788323e55e51ca690d47957e8eb5f9">halide_register_argv_and_metadata</a> (int(*filter_argv_call)(void **), const struct <a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a> *filter_metadata, const char *const *extra_key_value_pairs)</td></tr>
<tr class="memdesc:a78788323e55e51ca690d47957e8eb5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a78788323e55e51ca690d47957e8eb5f9" title="halide_register_argv_and_metadata() is a user-defined function that must be provided in order to use ...">halide_register_argv_and_metadata()</a> is a <b>user-defined</b> function that must be provided in order to use the registration.cc files produced by Generators when the 'registration' output is requested.  <br /></td></tr>
<tr class="separator:a78788323e55e51ca690d47957e8eb5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02da52a04bf26d2636c9e70dd73b2fac" id="r_a02da52a04bf26d2636c9e70dd73b2fac"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02da52a04bf26d2636c9e70dd73b2fac">HALIDE_ATTRIBUTE_ALIGN</a> (8) halide_profiler_func_stats</td></tr>
<tr class="memdesc:a02da52a04bf26d2636c9e70dd73b2fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions below here are relevant for pipelines compiled with the -profile target flag, which runs a sampling profiler thread alongside the pipeline.  <br /></td></tr>
<tr class="separator:a02da52a04bf26d2636c9e70dd73b2fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df8efecbde772f8650f6801f5ca5169" id="r_a3df8efecbde772f8650f6801f5ca5169"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df8efecbde772f8650f6801f5ca5169">halide_profiler_get_state</a> (void)</td></tr>
<tr class="memdesc:a3df8efecbde772f8650f6801f5ca5169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the global profiler state for programmatic inspection.  <br /></td></tr>
<tr class="separator:a3df8efecbde772f8650f6801f5ca5169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492f13d33a946efa2e69f372639e6775" id="r_a492f13d33a946efa2e69f372639e6775"><td class="memItemLeft" align="right" valign="top">struct halide_profiler_pipeline_stats *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a492f13d33a946efa2e69f372639e6775">halide_profiler_get_pipeline_state</a> (const char *pipeline_name)</td></tr>
<tr class="memdesc:a492f13d33a946efa2e69f372639e6775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the pipeline state associated with pipeline_name.  <br /></td></tr>
<tr class="separator:a492f13d33a946efa2e69f372639e6775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69d3a7547848c029e9edaf3e8240c01" id="r_af69d3a7547848c029e9edaf3e8240c01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69d3a7547848c029e9edaf3e8240c01">halide_profiler_sample</a> (struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *s, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *prev_t)</td></tr>
<tr class="memdesc:af69d3a7547848c029e9edaf3e8240c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects profiling information.  <br /></td></tr>
<tr class="separator:af69d3a7547848c029e9edaf3e8240c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449e2969ebd8ffbaaacbb88302bc21ff" id="r_a449e2969ebd8ffbaaacbb88302bc21ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a449e2969ebd8ffbaaacbb88302bc21ff">halide_profiler_reset</a> (void)</td></tr>
<tr class="memdesc:a449e2969ebd8ffbaaacbb88302bc21ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset profiler state cheaply.  <br /></td></tr>
<tr class="separator:a449e2969ebd8ffbaaacbb88302bc21ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a6253f36b6967880b1f53fa8a9752f" id="r_aa4a6253f36b6967880b1f53fa8a9752f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4a6253f36b6967880b1f53fa8a9752f">halide_profiler_shutdown</a> (void)</td></tr>
<tr class="memdesc:aa4a6253f36b6967880b1f53fa8a9752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all profiler state.  <br /></td></tr>
<tr class="separator:aa4a6253f36b6967880b1f53fa8a9752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98690684642752376f858a9c6f1ccd29" id="r_a98690684642752376f858a9c6f1ccd29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98690684642752376f858a9c6f1ccd29">halide_profiler_report</a> (void *user_context)</td></tr>
<tr class="memdesc:a98690684642752376f858a9c6f1ccd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out timing statistics for everything run since the last reset.  <br /></td></tr>
<tr class="separator:a98690684642752376f858a9c6f1ccd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3bdb4573e61ca17219fbd2eed91801" id="r_a1a3bdb4573e61ca17219fbd2eed91801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3bdb4573e61ca17219fbd2eed91801">halide_profiler_lock</a> (struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *)</td></tr>
<tr class="memdesc:a1a3bdb4573e61ca17219fbd2eed91801"><td class="mdescLeft">&#160;</td><td class="mdescRight">These routines are called to temporarily disable and then reenable the profiler.  <br /></td></tr>
<tr class="separator:a1a3bdb4573e61ca17219fbd2eed91801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69d73718f2f49559522f85df440f8b3" id="r_ac69d73718f2f49559522f85df440f8b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69d73718f2f49559522f85df440f8b3">halide_profiler_unlock</a> (struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *)</td></tr>
<tr class="separator:ac69d73718f2f49559522f85df440f8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">"Float16" functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions operate of bits (<code>uint16_t</code>) representing a half precision floating point number (IEEE-754 2008 binary16). </p>
</div></td></tr>
<tr class="memitem:af23e3224639e2458c55cebf2a6dccfaf" id="r_af23e3224639e2458c55cebf2a6dccfaf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af23e3224639e2458c55cebf2a6dccfaf">halide_float16_bits_to_float</a> (<a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>)</td></tr>
<tr class="memdesc:af23e3224639e2458c55cebf2a6dccfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bits representing a half precision floating point number and return the float that represents the same value.  <br /></td></tr>
<tr class="separator:af23e3224639e2458c55cebf2a6dccfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2494e69e2956ca6af09befd1d5bbf142" id="r_a2494e69e2956ca6af09befd1d5bbf142"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2494e69e2956ca6af09befd1d5bbf142">halide_float16_bits_to_double</a> (<a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>)</td></tr>
<tr class="memdesc:a2494e69e2956ca6af09befd1d5bbf142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bits representing a half precision floating point number and return the double that represents the same value.  <br /></td></tr>
<tr class="separator:a2494e69e2956ca6af09befd1d5bbf142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da489f1aeb8ed32002307caeaa35b95" id="r_a9da489f1aeb8ed32002307caeaa35b95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da489f1aeb8ed32002307caeaa35b95">halide_reuse_device_allocations</a> (void *user_context, bool)</td></tr>
<tr class="memdesc:a9da489f1aeb8ed32002307caeaa35b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> whether or not it is permitted to hold onto device allocations to service future requests instead of returning them eagerly to the underlying device API.  <br /></td></tr>
<tr class="separator:a9da489f1aeb8ed32002307caeaa35b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd349501e76494f9f6bd4b3d088b6d2" id="r_a9fd349501e76494f9f6bd4b3d088b6d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fd349501e76494f9f6bd4b3d088b6d2">halide_can_reuse_device_allocations</a> (void *user_context)</td></tr>
<tr class="memdesc:a9fd349501e76494f9f6bd4b3d088b6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether on device_free the memory is returned immediately to the device API, or placed on a free list for future use.  <br /></td></tr>
<tr class="separator:a9fd349501e76494f9f6bd4b3d088b6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ad1ca0c4898fd64fb62711db1a2429" id="r_af8ad1ca0c4898fd64fb62711db1a2429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8ad1ca0c4898fd64fb62711db1a2429">halide_register_device_allocation_pool</a> (struct <a class="el" href="structhalide__device__allocation__pool.html">halide_device_allocation_pool</a> *)</td></tr>
<tr class="memdesc:af8ad1ca0c4898fd64fb62711db1a2429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback to be informed when halide_reuse_device_allocations(false) is called, and all unused device allocations must be released.  <br /></td></tr>
<tr class="separator:af8ad1ca0c4898fd64fb62711db1a2429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file declares the routines used by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> internally in its runtime. </p>
<p>On platforms that support weak linking, these can be replaced with user-defined versions by defining an extern "C" function with the same name and signature.</p>
<p>When doing Just In Time (JIT) compilation members of some_pipeline_or_func.jit_handlers() must be replaced instead. The corresponding methods are documented below.</p>
<p>All of these functions take a "void *user_context" parameter as their first argument; if the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> kernel that calls back to any of these functions has been compiled with the UserContext feature set on its Target, then the value of that pointer passed from the code that calls the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> kernel is piped through to the function.</p>
<p>Some of these are also useful to call when using the default implementation. E.g. halide_shutdown_thread_pool.</p>
<p>Note that even on platforms with weak linking, some linker setups may not respect the override you provide. E.g. if the override is in a shared library and the halide object files are linked directly into the output, the builtin versions of the runtime functions will be called. See your linker documentation for more details. On Linux, LD_DYNAMIC_WEAK=1 may help. </p>

<p class="definition">Definition in file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a216875cf28091f8e34d7528225e7a20a" name="a216875cf28091f8e34d7528225e7a20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216875cf28091f8e34d7528225e7a20a">&#9670;&#160;</a></span>HALIDE_VERSION_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_VERSION_MAJOR&#160;&#160;&#160;19</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00026">26</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a0647c3b72552add6d9e1a3cf77505151" name="a0647c3b72552add6d9e1a3cf77505151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0647c3b72552add6d9e1a3cf77505151">&#9670;&#160;</a></span>HALIDE_VERSION_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_VERSION_MINOR&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00027">27</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a1a01eec46b85c91844f7a89a969a77d0" name="a1a01eec46b85c91844f7a89a969a77d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a01eec46b85c91844f7a89a969a77d0">&#9670;&#160;</a></span>HALIDE_VERSION_PATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_VERSION_PATCH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00028">28</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="ac0c2048ce1a292798d15d9dc3346de26" name="ac0c2048ce1a292798d15d9dc3346de26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c2048ce1a292798d15d9dc3346de26">&#9670;&#160;</a></span>HALIDE_ALWAYS_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ALWAYS_INLINE&#160;&#160;&#160;inline __attribute__((always_inline))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00049">49</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="aaf5c75e0994add0b42829f89d0bf3345" name="aaf5c75e0994add0b42829f89d0bf3345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5c75e0994add0b42829f89d0bf3345">&#9670;&#160;</a></span>HALIDE_NEVER_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_NEVER_INLINE&#160;&#160;&#160;__attribute__((noinline))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00050">50</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="ab4f587d17af0ba4c115547bcd9c873fd" name="ab4f587d17af0ba4c115547bcd9c873fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f587d17af0ba4c115547bcd9c873fd">&#9670;&#160;</a></span>HALIDE_MUST_USE_RESULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_MUST_USE_RESULT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00065">65</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a83937d3cfac5d949807b5f9522cb7fde" name="a83937d3cfac5d949807b5f9522cb7fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83937d3cfac5d949807b5f9522cb7fde">&#9670;&#160;</a></span>HALIDE_FUNCTION_ATTRS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FUNCTION_ATTRS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00076">76</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a011fabf6af2c9c965cacaf866d579f8a" name="a011fabf6af2c9c965cacaf866d579f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011fabf6af2c9c965cacaf866d579f8a">&#9670;&#160;</a></span>HALIDE_EXPORT_SYMBOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_EXPORT_SYMBOL&#160;&#160;&#160;__attribute__((visibility(&quot;default&quot;)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00083">83</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="afaa0f73fc7954ac27a2c11020681cdf3" name="afaa0f73fc7954ac27a2c11020681cdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa0f73fc7954ac27a2c11020681cdf3">&#9670;&#160;</a></span>HALIDE_ATTRIBUTE_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ATTRIBUTE_ALIGN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__attribute__((aligned(x)))</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00491">491</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a9bb1030f4a2614c18adb6d088529f911" name="a9bb1030f4a2614c18adb6d088529f911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb1030f4a2614c18adb6d088529f911">&#9670;&#160;</a></span>HALIDE_ATTRIBUTE_DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ATTRIBUTE_DEPRECATED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__attribute__((deprecated(x)))</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01705">1705</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a95ff0cf917a42d9d94858d965f0cea70" name="a95ff0cf917a42d9d94858d965f0cea70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ff0cf917a42d9d94858d965f0cea70">&#9670;&#160;</a></span>halide_print_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* halide_print_t) (void *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00170">170</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a51ba9ee9334354b8b260138b464bdaac" name="a51ba9ee9334354b8b260138b464bdaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ba9ee9334354b8b260138b464bdaac">&#9670;&#160;</a></span>halide_error_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* halide_error_handler_t) (void *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00184">184</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a44ad38bc9436040001a7fa8806e9a1a4" name="a44ad38bc9436040001a7fa8806e9a1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ad38bc9436040001a7fa8806e9a1a4">&#9670;&#160;</a></span>halide_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_task_t) (void *user_context, int task_number, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00229">229</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a35e17d010d9d296d3133f1b34060cda6" name="a35e17d010d9d296d3133f1b34060cda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e17d010d9d296d3133f1b34060cda6">&#9670;&#160;</a></span>halide_do_par_for_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_do_par_for_t) (void *, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a>, int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom method for performing a parallel for loop. </p>
<p>Returns the old do_par_for handler. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00238">238</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="ae0af757a561193139295a85256e68135" name="ae0af757a561193139295a85256e68135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0af757a561193139295a85256e68135">&#9670;&#160;</a></span>halide_semaphore_init_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_semaphore_init_t) (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00255">255</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a187d0100ae8d267bbcb6e840433c0f72" name="a187d0100ae8d267bbcb6e840433c0f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187d0100ae8d267bbcb6e840433c0f72">&#9670;&#160;</a></span>halide_semaphore_release_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_semaphore_release_t) (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00256">256</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a97edf37f8f01638b513e24f9173b489f" name="a97edf37f8f01638b513e24f9173b489f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97edf37f8f01638b513e24f9173b489f">&#9670;&#160;</a></span>halide_semaphore_try_acquire_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* halide_semaphore_try_acquire_t) (struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00257">257</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="aa33673c0e9af6749f566f32386b168c4" name="aa33673c0e9af6749f566f32386b168c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33673c0e9af6749f566f32386b168c4">&#9670;&#160;</a></span>halide_loop_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_loop_task_t) (void *user_context, int min, int extent, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure, void *task_parent)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A task representing a serial for loop evaluated over some range. </p>
<p>Note that task_parent is a pass through argument that should be passed to any dependent taks that are invoked using halide_do_parallel_tasks underneath this call. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00263">263</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="acc89fad6bf8607479e7643d17c973bd9" name="acc89fad6bf8607479e7643d17c973bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc89fad6bf8607479e7643d17c973bd9">&#9670;&#160;</a></span>halide_do_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_do_task_t) (void *, <a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you use the default do_par_for, you can still set a custom handler to perform each individual task. </p>
<p>Returns the old handler. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00330">330</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a7e98cafa58d17ab564e0783acb88c8bc" name="a7e98cafa58d17ab564e0783acb88c8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e98cafa58d17ab564e0783acb88c8bc">&#9670;&#160;</a></span>halide_do_loop_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_do_loop_task_t) (void *, <a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a>, int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The version of do_task called for loop tasks. </p>
<p>By default calls the loop task with the same arguments. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00339">339</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="afd29e5ed7d54ed3d92cb745915ef8909" name="afd29e5ed7d54ed3d92cb745915ef8909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd29e5ed7d54ed3d92cb745915ef8909">&#9670;&#160;</a></span>halide_do_parallel_tasks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_do_parallel_tasks_t) (void *, int, struct <a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a> *, void *task_parent)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide an entire custom tasking runtime via function pointers. </p>
<p>Note that do_task and semaphore_try_acquire are only ever called by halide_default_do_par_for and halide_default_do_parallel_tasks, so it's only necessary to provide those if you are mixing in the default implementations of do_par_for and do_parallel_tasks. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00352">352</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="aed4628363dd76e044feb9aa8280a1b84" name="aed4628363dd76e044feb9aa8280a1b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4628363dd76e044feb9aa8280a1b84">&#9670;&#160;</a></span>halide_malloc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *(* halide_malloc_t) (void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00429">429</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="aa17654ef6deb96a3aef03126bd35221a" name="aa17654ef6deb96a3aef03126bd35221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17654ef6deb96a3aef03126bd35221a">&#9670;&#160;</a></span>halide_free_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* halide_free_t) (void *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00430">430</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a7a1424c74013b0adc86c02878c407fb5" name="a7a1424c74013b0adc86c02878c407fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1424c74013b0adc86c02878c407fb5">&#9670;&#160;</a></span>halide_get_symbol_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *(* halide_get_symbol_t) (const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00452">452</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a169fd95ae0b4b9e080896cedc4adbd8e" name="a169fd95ae0b4b9e080896cedc4adbd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169fd95ae0b4b9e080896cedc4adbd8e">&#9670;&#160;</a></span>halide_load_library_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *(* halide_load_library_t) (const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00453">453</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a2788d811e1a39b30870b1d6b94d7826e" name="a2788d811e1a39b30870b1d6b94d7826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2788d811e1a39b30870b1d6b94d7826e">&#9670;&#160;</a></span>halide_get_library_symbol_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *(* halide_get_library_symbol_t) (void *lib, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00454">454</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a64a57ef65fae60e9b7e3a1bc09f38c14" name="a64a57ef65fae60e9b7e3a1bc09f38c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a57ef65fae60e9b7e3a1bc09f38c14">&#9670;&#160;</a></span>halide_type_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a> <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types in the halide type system. </p>
<p>They can be ints, unsigned ints, or floats (of various bit-widths), or a handle (which is always 64-bits). Note that the int/uint/float values do not imply a specific bit width (the bit width is expected to be encoded in a separate value). </p>

</div>
</div>
<a id="acac84473600d9caee1f3ab634cb117ba" name="acac84473600d9caee1f3ab634cb117ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac84473600d9caee1f3ab634cb117ba">&#9670;&#160;</a></span>halide_trace_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>(* halide_trace_t) (void *user_context, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00671">671</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a215e0bf22f304152800a8e2d23ccee4c" name="a215e0bf22f304152800a8e2d23ccee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215e0bf22f304152800a8e2d23ccee4c">&#9670;&#160;</a></span>halide_target_feature_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a> <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a compilation Target can have. </p>
<p>Be sure to keep this in sync with the Feature enum in <a class="el" href="_target_8h.html" title="Defines the structure that describes a Halide target.">Target.h</a> and the implementation of get_runtime_compatible_target in Target.cpp if you add a new feature. </p>

</div>
</div>
<a id="a7756790d1df276babe85759aecb9214e" name="a7756790d1df276babe85759aecb9214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7756790d1df276babe85759aecb9214e">&#9670;&#160;</a></span>halide_can_use_target_features_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_can_use_target_features_t) (int count, const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *features)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01484">1484</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a6f13e7e8488c33a21bdfefb666823be0" name="a6f13e7e8488c33a21bdfefb666823be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f13e7e8488c33a21bdfefb666823be0">&#9670;&#160;</a></span>halide_dimension_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct halide_dimension_t halide_dimension_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff80b56521d2a957df55d69ab81589a0" name="aff80b56521d2a957df55d69ab81589a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff80b56521d2a957df55d69ab81589a0">&#9670;&#160;</a></span>halide_buffer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct halide_buffer_t halide_buffer_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code. </p>
<p>It includes some stuff to track whether the image is not actually in main memory, but instead on a device (like a GPU). For a more convenient C++ wrapper, use Halide::Buffer&lt;T&gt;. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9f4c40f298e91dea4f532774dc57a450" name="a9f4c40f298e91dea4f532774dc57a450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4c40f298e91dea4f532774dc57a450">&#9670;&#160;</a></span>halide_type_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types in the halide type system. </p>
<p>They can be ints, unsigned ints, or floats (of various bit-widths), or a handle (which is always 64-bits). Note that the int/uint/float values do not imply a specific bit width (the bit width is expected to be encoded in a separate value). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa" name="a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa"></a>halide_type_int&#160;</td><td class="fielddoc"><p>signed integers </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d" name="a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d"></a>halide_type_uint&#160;</td><td class="fielddoc"><p>unsigned integers </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b" name="a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b"></a>halide_type_float&#160;</td><td class="fielddoc"><p>IEEE floating point numbers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef" name="a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef"></a>halide_type_handle&#160;</td><td class="fielddoc"><p>opaque pointer type (void *) </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f4c40f298e91dea4f532774dc57a450a33f41ea25f7f5bb3ed43a303d9787d1e" name="a9f4c40f298e91dea4f532774dc57a450a33f41ea25f7f5bb3ed43a303d9787d1e"></a>halide_type_bfloat&#160;</td><td class="fielddoc"><p>floating point numbers in the bfloat format </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00473">473</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a485130f12eb8bb5fa5a9478eeb6b0dfa" name="a485130f12eb8bb5fa5a9478eeb6b0dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485130f12eb8bb5fa5a9478eeb6b0dfa">&#9670;&#160;</a></span>halide_trace_event_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a485130f12eb8bb5fa5a9478eeb6b0dfa">halide_trace_event_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaa2cbd3048c959f6d8def944097d8e21c9" name="a485130f12eb8bb5fa5a9478eeb6b0dfaa2cbd3048c959f6d8def944097d8e21c9"></a>halide_trace_load&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaa57b32d087e0862bd6ba748ce7743a851" name="a485130f12eb8bb5fa5a9478eeb6b0dfaa57b32d087e0862bd6ba748ce7743a851"></a>halide_trace_store&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaad8657c19f6b2b9cc79fa3a438f39687b" name="a485130f12eb8bb5fa5a9478eeb6b0dfaad8657c19f6b2b9cc79fa3a438f39687b"></a>halide_trace_begin_realization&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaacb0bdc3e4044609ab7fae05b921595ab" name="a485130f12eb8bb5fa5a9478eeb6b0dfaacb0bdc3e4044609ab7fae05b921595ab"></a>halide_trace_end_realization&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaac4047c93cd032261e8373e38944bf7a1" name="a485130f12eb8bb5fa5a9478eeb6b0dfaac4047c93cd032261e8373e38944bf7a1"></a>halide_trace_produce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaac0c72771e1401fad47e3234caa121427" name="a485130f12eb8bb5fa5a9478eeb6b0dfaac0c72771e1401fad47e3234caa121427"></a>halide_trace_end_produce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaa0dac17982d8ef6c404f94e5b7dd4de54" name="a485130f12eb8bb5fa5a9478eeb6b0dfaa0dac17982d8ef6c404f94e5b7dd4de54"></a>halide_trace_consume&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaac98849a734841652345dc3d37660c136" name="a485130f12eb8bb5fa5a9478eeb6b0dfaac98849a734841652345dc3d37660c136"></a>halide_trace_end_consume&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaa7b9317d3544502c02e018db4bac2b97e" name="a485130f12eb8bb5fa5a9478eeb6b0dfaa7b9317d3544502c02e018db4bac2b97e"></a>halide_trace_begin_pipeline&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaa92151c79c44b19ad2c1074fb6f113b1c" name="a485130f12eb8bb5fa5a9478eeb6b0dfaa92151c79c44b19ad2c1074fb6f113b1c"></a>halide_trace_end_pipeline&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a485130f12eb8bb5fa5a9478eeb6b0dfaa30020f90f4631cab975d7afa75875f01" name="a485130f12eb8bb5fa5a9478eeb6b0dfaa30020f90f4631cab975d7afa75875f01"></a>halide_trace_tag&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00574">574</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="aba16e170cc9aa30b78ff703e101a448c" name="aba16e170cc9aa30b78ff703e101a448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba16e170cc9aa30b78ff703e101a448c">&#9670;&#160;</a></span>halide_error_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aba16e170cc9aa30b78ff703e101a448c">halide_error_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error codes that may be returned by a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04" name="aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04"></a>halide_error_code_success&#160;</td><td class="fielddoc"><p>There was no error. </p>
<p>This is the value returned by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> on success. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05" name="aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05"></a>halide_error_code_generic_error&#160;</td><td class="fielddoc"><p>An uncategorized error occurred. </p>
<p>Refer to the string passed to halide_error. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c" name="aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c"></a>halide_error_code_explicit_bounds_too_small&#160;</td><td class="fielddoc"><p>A Func was given an explicit bound via Func::bound, but this was not large enough to encompass the region that is used of the Func by the rest of the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cac864d0a2ca831c3c757b6e410d8cdd3f" name="aba16e170cc9aa30b78ff703e101a448cac864d0a2ca831c3c757b6e410d8cdd3f"></a>halide_error_code_bad_type&#160;</td><td class="fielddoc"><p>The elem_size field of a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> does not match the size in bytes of the type of that ImageParam. </p>
<p>Probable type mismatch. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea" name="aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea"></a>halide_error_code_access_out_of_bounds&#160;</td><td class="fielddoc"><p>A pipeline would access memory outside of the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> passed in. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6" name="aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6"></a>halide_error_code_buffer_allocation_too_large&#160;</td><td class="fielddoc"><p>A <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> was given that spans more than 2GB of memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b" name="aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b"></a>halide_error_code_buffer_extents_too_large&#160;</td><td class="fielddoc"><p>A <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> was given with extents that multiply to a number greater than 2^31-1. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6" name="aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6"></a>halide_error_code_constraints_make_required_region_smaller&#160;</td><td class="fielddoc"><p>Applying explicit constraints on the size of an input or output buffer shrank the size of that buffer below what will be accessed by the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334" name="aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334"></a>halide_error_code_constraint_violated&#160;</td><td class="fielddoc"><p>A constraint on a size or stride of an input or output buffer was not met by the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> passed in. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8" name="aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8"></a>halide_error_code_param_too_small&#160;</td><td class="fielddoc"><p>A scalar parameter passed in was smaller than its minimum declared value. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c" name="aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c"></a>halide_error_code_param_too_large&#160;</td><td class="fielddoc"><p>A scalar parameter passed in was greater than its minimum declared value. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0" name="aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0"></a>halide_error_code_out_of_memory&#160;</td><td class="fielddoc"><p>A call to halide_malloc returned NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a" name="aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a"></a>halide_error_code_buffer_argument_is_null&#160;</td><td class="fielddoc"><p>A <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> pointer passed in was NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff" name="aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff"></a>halide_error_code_debug_to_file_failed&#160;</td><td class="fielddoc"><p>debug_to_file failed to open or write to the specified file. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636" name="aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636"></a>halide_error_code_copy_to_host_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to copy from device to host. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54" name="aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54"></a>halide_error_code_copy_to_device_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to copy from host to device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb" name="aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb"></a>halide_error_code_device_malloc_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to allocate memory on device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952" name="aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952"></a>halide_error_code_device_sync_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to synchronize with a device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1" name="aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1"></a>halide_error_code_device_free_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to free a device allocation. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956" name="aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956"></a>halide_error_code_no_device_interface&#160;</td><td class="fielddoc"><p>Buffer has a non-zero device but no device interface, which violates a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> invariant. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0fb6033e4cda78003a8e3e224fce8834" name="aba16e170cc9aa30b78ff703e101a448ca0fb6033e4cda78003a8e3e224fce8834"></a>halide_error_code_unimplemented&#160;</td><td class="fielddoc"><p>This part of the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime is unimplemented on this platform. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0218e9271bc4857117e70b86c326d6bf" name="aba16e170cc9aa30b78ff703e101a448ca0218e9271bc4857117e70b86c326d6bf"></a>halide_error_code_symbol_not_found&#160;</td><td class="fielddoc"><p>A runtime symbol could not be loaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867" name="aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867"></a>halide_error_code_internal_error&#160;</td><td class="fielddoc"><p>There is a bug in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> compiler. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cacf7f17603b30be3f4df86d701df4ee2a" name="aba16e170cc9aa30b78ff703e101a448cacf7f17603b30be3f4df86d701df4ee2a"></a>halide_error_code_device_run_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to launch a GPU kernel. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caf843735e0a784d64e56fcff6069cdb5d" name="aba16e170cc9aa30b78ff703e101a448caf843735e0a784d64e56fcff6069cdb5d"></a>halide_error_code_unaligned_host_ptr&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered a host pointer that violated the alignment set for it by way of a call to set_host_alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca07b8321ceede9444ea7bba637a9bb7c1" name="aba16e170cc9aa30b78ff703e101a448ca07b8321ceede9444ea7bba637a9bb7c1"></a>halide_error_code_bad_fold&#160;</td><td class="fielddoc"><p>A fold_storage directive was used on a dimension that is not accessed in a monotonically increasing or decreasing fashion. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0a42d062cb8da32cf5158daab9c37c41" name="aba16e170cc9aa30b78ff703e101a448ca0a42d062cb8da32cf5158daab9c37c41"></a>halide_error_code_fold_factor_too_small&#160;</td><td class="fielddoc"><p>A fold_storage directive was used with a fold factor that was too small to store all the values of a producer needed by the consumer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca180c55e696deec0e26fc4b82fadefd4c" name="aba16e170cc9aa30b78ff703e101a448ca180c55e696deec0e26fc4b82fadefd4c"></a>halide_error_code_requirement_failed&#160;</td><td class="fielddoc"><p>User-specified require() expression was not satisfied. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca2b91673e6f8ed8585e1571a03173ea22" name="aba16e170cc9aa30b78ff703e101a448ca2b91673e6f8ed8585e1571a03173ea22"></a>halide_error_code_buffer_extents_negative&#160;</td><td class="fielddoc"><p>At least one of the buffer's extents are negative. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caa3fbac5e442e92463d4759bc05b013de" name="aba16e170cc9aa30b78ff703e101a448caa3fbac5e442e92463d4759bc05b013de"></a>halide_error_code_gpu_device_error&#160;</td><td class="fielddoc"><p>Call(s) to a GPU backend API failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca636cfe40bc322d3404e7a2822e75585c" name="aba16e170cc9aa30b78ff703e101a448ca636cfe40bc322d3404e7a2822e75585c"></a>halide_error_code_trace_failed&#160;</td><td class="fielddoc"><p>Failure recording trace packets for one of the halide_target_feature_trace features. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0e0b319ab036506ee80df45c1f5cdac0" name="aba16e170cc9aa30b78ff703e101a448ca0e0b319ab036506ee80df45c1f5cdac0"></a>halide_error_code_specialize_fail&#160;</td><td class="fielddoc"><p>A specialize_fail() schedule branch was selected at runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caf62f07052c51fb9e472d4cf6c532a7c8" name="aba16e170cc9aa30b78ff703e101a448caf62f07052c51fb9e472d4cf6c532a7c8"></a>halide_error_code_device_wrap_native_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to wrap a native device handle. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cae266cbe94993fa5d35f132f9c328d2db" name="aba16e170cc9aa30b78ff703e101a448cae266cbe94993fa5d35f132f9c328d2db"></a>halide_error_code_device_detach_native_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to detach a native device handle. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caffcf78ff125063ab9c8e954abe567ace" name="aba16e170cc9aa30b78ff703e101a448caffcf78ff125063ab9c8e954abe567ace"></a>halide_error_code_host_is_null&#160;</td><td class="fielddoc"><p>The host field on an input or output was null, the device field was not zero, and the pipeline tries to use the buffer on the host. </p>
<p>You may be passing a GPU-only buffer to a pipeline which is scheduled to use it on the CPU. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca1d2cfff02490bcedfd20469214ad70c3" name="aba16e170cc9aa30b78ff703e101a448ca1d2cfff02490bcedfd20469214ad70c3"></a>halide_error_code_bad_extern_fold&#160;</td><td class="fielddoc"><p>A folded buffer was passed to an extern stage, but the region touched wraps around the fold boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0ad8cd419a295189b17c72c43ff84205" name="aba16e170cc9aa30b78ff703e101a448ca0ad8cd419a295189b17c72c43ff84205"></a>halide_error_code_device_interface_no_device&#160;</td><td class="fielddoc"><p>Buffer has a non-null device_interface but device is 0, which violates a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> invariant. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca9b506d3be06437581c2cf134864e95d6" name="aba16e170cc9aa30b78ff703e101a448ca9b506d3be06437581c2cf134864e95d6"></a>halide_error_code_host_and_device_dirty&#160;</td><td class="fielddoc"><p>Buffer has both host and device dirty bits set, which violates a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> invariant. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448caae50247da4279642e31717a47cf7a589" name="aba16e170cc9aa30b78ff703e101a448caae50247da4279642e31717a47cf7a589"></a>halide_error_code_buffer_is_null&#160;</td><td class="fielddoc"><p>The <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> * passed to a halide runtime routine is nullptr and this is not allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cab786372718ef27630f52aeed8c2e1d2b" name="aba16e170cc9aa30b78ff703e101a448cab786372718ef27630f52aeed8c2e1d2b"></a>halide_error_code_device_buffer_copy_failed&#160;</td><td class="fielddoc"><p>The <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime encountered an error while trying to copy from one buffer to another. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cab53498a31c13dc516a1b442b7f783b50" name="aba16e170cc9aa30b78ff703e101a448cab53498a31c13dc516a1b442b7f783b50"></a>halide_error_code_device_crop_unsupported&#160;</td><td class="fielddoc"><p>Attempted to make cropped/sliced alias of a buffer with a device field, but the device_interface does not support cropping. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca4a191b004650bc15f04123288b21f6fc" name="aba16e170cc9aa30b78ff703e101a448ca4a191b004650bc15f04123288b21f6fc"></a>halide_error_code_device_crop_failed&#160;</td><td class="fielddoc"><p>Cropping/slicing a buffer failed for some other reason. </p>
<p>Turn on -debug in your target string. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca1f949dfbaa997c19b39d3ae50edb944f" name="aba16e170cc9aa30b78ff703e101a448ca1f949dfbaa997c19b39d3ae50edb944f"></a>halide_error_code_incompatible_device_interface&#160;</td><td class="fielddoc"><p>An operation on a buffer required an allocation on a particular device interface, but a device allocation already existed on a different device interface. </p>
<p>Free the old one first. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca88b1fd3d786d212a1c91f93437682175" name="aba16e170cc9aa30b78ff703e101a448ca88b1fd3d786d212a1c91f93437682175"></a>halide_error_code_bad_dimensions&#160;</td><td class="fielddoc"><p>The dimensions field of a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> does not match the dimensions of that ImageParam. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cad2e9ab8945e949414ac0998e6992e2f3" name="aba16e170cc9aa30b78ff703e101a448cad2e9ab8945e949414ac0998e6992e2f3"></a>halide_error_code_device_dirty_with_no_device_support&#160;</td><td class="fielddoc"><p>A buffer with the device_dirty flag set was passed to a pipeline compiled with no device backends enabled, so it doesn't know how to copy the data back from device memory to host memory. </p>
<p>Either call copy_to_host before calling the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, or enable the appropriate device backend. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cae7d98644ac4b7070b8d5a02bd14dd63a" name="aba16e170cc9aa30b78ff703e101a448cae7d98644ac4b7070b8d5a02bd14dd63a"></a>halide_error_code_storage_bound_too_small&#160;</td><td class="fielddoc"><p>An explicit storage bound provided is too small to store all the values produced by the function. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca0ab0a51167a93acec677fb6ec61aefce" name="aba16e170cc9aa30b78ff703e101a448ca0ab0a51167a93acec677fb6ec61aefce"></a>halide_error_code_split_factor_not_positive&#160;</td><td class="fielddoc"><p>A factor used to split a loop was discovered to be zero or negative at runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448ca40d93e4618ce4b82fcce81025796c153" name="aba16e170cc9aa30b78ff703e101a448ca40d93e4618ce4b82fcce81025796c153"></a>halide_error_code_vscale_invalid&#160;</td><td class="fielddoc"><p>"vscale" value of Scalable Vector detected in runtime does not match the vscale value used in compilation. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba16e170cc9aa30b78ff703e101a448cad62b19b86ea679d9f0a3f3d052ad228a" name="aba16e170cc9aa30b78ff703e101a448cad62b19b86ea679d9f0a3f3d052ad228a"></a>halide_error_code_cannot_profile_pipeline&#160;</td><td class="fielddoc"><p>Profiling failed for a pipeline invocation. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01070">1070</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a2ccb96b3d427fff8f1d68cc5f1e92f3a" name="a2ccb96b3d427fff8f1d68cc5f1e92f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">&#9670;&#160;</a></span>halide_target_feature_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a compilation Target can have. </p>
<p>Be sure to keep this in sync with the Feature enum in <a class="el" href="_target_8h.html" title="Defines the structure that describes a Halide target.">Target.h</a> and the implementation of get_runtime_compatible_target in Target.cpp if you add a new feature. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aade7b43403349f5e8490128ec8a353ea0" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aade7b43403349f5e8490128ec8a353ea0"></a>halide_target_feature_jit&#160;</td><td class="fielddoc"><p>Generate code that will run immediately inside the calling process. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa269192ac4c709ac4cd58a224aaa4ebed" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa269192ac4c709ac4cd58a224aaa4ebed"></a>halide_target_feature_debug&#160;</td><td class="fielddoc"><p>Turn on debug info and output for runtime code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1091af1b1f0fd0f65a4cf11d9465421b" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1091af1b1f0fd0f65a4cf11d9465421b"></a>halide_target_feature_no_asserts&#160;</td><td class="fielddoc"><p>Disable all runtime checks, for slightly tighter code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf66b5dc5721dc9d3437418d2af78218a" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf66b5dc5721dc9d3437418d2af78218a"></a>halide_target_feature_no_bounds_query&#160;</td><td class="fielddoc"><p>Disable the bounds querying functionality. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8efcb48a15fdbfeb9a80f4e4b47f6c35" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8efcb48a15fdbfeb9a80f4e4b47f6c35"></a>halide_target_feature_sse41&#160;</td><td class="fielddoc"><p>Use SSE 4.1 and earlier instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aae30ffae7b5e51bd142e5902c6b60d2a5" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aae30ffae7b5e51bd142e5902c6b60d2a5"></a>halide_target_feature_avx&#160;</td><td class="fielddoc"><p>Use AVX 1 instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1b8d4c5f8ff39549eab349f8f9187f30" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1b8d4c5f8ff39549eab349f8f9187f30"></a>halide_target_feature_avx2&#160;</td><td class="fielddoc"><p>Use AVX 2 instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa00ca2d6e033b225858ea63abb21123da" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa00ca2d6e033b225858ea63abb21123da"></a>halide_target_feature_fma&#160;</td><td class="fielddoc"><p>Enable x86 FMA instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c4a3ac722a0f391a41809f4fe1fa5e9" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c4a3ac722a0f391a41809f4fe1fa5e9"></a>halide_target_feature_fma4&#160;</td><td class="fielddoc"><p>Enable x86 (AMD) FMA4 instruction set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aac3f0411bb6041392120209d5eb97dd20" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aac3f0411bb6041392120209d5eb97dd20"></a>halide_target_feature_f16c&#160;</td><td class="fielddoc"><p>Enable x86 16-bit float support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5fa253bc01a2a59792fd5da6d351d35f" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5fa253bc01a2a59792fd5da6d351d35f"></a>halide_target_feature_armv7s&#160;</td><td class="fielddoc"><p>Generate code for ARMv7s. Only relevant for 32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f1be27fa92915a8d2193f0bbeb9ada5" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f1be27fa92915a8d2193f0bbeb9ada5"></a>halide_target_feature_no_neon&#160;</td><td class="fielddoc"><p>Avoid using NEON instructions. Only relevant for 32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf10caf4d87b54ef2a1eeef0a1a9ef7a4" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf10caf4d87b54ef2a1eeef0a1a9ef7a4"></a>halide_target_feature_vsx&#160;</td><td class="fielddoc"><p>Use VSX instructions. Only relevant on POWERPC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa995a835a73267a3edd9822c6d1927c3a" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa995a835a73267a3edd9822c6d1927c3a"></a>halide_target_feature_power_arch_2_07&#160;</td><td class="fielddoc"><p>Use POWER ISA 2.07 new instructions. Only relevant on POWERPC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aabaf8d7892508763403932f8e9e80b2e2" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aabaf8d7892508763403932f8e9e80b2e2"></a>halide_target_feature_cuda&#160;</td><td class="fielddoc"><p>Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5e16be3f2066021a8d24ee420d69b2a3" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5e16be3f2066021a8d24ee420d69b2a3"></a>halide_target_feature_cuda_capability30&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 3.0 (Kepler) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aad6cf6481cb5a8f405115dd91a7d71987" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aad6cf6481cb5a8f405115dd91a7d71987"></a>halide_target_feature_cuda_capability32&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 3.2 (Tegra K1) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa72e1c9e35b9184f0a8b7157374c81e9b" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa72e1c9e35b9184f0a8b7157374c81e9b"></a>halide_target_feature_cuda_capability35&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 3.5 (Kepler) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa45190927a84bdeab2a4195eae0b47f6" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa45190927a84bdeab2a4195eae0b47f6"></a>halide_target_feature_cuda_capability50&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 5.0 (Maxwell) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f6ed2f96b52eaeae62dc1beb66b74de" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f6ed2f96b52eaeae62dc1beb66b74de"></a>halide_target_feature_cuda_capability61&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 6.1 (Pascal) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c41735e9ecaf6299b4ca4cde53995a5" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c41735e9ecaf6299b4ca4cde53995a5"></a>halide_target_feature_cuda_capability70&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 7.0 (Volta) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aae994285f8cf6741104fc36429de829f8" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aae994285f8cf6741104fc36429de829f8"></a>halide_target_feature_cuda_capability75&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 7.5 (Turing) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aac0cce4a39a07985e9d3480ad9b9fecb0" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aac0cce4a39a07985e9d3480ad9b9fecb0"></a>halide_target_feature_cuda_capability80&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 8.0 (Ampere) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa510e0e93c604381bf7f5b6b374cce947" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa510e0e93c604381bf7f5b6b374cce947"></a>halide_target_feature_cuda_capability86&#160;</td><td class="fielddoc"><p>Enable CUDA compute capability 8.6 (Ampere) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa9af51d9a3d2a16a2053dee312567da3a" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa9af51d9a3d2a16a2053dee312567da3a"></a>halide_target_feature_opencl&#160;</td><td class="fielddoc"><p>Enable the OpenCL runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa10dfd45f611103dce0fcdbf671b89e5a" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa10dfd45f611103dce0fcdbf671b89e5a"></a>halide_target_feature_cl_doubles&#160;</td><td class="fielddoc"><p>Enable double support on OpenCL targets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa65d3ef99ab0c2a6347c9570cd78f2b57" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa65d3ef99ab0c2a6347c9570cd78f2b57"></a>halide_target_feature_cl_atomic64&#160;</td><td class="fielddoc"><p>Enable 64-bit atomics operations on OpenCL targets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf353c2e40c697e29b86a4e51829735df" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf353c2e40c697e29b86a4e51829735df"></a>halide_target_feature_user_context&#160;</td><td class="fielddoc"><p>Generated code takes a user_context pointer as first argument. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa700fd7b1280a9175b7cb3d43fe2c1754" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa700fd7b1280a9175b7cb3d43fe2c1754"></a>halide_target_feature_profile&#160;</td><td class="fielddoc"><p>Launch a sampling profiler alongside the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline that monitors and reports the runtime used by each Func. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa23b4add23a16a3cfe633b90f2fd6d292" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa23b4add23a16a3cfe633b90f2fd6d292"></a>halide_target_feature_no_runtime&#160;</td><td class="fielddoc"><p>Do not include a copy of the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime in any generated object file or assembly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa596a01105ce4f5896b14c69210899e35" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa596a01105ce4f5896b14c69210899e35"></a>halide_target_feature_metal&#160;</td><td class="fielddoc"><p>Enable the (Apple) Metal runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1efec7b26946ba7f59cc887dcd45ea22" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1efec7b26946ba7f59cc887dcd45ea22"></a>halide_target_feature_c_plus_plus_mangling&#160;</td><td class="fielddoc"><p>Generate C++ mangled names for result function, et al. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa00aee1f2d9370a407522de5378d9901c" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa00aee1f2d9370a407522de5378d9901c"></a>halide_target_feature_large_buffers&#160;</td><td class="fielddoc"><p>Enable 64-bit buffer indexing to support buffers &gt; 2GB. Ignored if bits != 64. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5bbb70ba548793579bef24d7bd8ffd6a" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5bbb70ba548793579bef24d7bd8ffd6a"></a>halide_target_feature_hvx_128&#160;</td><td class="fielddoc"><p>Enable HVX 128 byte mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaac0b0401c077429c652dc5d2723756f0" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaac0b0401c077429c652dc5d2723756f0"></a>halide_target_feature_hvx_v62&#160;</td><td class="fielddoc"><p>Enable Hexagon v62 architecture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf7f57223352cf39e7375d2e2af6004b2" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf7f57223352cf39e7375d2e2af6004b2"></a>halide_target_feature_fuzz_float_stores&#160;</td><td class="fielddoc"><p>On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa484bc02e560762b1c51c0bf254b00a9f" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa484bc02e560762b1c51c0bf254b00a9f"></a>halide_target_feature_soft_float_abi&#160;</td><td class="fielddoc"><p>Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa068da87b16c87dd104d9720fec39ec42" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa068da87b16c87dd104d9720fec39ec42"></a>halide_target_feature_msan&#160;</td><td class="fielddoc"><p>Enable hooks for MSAN support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa237eaab3cbd8d646c075b74f9958ba0" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa237eaab3cbd8d646c075b74f9958ba0"></a>halide_target_feature_avx512&#160;</td><td class="fielddoc"><p>Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See <a href="https://en.wikipedia.org/wiki/AVX-512">https://en.wikipedia.org/wiki/AVX-512</a> for a description of each AVX subset. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa2779d4303538045aa9317c5cfefde48" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa2779d4303538045aa9317c5cfefde48"></a>halide_target_feature_avx512_knl&#160;</td><td class="fielddoc"><p>Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa58fb5b7b5bc221459b800cc42930902f" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa58fb5b7b5bc221459b800cc42930902f"></a>halide_target_feature_avx512_skylake&#160;</td><td class="fielddoc"><p>Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa591bbdef6ade866e52fa671d8ea2aed1" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa591bbdef6ade866e52fa671d8ea2aed1"></a>halide_target_feature_avx512_cannonlake&#160;</td><td class="fielddoc"><p>Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0966785198db800ffbc3a7f892c78614" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0966785198db800ffbc3a7f892c78614"></a>halide_target_feature_avx512_zen4&#160;</td><td class="fielddoc"><p>Enable the AVX512 features supported by Zen4 processors. This include all of the Cannonlake features, plus AVX512-VNNI, AVX512-BF16, and more. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8d0583967260da27df1648419d4717e5" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8d0583967260da27df1648419d4717e5"></a>halide_target_feature_avx512_sapphirerapids&#160;</td><td class="fielddoc"><p>Enable the AVX512 features supported by Sapphire Rapids processors. This include all of the Zen4 features, plus AVX-VNNI and AMX instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0de323126eca04377e205b6a67b93970" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0de323126eca04377e205b6a67b93970"></a>halide_target_feature_trace_loads&#160;</td><td class="fielddoc"><p>Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa9d6461b681abeeb0ff4c850cfe4e1eb4" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa9d6461b681abeeb0ff4c850cfe4e1eb4"></a>halide_target_feature_trace_stores&#160;</td><td class="fielddoc"><p>Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1cebf3f4e7137ca7f3a74b4c2049de4d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1cebf3f4e7137ca7f3a74b4c2049de4d"></a>halide_target_feature_trace_realizations&#160;</td><td class="fielddoc"><p>Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa62b1c56df255787c4888275f5f231fe8" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa62b1c56df255787c4888275f5f231fe8"></a>halide_target_feature_trace_pipeline&#160;</td><td class="fielddoc"><p>Trace the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa24c82b9a47277314e22da121f1bd3afb" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa24c82b9a47277314e22da121f1bd3afb"></a>halide_target_feature_hvx_v65&#160;</td><td class="fielddoc"><p>Enable Hexagon v65 architecture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aafcc6d0b70a97d9745fa89939009c243d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aafcc6d0b70a97d9745fa89939009c243d"></a>halide_target_feature_hvx_v66&#160;</td><td class="fielddoc"><p>Enable Hexagon v66 architecture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa696ef920f911837226ad41932e4fa5f4" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa696ef920f911837226ad41932e4fa5f4"></a>halide_target_feature_hvx_v68&#160;</td><td class="fielddoc"><p>Enable Hexagon v68 architecture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa7e62bc4f299a2ee506ecc9f9a4c2e1d8" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa7e62bc4f299a2ee506ecc9f9a4c2e1d8"></a>halide_target_feature_cl_half&#160;</td><td class="fielddoc"><p>Enable half support on OpenCL targets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa704512285d26323364e0ac4be27ea235" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa704512285d26323364e0ac4be27ea235"></a>halide_target_feature_strict_float&#160;</td><td class="fielddoc"><p>Turn off all non-IEEE floating-point optimization. Currently applies only to LLVM targets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa04299a57d262e533d583341eb2ab95e6" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa04299a57d262e533d583341eb2ab95e6"></a>halide_target_feature_tsan&#160;</td><td class="fielddoc"><p>Enable hooks for TSAN support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa79533b07197f576db25b29532086ec11" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa79533b07197f576db25b29532086ec11"></a>halide_target_feature_asan&#160;</td><td class="fielddoc"><p>Enable hooks for ASAN support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa50db832a52ac3e6e126dd7d0dbaff6a5" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa50db832a52ac3e6e126dd7d0dbaff6a5"></a>halide_target_feature_d3d12compute&#160;</td><td class="fielddoc"><p>Enable Direct3D 12 Compute runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaefa8e582ca33d5f579fcff6633ef7f9d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaefa8e582ca33d5f579fcff6633ef7f9d"></a>halide_target_feature_check_unsafe_promises&#160;</td><td class="fielddoc"><p>Insert assertions for promises. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa0120c543cc8bedf464bac3db5d467b6" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa0120c543cc8bedf464bac3db5d467b6"></a>halide_target_feature_hexagon_dma&#160;</td><td class="fielddoc"><p>Enable Hexagon DMA buffers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa27059c7429ebfd330393abd1736c4b76" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa27059c7429ebfd330393abd1736c4b76"></a>halide_target_feature_embed_bitcode&#160;</td><td class="fielddoc"><p>Emulate clang -fembed-bitcode flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0e302d29180ab5ce1d40bea72c6e3877" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0e302d29180ab5ce1d40bea72c6e3877"></a>halide_target_feature_enable_llvm_loop_opt&#160;</td><td class="fielddoc"><p>Enable loop vectorization + unrolling in LLVM. Overrides halide_target_feature_disable_llvm_loop_opt. (Ignored for non-LLVM targets.) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aac3615ba04732ff64ade23461d4d6f98c" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aac3615ba04732ff64ade23461d4d6f98c"></a>halide_target_feature_wasm_mvponly&#160;</td><td class="fielddoc"><p>Disable all extensions to WebAssembly codegen (including +sign-ext and +nontrapping-fptoint, which are on by default). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa34f213cb539ffca7cecaf2ab7b904c90" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa34f213cb539ffca7cecaf2ab7b904c90"></a>halide_target_feature_wasm_simd128&#160;</td><td class="fielddoc"><p>Enable +simd128 instructions for WebAssembly codegen. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0b2e15f8dbc44bd792ffe2bf610a1c8d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0b2e15f8dbc44bd792ffe2bf610a1c8d"></a>halide_target_feature_wasm_threads&#160;</td><td class="fielddoc"><p>Enable use of threads in WebAssembly codegen. Requires the use of a wasm runtime that provides pthread-compatible wrappers (typically, Emscripten with the -pthreads flag). Unsupported under WASI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0426da0f7b2751316ec624928b83e3a2" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0426da0f7b2751316ec624928b83e3a2"></a>halide_target_feature_wasm_bulk_memory&#160;</td><td class="fielddoc"><p>Enable +bulk-memory instructions for WebAssembly codegen. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aabdb7ee46fdbf8ae329b28c79902f5246" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aabdb7ee46fdbf8ae329b28c79902f5246"></a>halide_target_feature_webgpu&#160;</td><td class="fielddoc"><p>Enable the WebGPU runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf96f6eed473e71596cf7a95e8fba4673" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf96f6eed473e71596cf7a95e8fba4673"></a>halide_target_feature_sve&#160;</td><td class="fielddoc"><p>Enable ARM Scalable Vector Extensions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa4be4a8674e19695fea6f11b638d65d2d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa4be4a8674e19695fea6f11b638d65d2d"></a>halide_target_feature_sve2&#160;</td><td class="fielddoc"><p>Enable ARM Scalable Vector Extensions v2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa69114eb66218ea947c31afc2e4c9a116" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa69114eb66218ea947c31afc2e4c9a116"></a>halide_target_feature_egl&#160;</td><td class="fielddoc"><p>Force use of EGL support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8b4a2c1fe23f18c298a87abe7fc52603" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8b4a2c1fe23f18c298a87abe7fc52603"></a>halide_target_feature_arm_dot_prod&#160;</td><td class="fielddoc"><p>Enable ARMv8.2-a dotprod extension (i.e. udot and sdot instructions) </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa6a20768eb5e50aa54e93ff315f97425" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa6a20768eb5e50aa54e93ff315f97425"></a>halide_target_feature_arm_fp16&#160;</td><td class="fielddoc"><p>Enable ARMv8.2-a half-precision floating point data processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3b97d2d3ddd66f0802976b392f0e1a69" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3b97d2d3ddd66f0802976b392f0e1a69"></a>halide_llvm_large_code_model&#160;</td><td class="fielddoc"><p>Use the LLVM large code model to compile. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1315ae4adad1d3f3f982adb44dac6e99" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1315ae4adad1d3f3f982adb44dac6e99"></a>halide_target_feature_rvv&#160;</td><td class="fielddoc"><p>Enable RISCV "V" Vector Extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa7492575fe2a831253bf277de22e8d6ad" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa7492575fe2a831253bf277de22e8d6ad"></a>halide_target_feature_armv8a&#160;</td><td class="fielddoc"><p>Enable ARMv8a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aabb0e6df774584ada86b625a9b5b7078c" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aabb0e6df774584ada86b625a9b5b7078c"></a>halide_target_feature_armv81a&#160;</td><td class="fielddoc"><p>Enable ARMv8.1a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa7ed89ae933c2a0f0ab5d2be73cdc7a6" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa7ed89ae933c2a0f0ab5d2be73cdc7a6"></a>halide_target_feature_armv82a&#160;</td><td class="fielddoc"><p>Enable ARMv8.2a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf1e76add3b61129215434c277b485835" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf1e76add3b61129215434c277b485835"></a>halide_target_feature_armv83a&#160;</td><td class="fielddoc"><p>Enable ARMv8.3a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaaeb9f2d79d23f44c760fab243f67f25e" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaaeb9f2d79d23f44c760fab243f67f25e"></a>halide_target_feature_armv84a&#160;</td><td class="fielddoc"><p>Enable ARMv8.4a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aad86c50f5f0248e29f37c13fa11fb77d3" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aad86c50f5f0248e29f37c13fa11fb77d3"></a>halide_target_feature_armv85a&#160;</td><td class="fielddoc"><p>Enable ARMv8.5a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa2de72255092c6400fab771954cd8f78f" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa2de72255092c6400fab771954cd8f78f"></a>halide_target_feature_armv86a&#160;</td><td class="fielddoc"><p>Enable ARMv8.6a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa7b617ae94206c5ac0fc1340f48260392" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa7b617ae94206c5ac0fc1340f48260392"></a>halide_target_feature_armv87a&#160;</td><td class="fielddoc"><p>Enable ARMv8.7a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa62b3268b6323b359be693a41693d6afd" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa62b3268b6323b359be693a41693d6afd"></a>halide_target_feature_armv88a&#160;</td><td class="fielddoc"><p>Enable ARMv8.8a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5573c708264903f88d01e0e9ee516129" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5573c708264903f88d01e0e9ee516129"></a>halide_target_feature_armv89a&#160;</td><td class="fielddoc"><p>Enable ARMv8.9a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aac09d31cf3a2ab1782ef02d8903e86f81" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aac09d31cf3a2ab1782ef02d8903e86f81"></a>halide_target_feature_sanitizer_coverage&#160;</td><td class="fielddoc"><p>Enable hooks for SanitizerCoverage support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3d974776b5f7d6cddcd2e2038ed8aafe" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3d974776b5f7d6cddcd2e2038ed8aafe"></a>halide_target_feature_profile_by_timer&#160;</td><td class="fielddoc"><p>Alternative to halide_target_feature_profile using timer interrupt for systems without threads or applicartions that need to avoid them. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa61a757e404885163cc0a8a13a00fd83d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa61a757e404885163cc0a8a13a00fd83d"></a>halide_target_feature_spirv&#160;</td><td class="fielddoc"><p>Enable SPIR-V code generation support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa37aa234291cdced2fc7a967073ecf441" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa37aa234291cdced2fc7a967073ecf441"></a>halide_target_feature_vulkan&#160;</td><td class="fielddoc"><p>Enable Vulkan runtime support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf1177e1606d2a3afe4e922168f1b5f72" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf1177e1606d2a3afe4e922168f1b5f72"></a>halide_target_feature_vulkan_int8&#160;</td><td class="fielddoc"><p>Enable Vulkan 8-bit integer support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aac8e448d2d5be74e94288e21aaead3947" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aac8e448d2d5be74e94288e21aaead3947"></a>halide_target_feature_vulkan_int16&#160;</td><td class="fielddoc"><p>Enable Vulkan 16-bit integer support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf2af9762a2d78af22a95b982360fa937" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf2af9762a2d78af22a95b982360fa937"></a>halide_target_feature_vulkan_int64&#160;</td><td class="fielddoc"><p>Enable Vulkan 64-bit integer support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa22189b958831a81f8f21c8b59b2e9854" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa22189b958831a81f8f21c8b59b2e9854"></a>halide_target_feature_vulkan_float16&#160;</td><td class="fielddoc"><p>Enable Vulkan 16-bit float support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa87991ab063bb3a4c3965ce77086e3f18" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa87991ab063bb3a4c3965ce77086e3f18"></a>halide_target_feature_vulkan_float64&#160;</td><td class="fielddoc"><p>Enable Vulkan 64-bit float support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf77e6816140418a1629229bc08fb763d" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf77e6816140418a1629229bc08fb763d"></a>halide_target_feature_vulkan_version10&#160;</td><td class="fielddoc"><p>Enable Vulkan v1.0 runtime target support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8e330952177a0646f0cb6d4b6e86dbd2" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8e330952177a0646f0cb6d4b6e86dbd2"></a>halide_target_feature_vulkan_version12&#160;</td><td class="fielddoc"><p>Enable Vulkan v1.2 runtime target support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8dc7b8478aeba8540c70ab9ab7e89692" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8dc7b8478aeba8540c70ab9ab7e89692"></a>halide_target_feature_vulkan_version13&#160;</td><td class="fielddoc"><p>Enable Vulkan v1.3 runtime target support. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa433f44f1eea39a3af05bf8591705234e" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa433f44f1eea39a3af05bf8591705234e"></a>halide_target_feature_semihosting&#160;</td><td class="fielddoc"><p>Used together with Target::NoOS for the baremetal target built with semihosting library and run with semihosting mode where minimum I/O communication with a host PC is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa69cbb0b6f1d5e15a44a70251b559add3" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa69cbb0b6f1d5e15a44a70251b559add3"></a>halide_target_feature_avx10_1&#160;</td><td class="fielddoc"><p>Intel AVX10 version 1 support. vector_bits is used to indicate width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aafc593f88c62bf63ba04ac0939dc79323" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aafc593f88c62bf63ba04ac0939dc79323"></a>halide_target_feature_x86_apx&#160;</td><td class="fielddoc"><p>Intel x86 APX support. Covers initial set of features released as APX: egpr,push2pop2,ppx,ndd . </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3962d2fc2f69c69b85d29c4818d727c1" name="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3962d2fc2f69c69b85d29c4818d727c1"></a>halide_target_feature_end&#160;</td><td class="fielddoc"><p>A sentinel. Every target is considered to have this feature, and setting this feature does nothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01353">1353</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a320c79a12e6121c7468cb203373e6afc" name="a320c79a12e6121c7468cb203373e6afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c79a12e6121c7468cb203373e6afc">&#9670;&#160;</a></span>halide_buffer_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a320c79a12e6121c7468cb203373e6afc">halide_buffer_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a320c79a12e6121c7468cb203373e6afca1b91e0ac0aba5891e4c7219878da7460" name="a320c79a12e6121c7468cb203373e6afca1b91e0ac0aba5891e4c7219878da7460"></a>halide_buffer_flag_host_dirty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a320c79a12e6121c7468cb203373e6afca117e8a76112638ba6510e084e1dfb292" name="a320c79a12e6121c7468cb203373e6afca117e8a76112638ba6510e084e1dfb292"></a>halide_buffer_flag_device_dirty&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01538">1538</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="afdce5dc7a11fa96f39baa1aee2333745" name="afdce5dc7a11fa96f39baa1aee2333745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce5dc7a11fa96f39baa1aee2333745">&#9670;&#160;</a></span>halide_argument_kind_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afdce5dc7a11fa96f39baa1aee2333745">halide_argument_kind_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1" name="afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1"></a>halide_argument_kind_input_scalar&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b" name="afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b"></a>halide_argument_kind_input_buffer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8" name="afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8"></a>halide_argument_kind_output_buffer&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01740">1740</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a96fe1dd85166a7f0da1b8f82f734296a" name="a96fe1dd85166a7f0da1b8f82f734296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fe1dd85166a7f0da1b8f82f734296a">&#9670;&#160;</a></span>halide_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_print </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a message to stderr. </p>
<p>Main use is to support tracing functionality, print, and print_when calls. Also called by the default halide_error. This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

</div>
</div>
<a id="a2c1ae09f6ef33a2508fc67ac50f2c207" name="a2c1ae09f6ef33a2508fc67ac50f2c207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1ae09f6ef33a2508fc67ac50f2c207">&#9670;&#160;</a></span>halide_default_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_default_print </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d3e4cf6c510fd8bc26420af06b7e4f3" name="a3d3e4cf6c510fd8bc26420af06b7e4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3e4cf6c510fd8bc26420af06b7e4f3">&#9670;&#160;</a></span>halide_set_custom_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a95ff0cf917a42d9d94858d965f0cea70">halide_print_t</a> halide_set_custom_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a95ff0cf917a42d9d94858d965f0cea70">halide_print_t</a></td>          <td class="paramname"><span class="paramname"><em>print</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea28d04de54b94f0dd6ada140b7734d8" name="aea28d04de54b94f0dd6ada140b7734d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea28d04de54b94f0dd6ada140b7734d8">&#9670;&#160;</a></span>halide_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_error </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls this function on runtime errors (for example bounds checking failures). </p>
<p>This function can be replaced in JITed code by using Func::set_error_handler, or in AOT code by calling halide_set_error_handler. In AOT code on platforms that support weak linking (i.e. not Windows), you can also override it by simply defining your own halide_error. </p>

<p class="reference">Referenced by <a class="el" href="printer_8h_source.html#l00051">Halide::Runtime::Internal::PrinterBase::allocation_error()</a>, <a class="el" href="memory__arena_8h_source.html#l00101">Halide::Runtime::Internal::MemoryArena::create()</a>, <a class="el" href="string__storage_8h_source.html#l00135">Halide::Runtime::Internal::StringStorage::create()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00679">halide_set_num_threads()</a>, <a class="el" href="memory__arena_8h_source.html#l00182">Halide::Runtime::Internal::MemoryArena::reclaim()</a>, <a class="el" href="memory__arena_8h_source.html#l00155">Halide::Runtime::Internal::MemoryArena::reserve()</a>, and <a class="el" href="string__storage_8h_source.html#l00266">Halide::Runtime::Internal::StringStorage::terminate()</a>.</p>

</div>
</div>
<a id="aaf9ec52392edc2a7b65aab13183a2543" name="aaf9ec52392edc2a7b65aab13183a2543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9ec52392edc2a7b65aab13183a2543">&#9670;&#160;</a></span>halide_default_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_default_error </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02d18a3f649e46538666fb87ab3fb6ba" name="a02d18a3f649e46538666fb87ab3fb6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d18a3f649e46538666fb87ab3fb6ba">&#9670;&#160;</a></span>halide_set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a51ba9ee9334354b8b260138b464bdaac">halide_error_handler_t</a> halide_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a51ba9ee9334354b8b260138b464bdaac">halide_error_handler_t</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a479133225b3cdf7b931f3c44e878e4e8" name="a479133225b3cdf7b931f3c44e878e4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479133225b3cdf7b931f3c44e878e4e8">&#9670;&#160;</a></span>halide_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *</td>          <td class="paramname"><span class="paramname"><em>mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion. </p>
<p>Equivalent to posix calls. </p>

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00874">874</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00686">Halide::Runtime::Internal::Synchronization::fast_mutex::lock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00607">halide_default_do_par_for()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00639">halide_default_do_parallel_tasks()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00728">halide_default_semaphore_release()</a>, <a class="el" href="synchronization__common_8h_source.html#l00937">halide_mutex_array_lock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00679">halide_set_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00696">halide_shutdown_thread_pool()</a>, <a class="el" href="scoped__mutex__lock_8h_source.html#l00014">Halide::Runtime::Internal::ScopedMutexLock::ScopedMutexLock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00440">Halide::Runtime::Internal::worker_thread()</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="a5e9b62fd2c1d38e6f06100b827830377" name="a5e9b62fd2c1d38e6f06100b827830377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9b62fd2c1d38e6f06100b827830377">&#9670;&#160;</a></span>halide_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *</td>          <td class="paramname"><span class="paramname"><em>mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00880">880</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00695">Halide::Runtime::Internal::Synchronization::fast_mutex::unlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00607">halide_default_do_par_for()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00639">halide_default_do_parallel_tasks()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00728">halide_default_semaphore_release()</a>, <a class="el" href="synchronization__common_8h_source.html#l00942">halide_mutex_array_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00679">halide_set_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00696">halide_shutdown_thread_pool()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00440">Halide::Runtime::Internal::worker_thread()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>, and <a class="el" href="scoped__mutex__lock_8h_source.html#l00019">Halide::Runtime::Internal::ScopedMutexLock::~ScopedMutexLock()</a>.</p>

</div>
</div>
<a id="a1bbe46503840459907ff553296b6b4a7" name="a1bbe46503840459907ff553296b6b4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbe46503840459907ff553296b6b4a7">&#9670;&#160;</a></span>halide_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_cond_signal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__cond.html">halide_cond</a> *</td>          <td class="paramname"><span class="paramname"><em>cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00892">892</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00821">Halide::Runtime::Internal::Synchronization::fast_cond::signal()</a>.</p>

</div>
</div>
<a id="ac302062bc1dc709a0a4f05e984a6a04f" name="ac302062bc1dc709a0a4f05e984a6a04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac302062bc1dc709a0a4f05e984a6a04f">&#9670;&#160;</a></span>halide_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__cond.html">halide_cond</a> *</td>          <td class="paramname"><span class="paramname"><em>cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00886">886</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00835">Halide::Runtime::Internal::Synchronization::fast_cond::broadcast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00446">Halide::Runtime::Internal::enqueue_work_already_locked()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00728">halide_default_semaphore_release()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00696">halide_shutdown_thread_pool()</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="a3491497aac052e84053ecca86c85866e" name="a3491497aac052e84053ecca86c85866e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3491497aac052e84053ecca86c85866e">&#9670;&#160;</a></span>halide_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_cond_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__cond.html">halide_cond</a> *</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *</td>          <td class="paramname"><span class="paramname"><em>mutex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00898">898</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00848">Halide::Runtime::Internal::Synchronization::fast_cond::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="adaef67a95017fee5d961b93f458c2ff4" name="adaef67a95017fee5d961b93f458c2ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaef67a95017fee5d961b93f458c2ff4">&#9670;&#160;</a></span>halide_mutex_array_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhalide__mutex__array.html">halide_mutex_array</a> * halide_mutex_array_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>sz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00911">911</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00908">halide_mutex_array::array</a>, <a class="el" href="#a2fa49d775b9a20fab152a0650c4c936b">halide_free()</a>, <a class="el" href="#a26f08f75e6692df61c62b3a7a9e02fe4">halide_malloc()</a>, and <a class="el" href="runtime__internal_8h.html#aafbb38d8f13c5b0472c92d8e2abbea15">memset()</a>.</p>

</div>
</div>
<a id="a9910a72bd440a92da0890185f2a8e748" name="a9910a72bd440a92da0890185f2a8e748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9910a72bd440a92da0890185f2a8e748">&#9670;&#160;</a></span>halide_mutex_array_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_array_destroy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00931">931</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00908">halide_mutex_array::array</a>, and <a class="el" href="#a2fa49d775b9a20fab152a0650c4c936b">halide_free()</a>.</p>

</div>
</div>
<a id="aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2" name="aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d5b6af3c4dd021e7f8e5a8dbd4d7c2">&#9670;&#160;</a></span>halide_mutex_array_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_mutex_array_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex__array.html">halide_mutex_array</a> *</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00937">937</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00908">halide_mutex_array::array</a>, <a class="el" href="_halide_runtime_8h_source.html#l01072">halide_error_code_success</a>, and <a class="el" href="synchronization__common_8h_source.html#l00874">halide_mutex_lock()</a>.</p>

</div>
</div>
<a id="a416d98f433f488ad15e5c4b518e5ed56" name="a416d98f433f488ad15e5c4b518e5ed56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416d98f433f488ad15e5c4b518e5ed56">&#9670;&#160;</a></span>halide_mutex_array_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_mutex_array_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex__array.html">halide_mutex_array</a> *</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="synchronization__common_8h_source.html#l00942">942</a> of file <a class="el" href="synchronization__common_8h_source.html">synchronization_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00908">halide_mutex_array::array</a>, <a class="el" href="_halide_runtime_8h_source.html#l01072">halide_error_code_success</a>, and <a class="el" href="synchronization__common_8h_source.html#l00880">halide_mutex_unlock()</a>.</p>

</div>
</div>
<a id="a15f85711e52c707df2e484f69dfaf7c5" name="a15f85711e52c707df2e484f69dfaf7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f85711e52c707df2e484f69dfaf7c5">&#9670;&#160;</a></span>halide_do_par_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_par_for </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a></td>          <td class="paramname"><span class="paramname"><em>task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00799">799</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00576">Halide::Runtime::Internal::custom_do_par_for</a>.</p>

</div>
</div>
<a id="ab3e13f5910a047d1908532367ce0b21f" name="ab3e13f5910a047d1908532367ce0b21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e13f5910a047d1908532367ce0b21f">&#9670;&#160;</a></span>halide_shutdown_thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_shutdown_thread_pool </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00696">696</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00886">halide_cond_broadcast()</a>, <a class="el" href="#aba03c92519ed6b3df69caf08e8278720">halide_join_thread()</a>, <a class="el" href="synchronization__common_8h_source.html#l00874">halide_mutex_lock()</a>, <a class="el" href="synchronization__common_8h_source.html#l00880">halide_mutex_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00135">Halide::Runtime::Internal::work_queue_t::initialized</a>, <a class="el" href="thread__pool__common_8h_source.html#l00098">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="thread__pool__common_8h_source.html#l00160">Halide::Runtime::Internal::work_queue_t::reset()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00135">Halide::Runtime::Internal::work_queue_t::shutdown</a>, <a class="el" href="thread__pool__common_8h_source.html#l00131">Halide::Runtime::Internal::work_queue_t::threads</a>, <a class="el" href="thread__pool__common_8h_source.html#l00111">Halide::Runtime::Internal::work_queue_t::threads_created</a>, <a class="el" href="thread__pool__common_8h_source.html#l00124">Halide::Runtime::Internal::work_queue_t::wake_a_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00124">Halide::Runtime::Internal::work_queue_t::wake_b_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00124">Halide::Runtime::Internal::work_queue_t::wake_owners</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00168">Halide::Runtime::Internal::work_queue</a>.</p>

</div>
</div>
<a id="ab9eb8b02091849cfbcbdf7d2f4177857" name="ab9eb8b02091849cfbcbdf7d2f4177857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eb8b02091849cfbcbdf7d2f4177857">&#9670;&#160;</a></span>halide_set_custom_do_par_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a> halide_set_custom_do_par_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a></td>          <td class="paramname"><span class="paramname"><em>do_par_for</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00770">770</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00576">Halide::Runtime::Internal::custom_do_par_for</a>.</p>

</div>
</div>
<a id="a22c6d91bcf45d8867e426b8c5a485642" name="a22c6d91bcf45d8867e426b8c5a485642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c6d91bcf45d8867e426b8c5a485642">&#9670;&#160;</a></span>halide_semaphore_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_semaphore_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00815">815</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00578">Halide::Runtime::Internal::custom_semaphore_init</a>.</p>

</div>
</div>
<a id="aff56d38727ba3516acefd55e00efe927" name="aff56d38727ba3516acefd55e00efe927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56d38727ba3516acefd55e00efe927">&#9670;&#160;</a></span>halide_semaphore_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_semaphore_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00819">819</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00580">Halide::Runtime::Internal::custom_semaphore_release</a>.</p>

</div>
</div>
<a id="a3131d49fedf2a43cfb57d567e275002e" name="a3131d49fedf2a43cfb57d567e275002e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3131d49fedf2a43cfb57d567e275002e">&#9670;&#160;</a></span>halide_semaphore_try_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool halide_semaphore_try_acquire </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00823">823</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00579">Halide::Runtime::Internal::custom_semaphore_try_acquire</a>.</p>

</div>
</div>
<a id="aed044f78166cb19092f9723f17953fab" name="aed044f78166cb19092f9723f17953fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed044f78166cb19092f9723f17953fab">&#9670;&#160;</a></span>halide_do_parallel_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_parallel_tasks </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>task_parent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue some number of the tasks described above and wait for them to complete. </p>
<p>While waiting, the calling threads assists with either the tasks enqueued, or other non-blocking tasks in the task system. Note that task_parent should be NULL for top-level calls and the pass through argument if this call is being made from another task. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00809">809</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00577">Halide::Runtime::Internal::custom_do_parallel_tasks</a>.</p>

</div>
</div>
<a id="aece7417671894d7557b9e93ea0ebc0ae" name="aece7417671894d7557b9e93ea0ebc0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece7417671894d7557b9e93ea0ebc0ae">&#9670;&#160;</a></span>halide_set_custom_do_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a> halide_set_custom_do_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a></td>          <td class="paramname"><span class="paramname"><em>do_task</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00758">758</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00574">Halide::Runtime::Internal::custom_do_task</a>.</p>

</div>
</div>
<a id="a4b73ddae74b80251d2ffce9a624b6125" name="a4b73ddae74b80251d2ffce9a624b6125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b73ddae74b80251d2ffce9a624b6125">&#9670;&#160;</a></span>halide_do_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_task </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00794">794</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00574">Halide::Runtime::Internal::custom_do_task</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="ae154f3f0e0e204226c2af24ac58ef016" name="ae154f3f0e0e204226c2af24ac58ef016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae154f3f0e0e204226c2af24ac58ef016">&#9670;&#160;</a></span>halide_set_custom_do_loop_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a> halide_set_custom_do_loop_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a></td>          <td class="paramname"><span class="paramname"><em>do_task</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00764">764</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00575">Halide::Runtime::Internal::custom_do_loop_task</a>.</p>

</div>
</div>
<a id="a1e478ab191f59290de68e17d3f624da1" name="a1e478ab191f59290de68e17d3f624da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e478ab191f59290de68e17d3f624da1">&#9670;&#160;</a></span>halide_do_loop_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_loop_task </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>task_parent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00804">804</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00575">Halide::Runtime::Internal::custom_do_loop_task</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="a06d1866f7cd8fe9cfc8d9f4603feaea2" name="a06d1866f7cd8fe9cfc8d9f4603feaea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d1866f7cd8fe9cfc8d9f4603feaea2">&#9670;&#160;</a></span>halide_set_custom_parallel_runtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_custom_parallel_runtime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a35e17d010d9d296d3133f1b34060cda6">halide_do_par_for_t</a></td>          <td class="paramname"><span class="paramname"><em>do_par_for</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acc89fad6bf8607479e7643d17c973bd9">halide_do_task_t</a></td>          <td class="paramname"><span class="paramname"><em>do_task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7e98cafa58d17ab564e0783acb88c8bc">halide_do_loop_task_t</a></td>          <td class="paramname"><span class="paramname"><em>do_loop_task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afd29e5ed7d54ed3d92cb745915ef8909">halide_do_parallel_tasks_t</a></td>          <td class="paramname"><span class="paramname"><em>do_parallel_tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae0af757a561193139295a85256e68135">halide_semaphore_init_t</a></td>          <td class="paramname"><span class="paramname"><em>semaphore_init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a97edf37f8f01638b513e24f9173b489f">halide_semaphore_try_acquire_t</a></td>          <td class="paramname"><span class="paramname"><em>semaphore_try_acquire</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a187d0100ae8d267bbcb6e840433c0f72">halide_semaphore_release_t</a></td>          <td class="paramname"><span class="paramname"><em>semaphore_release</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00776">776</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00575">Halide::Runtime::Internal::custom_do_loop_task</a>, <a class="el" href="thread__pool__common_8h_source.html#l00576">Halide::Runtime::Internal::custom_do_par_for</a>, <a class="el" href="thread__pool__common_8h_source.html#l00577">Halide::Runtime::Internal::custom_do_parallel_tasks</a>, <a class="el" href="thread__pool__common_8h_source.html#l00574">Halide::Runtime::Internal::custom_do_task</a>, <a class="el" href="thread__pool__common_8h_source.html#l00578">Halide::Runtime::Internal::custom_semaphore_init</a>, <a class="el" href="thread__pool__common_8h_source.html#l00580">Halide::Runtime::Internal::custom_semaphore_release</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00579">Halide::Runtime::Internal::custom_semaphore_try_acquire</a>.</p>

</div>
</div>
<a id="a3a20aae4f3c690d66578775e1245ec22" name="a3a20aae4f3c690d66578775e1245ec22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a20aae4f3c690d66578775e1245ec22">&#9670;&#160;</a></span>halide_default_do_par_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_do_par_for </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a></td>          <td class="paramname"><span class="paramname"><em>task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default versions of the parallel runtime functions. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00607">607</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00047">Halide::Runtime::Internal::work::active_workers</a>, <a class="el" href="_halide_runtime_8h_source.html#l00278">halide_parallel_task_t::closure</a>, <a class="el" href="thread__pool__common_8h_source.html#l00446">Halide::Runtime::Internal::enqueue_work_already_locked()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00048">Halide::Runtime::Internal::work::exit_status</a>, <a class="el" href="_halide_runtime_8h_source.html#l00290">halide_parallel_task_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00275">halide_parallel_task_t::fn</a>, <a class="el" href="_halide_runtime_8h_source.html#l01072">halide_error_code_success</a>, <a class="el" href="synchronization__common_8h_source.html#l00874">halide_mutex_lock()</a>, <a class="el" href="synchronization__common_8h_source.html#l00880">halide_mutex_unlock()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00290">halide_parallel_task_t::min</a>, <a class="el" href="_halide_runtime_8h_source.html#l00309">halide_parallel_task_t::min_threads</a>, <a class="el" href="thread__pool__common_8h_source.html#l00098">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="_halide_runtime_8h_source.html#l00281">halide_parallel_task_t::name</a>, <a class="el" href="thread__pool__common_8h_source.html#l00049">Halide::Runtime::Internal::work::next_semaphore</a>, <a class="el" href="_halide_runtime_8h_source.html#l00286">halide_parallel_task_t::num_semaphores</a>, <a class="el" href="thread__pool__common_8h_source.html#l00051">Halide::Runtime::Internal::work::owner_is_sleeping</a>, <a class="el" href="thread__pool__common_8h_source.html#l00043">Halide::Runtime::Internal::work::parent_job</a>, <a class="el" href="_halide_runtime_8h_source.html#l00285">halide_parallel_task_t::semaphores</a>, <a class="el" href="_halide_runtime_8h_source.html#l00314">halide_parallel_task_t::serial</a>, <a class="el" href="thread__pool__common_8h_source.html#l00042">Halide::Runtime::Internal::work::sibling_count</a>, <a class="el" href="thread__pool__common_8h_source.html#l00041">Halide::Runtime::Internal::work::siblings</a>, <a class="el" href="thread__pool__common_8h_source.html#l00034">Halide::Runtime::Internal::work::task</a>, <a class="el" href="thread__pool__common_8h_source.html#l00038">Halide::Runtime::Internal::work::task_fn</a>, <a class="el" href="thread__pool__common_8h_source.html#l00046">Halide::Runtime::Internal::work::user_context</a>, <a class="el" href="thread__pool__common_8h_source.html#l00168">Halide::Runtime::Internal::work_queue</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="ad539efd611fada06fc5035162bd2d94d" name="ad539efd611fada06fc5035162bd2d94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad539efd611fada06fc5035162bd2d94d">&#9670;&#160;</a></span>halide_default_do_parallel_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_do_parallel_tasks </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__parallel__task__t.html">halide_parallel_task_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>task_parent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00639">639</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00047">Halide::Runtime::Internal::work::active_workers</a>, <a class="el" href="thread__pool__common_8h_source.html#l00446">Halide::Runtime::Internal::enqueue_work_already_locked()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00048">Halide::Runtime::Internal::work::exit_status</a>, <a class="el" href="_halide_runtime_8h_source.html#l00290">halide_parallel_task_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l01072">halide_error_code_success</a>, <a class="el" href="synchronization__common_8h_source.html#l00874">halide_mutex_lock()</a>, <a class="el" href="synchronization__common_8h_source.html#l00880">halide_mutex_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00098">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="thread__pool__common_8h_source.html#l00049">Halide::Runtime::Internal::work::next_semaphore</a>, <a class="el" href="thread__pool__common_8h_source.html#l00051">Halide::Runtime::Internal::work::owner_is_sleeping</a>, <a class="el" href="thread__pool__common_8h_source.html#l00043">Halide::Runtime::Internal::work::parent_job</a>, <a class="el" href="thread__pool__common_8h_source.html#l00034">Halide::Runtime::Internal::work::task</a>, <a class="el" href="thread__pool__common_8h_source.html#l00038">Halide::Runtime::Internal::work::task_fn</a>, <a class="el" href="thread__pool__common_8h_source.html#l00046">Halide::Runtime::Internal::work::user_context</a>, <a class="el" href="thread__pool__common_8h_source.html#l00168">Halide::Runtime::Internal::work_queue</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00205">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a id="a1529a6494b14d3a4f19b8080fdd77e31" name="a1529a6494b14d3a4f19b8080fdd77e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1529a6494b14d3a4f19b8080fdd77e31">&#9670;&#160;</a></span>halide_default_do_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_do_task </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a44ad38bc9436040001a7fa8806e9a1a4">halide_task_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00596">596</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

</div>
</div>
<a id="a422057cf799d8a82eb0d68889875615a" name="a422057cf799d8a82eb0d68889875615a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422057cf799d8a82eb0d68889875615a">&#9670;&#160;</a></span>halide_default_do_loop_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_do_loop_task </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa33673c0e9af6749f566f32386b168c4">halide_loop_task_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>task_parent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00601">601</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

</div>
</div>
<a id="a4fae5d7a366b3ae0d875b18760e3a331" name="a4fae5d7a366b3ae0d875b18760e3a331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fae5d7a366b3ae0d875b18760e3a331">&#9670;&#160;</a></span>halide_default_semaphore_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_semaphore_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00722">722</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00719">halide_semaphore_impl_t::value</a>.</p>

</div>
</div>
<a id="aae4bb05550beaebe11ae30ee49ec9cf9" name="aae4bb05550beaebe11ae30ee49ec9cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4bb05550beaebe11ae30ee49ec9cf9">&#9670;&#160;</a></span>halide_default_semaphore_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_semaphore_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00728">728</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="synchronization__common_8h_source.html#l00886">halide_cond_broadcast()</a>, <a class="el" href="synchronization__common_8h_source.html#l00874">halide_mutex_lock()</a>, <a class="el" href="synchronization__common_8h_source.html#l00880">halide_mutex_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00098">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="thread__pool__common_8h_source.html#l00719">halide_semaphore_impl_t::value</a>, <a class="el" href="thread__pool__common_8h_source.html#l00124">Halide::Runtime::Internal::work_queue_t::wake_a_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00124">Halide::Runtime::Internal::work_queue_t::wake_owners</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00168">Halide::Runtime::Internal::work_queue</a>.</p>

</div>
</div>
<a id="a333094ead7caa2b27e1cd6c92e2367c7" name="a333094ead7caa2b27e1cd6c92e2367c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333094ead7caa2b27e1cd6c92e2367c7">&#9670;&#160;</a></span>halide_default_semaphore_try_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool halide_default_semaphore_try_acquire </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__semaphore__t.html">halide_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00742">742</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00719">halide_semaphore_impl_t::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00053">Halide::Runtime::Internal::work::make_runnable()</a>.</p>

</div>
</div>
<a id="a6c90ae80fd6658eaf1754c85fd732ab2" name="a6c90ae80fd6658eaf1754c85fd732ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c90ae80fd6658eaf1754c85fd732ab2">&#9670;&#160;</a></span>halide_spawn_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct halide_thread * halide_spawn_thread </td>
          <td>(</td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>f&#160;</em></span>)(void *), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>closure</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawn a thread. </p>
<p>Returns a handle to the thread for the purposes of joining it. The thread must be joined in order to clean up any resources associated with it. </p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00446">Halide::Runtime::Internal::enqueue_work_already_locked()</a>.</p>

</div>
</div>
<a id="aba03c92519ed6b3df69caf08e8278720" name="aba03c92519ed6b3df69caf08e8278720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba03c92519ed6b3df69caf08e8278720">&#9670;&#160;</a></span>halide_join_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_join_thread </td>
          <td>(</td>
          <td class="paramtype">struct halide_thread *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a thread. </p>

<p class="reference">Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00696">halide_shutdown_thread_pool()</a>.</p>

</div>
</div>
<a id="a36d93e0796319cf64432c511affba1a5" name="a36d93e0796319cf64432c511affba1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d93e0796319cf64432c511affba1a5">&#9670;&#160;</a></span>halide_set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of threads used by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s thread pool. </p>
<p>Returns the old number.</p>
<p>n &lt; 0 : error condition n == 0 : use a reasonable system default (typically, number of cpus online). n == 1 : use exactly one thread; this will always enforce serial execution n &gt; 1 : use a pool of exactly n threads.</p>
<p>(Note that this is only guaranteed when using the default implementations of <a class="el" href="#a15f85711e52c707df2e484f69dfaf7c5">halide_do_par_for()</a>; custom implementations may completely ignore values passed to <a class="el" href="#a36d93e0796319cf64432c511affba1a5" title="Set the number of threads used by Halide&#39;s thread pool.">halide_set_num_threads()</a>.) </p>

<p class="definition">Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00679">679</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p class="reference">References <a class="el" href="thread__pool__common_8h_source.html#l00074">Halide::Runtime::Internal::clamp_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00084">Halide::Runtime::Internal::default_desired_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00101">Halide::Runtime::Internal::work_queue_t::desired_threads_working</a>, <a class="el" href="#aea28d04de54b94f0dd6ada140b7734d8">halide_error()</a>, <a class="el" href="synchronization__common_8h_source.html#l00874">halide_mutex_lock()</a>, <a class="el" href="synchronization__common_8h_source.html#l00880">halide_mutex_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00098">Halide::Runtime::Internal::work_queue_t::mutex</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00168">Halide::Runtime::Internal::work_queue</a>.</p>

</div>
</div>
<a id="a26f08f75e6692df61c62b3a7a9e02fe4" name="a26f08f75e6692df61c62b3a7a9e02fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f08f75e6692df61c62b3a7a9e02fe4">&#9670;&#160;</a></span>halide_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_malloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores, <em>and</em> with an allocated size that is (at least) an integral multiple of that same alignment. The default implementation uses 32-byte alignment on arm and 64-byte alignment on x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

<p class="reference">Referenced by <a class="el" href="synchronization__common_8h_source.html#l00911">halide_mutex_array_create()</a>.</p>

</div>
</div>
<a id="a2fa49d775b9a20fab152a0650c4c936b" name="a2fa49d775b9a20fab152a0650c4c936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa49d775b9a20fab152a0650c4c936b">&#9670;&#160;</a></span>halide_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_free </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="synchronization__common_8h_source.html#l00911">halide_mutex_array_create()</a>, and <a class="el" href="synchronization__common_8h_source.html#l00931">halide_mutex_array_destroy()</a>.</p>

</div>
</div>
<a id="aa64690021c26a5e8c9b9f127da447a55" name="aa64690021c26a5e8c9b9f127da447a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64690021c26a5e8c9b9f127da447a55">&#9670;&#160;</a></span>halide_default_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_default_malloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab246841764b58f9675fdb27db0b4bd34" name="ab246841764b58f9675fdb27db0b4bd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab246841764b58f9675fdb27db0b4bd34">&#9670;&#160;</a></span>halide_default_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_default_free </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d0668aaae035f2f4f3132857acee4e3" name="a4d0668aaae035f2f4f3132857acee4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0668aaae035f2f4f3132857acee4e3">&#9670;&#160;</a></span>halide_set_custom_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aed4628363dd76e044feb9aa8280a1b84">halide_malloc_t</a> halide_set_custom_malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed4628363dd76e044feb9aa8280a1b84">halide_malloc_t</a></td>          <td class="paramname"><span class="paramname"><em>user_malloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd43bc97b2337e57fd6af03be17a5bb8" name="acd43bc97b2337e57fd6af03be17a5bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd43bc97b2337e57fd6af03be17a5bb8">&#9670;&#160;</a></span>halide_set_custom_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa17654ef6deb96a3aef03126bd35221a">halide_free_t</a> halide_set_custom_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa17654ef6deb96a3aef03126bd35221a">halide_free_t</a></td>          <td class="paramname"><span class="paramname"><em>user_free</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a647186e912f5c3f52fb1c1e1a17d5af9" name="a647186e912f5c3f52fb1c1e1a17d5af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647186e912f5c3f52fb1c1e1a17d5af9">&#9670;&#160;</a></span>halide_get_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_get_symbol </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="#a201fccb476f83105b06389a7701f5bef">halide_set_custom_load_library()</a> and <a class="el" href="#ae6d93a904e3a104ff12c4760aad458ef">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a id="abcc88316b939747585e937b3613d5fbf" name="abcc88316b939747585e937b3613d5fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc88316b939747585e937b3613d5fbf">&#9670;&#160;</a></span>halide_load_library()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_load_library </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5106b2c865ee58d0831a054ad16dadc1" name="a5106b2c865ee58d0831a054ad16dadc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5106b2c865ee58d0831a054ad16dadc1">&#9670;&#160;</a></span>halide_get_library_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_get_library_symbol </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>lib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="vulkan__interface_8h_source.html#l00049">Halide::Runtime::Internal::Vulkan::halide_vulkan_get_symbol()</a>.</p>

</div>
</div>
<a id="ae490d646731f0c82c4fa652f61e17802" name="ae490d646731f0c82c4fa652f61e17802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae490d646731f0c82c4fa652f61e17802">&#9670;&#160;</a></span>halide_default_get_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_default_get_symbol </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa886f515ea8d068890f2bb9ced0c35f9" name="aa886f515ea8d068890f2bb9ced0c35f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa886f515ea8d068890f2bb9ced0c35f9">&#9670;&#160;</a></span>halide_default_load_library()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_default_load_library </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d836778ce297e25b37e5fe62a781b75" name="a1d836778ce297e25b37e5fe62a781b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d836778ce297e25b37e5fe62a781b75">&#9670;&#160;</a></span>halide_default_get_library_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * halide_default_get_library_symbol </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>lib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a237a39b6dc5c4059539983984c3ef4f7" name="a237a39b6dc5c4059539983984c3ef4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237a39b6dc5c4059539983984c3ef4f7">&#9670;&#160;</a></span>halide_set_custom_get_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7a1424c74013b0adc86c02878c407fb5">halide_get_symbol_t</a> halide_set_custom_get_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7a1424c74013b0adc86c02878c407fb5">halide_get_symbol_t</a></td>          <td class="paramname"><span class="paramname"><em>user_get_symbol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a201fccb476f83105b06389a7701f5bef" name="a201fccb476f83105b06389a7701f5bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201fccb476f83105b06389a7701f5bef">&#9670;&#160;</a></span>halide_set_custom_load_library()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a169fd95ae0b4b9e080896cedc4adbd8e">halide_load_library_t</a> halide_set_custom_load_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a169fd95ae0b4b9e080896cedc4adbd8e">halide_load_library_t</a></td>          <td class="paramname"><span class="paramname"><em>user_load_library</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d93a904e3a104ff12c4760aad458ef" name="ae6d93a904e3a104ff12c4760aad458ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d93a904e3a104ff12c4760aad458ef">&#9670;&#160;</a></span>halide_set_custom_get_library_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2788d811e1a39b30870b1d6b94d7826e">halide_get_library_symbol_t</a> halide_set_custom_get_library_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2788d811e1a39b30870b1d6b94d7826e">halide_get_library_symbol_t</a></td>          <td class="paramname"><span class="paramname"><em>user_get_library_symbol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a686169d62735df48a614ccc48fed75a8" name="a686169d62735df48a614ccc48fed75a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686169d62735df48a614ccc48fed75a8">&#9670;&#160;</a></span>halide_debug_to_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_debug_to_file </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when debug_to_file is used inside Halide code. </p>
<p>See Func::debug_to_file for how this is called</p>
<p>Cannot be replaced in JITted code at present. </p>

</div>
</div>
<a id="a83d172a9f341a56bc9c5124d2c61a5aa" name="a83d172a9f341a56bc9c5124d2c61a5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d172a9f341a56bc9c5124d2c61a5aa">&#9670;&#160;</a></span>halide_trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_trace </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *</td>          <td class="paramname"><span class="paramname"><em>event</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when Funcs are marked as trace_load, trace_store, or trace_realization. </p>
<p>See Func::set_custom_trace. The default implementation either prints events via halide_print, or if HL_TRACE_FILE is defined, dumps the trace to that file in a sequence of trace packets. The header for a trace packet is defined below. If the trace is going to be large, you may want to make the file a named pipe, and then read from that pipe into gzip.</p>
<p>halide_trace returns a unique ID which will be passed to future events that "belong" to the earlier event as the parent id. The ownership hierarchy looks like:</p>
<p>begin_pipeline +&ndash;trace_tag (if any) +&ndash;trace_tag (if any) ... +&ndash;begin_realization | +&ndash;produce | | +&ndash;load/store | | +&ndash;end_produce | +&ndash;consume | | +&ndash;load | | +&ndash;end_consume | +&ndash;end_realization +&ndash;end_pipeline</p>
<p>Threading means that ownership cannot be inferred from the ordering of events. There can be many active realizations of a given function, or many active productions for a single realization. Within a single production, the ordering of events is meaningful.</p>
<p>Note that all trace_tag events (if any) will occur just after the begin_pipeline event, but before any begin_realization events. All trace_tags for a given Func will be emitted in the order added. </p>

</div>
</div>
<a id="a9983cd83d6ff3aae428080d20e2af680" name="a9983cd83d6ff3aae428080d20e2af680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9983cd83d6ff3aae428080d20e2af680">&#9670;&#160;</a></span>halide_default_trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_default_trace </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *</td>          <td class="paramname"><span class="paramname"><em>event</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a963a4ee1ed5d4c89b29eadca3a2e0236" name="a963a4ee1ed5d4c89b29eadca3a2e0236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963a4ee1ed5d4c89b29eadca3a2e0236">&#9670;&#160;</a></span>halide_set_custom_trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acac84473600d9caee1f3ab634cb117ba">halide_trace_t</a> halide_set_custom_trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acac84473600d9caee1f3ab634cb117ba">halide_trace_t</a></td>          <td class="paramname"><span class="paramname"><em>trace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8761e708f878372e3201126e83d6f3b6" name="a8761e708f878372e3201126e83d6f3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8761e708f878372e3201126e83d6f3b6">&#9670;&#160;</a></span>halide_set_trace_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_trace_file </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the file descriptor that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> should write binary trace events to. </p>
<p>If called with 0 as the argument, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> outputs trace information to stdout in a human-readable format. If never called, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> checks the for existence of an environment variable called HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined, it outputs trace information to stdout in a human-readable format. </p>

</div>
</div>
<a id="aee99b65dcbc81d91a0f22507eb7f8017" name="aee99b65dcbc81d91a0f22507eb7f8017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee99b65dcbc81d91a0f22507eb7f8017">&#9670;&#160;</a></span>halide_get_trace_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_get_trace_file </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls this to retrieve the file descriptor to write binary trace events to. </p>
<p>The default implementation returns the value set by halide_set_trace_file. Implement it yourself if you wish to use a custom file descriptor per user_context. Return zero from your implementation to tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> to print human-readable trace information to stdout. </p>

</div>
</div>
<a id="af1bf251b013e6945c4ceefc34890b4cb" name="af1bf251b013e6945c4ceefc34890b4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bf251b013e6945c4ceefc34890b4cb">&#9670;&#160;</a></span>halide_shutdown_trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_shutdown_trace </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If tracing is writing to a file. </p>
<p>This call closes that file (flushing the trace). Returns zero on success. </p>

</div>
</div>
<a id="a5412b6569e456b0a85896d9afa986630" name="a5412b6569e456b0a85896d9afa986630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5412b6569e456b0a85896d9afa986630">&#9670;&#160;</a></span>halide_device_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_device_release </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *</td>          <td class="paramname"><span class="paramname"><em>device_interface</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release all data associated with the given device interface, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. </p>
<p>Must be called explicitly when using AOT compilation. This is <em>not</em> thread-safe with respect to actively running <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code. Ensure all pipelines are finished before calling this. </p>

</div>
</div>
<a id="a37bb9875eba947a4ef1f8e4ee19a7f5e" name="a37bb9875eba947a4ef1f8e4ee19a7f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bb9875eba947a4ef1f8e4ee19a7f5e">&#9670;&#160;</a></span>halide_copy_to_host()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_host </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy image data from device memory to host memory. </p>
<p>This must be called explicitly to copy back the results of a GPU-based filter. </p>

</div>
</div>
<a id="ae564c907ea0e5b5520e876ce28f29af9" name="ae564c907ea0e5b5520e876ce28f29af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae564c907ea0e5b5520e876ce28f29af9">&#9670;&#160;</a></span>halide_copy_to_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_device </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *</td>          <td class="paramname"><span class="paramname"><em>device_interface</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy image data from host memory to device memory. </p>
<p>This should not be called directly; <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> handles copying to the device automatically. If interface is NULL and the buf has a non-zero dev field, the device associated with the dev handle will be used. Otherwise if the dev field is 0 and interface is NULL, an error is returned. </p>

</div>
</div>
<a id="a87da62417a064c727dd93555efe899e3" name="a87da62417a064c727dd93555efe899e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87da62417a064c727dd93555efe899e3">&#9670;&#160;</a></span>halide_buffer_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_buffer_copy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dst_device_interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from one buffer to another. </p>
<p>The buffers may have different shapes and sizes, but the destination buffer's shape must be contained within the source buffer's shape. That is, for each dimension, the min on the destination buffer must be greater than or equal to the min on the source buffer, and min+extent on the destination buffer must be less that or equal to min+extent on the source buffer. The source data is pulled from either device or host memory on the source, depending on the dirty flags. host is preferred if both are valid. The dst_device_interface parameter controls the destination memory space. NULL means host memory. </p>

</div>
</div>
<a id="a204ba51137185e33cadbb11e5a1f8cc5" name="a204ba51137185e33cadbb11e5a1f8cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204ba51137185e33cadbb11e5a1f8cc5">&#9670;&#160;</a></span>halide_device_crop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_crop </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the destination buffer a device allocation which is an alias for the same coordinate range in the source buffer. </p>
<p>Modifies the device, device_interface, and the device_dirty flag only. Only supported by some device APIs (others will return halide_error_code_device_crop_unsupported). Call halide_device_release_crop instead of halide_device_free to clean up resources associated with the cropped view. Do not free the device allocation on the source buffer while the destination buffer still lives. Note that the two buffers do not share dirty flags, so care must be taken to update them together as needed. Note that src and dst are required to have the same number of dimensions.</p>
<p>Note also that (in theory) device interfaces which support cropping may still not support cropping a crop (instead, create a new crop of the parent buffer); in practice, no known implementation has this limitation, although it is possible that some future implementations may require it. </p>

</div>
</div>
<a id="ab036129c58b7829f3a15442d9d61d875" name="ab036129c58b7829f3a15442d9d61d875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab036129c58b7829f3a15442d9d61d875">&#9670;&#160;</a></span>halide_device_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_slice </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>slice_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>slice_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the destination buffer a device allocation which is an alias for a similar coordinate range in the source buffer, but with one dimension sliced away in the dst. </p>
<p>Modifies the device, device_interface, and the device_dirty flag only. Only supported by some device APIs (others will return halide_error_code_device_crop_unsupported). Call halide_device_release_crop instead of halide_device_free to clean up resources associated with the sliced view. Do not free the device allocation on the source buffer while the destination buffer still lives. Note that the two buffers do not share dirty flags, so care must be taken to update them together as needed. Note that the dst buffer must have exactly one fewer dimension than the src buffer, and that slice_dim and slice_pos must be valid within src. </p>

</div>
</div>
<a id="aeb0deb2630647ba1eb007090d7d54674" name="aeb0deb2630647ba1eb007090d7d54674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0deb2630647ba1eb007090d7d54674">&#9670;&#160;</a></span>halide_device_release_crop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_release_crop </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any resources associated with a cropped/sliced view of another buffer. </p>

</div>
</div>
<a id="a13dfb9b20f566b9221cbb883fd622595" name="a13dfb9b20f566b9221cbb883fd622595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dfb9b20f566b9221cbb883fd622595">&#9670;&#160;</a></span>halide_device_sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_sync </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for current GPU operations to complete. </p>
<p>Calling this explicitly should rarely be necessary, except maybe for profiling. </p>

</div>
</div>
<a id="ac76963f0e4db67ac7c87b376484a4ba3" name="ac76963f0e4db67ac7c87b376484a4ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76963f0e4db67ac7c87b376484a4ba3">&#9670;&#160;</a></span>halide_device_sync_global()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_sync_global </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *</td>          <td class="paramname"><span class="paramname"><em>device_interface</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for current GPU operations to complete. </p>
<p>Calling this explicitly should rarely be necessary, except maybe for profiling. This variation of the synchronizing is useful when a synchronization is desirable without specifying any buffer to synchronize on. Calling this with a null device_interface is always illegal. </p>

</div>
</div>
<a id="a9f5dea3365145ef7bcda3df9c787d9bc" name="a9f5dea3365145ef7bcda3df9c787d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5dea3365145ef7bcda3df9c787d9bc">&#9670;&#160;</a></span>halide_device_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_malloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *</td>          <td class="paramname"><span class="paramname"><em>device_interface</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate device memory to back a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a>. </p>

</div>
</div>
<a id="ac643953e77f882726d175d8bd9250c13" name="ac643953e77f882726d175d8bd9250c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac643953e77f882726d175d8bd9250c13">&#9670;&#160;</a></span>halide_device_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_free </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free device memory. </p>

</div>
</div>
<a id="aee10938953dddc5f12b9cf50169e3983" name="aee10938953dddc5f12b9cf50169e3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee10938953dddc5f12b9cf50169e3983">&#9670;&#160;</a></span>halide_device_wrap_native()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_wrap_native </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *</td>          <td class="paramname"><span class="paramname"><em>device_interface</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap or detach a native device handle, setting the device field and device_interface field as appropriate for the given GPU API. </p>
<p>The meaning of the opaque handle is specific to the device interface, so if you know the device interface in use, call the more specific functions in the runtime headers for your specific device API instead (e.g. <a class="el" href="_halide_runtime_cuda_8h.html" title="Routines specific to the Halide Cuda runtime.">HalideRuntimeCuda.h</a>). </p>

</div>
</div>
<a id="ae2a9eaadad05dcdc6a042aa3a1e53e25" name="ae2a9eaadad05dcdc6a042aa3a1e53e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a9eaadad05dcdc6a042aa3a1e53e25">&#9670;&#160;</a></span>halide_device_detach_native()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_detach_native </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9906fca5a688c26e0465a1b3da84ccfb" name="a9906fca5a688c26e0465a1b3da84ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9906fca5a688c26e0465a1b3da84ccfb">&#9670;&#160;</a></span>halide_set_gpu_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_gpu_device </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects which gpu device to use. </p>
<p>0 is usually the display device. If never called, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> uses the environment variable HL_GPU_DEVICE. If that variable is unset, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> uses the last device. Set this to -1 to use the last device. </p>

</div>
</div>
<a id="adc511579a9ad82da9c1c611f008dd454" name="adc511579a9ad82da9c1c611f008dd454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc511579a9ad82da9c1c611f008dd454">&#9670;&#160;</a></span>halide_get_gpu_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_get_gpu_device </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls this to get the desired halide gpu device setting. </p>
<p>Implement this yourself to use a different gpu device per user_context. The default implementation returns the value set by halide_set_gpu_device, or the environment variable HL_GPU_DEVICE. </p>

<p class="definition">Definition at line <a class="el" href="_halide_py_torch_cuda_helpers_8h_source.html#l00053">53</a> of file <a class="el" href="_halide_py_torch_cuda_helpers_8h_source.html">HalidePyTorchCudaHelpers.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_py_torch_cuda_helpers_8h_source.html#l00022">Halide::PyTorch::UserContext::device_id</a>.</p>

</div>
</div>
<a id="abf85692a77aec0b887f345d0d3ca6777" name="abf85692a77aec0b887f345d0d3ca6777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf85692a77aec0b887f345d0d3ca6777">&#9670;&#160;</a></span>halide_memoization_cache_set_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_set_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results. </p>
<p>This is not a strict maximum in that concurrency and simultaneous use of memoized reults larger than the cache size can both cause it to temporariliy be larger than the size specified here. </p>

</div>
</div>
<a id="a0e828012fc956325101a835716f8ca22" name="a0e828012fc956325101a835716f8ca22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e828012fc956325101a835716f8ca22">&#9670;&#160;</a></span>halide_memoization_cache_lookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_memoization_cache_lookup </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cache_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>realized_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>tuple_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **</td>          <td class="paramname"><span class="paramname"><em>tuple_buffers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so. </p>
<p>(The internals of the cache key should be considered opaque by this function.) If this routine returns true, it is a cache miss. Otherwise, it will return false and the buffers passed in will be filled, via copying, with memoized data. The last argument is a list if <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> in the list. The tuple_count parameters determines the length of the list.</p>
<p>The return values are: -1: Signals an error. 0: Success and cache hit. 1: Success and cache miss. </p>

</div>
</div>
<a id="a8795da8e9bbd6f19e8dcea37a277c110" name="a8795da8e9bbd6f19e8dcea37a277c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8795da8e9bbd6f19e8dcea37a277c110">&#9670;&#160;</a></span>halide_memoization_cache_store()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_memoization_cache_store </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cache_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>realized_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>tuple_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **</td>          <td class="paramname"><span class="paramname"><em>tuple_buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_eviction_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>eviction_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup. </p>
<p>(The internals of the cache key should be considered opaque by this function.) Data is copied out from the inputs and inputs are unmodified. The last argument is a list if <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> in the list. The tuple_count parameters determines the length of the list.</p>
<p>If there is a memory allocation failure, the store does not store the data into the cache.</p>
<p>If has_eviction_key is true, the entry is marked with eviction_key to allow removing the key with halide_memoization_cache_evict. </p>

</div>
</div>
<a id="ab9a460aadc9868ee8c81a03adf6d65e7" name="ab9a460aadc9868ee8c81a03adf6d65e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a460aadc9868ee8c81a03adf6d65e7">&#9670;&#160;</a></span>halide_memoization_cache_evict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_evict </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>eviction_key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evict all cache entries that were tagged with the given eviction_key in the memoize scheduling directive. </p>

</div>
</div>
<a id="a714f9e341f1d71baf8abc77bc50e1db5" name="a714f9e341f1d71baf8abc77bc50e1db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714f9e341f1d71baf8abc77bc50e1db5">&#9670;&#160;</a></span>halide_memoization_cache_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_release </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>host</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If halide_memoization_cache_lookup succeeds, halide_memoization_cache_release must be called to signal the storage is no longer being used by the caller. </p>
<p>It will be passed the host pointer of one the buffers returned by halide_memoization_cache_lookup. That is halide_memoization_cache_release will be called multiple times for the case where halide_memoization_cache_lookup is handling multiple buffers. (This corresponds to memoizing a Tuple in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.) Note that the host pointer must be sufficient to get to all information the release operation needs. The default <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> cache impleemntation accomplishes this by storing extra data before the start of the user modifiable host storage.</p>
<p>This call is like free and does not have a failure return. </p>

</div>
</div>
<a id="ac6a5970d700c7006afcc34cc7298a4ca" name="ac6a5970d700c7006afcc34cc7298a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a5970d700c7006afcc34cc7298a4ca">&#9670;&#160;</a></span>halide_memoization_cache_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_cleanup </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all memory and resources associated with the memoization cache. </p>
<p>Must be called at a time when no other threads are accessing the cache. </p>

</div>
</div>
<a id="a7c2d62d86b65a105c91af9cd961e1993" name="a7c2d62d86b65a105c91af9cd961e1993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2d62d86b65a105c91af9cd961e1993">&#9670;&#160;</a></span>halide_msan_check_memory_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_msan_check_memory_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that a given range of memory has been initialized; only used when Target::MSAN is enabled. </p>
<p>The default implementation simply calls the LLVM-provided __msan_check_mem_is_initialized() function.</p>
<p>The return value should always be zero. </p>

</div>
</div>
<a id="afbf83add6bd8d42819d610e03ea490d4" name="afbf83add6bd8d42819d610e03ea490d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf83add6bd8d42819d610e03ea490d4">&#9670;&#160;</a></span>halide_msan_check_buffer_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_msan_check_buffer_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that the data pointed to by the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> is initialized (but <em>not</em> the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> itself), using <a class="el" href="#a7c2d62d86b65a105c91af9cd961e1993" title="Verify that a given range of memory has been initialized; only used when Target::MSAN is enabled.">halide_msan_check_memory_is_initialized()</a> for checking. </p>
<p>The default implementation takes pains to only check the active memory ranges (skipping padding), and sorting into ranges to always check the smallest number of ranges, in monotonically increasing memory order.</p>
<p>Most client code should never need to replace the default implementation.</p>
<p>The return value should always be zero. </p>

</div>
</div>
<a id="a3cb4c6def086b090a357530e794806a7" name="a3cb4c6def086b090a357530e794806a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb4c6def086b090a357530e794806a7">&#9670;&#160;</a></span>halide_msan_annotate_memory_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_msan_annotate_memory_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled. </p>
<p>The default implementation simply calls the LLVM-provided __msan_unpoison() function.</p>
<p>The return value should always be zero. </p>

<p class="reference">Referenced by <a class="el" href="printer_8h_source.html#l00074">Halide::Runtime::Internal::PrinterBase::str()</a>.</p>

</div>
</div>
<a id="a2b09afc09e3a8781b8d3545c3799747f" name="a2b09afc09e3a8781b8d3545c3799747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b09afc09e3a8781b8d3545c3799747f">&#9670;&#160;</a></span>halide_msan_annotate_buffer_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_msan_annotate_buffer_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the data pointed to by the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> as initialized (but <em>not</em> the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> itself), using <a class="el" href="#a3cb4c6def086b090a357530e794806a7" title="Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled.">halide_msan_annotate_memory_is_initialized()</a> for marking. </p>
<p>The default implementation takes pains to only mark the active memory ranges (skipping padding), and sorting into ranges to always mark the smallest number of ranges, in monotonically increasing memory order.</p>
<p>Most client code should never need to replace the default implementation.</p>
<p>The return value should always be zero. </p>

</div>
</div>
<a id="a506f6e93f28aa3a0a9af8cdd8f9039ec" name="a506f6e93f28aa3a0a9af8cdd8f9039ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506f6e93f28aa3a0a9af8cdd8f9039ec">&#9670;&#160;</a></span>halide_msan_annotate_buffer_is_initialized_as_destructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_msan_annotate_buffer_is_initialized_as_destructor </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56de7e95e571c442a05506a451318f00" name="a56de7e95e571c442a05506a451318f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de7e95e571c442a05506a451318f00">&#9670;&#160;</a></span>halide_error_bounds_inference_call_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bounds_inference_call_failed </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>extern_stage_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> calls the functions below on various error conditions. </p>
<p>The default implementations construct an error message, call halide_error, then return the matching error code above. On platforms that support weak linking, you can override these to catch the errors individually. A call into an extern stage for the purposes of bounds inference failed. Returns the error code given by the extern stage. </p>

</div>
</div>
<a id="a83ec7fcc618e1b0508a6f4f726a7bcae" name="a83ec7fcc618e1b0508a6f4f726a7bcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ec7fcc618e1b0508a6f4f726a7bcae">&#9670;&#160;</a></span>halide_error_extern_stage_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_extern_stage_failed </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>extern_stage_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A call to an extern stage failed. </p>
<p>Returned the error code given by the extern stage. </p>

</div>
</div>
<a id="aa5b03b398e934c740dd4905a02a9bb81" name="aa5b03b398e934c740dd4905a02a9bb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b03b398e934c740dd4905a02a9bb81">&#9670;&#160;</a></span>halide_error_explicit_bounds_too_small()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_explicit_bounds_too_small </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_required</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_required</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a id="aec0adc8cfcfb4ee5eeb7a3897e24e96b" name="aec0adc8cfcfb4ee5eeb7a3897e24e96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0adc8cfcfb4ee5eeb7a3897e24e96b">&#9670;&#160;</a></span>halide_error_bad_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_type </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a></td>          <td class="paramname"><span class="paramname"><em>type_given</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a></td>          <td class="paramname"><span class="paramname"><em>correct_type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4145d6f03f261224d07004050d9bb004" name="a4145d6f03f261224d07004050d9bb004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4145d6f03f261224d07004050d9bb004">&#9670;&#160;</a></span>halide_error_bad_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_dimensions </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>dimensions_given</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a></td>          <td class="paramname"><span class="paramname"><em>correct_dimensions</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa54c6e910c7b7feb2a51c7a0a549a9bd" name="aa54c6e910c7b7feb2a51c7a0a549a9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54c6e910c7b7feb2a51c7a0a549a9bd">&#9670;&#160;</a></span>halide_error_access_out_of_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_access_out_of_bounds </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_touched</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_touched</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_valid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_valid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33fa368bf1d21414be0ab0a00e8ca7f6" name="a33fa368bf1d21414be0ab0a00e8ca7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fa368bf1d21414be0ab0a00e8ca7f6">&#9670;&#160;</a></span>halide_error_buffer_allocation_too_large()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_allocation_too_large </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>allocation_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c0d5408cb06758ec15b51de93d6772c" name="a5c0d5408cb06758ec15b51de93d6772c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0d5408cb06758ec15b51de93d6772c">&#9670;&#160;</a></span>halide_error_buffer_extents_negative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_extents_negative </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80d5f3810ffacdc2950743193411c6d4" name="a80d5f3810ffacdc2950743193411c6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d5f3810ffacdc2950743193411c6d4">&#9670;&#160;</a></span>halide_error_buffer_extents_too_large()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_extents_too_large </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>actual_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fcbb3316d10d47471e9d74ba74d8e6b" name="a5fcbb3316d10d47471e9d74ba74d8e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcbb3316d10d47471e9d74ba74d8e6b">&#9670;&#160;</a></span>halide_error_constraints_make_required_region_smaller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_constraints_make_required_region_smaller </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>constrained_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>constrained_extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>required_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>required_extent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41a91525ca15c31958738cf7ec44e410" name="a41a91525ca15c31958738cf7ec44e410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a91525ca15c31958738cf7ec44e410">&#9670;&#160;</a></span>halide_error_constraint_violated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_constraint_violated </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>constrained_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>constrained_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dc44166713b0e8fbef22542e4e0fe95" name="a9dc44166713b0e8fbef22542e4e0fe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc44166713b0e8fbef22542e4e0fe95">&#9670;&#160;</a></span>halide_error_param_too_small_i64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_i64 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>min_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93fce86c8f8d93969bde686d502b4340" name="a93fce86c8f8d93969bde686d502b4340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fce86c8f8d93969bde686d502b4340">&#9670;&#160;</a></span>halide_error_param_too_small_u64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_u64 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>min_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d06e8302739a4a26bfa2b0113fc376d" name="a8d06e8302739a4a26bfa2b0113fc376d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d06e8302739a4a26bfa2b0113fc376d">&#9670;&#160;</a></span>halide_error_param_too_small_f64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_f64 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f31f3a6a09ab3b5b798cecbd3f5e045" name="a8f31f3a6a09ab3b5b798cecbd3f5e045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f31f3a6a09ab3b5b798cecbd3f5e045">&#9670;&#160;</a></span>halide_error_param_too_large_i64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_i64 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>max_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca082a34f38e8657551128db3969f8af" name="aca082a34f38e8657551128db3969f8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca082a34f38e8657551128db3969f8af">&#9670;&#160;</a></span>halide_error_param_too_large_u64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_u64 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>max_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bc42c90e0703c23c6f141fb476cfa04" name="a7bc42c90e0703c23c6f141fb476cfa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc42c90e0703c23c6f141fb476cfa04">&#9670;&#160;</a></span>halide_error_param_too_large_f64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_f64 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64356948f9a36e16664585fff6f0949d" name="a64356948f9a36e16664585fff6f0949d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64356948f9a36e16664585fff6f0949d">&#9670;&#160;</a></span>halide_error_out_of_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_out_of_memory </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab974b4b7963cad8613c3825a5689086" name="aab974b4b7963cad8613c3825a5689086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab974b4b7963cad8613c3825a5689086">&#9670;&#160;</a></span>halide_error_buffer_argument_is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_argument_is_null </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d12212093b19b3c2ea2b83df15302e3" name="a6d12212093b19b3c2ea2b83df15302e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d12212093b19b3c2ea2b83df15302e3">&#9670;&#160;</a></span>halide_error_debug_to_file_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_debug_to_file_failed </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>error_code</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c72825991b91cbc68d0ee35b5dd6eb" name="af4c72825991b91cbc68d0ee35b5dd6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c72825991b91cbc68d0ee35b5dd6eb">&#9670;&#160;</a></span>halide_error_unaligned_host_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_unaligned_host_ptr </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86407c41832653562525f5699658e78e" name="a86407c41832653562525f5699658e78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86407c41832653562525f5699658e78e">&#9670;&#160;</a></span>halide_error_host_is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_host_is_null </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a184d4a3242a700a5bfa984202d150058" name="a184d4a3242a700a5bfa984202d150058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184d4a3242a700a5bfa984202d150058">&#9670;&#160;</a></span>halide_error_bad_fold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_fold </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>loop_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12c89710ae1981e7ccad2e28eaecae49" name="a12c89710ae1981e7ccad2e28eaecae49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c89710ae1981e7ccad2e28eaecae49">&#9670;&#160;</a></span>halide_error_bad_extern_fold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_extern_fold </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>valid_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fold_factor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bc79be62fbe8dec0a9fe81880809d09" name="a8bc79be62fbe8dec0a9fe81880809d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc79be62fbe8dec0a9fe81880809d09">&#9670;&#160;</a></span>halide_error_fold_factor_too_small()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_fold_factor_too_small </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fold_factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>loop_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>required_extent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f2a64a173a5f8f76b77f495782bf3d0" name="a6f2a64a173a5f8f76b77f495782bf3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2a64a173a5f8f76b77f495782bf3d0">&#9670;&#160;</a></span>halide_error_requirement_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_requirement_failed </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4b32bec5b0969e6c79bccb4f92fd295" name="aa4b32bec5b0969e6c79bccb4f92fd295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b32bec5b0969e6c79bccb4f92fd295">&#9670;&#160;</a></span>halide_error_specialize_fail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_specialize_fail </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ab5d9defb54674dbb97c6b629d50358" name="a6ab5d9defb54674dbb97c6b629d50358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab5d9defb54674dbb97c6b629d50358">&#9670;&#160;</a></span>halide_error_no_device_interface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_no_device_interface </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="vulkan__context_8h_source.html#l00051">Halide::Runtime::Internal::Vulkan::VulkanContext::VulkanContext()</a>.</p>

</div>
</div>
<a id="aa4d7a1dd2fd8cec3b76da2c9b0bbf39b" name="aa4d7a1dd2fd8cec3b76da2c9b0bbf39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d7a1dd2fd8cec3b76da2c9b0bbf39b">&#9670;&#160;</a></span>halide_error_device_interface_no_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_device_interface_no_device </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4f30607f12425475a81e3735a9d017a" name="aa4f30607f12425475a81e3735a9d017a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f30607f12425475a81e3735a9d017a">&#9670;&#160;</a></span>halide_error_host_and_device_dirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_host_and_device_dirty </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c42da47a5082bf52f62143c3e667c9f" name="a5c42da47a5082bf52f62143c3e667c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c42da47a5082bf52f62143c3e667c9f">&#9670;&#160;</a></span>halide_error_buffer_is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_is_null </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>routine</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f373bfbd4135315a9ac195152fd0243" name="a4f373bfbd4135315a9ac195152fd0243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f373bfbd4135315a9ac195152fd0243">&#9670;&#160;</a></span>halide_error_device_dirty_with_no_device_support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_device_dirty_with_no_device_support </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa215552d657bc58c32cf4ccff6d24df3" name="aa215552d657bc58c32cf4ccff6d24df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa215552d657bc58c32cf4ccff6d24df3">&#9670;&#160;</a></span>halide_error_storage_bound_too_small()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_storage_bound_too_small </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>provided_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>required_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab199bb9f42e5a36069af2e8b08994eef" name="ab199bb9f42e5a36069af2e8b08994eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab199bb9f42e5a36069af2e8b08994eef">&#9670;&#160;</a></span>halide_error_device_crop_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_device_crop_failed </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebb5e935878f0bce62df337bf057cc98" name="aebb5e935878f0bce62df337bf057cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb5e935878f0bce62df337bf057cc98">&#9670;&#160;</a></span>halide_error_split_factor_not_positive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_split_factor_not_positive </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>outer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>inner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>factor_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b11f8a2ad06e387f2c31d1b34b524a0" name="a8b11f8a2ad06e387f2c31d1b34b524a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b11f8a2ad06e387f2c31d1b34b524a0">&#9670;&#160;</a></span>halide_error_vscale_invalid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_vscale_invalid </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>runtime_vscale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>compiletime_vscale</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb3de9758e5af340b55d91e929ea52be" name="aeb3de9758e5af340b55d91e929ea52be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3de9758e5af340b55d91e929ea52be">&#9670;&#160;</a></span>halide_can_use_target_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_can_use_target_features </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called internally by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags. </p>
<p>The implementation must do the following:</p>
<p>&ndash; If there are flags set in features that the function knows <em>cannot</em> be supported, return 0. &ndash; Otherwise, return 1. &ndash; Note that any flags set in features that the function doesn't know how to test should be ignored; this implies that a return value of 1 means "not known to be bad" rather than "known to be good".</p>
<p>In other words: a return value of 0 means "It is not safe to use code compiled with these features", while a return value of 1 means "It is not obviously unsafe to use code compiled with these features".</p>
<p>The default implementation simply calls halide_default_can_use_target_features.</p>
<p>Note that <code>features</code> points to an array of <code>count</code> uint64_t; this array must contain enough bits to represent all the currently known features. Any excess bits must be set to zero. </p>

</div>
</div>
<a id="a85d894ba76723de46670273e21186516" name="a85d894ba76723de46670273e21186516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d894ba76723de46670273e21186516">&#9670;&#160;</a></span>halide_set_custom_can_use_target_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7756790d1df276babe85759aecb9214e">halide_can_use_target_features_t</a> halide_set_custom_can_use_target_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7756790d1df276babe85759aecb9214e">halide_can_use_target_features_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c82f395159cd26471734262410d5bb7" name="a9c82f395159cd26471734262410d5bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c82f395159cd26471734262410d5bb7">&#9670;&#160;</a></span>halide_default_can_use_target_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_can_use_target_features </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the default implementation of halide_can_use_target_features; it is provided for convenience of user code that may wish to extend halide_can_use_target_features but continue providing existing support, e.g. </p>
<pre class="fragment">int halide_can_use_target_features(int count, const uint64_t *features) {
     if (features[halide_target_somefeature &gt;&gt; 6] &amp; (1LL &lt;&lt; (halide_target_somefeature &amp; 63))) {
         if (!can_use_somefeature()) {
             return 0;
         }
     }
     return halide_default_can_use_target_features(count, features);
}
</pre> 
</div>
</div>
<a id="a78788323e55e51ca690d47957e8eb5f9" name="a78788323e55e51ca690d47957e8eb5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78788323e55e51ca690d47957e8eb5f9">&#9670;&#160;</a></span>halide_register_argv_and_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_register_argv_and_metadata </td>
          <td>(</td>
          <td class="paramtype">int(*</td>          <td class="paramname"><span class="paramname"><em>filter_argv_call&#160;</em></span>)(void **), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a> *</td>          <td class="paramname"><span class="paramname"><em>filter_metadata</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *</td>          <td class="paramname"><span class="paramname"><em>extra_key_value_pairs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a78788323e55e51ca690d47957e8eb5f9" title="halide_register_argv_and_metadata() is a user-defined function that must be provided in order to use ...">halide_register_argv_and_metadata()</a> is a <b>user-defined</b> function that must be provided in order to use the registration.cc files produced by Generators when the 'registration' output is requested. </p>
<p>Each registration.cc file provides a static initializer that calls this function with the given filter's argv-call variant, its metadata, and (optionally) and additional textual data that the build system chooses to tack on for its own purposes. Note that this will be called at static-initializer time (i.e., before main() is called), and in an unpredictable order. Note that extra_key_value_pairs may be nullptr; if it's not null, it's expected to be a null-terminated list of strings, with an even number of entries. </p>

</div>
</div>
<a id="a02da52a04bf26d2636c9e70dd73b2fac" name="a02da52a04bf26d2636c9e70dd73b2fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02da52a04bf26d2636c9e70dd73b2fac">&#9670;&#160;</a></span>HALIDE_ATTRIBUTE_ALIGN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HALIDE_ATTRIBUTE_ALIGN </td>
          <td>(</td>
          <td class="paramtype">8</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The functions below here are relevant for pipelines compiled with the -profile target flag, which runs a sampling profiler thread alongside the pipeline. </p>
<p>Per-invocation-of-a-pipeline state.</p>
<p>Per-pipeline state tracked by the sampling profiler.</p>
<p>Per-Func state tracked by the sampling profiler.</p>
<p>These exist in a linked list.</p>
<p>Lives on the stack of the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> code. Exists in a doubly-linked list to that it can be cleanly removed. </p>

<p class="definition">Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01825">1825</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a id="a3df8efecbde772f8650f6801f5ca5169" name="a3df8efecbde772f8650f6801f5ca5169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df8efecbde772f8650f6801f5ca5169">&#9670;&#160;</a></span>halide_profiler_get_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> * halide_profiler_get_state </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the global profiler state for programmatic inspection. </p>
<p>Lock it before using to pause the profiler. </p>

</div>
</div>
<a id="a492f13d33a946efa2e69f372639e6775" name="a492f13d33a946efa2e69f372639e6775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492f13d33a946efa2e69f372639e6775">&#9670;&#160;</a></span>halide_profiler_get_pipeline_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct halide_profiler_pipeline_stats * halide_profiler_get_pipeline_state </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pipeline_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the pipeline state associated with pipeline_name. </p>
<p>This function grabs the global profiler state's lock on entry. </p>

</div>
</div>
<a id="af69d3a7547848c029e9edaf3e8240c01" name="af69d3a7547848c029e9edaf3e8240c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69d3a7547848c029e9edaf3e8240c01">&#9670;&#160;</a></span>halide_profiler_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_profiler_sample </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>prev_t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects profiling information. </p>
<p>Intended to be called from a timer interrupt handler if timer based profiling is being used. State argument is acquired via halide_profiler_get_pipeline_state. prev_t argument is the previous time and can be used to set a more accurate time interval if desired. </p>

</div>
</div>
<a id="a449e2969ebd8ffbaaacbb88302bc21ff" name="a449e2969ebd8ffbaaacbb88302bc21ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449e2969ebd8ffbaaacbb88302bc21ff">&#9670;&#160;</a></span>halide_profiler_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_reset </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset profiler state cheaply. </p>
<p>May leave threads running or some memory allocated but all accumulated statistics are reset. Blocks until all running profiled <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipelines exit. </p>

</div>
</div>
<a id="aa4a6253f36b6967880b1f53fa8a9752f" name="aa4a6253f36b6967880b1f53fa8a9752f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a6253f36b6967880b1f53fa8a9752f">&#9670;&#160;</a></span>halide_profiler_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_shutdown </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all profiler state. </p>
<p>Blocks until all running profiled <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipelines exit. </p>

</div>
</div>
<a id="a98690684642752376f858a9c6f1ccd29" name="a98690684642752376f858a9c6f1ccd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98690684642752376f858a9c6f1ccd29">&#9670;&#160;</a></span>halide_profiler_report()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_report </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print out timing statistics for everything run since the last reset. </p>
<p>Also happens at process exit. </p>

</div>
</div>
<a id="a1a3bdb4573e61ca17219fbd2eed91801" name="a1a3bdb4573e61ca17219fbd2eed91801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3bdb4573e61ca17219fbd2eed91801">&#9670;&#160;</a></span>halide_profiler_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These routines are called to temporarily disable and then reenable the profiler. </p>

</div>
</div>
<a id="ac69d73718f2f49559522f85df440f8b3" name="ac69d73718f2f49559522f85df440f8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69d73718f2f49559522f85df440f8b3">&#9670;&#160;</a></span>halide_profiler_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af23e3224639e2458c55cebf2a6dccfaf" name="af23e3224639e2458c55cebf2a6dccfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23e3224639e2458c55cebf2a6dccfaf">&#9670;&#160;</a></span>halide_float16_bits_to_float()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float halide_float16_bits_to_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bits representing a half precision floating point number and return the float that represents the same value. </p>

</div>
</div>
<a id="a2494e69e2956ca6af09befd1d5bbf142" name="a2494e69e2956ca6af09befd1d5bbf142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2494e69e2956ca6af09befd1d5bbf142">&#9670;&#160;</a></span>halide_float16_bits_to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double halide_float16_bits_to_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bits representing a half precision floating point number and return the double that represents the same value. </p>

<p class="reference">Referenced by <a class="el" href="printer_8h_source.html#l00149">Halide::Runtime::Internal::PrinterBase::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a9da489f1aeb8ed32002307caeaa35b95" name="a9da489f1aeb8ed32002307caeaa35b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da489f1aeb8ed32002307caeaa35b95">&#9670;&#160;</a></span>halide_reuse_device_allocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int halide_reuse_device_allocations </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> whether or not it is permitted to hold onto device allocations to service future requests instead of returning them eagerly to the underlying device API. </p>
<p>Many device allocators are quite slow, so it can be beneficial to set this to true. The default value for now is false.</p>
<p>Note that if enabled, the eviction policy is very simplistic. The 32 most-recently used allocations are preserved, regardless of their size. Additionally, if a call to cuMalloc results in an out-of-memory error, the entire cache is flushed and the allocation is retried. See <a href="https://github.com/halide/Halide/issues/4093">https://github.com/halide/Halide/issues/4093</a></p>
<p>If set to false, releases all unused device allocations back to the underlying device APIs. For finer-grained control, see specific methods in each device api runtime.</p>
<p>Note that if the flag is set to true, this call <em>must</em> succeed and return a value of halide_error_code_success (i.e., zero); if you replace the implementation of this call in the runtime, you must honor this contract. </p>

</div>
</div>
<a id="a9fd349501e76494f9f6bd4b3d088b6d2" name="a9fd349501e76494f9f6bd4b3d088b6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd349501e76494f9f6bd4b3d088b6d2">&#9670;&#160;</a></span>halide_can_reuse_device_allocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool halide_can_reuse_device_allocations </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether on device_free the memory is returned immediately to the device API, or placed on a free list for future use. </p>
<p>Override and switch based on the user_context for finer-grained control. By default just returns the value most recently set by the method above. </p>

</div>
</div>
<a id="af8ad1ca0c4898fd64fb62711db1a2429" name="af8ad1ca0c4898fd64fb62711db1a2429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ad1ca0c4898fd64fb62711db1a2429">&#9670;&#160;</a></span>halide_register_device_allocation_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void halide_register_device_allocation_pool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__device__allocation__pool.html">halide_device_allocation_pool</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a callback to be informed when halide_reuse_device_allocations(false) is called, and all unused device allocations must be released. </p>
<p>The object passed should have global lifetime, and its next field will be clobbered. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_bf9f26469d00835ba20ff8d80ee5a804.html">runtime</a></li><li class="navelem"><a class="el" href="_halide_runtime_8h.html">HalideRuntime.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
