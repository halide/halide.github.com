<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: src/IRMatch.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide<span id="projectnumber">&#160;19.0.0</span>
   </div>
   <div id="projectbrief">Halide compiler and libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_i_r_match_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">IRMatch.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Defines a method to match a fragment of IR against a pattern containing wildcards.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;map&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>&quot;</code><br />
</div>
<p><a href="_i_r_match_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">Halide::Internal::IRMatcher::MatcherState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To save stack space, the matcher objects are largely stateless and immutable.  <a href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1enable__if__pattern.html">Halide::Internal::IRMatcher::enable_if_pattern&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1enable__if__pattern_1_1type.html">Halide::Internal::IRMatcher::enable_if_pattern&lt; T, typename &gt;::type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1bindings.html">Halide::Internal::IRMatcher::bindings&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">Halide::Internal::IRMatcher::SpecificExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr_1_1pattern__tag.html">Halide::Internal::IRMatcher::SpecificExpr::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int.html">Halide::Internal::IRMatcher::WildConstInt&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConstInt&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int.html">Halide::Internal::IRMatcher::WildConstUInt&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConstUInt&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float.html">Halide::Internal::IRMatcher::WildConstFloat&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConstFloat&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const.html">Halide::Internal::IRMatcher::WildConst&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConst&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild.html">Halide::Internal::IRMatcher::Wild&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_1_1pattern__tag.html">Halide::Internal::IRMatcher::Wild&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">Halide::Internal::IRMatcher::IntLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal_1_1pattern__tag.html">Halide::Internal::IRMatcher::IntLiteral::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin_1_1pattern__tag.html">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">Halide::Internal::IRMatcher::NotOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::NotOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">Halide::Internal::IRMatcher::BroadcastOp&lt; A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::BroadcastOp&lt; A, B &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">Halide::Internal::IRMatcher::RampOp&lt; A, B, C &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::RampOp&lt; A, B, C &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, B, reduce_op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, B, reduce_op &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">Halide::Internal::IRMatcher::CastOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::CastOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_widen_op.html">Halide::Internal::IRMatcher::WidenOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_widen_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::WidenOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_slice_op.html">Halide::Internal::IRMatcher::SliceOp&lt; Vec, Base, Stride, Lanes &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_slice_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::SliceOp&lt; Vec, Base, Stride, Lanes &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Halide::Internal::IRMatcher::Fold&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold_1_1pattern__tag.html">Halide::Internal::IRMatcher::Fold&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Halide::Internal::IRMatcher::Overflows&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows_1_1pattern__tag.html">Halide::Internal::IRMatcher::Overflows&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow.html">Halide::Internal::IRMatcher::Overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow_1_1pattern__tag.html">Halide::Internal::IRMatcher::Overflow::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">Halide::Internal::IRMatcher::IsConst&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsConst&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove_1_1pattern__tag.html">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">Halide::Internal::IRMatcher::IsFloat&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsFloat&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">Halide::Internal::IRMatcher::IsInt&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsInt&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">Halide::Internal::IRMatcher::IsUInt&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsUInt&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">Halide::Internal::IRMatcher::IsScalar&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsScalar&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value.html">Halide::Internal::IRMatcher::IsMaxValue&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsMaxValue&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value.html">Halide::Internal::IRMatcher::IsMinValue&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsMinValue&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_lanes_of.html">Halide::Internal::IRMatcher::LanesOf&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_lanes_of_1_1pattern__tag.html">Halide::Internal::IRMatcher::LanesOf&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html">Halide::Internal::IRMatcher</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_internal_1_1_i_r_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative template-metaprogramming approach to expression matching. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac3cabe703f762c1fb43f00c9a77d6ae4" id="r_ac3cabe703f762c1fb43f00c9a77d6ae4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3cabe703f762c1fb43f00c9a77d6ae4">HALIDE_DEBUG_MATCHED_RULES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac3cabe703f762c1fb43f00c9a77d6ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38de29759124484d5b8934bf77b54fc4" id="r_a38de29759124484d5b8934bf77b54fc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38de29759124484d5b8934bf77b54fc4">HALIDE_DEBUG_UNMATCHED_RULES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a38de29759124484d5b8934bf77b54fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71623e6847732d0ea4b811d8f93d0bd6" id="r_a71623e6847732d0ea4b811d8f93d0bd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71623e6847732d0ea4b811d8f93d0bd6">HALIDE_FUZZ_TEST_RULES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a71623e6847732d0ea4b811d8f93d0bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad10452d8940fd9d44b657a915b7cea42" id="r_ad10452d8940fd9d44b657a915b7cea42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad10452d8940fd9d44b657a915b7cea42">Halide::Internal::expr_match</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;pattern, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad10452d8940fd9d44b657a915b7cea42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <br /></td></tr>
<tr class="separator:ad10452d8940fd9d44b657a915b7cea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d77cbd158befc1b58416319609f313" id="r_ad8d77cbd158befc1b58416319609f313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad8d77cbd158befc1b58416319609f313">Halide::Internal::expr_match</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;pattern, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad8d77cbd158befc1b58416319609f313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <br /></td></tr>
<tr class="separator:ad8d77cbd158befc1b58416319609f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7dcf498f892ed7052bf6f812fe8b90" id="r_abc7dcf498f892ed7052bf6f812fe8b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abc7dcf498f892ed7052bf6f812fe8b90">Halide::Internal::with_lanes</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x, int lanes)</td></tr>
<tr class="memdesc:abc7dcf498f892ed7052bf6f812fe8b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the expression x to have <code>lanes</code> lanes.  <br /></td></tr>
<tr class="separator:abc7dcf498f892ed7052bf6f812fe8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eed932bc0eb3a15edcb20795bfb8c2f" id="r_a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">Halide::Internal::expr_match_test</a> ()</td></tr>
<tr class="separator:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29c5f8f734b23806ea65f9480e68426" id="r_ae29c5f8f734b23806ea65f9480e68426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae29c5f8f734b23806ea65f9480e68426">Halide::Internal::IRMatcher::make_const_special_expr</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> ty)</td></tr>
<tr class="separator:ae29c5f8f734b23806ea65f9480e68426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef33d9a64963f7e5a6b8bd1ddc6565" id="r_adbef33d9a64963f7e5a6b8bd1ddc6565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adbef33d9a64963f7e5a6b8bd1ddc6565">Halide::Internal::IRMatcher::make_const_expr</a> (<a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a> val, <a class="el" href="structhalide__type__t.html">halide_type_t</a> ty)</td></tr>
<tr class="separator:adbef33d9a64963f7e5a6b8bd1ddc6565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a38470cb6dda7791e9f1cf9dbe8c6a" id="r_a23a38470cb6dda7791e9f1cf9dbe8c6a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a23a38470cb6dda7791e9f1cf9dbe8c6a">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> &amp;e)</td></tr>
<tr class="separator:a23a38470cb6dda7791e9f1cf9dbe8c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543805cca04bfd93484c09dc5acd93e8" id="r_a543805cca04bfd93484c09dc5acd93e8"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a543805cca04bfd93484c09dc5acd93e8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a543805cca04bfd93484c09dc5acd93e8">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int.html">WildConstInt</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:a543805cca04bfd93484c09dc5acd93e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad098b1f03d2f63ea946c4fa388f97adc" id="r_ad098b1f03d2f63ea946c4fa388f97adc"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:ad098b1f03d2f63ea946c4fa388f97adc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad098b1f03d2f63ea946c4fa388f97adc">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int.html">WildConstUInt</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:ad098b1f03d2f63ea946c4fa388f97adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb595aec01635d485f860fbb07591b4" id="r_adfb595aec01635d485f860fbb07591b4"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:adfb595aec01635d485f860fbb07591b4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adfb595aec01635d485f860fbb07591b4">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float.html">WildConstFloat</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:adfb595aec01635d485f860fbb07591b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebc587072c643909da6a9875ecb2d8a" id="r_a0ebc587072c643909da6a9875ecb2d8a"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a0ebc587072c643909da6a9875ecb2d8a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0ebc587072c643909da6a9875ecb2d8a">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const.html">WildConst</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:a0ebc587072c643909da6a9875ecb2d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47b35b955c490517606bd7817093ef5" id="r_ad47b35b955c490517606bd7817093ef5"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:ad47b35b955c490517606bd7817093ef5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad47b35b955c490517606bd7817093ef5">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild.html">Wild</a>&lt; i &gt; &amp;op)</td></tr>
<tr class="separator:ad47b35b955c490517606bd7817093ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd315ae5bcc2a043e21ba0ce7fc6604" id="r_a4cd315ae5bcc2a043e21ba0ce7fc6604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4cd315ae5bcc2a043e21ba0ce7fc6604">Halide::Internal::IRMatcher::unwrap</a> (<a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a> t)</td></tr>
<tr class="separator:a4cd315ae5bcc2a043e21ba0ce7fc6604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04098851fbbe2fcc79ea1cf70344d4f3" id="r_a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag&gt; </td></tr>
<tr class="memitem:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">Halide::Internal::IRMatcher::pattern_arg</a> (T t)</td></tr>
<tr class="separator:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b87b47d755caab685d8ced4a583822" id="r_a05b87b47d755caab685d8ced4a583822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a05b87b47d755caab685d8ced4a583822">Halide::Internal::IRMatcher::pattern_arg</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> x)</td></tr>
<tr class="separator:a05b87b47d755caab685d8ced4a583822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573935a29e2841c774dab39b74f819cc" id="r_a573935a29e2841c774dab39b74f819cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a573935a29e2841c774dab39b74f819cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a573935a29e2841c774dab39b74f819cc">Halide::Internal::IRMatcher::assert_is_lvalue_if_expr</a> ()</td></tr>
<tr class="separator:a573935a29e2841c774dab39b74f819cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21824f09098bb3ae41a9dabdbaaef06" id="r_ae21824f09098bb3ae41a9dabdbaaef06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae21824f09098bb3ae41a9dabdbaaef06">Halide::Internal::IRMatcher::pattern_arg</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="separator:ae21824f09098bb3ae41a9dabdbaaef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e53940f96fc63b025f2c4b5476b1d41" id="r_a3e53940f96fc63b025f2c4b5476b1d41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag, typename  = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, SpecificExpr&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3e53940f96fc63b025f2c4b5476b1d41">Halide::Internal::IRMatcher::unwrap</a> (T t)</td></tr>
<tr class="separator:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9145efb36fc10a7b8b7a5b07cb7000" id="r_a9b9145efb36fc10a7b8b7a5b07cb7000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9b9145efb36fc10a7b8b7a5b07cb7000">Halide::Internal::IRMatcher::unwrap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> &amp;e)</td></tr>
<tr class="separator:a9b9145efb36fc10a7b8b7a5b07cb7000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24953e117a05f421a341992df5ab12" id="r_a5e24953e117a05f421a341992df5ab12"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5e24953e117a05f421a341992df5ab12">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a> &amp;op)</td></tr>
<tr class="separator:a5e24953e117a05f421a341992df5ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02c255ad5cbd923bb80d831dcb29a9f" id="r_ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>) noexcept</td></tr>
<tr class="separator:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d935203140ecdaa7c89c2f61a66371d" id="r_a9d935203140ecdaa7c89c2f61a66371d"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a9d935203140ecdaa7c89c2f61a66371d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9d935203140ecdaa7c89c2f61a66371d">Halide::Internal::IRMatcher::constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>) noexcept</td></tr>
<tr class="separator:a9d935203140ecdaa7c89c2f61a66371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5823d477b61633b1b0607075dea6a5f" id="r_af5823d477b61633b1b0607075dea6a5f"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af5823d477b61633b1b0607075dea6a5f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af5823d477b61633b1b0607075dea6a5f">Halide::Internal::IRMatcher::constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, double, double) noexcept</td></tr>
<tr class="separator:af5823d477b61633b1b0607075dea6a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c85b1b1664ed0848b20ddbb235747ad" id="r_a8c85b1b1664ed0848b20ddbb235747ad"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8c85b1b1664ed0848b20ddbb235747ad">Halide::Internal::IRMatcher::commutative</a> (<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> t)</td></tr>
<tr class="separator:a8c85b1b1664ed0848b20ddbb235747ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e96dcc65e8cb2a61d81b286441a6dc5" id="r_a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>) noexcept</td></tr>
<tr class="separator:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61cdd5630b9f58581f7be27e747bf76" id="r_af61cdd5630b9f58581f7be27e747bf76"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af61cdd5630b9f58581f7be27e747bf76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af61cdd5630b9f58581f7be27e747bf76">Halide::Internal::IRMatcher::constant_fold_cmp_op</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>) noexcept</td></tr>
<tr class="separator:af61cdd5630b9f58581f7be27e747bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5671074743a4d51f6d5470676fdd6f32" id="r_a5671074743a4d51f6d5470676fdd6f32"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a5671074743a4d51f6d5470676fdd6f32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5671074743a4d51f6d5470676fdd6f32">Halide::Internal::IRMatcher::constant_fold_cmp_op</a> (double, double) noexcept</td></tr>
<tr class="separator:a5671074743a4d51f6d5470676fdd6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade895692a2d4a8c423a4ba7e143285a1" id="r_ade895692a2d4a8c423a4ba7e143285a1"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ade895692a2d4a8c423a4ba7e143285a1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ade895692a2d4a8c423a4ba7e143285a1">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ade895692a2d4a8c423a4ba7e143285a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a6778de569ac64dea6b927816a37a" id="r_a133a6778de569ac64dea6b927816a37a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a133a6778de569ac64dea6b927816a37a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a133a6778de569ac64dea6b927816a37a">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a133a6778de569ac64dea6b927816a37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca3aebf7980d62dafd0ca85581fe989" id="r_a2ca3aebf7980d62dafd0ca85581fe989"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2ca3aebf7980d62dafd0ca85581fe989"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2ca3aebf7980d62dafd0ca85581fe989">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a2ca3aebf7980d62dafd0ca85581fe989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d84bd7945b4c5495c5e9a3cb834cd3f" id="r_a5d84bd7945b4c5495c5e9a3cb834cd3f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a5d84bd7945b4c5495c5e9a3cb834cd3f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5d84bd7945b4c5495c5e9a3cb834cd3f">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a5d84bd7945b4c5495c5e9a3cb834cd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276026aaf1be95439e0055bbc76da7af" id="r_a276026aaf1be95439e0055bbc76da7af"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a276026aaf1be95439e0055bbc76da7af"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a276026aaf1be95439e0055bbc76da7af">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a276026aaf1be95439e0055bbc76da7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b8b8db1dbc38239ede36b970a5dfa2" id="r_a69b8b8db1dbc38239ede36b970a5dfa2"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a69b8b8db1dbc38239ede36b970a5dfa2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a69b8b8db1dbc38239ede36b970a5dfa2">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a69b8b8db1dbc38239ede36b970a5dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdbec6fe35b166e080ee998ad727af9" id="r_acfdbec6fe35b166e080ee998ad727af9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:acfdbec6fe35b166e080ee998ad727af9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#acfdbec6fe35b166e080ee998ad727af9">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:acfdbec6fe35b166e080ee998ad727af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d77510464f34ea78223de56f8742734" id="r_a5d77510464f34ea78223de56f8742734"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a5d77510464f34ea78223de56f8742734"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5d77510464f34ea78223de56f8742734">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a5d77510464f34ea78223de56f8742734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f1a32ea406ed879c9dbb58057e31e" id="r_a429f1a32ea406ed879c9dbb58057e31e"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a429f1a32ea406ed879c9dbb58057e31e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a429f1a32ea406ed879c9dbb58057e31e">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a429f1a32ea406ed879c9dbb58057e31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf904a36391eb209df43c1457eeab0ff" id="r_abf904a36391eb209df43c1457eeab0ff"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:abf904a36391eb209df43c1457eeab0ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#abf904a36391eb209df43c1457eeab0ff">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:abf904a36391eb209df43c1457eeab0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954649c92c62f55129431785f95dba61" id="r_a954649c92c62f55129431785f95dba61"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a954649c92c62f55129431785f95dba61"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a954649c92c62f55129431785f95dba61">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a954649c92c62f55129431785f95dba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e5d572625fd13fc39ad7a0d4d43c94" id="r_ad2e5d572625fd13fc39ad7a0d4d43c94"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad2e5d572625fd13fc39ad7a0d4d43c94"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad2e5d572625fd13fc39ad7a0d4d43c94">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ad2e5d572625fd13fc39ad7a0d4d43c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4170ea254d53d36ef746c10f4064ee0" id="r_ab4170ea254d53d36ef746c10f4064ee0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab4170ea254d53d36ef746c10f4064ee0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab4170ea254d53d36ef746c10f4064ee0">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ab4170ea254d53d36ef746c10f4064ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc95a29e77209936abda837a61569a8" id="r_aabc95a29e77209936abda837a61569a8"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aabc95a29e77209936abda837a61569a8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aabc95a29e77209936abda837a61569a8">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:aabc95a29e77209936abda837a61569a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c859618e593c81032c13ed0ac1a37c4" id="r_a6c859618e593c81032c13ed0ac1a37c4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6c859618e593c81032c13ed0ac1a37c4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6c859618e593c81032c13ed0ac1a37c4">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a6c859618e593c81032c13ed0ac1a37c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22054e3eaa6b5261e2906094b9a2a687" id="r_a22054e3eaa6b5261e2906094b9a2a687"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a22054e3eaa6b5261e2906094b9a2a687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a22054e3eaa6b5261e2906094b9a2a687">Halide::Internal::IRMatcher::operator+</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a22054e3eaa6b5261e2906094b9a2a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337dc5abeb4b5ac7502c84b6726ec395" id="r_a337dc5abeb4b5ac7502c84b6726ec395"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a337dc5abeb4b5ac7502c84b6726ec395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a337dc5abeb4b5ac7502c84b6726ec395">Halide::Internal::IRMatcher::add</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator+(a, b))</td></tr>
<tr class="separator:a337dc5abeb4b5ac7502c84b6726ec395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdd7fb7b36b2cf3b64bda5111d28b4e" id="r_afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afbdd7fb7b36b2cf3b64bda5111d28b4e">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a4cb65f0a03b2bd504543b36bd9817" id="r_ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad0a4cb65f0a03b2bd504543b36bd9817">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd876acceaa7d5ecf7c52ce3fb847b" id="r_a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a21fd876acceaa7d5ecf7c52ce3fb847b">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87772ce7641a946fb08359b977ec067" id="r_ab87772ce7641a946fb08359b977ec067"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab87772ce7641a946fb08359b977ec067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab87772ce7641a946fb08359b977ec067">Halide::Internal::IRMatcher::operator-</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:ab87772ce7641a946fb08359b977ec067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2519d95c8671e7dd3bfaf00b1df2b0" id="r_a8f2519d95c8671e7dd3bfaf00b1df2b0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a8f2519d95c8671e7dd3bfaf00b1df2b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8f2519d95c8671e7dd3bfaf00b1df2b0">Halide::Internal::IRMatcher::sub</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator-(a, b))</td></tr>
<tr class="separator:a8f2519d95c8671e7dd3bfaf00b1df2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9451c858ad2679ef5b735719ddd065" id="r_a5e9451c858ad2679ef5b735719ddd065"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5e9451c858ad2679ef5b735719ddd065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5e9451c858ad2679ef5b735719ddd065">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a5e9451c858ad2679ef5b735719ddd065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31218a5a5b22ea9d423a526bf48b3197" id="r_a31218a5a5b22ea9d423a526bf48b3197"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a31218a5a5b22ea9d423a526bf48b3197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a31218a5a5b22ea9d423a526bf48b3197">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a31218a5a5b22ea9d423a526bf48b3197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160bccbd5b3260ff67658ea4d533952d" id="r_a160bccbd5b3260ff67658ea4d533952d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a160bccbd5b3260ff67658ea4d533952d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a160bccbd5b3260ff67658ea4d533952d">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a160bccbd5b3260ff67658ea4d533952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d830440f107dc41a1716783e211503a" id="r_a2d830440f107dc41a1716783e211503a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2d830440f107dc41a1716783e211503a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2d830440f107dc41a1716783e211503a">Halide::Internal::IRMatcher::operator*</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a2d830440f107dc41a1716783e211503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9fbcfd2433ac643c9e2cb754b588d" id="r_a40a9fbcfd2433ac643c9e2cb754b588d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a40a9fbcfd2433ac643c9e2cb754b588d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40a9fbcfd2433ac643c9e2cb754b588d">Halide::Internal::IRMatcher::mul</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator*(a, b))</td></tr>
<tr class="separator:a40a9fbcfd2433ac643c9e2cb754b588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47740df91721e730d765b5472669f11" id="r_aa47740df91721e730d765b5472669f11"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa47740df91721e730d765b5472669f11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa47740df91721e730d765b5472669f11">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:aa47740df91721e730d765b5472669f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6c8f1d6156f6cd65f9a5521909ac6" id="r_a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a41a6c8f1d6156f6cd65f9a5521909ac6">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e49735a398b8127b96e4d5713e571f" id="r_a78e49735a398b8127b96e4d5713e571f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a78e49735a398b8127b96e4d5713e571f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a78e49735a398b8127b96e4d5713e571f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a78e49735a398b8127b96e4d5713e571f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45261747b321afc0e81b7d92c48aa574" id="r_a45261747b321afc0e81b7d92c48aa574"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a45261747b321afc0e81b7d92c48aa574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a45261747b321afc0e81b7d92c48aa574">Halide::Internal::IRMatcher::operator/</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a45261747b321afc0e81b7d92c48aa574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383cd228eb518f611dbd291a516ad802" id="r_a383cd228eb518f611dbd291a516ad802"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a383cd228eb518f611dbd291a516ad802"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a383cd228eb518f611dbd291a516ad802">Halide::Internal::IRMatcher::div</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator/(a, b))</td></tr>
<tr class="separator:a383cd228eb518f611dbd291a516ad802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183445e4d4dca061c05996652f2dac5b" id="r_a183445e4d4dca061c05996652f2dac5b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a183445e4d4dca061c05996652f2dac5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a183445e4d4dca061c05996652f2dac5b">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a183445e4d4dca061c05996652f2dac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a117db2cf577ff20571558dbe97bf7f" id="r_a7a117db2cf577ff20571558dbe97bf7f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7a117db2cf577ff20571558dbe97bf7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7a117db2cf577ff20571558dbe97bf7f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a7a117db2cf577ff20571558dbe97bf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d8b67bef430b9df555bf291792614f" id="r_ae4d8b67bef430b9df555bf291792614f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae4d8b67bef430b9df555bf291792614f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae4d8b67bef430b9df555bf291792614f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:ae4d8b67bef430b9df555bf291792614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc1219661497d08a78d27e8750e11d0" id="r_a5bc1219661497d08a78d27e8750e11d0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a5bc1219661497d08a78d27e8750e11d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5bc1219661497d08a78d27e8750e11d0">Halide::Internal::IRMatcher::operator%</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a5bc1219661497d08a78d27e8750e11d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d085a252877ef3f8c139c13936075c" id="r_af6d085a252877ef3f8c139c13936075c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af6d085a252877ef3f8c139c13936075c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af6d085a252877ef3f8c139c13936075c">Halide::Internal::IRMatcher::mod</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator%(a, b))</td></tr>
<tr class="separator:af6d085a252877ef3f8c139c13936075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb7e262c2c8f83476f33fa96ab4411" id="r_a49bb7e262c2c8f83476f33fa96ab4411"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a49bb7e262c2c8f83476f33fa96ab4411">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac259ecbd0cbade6ea8b16a03992de682" id="r_ac259ecbd0cbade6ea8b16a03992de682"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac259ecbd0cbade6ea8b16a03992de682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac259ecbd0cbade6ea8b16a03992de682">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac259ecbd0cbade6ea8b16a03992de682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5ce93cc0835cb6d4c79f2aa366ae5d" id="r_acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#acb5ce93cc0835cb6d4c79f2aa366ae5d">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d0f25c1cc3452f338fed00dbbc7006" id="r_a13d0f25c1cc3452f338fed00dbbc7006"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a13d0f25c1cc3452f338fed00dbbc7006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a13d0f25c1cc3452f338fed00dbbc7006">Halide::Internal::IRMatcher::min</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a13d0f25c1cc3452f338fed00dbbc7006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f49f4ff4022205c07838918fd036ec2" id="r_a9f49f4ff4022205c07838918fd036ec2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9f49f4ff4022205c07838918fd036ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9f49f4ff4022205c07838918fd036ec2">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a9f49f4ff4022205c07838918fd036ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee047ac24b43b0ea19cdc26ae9177a0" id="r_a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0ee047ac24b43b0ea19cdc26ae9177a0">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e1f600078ba83441a1da2e360cc255" id="r_a78e1f600078ba83441a1da2e360cc255"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a78e1f600078ba83441a1da2e360cc255"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a78e1f600078ba83441a1da2e360cc255">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a78e1f600078ba83441a1da2e360cc255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ac090f719272da825a4749e3feba0f" id="r_a40ac090f719272da825a4749e3feba0f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a40ac090f719272da825a4749e3feba0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40ac090f719272da825a4749e3feba0f">Halide::Internal::IRMatcher::max</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a40ac090f719272da825a4749e3feba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dd8f17b989502f974f83eb229b318c" id="r_a62dd8f17b989502f974f83eb229b318c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a62dd8f17b989502f974f83eb229b318c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a62dd8f17b989502f974f83eb229b318c">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a62dd8f17b989502f974f83eb229b318c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8986bb12c496cdc93b809e91f10613ad" id="r_a8986bb12c496cdc93b809e91f10613ad"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8986bb12c496cdc93b809e91f10613ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8986bb12c496cdc93b809e91f10613ad">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a8986bb12c496cdc93b809e91f10613ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab312d3c67fa31a253ca57f6420879d5f" id="r_ab312d3c67fa31a253ca57f6420879d5f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab312d3c67fa31a253ca57f6420879d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab312d3c67fa31a253ca57f6420879d5f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:ab312d3c67fa31a253ca57f6420879d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833cce3a02abce0789516bf33049a4b0" id="r_a833cce3a02abce0789516bf33049a4b0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a833cce3a02abce0789516bf33049a4b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a833cce3a02abce0789516bf33049a4b0">Halide::Internal::IRMatcher::operator&lt;</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a833cce3a02abce0789516bf33049a4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4330ae468f2bc8bf764b4dc78093778" id="r_ac4330ae468f2bc8bf764b4dc78093778"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac4330ae468f2bc8bf764b4dc78093778"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac4330ae468f2bc8bf764b4dc78093778">Halide::Internal::IRMatcher::lt</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&lt;(a, b))</td></tr>
<tr class="separator:ac4330ae468f2bc8bf764b4dc78093778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59404f6a9be2edd1e7b087067186085" id="r_ad59404f6a9be2edd1e7b087067186085"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad59404f6a9be2edd1e7b087067186085"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad59404f6a9be2edd1e7b087067186085">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ad59404f6a9be2edd1e7b087067186085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2f045c1fac015142c7849a2d0a6c0e" id="r_a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6f2f045c1fac015142c7849a2d0a6c0e">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fd57e139aae6bc2a749b7dd7a2fa5b" id="r_a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a90fd57e139aae6bc2a749b7dd7a2fa5b">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LT &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e553686bff1060ee43f34fd4802a23" id="r_a51e553686bff1060ee43f34fd4802a23"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a51e553686bff1060ee43f34fd4802a23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a51e553686bff1060ee43f34fd4802a23">Halide::Internal::IRMatcher::operator&gt;</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a51e553686bff1060ee43f34fd4802a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ca018cc9aed19d368a2ee56c8592a" id="r_a274ca018cc9aed19d368a2ee56c8592a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a274ca018cc9aed19d368a2ee56c8592a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a274ca018cc9aed19d368a2ee56c8592a">Halide::Internal::IRMatcher::gt</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&gt;(a, b))</td></tr>
<tr class="separator:a274ca018cc9aed19d368a2ee56c8592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21a7fd9d8ad2e8c69060a0ba114658c" id="r_aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa21a7fd9d8ad2e8c69060a0ba114658c">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b98496c33623a602cfc21154a2c5a4c" id="r_a6b98496c33623a602cfc21154a2c5a4c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6b98496c33623a602cfc21154a2c5a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b98496c33623a602cfc21154a2c5a4c">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6b98496c33623a602cfc21154a2c5a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88710908fc5963e4b0f13cf21bc8d406" id="r_a88710908fc5963e4b0f13cf21bc8d406"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a88710908fc5963e4b0f13cf21bc8d406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a88710908fc5963e4b0f13cf21bc8d406">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GT &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a88710908fc5963e4b0f13cf21bc8d406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25a85f3e64642ba824e9bd9c455ca3" id="r_a1f25a85f3e64642ba824e9bd9c455ca3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1f25a85f3e64642ba824e9bd9c455ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1f25a85f3e64642ba824e9bd9c455ca3">Halide::Internal::IRMatcher::operator&lt;=</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a1f25a85f3e64642ba824e9bd9c455ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac250b793aa021eccd179c53908dda5c4" id="r_ac250b793aa021eccd179c53908dda5c4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac250b793aa021eccd179c53908dda5c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac250b793aa021eccd179c53908dda5c4">Halide::Internal::IRMatcher::le</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&lt;=(a, b))</td></tr>
<tr class="separator:ac250b793aa021eccd179c53908dda5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c526b5044511ee7ca7e9bcdcb1a69b6" id="r_a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2c526b5044511ee7ca7e9bcdcb1a69b6">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4471ac09a360f80dd78b853300053" id="r_ac8d4471ac09a360f80dd78b853300053"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac8d4471ac09a360f80dd78b853300053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac8d4471ac09a360f80dd78b853300053">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac8d4471ac09a360f80dd78b853300053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d1b4920a766465287987573f8f6a13" id="r_a98d1b4920a766465287987573f8f6a13"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a98d1b4920a766465287987573f8f6a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a98d1b4920a766465287987573f8f6a13">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a98d1b4920a766465287987573f8f6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a0be176f231cfdf8c62021bbda629" id="r_a7d7a0be176f231cfdf8c62021bbda629"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a7d7a0be176f231cfdf8c62021bbda629"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7d7a0be176f231cfdf8c62021bbda629">Halide::Internal::IRMatcher::operator&gt;=</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a7d7a0be176f231cfdf8c62021bbda629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea49e0a06ecc1246107091521cbb3926" id="r_aea49e0a06ecc1246107091521cbb3926"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aea49e0a06ecc1246107091521cbb3926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aea49e0a06ecc1246107091521cbb3926">Halide::Internal::IRMatcher::ge</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&gt;=(a, b))</td></tr>
<tr class="separator:aea49e0a06ecc1246107091521cbb3926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6bc166b2fb647aa37ee405b103547" id="r_ab0a6bc166b2fb647aa37ee405b103547"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab0a6bc166b2fb647aa37ee405b103547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab0a6bc166b2fb647aa37ee405b103547">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ab0a6bc166b2fb647aa37ee405b103547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7f8aad5e2da6f956f9793c17b05a2" id="r_a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0de7f8aad5e2da6f956f9793c17b05a2">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0615b3c844f1bbbdc91d406c38a702f" id="r_ae0615b3c844f1bbbdc91d406c38a702f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae0615b3c844f1bbbdc91d406c38a702f">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d4ab05211a0d72975207ee6e0e4c40" id="r_af9d4ab05211a0d72975207ee6e0e4c40"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af9d4ab05211a0d72975207ee6e0e4c40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af9d4ab05211a0d72975207ee6e0e4c40">Halide::Internal::IRMatcher::operator==</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:af9d4ab05211a0d72975207ee6e0e4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda856931d657019ab52370ce9622ca9" id="r_afda856931d657019ab52370ce9622ca9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:afda856931d657019ab52370ce9622ca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afda856931d657019ab52370ce9622ca9">Halide::Internal::IRMatcher::eq</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator==(a, b))</td></tr>
<tr class="separator:afda856931d657019ab52370ce9622ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039e07269a504c112cccbbddad2abd5" id="r_ae039e07269a504c112cccbbddad2abd5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae039e07269a504c112cccbbddad2abd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae039e07269a504c112cccbbddad2abd5">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; EQ &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ae039e07269a504c112cccbbddad2abd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369eaca268feef6557e2a11f3d3d44f6" id="r_a369eaca268feef6557e2a11f3d3d44f6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a369eaca268feef6557e2a11f3d3d44f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a369eaca268feef6557e2a11f3d3d44f6">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; EQ &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a369eaca268feef6557e2a11f3d3d44f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3fec822b82e4550f36edcd0f94395" id="r_a77a3fec822b82e4550f36edcd0f94395"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77a3fec822b82e4550f36edcd0f94395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a77a3fec822b82e4550f36edcd0f94395">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; EQ &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a77a3fec822b82e4550f36edcd0f94395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7110bb296528fe0b4cd90b8a969fbf9c" id="r_a7110bb296528fe0b4cd90b8a969fbf9c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a7110bb296528fe0b4cd90b8a969fbf9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7110bb296528fe0b4cd90b8a969fbf9c">Halide::Internal::IRMatcher::operator!=</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a7110bb296528fe0b4cd90b8a969fbf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b366748fa8c12e792e3ede293bdcbc4" id="r_a1b366748fa8c12e792e3ede293bdcbc4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1b366748fa8c12e792e3ede293bdcbc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1b366748fa8c12e792e3ede293bdcbc4">Halide::Internal::IRMatcher::ne</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">IRMatcher::operator!</a>=(a, b))</td></tr>
<tr class="separator:a1b366748fa8c12e792e3ede293bdcbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d31793eaf2c9bb7b2091ed268032cd" id="r_af1d31793eaf2c9bb7b2091ed268032cd"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af1d31793eaf2c9bb7b2091ed268032cd">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; NE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88969b742de298fa4e89c1b7e0cd9507" id="r_a88969b742de298fa4e89c1b7e0cd9507"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a88969b742de298fa4e89c1b7e0cd9507"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a88969b742de298fa4e89c1b7e0cd9507">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; NE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a88969b742de298fa4e89c1b7e0cd9507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761e19f9cf67ff92b92350cb2f6b113" id="r_ac761e19f9cf67ff92b92350cb2f6b113"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac761e19f9cf67ff92b92350cb2f6b113">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; NE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b766949dea9fe12a94f607a279b4845" id="r_a6b766949dea9fe12a94f607a279b4845"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6b766949dea9fe12a94f607a279b4845"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b766949dea9fe12a94f607a279b4845">Halide::Internal::IRMatcher::operator||</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a6b766949dea9fe12a94f607a279b4845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ef677a9266173fc51c21c0691a351" id="r_a0f6ef677a9266173fc51c21c0691a351"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a0f6ef677a9266173fc51c21c0691a351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0f6ef677a9266173fc51c21c0691a351">Halide::Internal::IRMatcher::or_op</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator||(a, b))</td></tr>
<tr class="separator:a0f6ef677a9266173fc51c21c0691a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e3a69d10dc265ce7af23472b244e7a" id="r_ad6e3a69d10dc265ce7af23472b244e7a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6e3a69d10dc265ce7af23472b244e7a">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9551d885c2e22f2a7452adad11b9088" id="r_ac9551d885c2e22f2a7452adad11b9088"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac9551d885c2e22f2a7452adad11b9088"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac9551d885c2e22f2a7452adad11b9088">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac9551d885c2e22f2a7452adad11b9088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af673f00fb1b63e823eba6f706412faf3" id="r_af673f00fb1b63e823eba6f706412faf3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af673f00fb1b63e823eba6f706412faf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af673f00fb1b63e823eba6f706412faf3">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:af673f00fb1b63e823eba6f706412faf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b27a055ef4f01ea720a5601cc8acb8" id="r_a84b27a055ef4f01ea720a5601cc8acb8"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a84b27a055ef4f01ea720a5601cc8acb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a84b27a055ef4f01ea720a5601cc8acb8">Halide::Internal::IRMatcher::operator&amp;&amp;</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a84b27a055ef4f01ea720a5601cc8acb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e8bc42d079dd5a396862161982a040" id="r_a24e8bc42d079dd5a396862161982a040"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a24e8bc42d079dd5a396862161982a040"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a24e8bc42d079dd5a396862161982a040">Halide::Internal::IRMatcher::and_op</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&amp;&amp;(a, b))</td></tr>
<tr class="separator:a24e8bc42d079dd5a396862161982a040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5bef8af3af1585ae4d230d4096ea7e" id="r_a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4b5bef8af3af1585ae4d230d4096ea7e">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c3ee7ce56b6e53ed07ee537ad0ae0" id="r_a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6d7c3ee7ce56b6e53ed07ee537ad0ae0">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d065a5b95304e191321a47658e1da7" id="r_a90d065a5b95304e191321a47658e1da7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a90d065a5b95304e191321a47658e1da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a90d065a5b95304e191321a47658e1da7">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a90d065a5b95304e191321a47658e1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade15fc322252444c511ae6458ee2e898" id="r_ade15fc322252444c511ae6458ee2e898"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ade15fc322252444c511ae6458ee2e898">Halide::Internal::IRMatcher::bitwise_or_reduce</a> ()</td></tr>
<tr class="separator:ade15fc322252444c511ae6458ee2e898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f76d20c53e195277c279e315c97e75" id="r_a86f76d20c53e195277c279e315c97e75"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a86f76d20c53e195277c279e315c97e75"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a86f76d20c53e195277c279e315c97e75">Halide::Internal::IRMatcher::bitwise_or_reduce</a> (<a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> first, Args... rest)</td></tr>
<tr class="separator:a86f76d20c53e195277c279e315c97e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fba2b048ff9dfde5b4fd084ae4a6de" id="r_a67fba2b048ff9dfde5b4fd084ae4a6de"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a67fba2b048ff9dfde5b4fd084ae4a6de">Halide::Internal::IRMatcher::and_reduce</a> ()</td></tr>
<tr class="separator:a67fba2b048ff9dfde5b4fd084ae4a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156714bf9d1b4d9991b828dd4ae5b38" id="r_ad156714bf9d1b4d9991b828dd4ae5b38"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad156714bf9d1b4d9991b828dd4ae5b38"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad156714bf9d1b4d9991b828dd4ae5b38">Halide::Internal::IRMatcher::and_reduce</a> (bool first, Args... rest)</td></tr>
<tr class="separator:ad156714bf9d1b4d9991b828dd4ae5b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeda156ac4dd5650fe120a1f0bae129e" id="r_aeeda156ac4dd5650fe120a1f0bae129e"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aeeda156ac4dd5650fe120a1f0bae129e">Halide::Internal::IRMatcher::const_min</a> (int a, int b)</td></tr>
<tr class="separator:aeeda156ac4dd5650fe120a1f0bae129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dabe99da0a15b970cff72da6da43dc" id="r_a29dabe99da0a15b970cff72da6da43dc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a29dabe99da0a15b970cff72da6da43dc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a29dabe99da0a15b970cff72da6da43dc">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; Args... &gt; &amp;op)</td></tr>
<tr class="separator:a29dabe99da0a15b970cff72da6da43dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1008f0c0246dd21c990ca1375513ef" id="r_a2c1008f0c0246dd21c990ca1375513ef"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2c1008f0c0246dd21c990ca1375513ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2c1008f0c0246dd21c990ca1375513ef">Halide::Internal::IRMatcher::intrin</a> (<a class="el" href="struct_halide_1_1_internal_1_1_call.html#a3643a3e5cf73435e07215fca17949974">Call::IntrinsicOp</a> intrinsic_op, Args... args) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(args))... &gt;</td></tr>
<tr class="separator:a2c1008f0c0246dd21c990ca1375513ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f41c13a3b156e58c416df72310352f2" id="r_a0f41c13a3b156e58c416df72310352f2"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a0f41c13a3b156e58c416df72310352f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0f41c13a3b156e58c416df72310352f2">Halide::Internal::IRMatcher::widen_right_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a0f41c13a3b156e58c416df72310352f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d919cea58643bdc5eaca6749580d9fa" id="r_a8d919cea58643bdc5eaca6749580d9fa"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a8d919cea58643bdc5eaca6749580d9fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8d919cea58643bdc5eaca6749580d9fa">Halide::Internal::IRMatcher::widen_right_mul</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a8d919cea58643bdc5eaca6749580d9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3315f9708903bede531625136ea12a23" id="r_a3315f9708903bede531625136ea12a23"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a3315f9708903bede531625136ea12a23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3315f9708903bede531625136ea12a23">Halide::Internal::IRMatcher::widen_right_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a3315f9708903bede531625136ea12a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55178af5e3b02b5255a94e0569a3408c" id="r_a55178af5e3b02b5255a94e0569a3408c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a55178af5e3b02b5255a94e0569a3408c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a55178af5e3b02b5255a94e0569a3408c">Halide::Internal::IRMatcher::widening_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a55178af5e3b02b5255a94e0569a3408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce80d3e53d9314292ed9c4219486cbe" id="r_a6ce80d3e53d9314292ed9c4219486cbe"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6ce80d3e53d9314292ed9c4219486cbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6ce80d3e53d9314292ed9c4219486cbe">Halide::Internal::IRMatcher::widening_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a6ce80d3e53d9314292ed9c4219486cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bd76459b363b4941109dc8737c5dba" id="r_a48bd76459b363b4941109dc8737c5dba"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a48bd76459b363b4941109dc8737c5dba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a48bd76459b363b4941109dc8737c5dba">Halide::Internal::IRMatcher::widening_mul</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a48bd76459b363b4941109dc8737c5dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f87c36110f9d7459d2cdd4ada22a557" id="r_a3f87c36110f9d7459d2cdd4ada22a557"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a3f87c36110f9d7459d2cdd4ada22a557"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3f87c36110f9d7459d2cdd4ada22a557">Halide::Internal::IRMatcher::saturating_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a3f87c36110f9d7459d2cdd4ada22a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5a757e2b3168a4b06595410120e2b" id="r_aa3f5a757e2b3168a4b06595410120e2b"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa3f5a757e2b3168a4b06595410120e2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa3f5a757e2b3168a4b06595410120e2b">Halide::Internal::IRMatcher::saturating_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:aa3f5a757e2b3168a4b06595410120e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d8f19f7691132488d25e1b200d0eb" id="r_aea4d8f19f7691132488d25e1b200d0eb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aea4d8f19f7691132488d25e1b200d0eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aea4d8f19f7691132488d25e1b200d0eb">Halide::Internal::IRMatcher::saturating_cast</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t, A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:aea4d8f19f7691132488d25e1b200d0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b22be350851606a059a0b62423e0c" id="r_a616b22be350851606a059a0b62423e0c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a616b22be350851606a059a0b62423e0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a616b22be350851606a059a0b62423e0c">Halide::Internal::IRMatcher::halving_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a616b22be350851606a059a0b62423e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa264cecf50c3be3f61a5a74e6acae758" id="r_aa264cecf50c3be3f61a5a74e6acae758"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa264cecf50c3be3f61a5a74e6acae758"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa264cecf50c3be3f61a5a74e6acae758">Halide::Internal::IRMatcher::halving_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:aa264cecf50c3be3f61a5a74e6acae758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32711f0db688217a84f12677e958a393" id="r_a32711f0db688217a84f12677e958a393"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a32711f0db688217a84f12677e958a393"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a32711f0db688217a84f12677e958a393">Halide::Internal::IRMatcher::rounding_halving_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a32711f0db688217a84f12677e958a393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d73347f758b37e84dd96b2fa524032" id="r_a02d73347f758b37e84dd96b2fa524032"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a02d73347f758b37e84dd96b2fa524032"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a02d73347f758b37e84dd96b2fa524032">Halide::Internal::IRMatcher::shift_left</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a02d73347f758b37e84dd96b2fa524032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03704bed4c099f03d477e9cbe6ecf96" id="r_ab03704bed4c099f03d477e9cbe6ecf96"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab03704bed4c099f03d477e9cbe6ecf96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab03704bed4c099f03d477e9cbe6ecf96">Halide::Internal::IRMatcher::shift_right</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:ab03704bed4c099f03d477e9cbe6ecf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a849a0adf0cb90e57a54fcbc7e346" id="r_a024a849a0adf0cb90e57a54fcbc7e346"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a024a849a0adf0cb90e57a54fcbc7e346"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a024a849a0adf0cb90e57a54fcbc7e346">Halide::Internal::IRMatcher::rounding_shift_left</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a024a849a0adf0cb90e57a54fcbc7e346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fb5637bd3165e3f741c207c0b8d175" id="r_a32fb5637bd3165e3f741c207c0b8d175"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a32fb5637bd3165e3f741c207c0b8d175"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a32fb5637bd3165e3f741c207c0b8d175">Halide::Internal::IRMatcher::rounding_shift_right</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a32fb5637bd3165e3f741c207c0b8d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2de4cbcda2b78606947b7be198e374" id="r_aaf2de4cbcda2b78606947b7be198e374"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &gt; </td></tr>
<tr class="memitem:aaf2de4cbcda2b78606947b7be198e374"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aaf2de4cbcda2b78606947b7be198e374">Halide::Internal::IRMatcher::mul_shift_right</a> (A &amp;&amp;a, B &amp;&amp;b, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &amp;&amp;c) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c))&gt;</td></tr>
<tr class="separator:aaf2de4cbcda2b78606947b7be198e374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9c7eb597e1ca46680abe64a7ad7f9c" id="r_adf9c7eb597e1ca46680abe64a7ad7f9c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &gt; </td></tr>
<tr class="memitem:adf9c7eb597e1ca46680abe64a7ad7f9c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adf9c7eb597e1ca46680abe64a7ad7f9c">Halide::Internal::IRMatcher::rounding_mul_shift_right</a> (A &amp;&amp;a, B &amp;&amp;b, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &amp;&amp;c) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c))&gt;</td></tr>
<tr class="separator:adf9c7eb597e1ca46680abe64a7ad7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1221d76d53d37224ffeaf8e4e016044e" id="r_a1221d76d53d37224ffeaf8e4e016044e"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a1221d76d53d37224ffeaf8e4e016044e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">Halide::Internal::IRMatcher::operator!</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a1221d76d53d37224ffeaf8e4e016044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ababe61b897e02458abaa51ff96952" id="r_a60ababe61b897e02458abaa51ff96952"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a60ababe61b897e02458abaa51ff96952"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a60ababe61b897e02458abaa51ff96952">Halide::Internal::IRMatcher::not_op</a> (A &amp;&amp;a) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">IRMatcher::operator!</a>(a))</td></tr>
<tr class="separator:a60ababe61b897e02458abaa51ff96952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb673cc5d6c076515df56ec062858b1a" id="r_abb673cc5d6c076515df56ec062858b1a"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:abb673cc5d6c076515df56ec062858b1a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#abb673cc5d6c076515df56ec062858b1a">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:abb673cc5d6c076515df56ec062858b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c09695e5b202c17965d756056509267" id="r_a2c09695e5b202c17965d756056509267"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> , typename T , typename F &gt; </td></tr>
<tr class="memitem:a2c09695e5b202c17965d756056509267"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2c09695e5b202c17965d756056509267">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a>&lt; <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a>, T, F &gt; &amp;op)</td></tr>
<tr class="separator:a2c09695e5b202c17965d756056509267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f94a63ffe179595c2f5479d053d3ba" id="r_a99f94a63ffe179595c2f5479d053d3ba"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> , typename T , typename F &gt; </td></tr>
<tr class="memitem:a99f94a63ffe179595c2f5479d053d3ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a99f94a63ffe179595c2f5479d053d3ba">Halide::Internal::IRMatcher::select</a> (<a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &amp;&amp;c, T &amp;&amp;t, F &amp;&amp;f) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(t)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(f))&gt;</td></tr>
<tr class="separator:a99f94a63ffe179595c2f5479d053d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ac4364ff6355145291b654f04eb8ae" id="r_af9ac4364ff6355145291b654f04eb8ae"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af9ac4364ff6355145291b654f04eb8ae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af9ac4364ff6355145291b654f04eb8ae">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a>&lt; A, B &gt; &amp;op)</td></tr>
<tr class="separator:af9ac4364ff6355145291b654f04eb8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9922c231b05db372ed6a96007a2d6a20" id="r_a9922c231b05db372ed6a96007a2d6a20"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a9922c231b05db372ed6a96007a2d6a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9922c231b05db372ed6a96007a2d6a20">Halide::Internal::IRMatcher::broadcast</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes))&gt;</td></tr>
<tr class="separator:a9922c231b05db372ed6a96007a2d6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981f10641240687d3f0cc1481af8a284" id="r_a981f10641240687d3f0cc1481af8a284"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &gt; </td></tr>
<tr class="memitem:a981f10641240687d3f0cc1481af8a284"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a981f10641240687d3f0cc1481af8a284">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a>&lt; A, B, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &gt; &amp;op)</td></tr>
<tr class="separator:a981f10641240687d3f0cc1481af8a284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f2d238dfcffbd0c3451ef90232877" id="r_a431f2d238dfcffbd0c3451ef90232877"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &gt; </td></tr>
<tr class="memitem:a431f2d238dfcffbd0c3451ef90232877"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a431f2d238dfcffbd0c3451ef90232877">Halide::Internal::IRMatcher::ramp</a> (A &amp;&amp;a, B &amp;&amp;b, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a> &amp;&amp;c) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c))&gt;</td></tr>
<tr class="separator:a431f2d238dfcffbd0c3451ef90232877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6de11605dc56bea1406801f7075a35" id="r_a3f6de11605dc56bea1406801f7075a35"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27">VectorReduce::Operator</a> reduce_op&gt; </td></tr>
<tr class="memitem:a3f6de11605dc56bea1406801f7075a35"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3f6de11605dc56bea1406801f7075a35">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; A, B, reduce_op &gt; &amp;op)</td></tr>
<tr class="separator:a3f6de11605dc56bea1406801f7075a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6723cb8cab78dc4c8f379e3c83a8360" id="r_ad6723cb8cab78dc4c8f379e3c83a8360"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad6723cb8cab78dc4c8f379e3c83a8360"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6723cb8cab78dc4c8f379e3c83a8360">Halide::Internal::IRMatcher::h_add</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a16ec0621eb057662b7f7d001dbd0da01">VectorReduce::Add</a> &gt;</td></tr>
<tr class="separator:ad6723cb8cab78dc4c8f379e3c83a8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6067256015c2d4afa44d97cb8eda1e6" id="r_ad6067256015c2d4afa44d97cb8eda1e6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad6067256015c2d4afa44d97cb8eda1e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6067256015c2d4afa44d97cb8eda1e6">Halide::Internal::IRMatcher::h_min</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a0abcd93c020ca8bae3babbfc837e8f02">VectorReduce::Min</a> &gt;</td></tr>
<tr class="separator:ad6067256015c2d4afa44d97cb8eda1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921a69b5feab00a02588a95d2f450cb" id="r_a9921a69b5feab00a02588a95d2f450cb"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a9921a69b5feab00a02588a95d2f450cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9921a69b5feab00a02588a95d2f450cb">Halide::Internal::IRMatcher::h_max</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27af60bd97c582326c966cc33190093b82d">VectorReduce::Max</a> &gt;</td></tr>
<tr class="separator:a9921a69b5feab00a02588a95d2f450cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27178171a8cfdc63ef6273eabe81ad93" id="r_a27178171a8cfdc63ef6273eabe81ad93"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a27178171a8cfdc63ef6273eabe81ad93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a27178171a8cfdc63ef6273eabe81ad93">Halide::Internal::IRMatcher::h_and</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a3507ab281fc9d4d92dd7ae852526fc23">VectorReduce::And</a> &gt;</td></tr>
<tr class="separator:a27178171a8cfdc63ef6273eabe81ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7f03a2bb65c45f200332b34be7a589" id="r_a8c7f03a2bb65c45f200332b34be7a589"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a8c7f03a2bb65c45f200332b34be7a589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8c7f03a2bb65c45f200332b34be7a589">Halide::Internal::IRMatcher::h_or</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a79f25cf9b2e8a9b72cca870af08ed32b">VectorReduce::Or</a> &gt;</td></tr>
<tr class="separator:a8c7f03a2bb65c45f200332b34be7a589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfe016557082504c94ef795cd0e3c8f" id="r_a6bfe016557082504c94ef795cd0e3c8f"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a6bfe016557082504c94ef795cd0e3c8f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6bfe016557082504c94ef795cd0e3c8f">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a6bfe016557082504c94ef795cd0e3c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd99c19b0522f947c719b3995ffe70cb" id="r_afd99c19b0522f947c719b3995ffe70cb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:afd99c19b0522f947c719b3995ffe70cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afd99c19b0522f947c719b3995ffe70cb">Halide::Internal::IRMatcher::operator-</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:afd99c19b0522f947c719b3995ffe70cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e62d8f98688b2d727534fbf22289f2c" id="r_a1e62d8f98688b2d727534fbf22289f2c"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a1e62d8f98688b2d727534fbf22289f2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e62d8f98688b2d727534fbf22289f2c">Halide::Internal::IRMatcher::negate</a> (A &amp;&amp;a) -&gt; decltype(IRMatcher::operator-(a))</td></tr>
<tr class="separator:a1e62d8f98688b2d727534fbf22289f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29c62283aaa98fbe8c96610b140524" id="r_aad29c62283aaa98fbe8c96610b140524"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aad29c62283aaa98fbe8c96610b140524"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aad29c62283aaa98fbe8c96610b140524">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:aad29c62283aaa98fbe8c96610b140524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548d0224c06bd3698a5bc689a8c61fb6" id="r_a548d0224c06bd3698a5bc689a8c61fb6"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a548d0224c06bd3698a5bc689a8c61fb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a548d0224c06bd3698a5bc689a8c61fb6">Halide::Internal::IRMatcher::cast</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a548d0224c06bd3698a5bc689a8c61fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68d14eadb7437bab489213ebdb4a531" id="r_af68d14eadb7437bab489213ebdb4a531"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:af68d14eadb7437bab489213ebdb4a531"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af68d14eadb7437bab489213ebdb4a531">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_widen_op.html">WidenOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:af68d14eadb7437bab489213ebdb4a531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461174a1b869c91b32a218f81d181772" id="r_a461174a1b869c91b32a218f81d181772"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a461174a1b869c91b32a218f81d181772"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a461174a1b869c91b32a218f81d181772">Halide::Internal::IRMatcher::widen</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_widen_op.html">WidenOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a461174a1b869c91b32a218f81d181772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9ffa8c222ab41a5f5ee73d73604846" id="r_a3a9ffa8c222ab41a5f5ee73d73604846"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename Base , typename Stride , typename Lanes &gt; </td></tr>
<tr class="memitem:a3a9ffa8c222ab41a5f5ee73d73604846"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3a9ffa8c222ab41a5f5ee73d73604846">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_slice_op.html">SliceOp</a>&lt; Vec, Base, Stride, Lanes &gt; &amp;op)</td></tr>
<tr class="separator:a3a9ffa8c222ab41a5f5ee73d73604846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430b76c2c3bb4b6245b1be3b0164e4ac" id="r_a430b76c2c3bb4b6245b1be3b0164e4ac"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename Base , typename Stride , typename Lanes &gt; </td></tr>
<tr class="memitem:a430b76c2c3bb4b6245b1be3b0164e4ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a430b76c2c3bb4b6245b1be3b0164e4ac">Halide::Internal::IRMatcher::slice</a> (Vec vec, Base base, Stride stride, Lanes lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_slice_op.html">SliceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(vec)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(base)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(stride)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes))&gt;</td></tr>
<tr class="separator:a430b76c2c3bb4b6245b1be3b0164e4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606c85092b9877e71685d7cf5e41ab31" id="r_a606c85092b9877e71685d7cf5e41ab31"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a606c85092b9877e71685d7cf5e41ab31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a606c85092b9877e71685d7cf5e41ab31">Halide::Internal::IRMatcher::fold</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a606c85092b9877e71685d7cf5e41ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f52d5a00e7a66986bbdd57ffd850b6e" id="r_a7f52d5a00e7a66986bbdd57ffd850b6e"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a7f52d5a00e7a66986bbdd57ffd850b6e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7f52d5a00e7a66986bbdd57ffd850b6e">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a7f52d5a00e7a66986bbdd57ffd850b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54edd4eb65abe7517ce70567983e7b42" id="r_a54edd4eb65abe7517ce70567983e7b42"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a54edd4eb65abe7517ce70567983e7b42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54edd4eb65abe7517ce70567983e7b42">Halide::Internal::IRMatcher::overflows</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a54edd4eb65abe7517ce70567983e7b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b1e66f4f2995734b5f6ec9da9ed789" id="r_a89b1e66f4f2995734b5f6ec9da9ed789"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a89b1e66f4f2995734b5f6ec9da9ed789"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a89b1e66f4f2995734b5f6ec9da9ed789">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a89b1e66f4f2995734b5f6ec9da9ed789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8115e05de176146f290171aecf070e" id="r_a8b8115e05de176146f290171aecf070e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8b8115e05de176146f290171aecf070e">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow.html">Overflow</a> &amp;op)</td></tr>
<tr class="separator:a8b8115e05de176146f290171aecf070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28433cdc327c82a5cad11ca6e051ea75" id="r_a28433cdc327c82a5cad11ca6e051ea75"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a28433cdc327c82a5cad11ca6e051ea75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a28433cdc327c82a5cad11ca6e051ea75">Halide::Internal::IRMatcher::is_const</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a28433cdc327c82a5cad11ca6e051ea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6beb2dc17775cfdcdf7f22192854b09" id="r_ac6beb2dc17775cfdcdf7f22192854b09"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ac6beb2dc17775cfdcdf7f22192854b09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac6beb2dc17775cfdcdf7f22192854b09">Halide::Internal::IRMatcher::is_const</a> (A &amp;&amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> value) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:ac6beb2dc17775cfdcdf7f22192854b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc4c9c66f354b618679504246589524" id="r_a7fc4c9c66f354b618679504246589524"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a7fc4c9c66f354b618679504246589524"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7fc4c9c66f354b618679504246589524">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a7fc4c9c66f354b618679504246589524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9f4c30615143a322274dab09e1829c" id="r_afc9f4c30615143a322274dab09e1829c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Prover &gt; </td></tr>
<tr class="memitem:afc9f4c30615143a322274dab09e1829c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afc9f4c30615143a322274dab09e1829c">Halide::Internal::IRMatcher::can_prove</a> (A &amp;&amp;a, Prover *p) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), Prover &gt;</td></tr>
<tr class="separator:afc9f4c30615143a322274dab09e1829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a29d27f492fbceb004e7ec8cdd7f21" id="r_a17a29d27f492fbceb004e7ec8cdd7f21"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Prover &gt; </td></tr>
<tr class="memitem:a17a29d27f492fbceb004e7ec8cdd7f21"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a17a29d27f492fbceb004e7ec8cdd7f21">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a>&lt; A, Prover &gt; &amp;op)</td></tr>
<tr class="separator:a17a29d27f492fbceb004e7ec8cdd7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772465f4fe4374660084eea333ed6bc9" id="r_a772465f4fe4374660084eea333ed6bc9"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a772465f4fe4374660084eea333ed6bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a772465f4fe4374660084eea333ed6bc9">Halide::Internal::IRMatcher::is_float</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a772465f4fe4374660084eea333ed6bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867d9a336eed16518c23bc0a39ac4ce2" id="r_a867d9a336eed16518c23bc0a39ac4ce2"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a867d9a336eed16518c23bc0a39ac4ce2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a867d9a336eed16518c23bc0a39ac4ce2">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a867d9a336eed16518c23bc0a39ac4ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9999c5c4ea6e145b44951721770ad4af" id="r_a9999c5c4ea6e145b44951721770ad4af"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9999c5c4ea6e145b44951721770ad4af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9999c5c4ea6e145b44951721770ad4af">Halide::Internal::IRMatcher::is_int</a> (A &amp;&amp;a, int bits=0, int lanes=0) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a9999c5c4ea6e145b44951721770ad4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d678f9946437161b4741a4494c9dd2" id="r_a40d678f9946437161b4741a4494c9dd2"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a40d678f9946437161b4741a4494c9dd2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40d678f9946437161b4741a4494c9dd2">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a40d678f9946437161b4741a4494c9dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b141d62cd4651f5802e696f2b5ec11f" id="r_a8b141d62cd4651f5802e696f2b5ec11f"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a8b141d62cd4651f5802e696f2b5ec11f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8b141d62cd4651f5802e696f2b5ec11f">Halide::Internal::IRMatcher::is_uint</a> (A &amp;&amp;a, int bits=0, int lanes=0) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a8b141d62cd4651f5802e696f2b5ec11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb59ea9fa82701dc83c16e18b158a59c" id="r_abb59ea9fa82701dc83c16e18b158a59c"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:abb59ea9fa82701dc83c16e18b158a59c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#abb59ea9fa82701dc83c16e18b158a59c">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:abb59ea9fa82701dc83c16e18b158a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0455ea7d220c198c585b7651e74f55" id="r_a5f0455ea7d220c198c585b7651e74f55"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5f0455ea7d220c198c585b7651e74f55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5f0455ea7d220c198c585b7651e74f55">Halide::Internal::IRMatcher::is_scalar</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a5f0455ea7d220c198c585b7651e74f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ff5397fb577a5d8029fcfd95e81555" id="r_a67ff5397fb577a5d8029fcfd95e81555"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a67ff5397fb577a5d8029fcfd95e81555"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a67ff5397fb577a5d8029fcfd95e81555">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a67ff5397fb577a5d8029fcfd95e81555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222c889d7baed380d66d0d58c32a1714" id="r_a222c889d7baed380d66d0d58c32a1714"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a222c889d7baed380d66d0d58c32a1714"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a222c889d7baed380d66d0d58c32a1714">Halide::Internal::IRMatcher::is_max_value</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value.html">IsMaxValue</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a222c889d7baed380d66d0d58c32a1714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbc351fbdcd1067ad929c99c52190e1" id="r_abfbc351fbdcd1067ad929c99c52190e1"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:abfbc351fbdcd1067ad929c99c52190e1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#abfbc351fbdcd1067ad929c99c52190e1">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value.html">IsMaxValue</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:abfbc351fbdcd1067ad929c99c52190e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f17def21287dbec4a6511400c023e56" id="r_a9f17def21287dbec4a6511400c023e56"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9f17def21287dbec4a6511400c023e56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9f17def21287dbec4a6511400c023e56">Halide::Internal::IRMatcher::is_min_value</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value.html">IsMinValue</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a9f17def21287dbec4a6511400c023e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce3f7a93590fd755500d96106752a6c" id="r_a0ce3f7a93590fd755500d96106752a6c"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a0ce3f7a93590fd755500d96106752a6c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0ce3f7a93590fd755500d96106752a6c">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value.html">IsMinValue</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a0ce3f7a93590fd755500d96106752a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f341bd5d834bc61f6432a5b8954666" id="r_ac8f341bd5d834bc61f6432a5b8954666"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ac8f341bd5d834bc61f6432a5b8954666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac8f341bd5d834bc61f6432a5b8954666">Halide::Internal::IRMatcher::lanes_of</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_lanes_of.html">LanesOf</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:ac8f341bd5d834bc61f6432a5b8954666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3626aa8d37dcc81ce2615f5353a16b" id="r_a2b3626aa8d37dcc81ce2615f5353a16b"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a2b3626aa8d37dcc81ce2615f5353a16b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2b3626aa8d37dcc81ce2615f5353a16b">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_lanes_of.html">LanesOf</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a2b3626aa8d37dcc81ce2615f5353a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f60c82d8daf8da2c27b3497c6c083f" id="r_aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memTemplParams" colspan="2">template&lt;typename Before , typename After , typename <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa3b1b1a93a9b97ec3c8f2636fc6d54d0f">Predicate</a> , typename  = typename std::enable_if&lt;std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                            std::decay&lt;After&gt;::type::foldable&gt;::type&gt; </td></tr>
<tr class="memitem:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa0f60c82d8daf8da2c27b3497c6c083f">Halide::Internal::IRMatcher::fuzz_test_rule</a> (Before &amp;&amp;before, After &amp;&amp;after, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa3b1b1a93a9b97ec3c8f2636fc6d54d0f">Predicate</a> &amp;&amp;pred, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type) noexcept</td></tr>
<tr class="separator:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440cc0cc987c622f2361638a3d310170" id="r_a440cc0cc987c622f2361638a3d310170"><td class="memTemplParams" colspan="2">template&lt;typename Before , typename After , typename <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa3b1b1a93a9b97ec3c8f2636fc6d54d0f">Predicate</a> , typename  = typename std::enable_if&lt;!(std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                              std::decay&lt;After&gt;::type::foldable)&gt;::type&gt; </td></tr>
<tr class="memitem:a440cc0cc987c622f2361638a3d310170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a440cc0cc987c622f2361638a3d310170">Halide::Internal::IRMatcher::fuzz_test_rule</a> (Before &amp;&amp;before, After &amp;&amp;after, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa3b1b1a93a9b97ec3c8f2636fc6d54d0f">Predicate</a> &amp;&amp;pred, <a class="el" href="structhalide__type__t.html">halide_type_t</a>, <a class="el" href="structhalide__type__t.html">halide_type_t</a>, int dummy=0) noexcept</td></tr>
<tr class="separator:a440cc0cc987c622f2361638a3d310170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c3af3849b20aa80caa9ceeb4d67b66" id="r_a17c3af3849b20aa80caa9ceeb4d67b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a17c3af3849b20aa80caa9ceeb4d67b66">Halide::Internal::IRMatcher::evaluate_predicate</a> (bool x, <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a> &amp;) noexcept</td></tr>
<tr class="separator:a17c3af3849b20aa80caa9ceeb4d67b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef18091a070c6c3f362c6ca55e75c2db" id="r_aef18091a070c6c3f362c6ca55e75c2db"><td class="memTemplParams" colspan="2">template&lt;typename Pattern , typename  = typename enable_if_pattern&lt;Pattern&gt;::type&gt; </td></tr>
<tr class="memitem:aef18091a070c6c3f362c6ca55e75c2db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aef18091a070c6c3f362c6ca55e75c2db">Halide::Internal::IRMatcher::evaluate_predicate</a> (Pattern p, <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a> &amp;state)</td></tr>
<tr class="separator:aef18091a070c6c3f362c6ca55e75c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dfea57650e9742f5aed422e6be5a58" id="r_a02dfea57650e9742f5aed422e6be5a58"><td class="memTemplParams" colspan="2">template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </td></tr>
<tr class="memitem:a02dfea57650e9742f5aed422e6be5a58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a02dfea57650e9742f5aed422e6be5a58">Halide::Internal::IRMatcher::rewriter</a> (Instance instance, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(instance))&gt;</td></tr>
<tr class="memdesc:a02dfea57650e9742f5aed422e6be5a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression.  <br /></td></tr>
<tr class="separator:a02dfea57650e9742f5aed422e6be5a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54abcfed7ab37a4c726020c119d0efff" id="r_a54abcfed7ab37a4c726020c119d0efff"><td class="memTemplParams" colspan="2">template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </td></tr>
<tr class="memitem:a54abcfed7ab37a4c726020c119d0efff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54abcfed7ab37a4c726020c119d0efff">Halide::Internal::IRMatcher::rewriter</a> (Instance instance, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(instance))&gt;</td></tr>
<tr class="separator:a54abcfed7ab37a4c726020c119d0efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4726f950a627f1361e2bdb1fb98a2" id="r_aaeb4726f950a627f1361e2bdb1fb98a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aaeb4726f950a627f1361e2bdb1fb98a2">Halide::Internal::IRMatcher::rewriter</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(e))&gt;</td></tr>
<tr class="separator:aaeb4726f950a627f1361e2bdb1fb98a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54caa0633d17c57ea0df1aa5bdca3850" id="r_a54caa0633d17c57ea0df1aa5bdca3850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54caa0633d17c57ea0df1aa5bdca3850">Halide::Internal::IRMatcher::rewriter</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(e))&gt;</td></tr>
<tr class="separator:a54caa0633d17c57ea0df1aa5bdca3850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6feb6895f4d41d350eda704b7e3cc4bc" id="r_a6feb6895f4d41d350eda704b7e3cc4bc"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6feb6895f4d41d350eda704b7e3cc4bc">Halide::Internal::IRMatcher::max_wild</a> = 6</td></tr>
<tr class="separator:a6feb6895f4d41d350eda704b7e3cc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a method to match a fragment of IR against a pattern containing wildcards. </p>

<p class="definition">Definition in file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac3cabe703f762c1fb43f00c9a77d6ae4" name="ac3cabe703f762c1fb43f00c9a77d6ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cabe703f762c1fb43f00c9a77d6ae4">&#9670;&#160;</a></span>HALIDE_DEBUG_MATCHED_RULES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_DEBUG_MATCHED_RULES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02843">2843</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a38de29759124484d5b8934bf77b54fc4" name="a38de29759124484d5b8934bf77b54fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38de29759124484d5b8934bf77b54fc4">&#9670;&#160;</a></span>HALIDE_DEBUG_UNMATCHED_RULES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_DEBUG_UNMATCHED_RULES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02844">2844</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a71623e6847732d0ea4b811d8f93d0bd6" name="a71623e6847732d0ea4b811d8f93d0bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71623e6847732d0ea4b811d8f93d0bd6">&#9670;&#160;</a></span>HALIDE_FUZZ_TEST_RULES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FUZZ_TEST_RULES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02850">2850</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_i_r_match_8h.html">IRMatch.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
