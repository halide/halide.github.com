<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: src/Generator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_generator_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_abstract_generator_8h_source.html">AbstractGenerator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_func_8h_source.html">Func.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_image_param_8h_source.html">ImageParam.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_introspection_8h_source.html">Introspection.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_object_instance_registry_8h_source.html">ObjectInstanceRegistry.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_target_8h_source.html">Target.h</a>&quot;</code><br />
</div>
<p><a href="_generator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html">Halide::Internal::GeneratorFactoryProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html" title="GeneratorFactoryProvider provides a way to customize the Generators that are visible to generate_filt...">GeneratorFactoryProvider</a> provides a way to customize the Generators that are visible to generate_filter_main (which otherwise would just look at the global registry of C++ Generators).  <a href="class_halide_1_1_internal_1_1_generator_factory_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1cond.html">Halide::Internal::cond&lt; B, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type.html">Halide::Internal::select_type&lt; First, Rest &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type_3_01_first_01_4.html">Halide::Internal::select_type&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">Halide::Internal::GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Halide::Internal::Convert&lt; FROM, TO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_impl.html">Halide::Internal::GeneratorParamImpl&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">Halide::Internal::GeneratorParam_Target&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___auto_scheduler_params.html">Halide::Internal::GeneratorParam_AutoSchedulerParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">Halide::Internal::GeneratorParam_LoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">Halide::Internal::GeneratorParam_Arithmetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">Halide::Internal::GeneratorParam_Bool&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">Halide::Internal::GeneratorParam_Enum&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">Halide::Internal::GeneratorParam_Type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___string.html">Halide::Internal::GeneratorParam_String&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_param.html">Halide::GeneratorParam&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a> is a templated class that can be used to modify the behavior of the <a class="el" href="class_halide_1_1_generator.html">Generator</a> at code-generation time.  <a href="class_halide_1_1_generator_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">Halide::Internal::GeneratorInput_Buffer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html">Halide::Internal::StubInputBuffer&lt; T, Dims &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html" title="StubInputBuffer is the placeholder that a Stub uses when it requires a Buffer for an input (rather th...">StubInputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an input (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>).  <a href="class_halide_1_1_internal_1_1_stub_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer_base.html">Halide::Internal::StubOutputBufferBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html">Halide::Internal::StubOutputBuffer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html" title="StubOutputBuffer is the placeholder that a Stub uses when it requires a Buffer for an output (rather ...">StubOutputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an output (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>).  <a href="class_halide_1_1_internal_1_1_stub_output_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input.html">Halide::Internal::StubInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html">Halide::Internal::GIOBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html" title="GIOBase is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not pa...">GIOBase</a> is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not part of the public API and should never be used directly by user code.  <a href="class_halide_1_1_internal_1_1_g_i_o_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_base.html">Halide::Internal::GeneratorInputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_impl.html">Halide::Internal::GeneratorInputImpl&lt; T, ValueType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">Halide::Internal::GeneratorInput_Buffer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">Halide::Internal::GeneratorInput_Func&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___dynamic_scalar.html">Halide::Internal::GeneratorInput_DynamicScalar&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">Halide::Internal::GeneratorInput_Scalar&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">Halide::Internal::GeneratorInput_Arithmetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1type__sink.html">Halide::Internal::type_sink&lt; typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">Halide::Internal::has_static_halide_type_method&lt; T2, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method_3_01_t2_00_01typename_01type__si902d603523cc7c0df71b135e75cbe224.html">Halide::Internal::has_static_halide_type_method&lt; T2, typename type_sink&lt; decltype(T2::static_halide_type())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_input.html">Halide::GeneratorInput&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_base.html">Halide::Internal::GeneratorOutputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_impl.html">Halide::Internal::GeneratorOutputImpl&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">Halide::Internal::GeneratorOutput_Buffer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">Halide::Internal::GeneratorOutput_Func&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">Halide::Internal::GeneratorOutput_Arithmetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_output.html">Halide::GeneratorOutput&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___synthetic.html">Halide::Internal::GeneratorParam_Synthetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_context.html" title="GeneratorContext is a class that is used when using Generators (or Stubs) directly; it is used to all...">GeneratorContext</a> is a class that is used when using Generators (or Stubs) directly; it is used to allow the outer context (typically, either a <a class="el" href="class_halide_1_1_generator.html">Generator</a> or "top-level" code) to specify certain information to the inner context to ensure that inner and outer Generators are compiled in a compatible way.  <a href="class_halide_1_1_generator_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_names_interface.html">Halide::NamesInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations.html">Halide::Internal::NoRealizations&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_4.html">Halide::Internal::NoRealizations&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_01_t_00_01_args_8_8_8_01_4.html">Halide::Internal::NoRealizations&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_info.html">Halide::Internal::GeneratorParamInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">Halide::Internal::GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">Halide::Internal::GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator.html">Halide::Generator&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_execute_generator_args.html">Halide::Internal::ExecuteGeneratorArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_execute_generator_args.html" title="ExecuteGeneratorArgs is the set of arguments to execute_generator().">ExecuteGeneratorArgs</a> is the set of arguments to <a class="el" href="namespace_halide_1_1_internal.html#ac8012ee5b0051705ecbc75a83ae6b465" title="Execute a Generator for AOT compilation – this provides the implementation of the command-line Genera...">execute_generator()</a>.  <a href="struct_halide_1_1_internal_1_1_execute_generator_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_generator_min_max"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html">Halide::Internal::GeneratorMinMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehalide__register__generator"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehalide__register__generator.html">halide_register_generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a08dae13ee17f505472e95d3bcaec9984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a08dae13ee17f505472e95d3bcaec9984">HALIDE_GENERATOR_PARAM_TYPED_SETTER</a>(TYPE)&#160;&#160;&#160;virtual void set(const TYPE &amp;new_value) = 0;</td></tr>
<tr class="separator:a08dae13ee17f505472e95d3bcaec9984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dae13ee17f505472e95d3bcaec9984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a08dae13ee17f505472e95d3bcaec9984">HALIDE_GENERATOR_PARAM_TYPED_SETTER</a>(TYPE)</td></tr>
<tr class="separator:a08dae13ee17f505472e95d3bcaec9984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f">HALIDE_FORWARD_METHOD</a>(Class,  Method)</td></tr>
<tr class="separator:a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cefa62995eaf97e7a6795e159d7e245"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a3cefa62995eaf97e7a6795e159d7e245">HALIDE_FORWARD_METHOD_CONST</a>(Class,  Method)</td></tr>
<tr class="separator:a3cefa62995eaf97e7a6795e159d7e245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856471e468d66102a7f7c3384e7bf3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME,  GEN_REGISTRY_NAME,  FULLY_QUALIFIED_STUB_NAME)</td></tr>
<tr class="separator:a5856471e468d66102a7f7c3384e7bf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a745ace50c85e1e1086beda5bd7598d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a9a745ace50c85e1e1086beda5bd7598d">_HALIDE_REGISTER_GENERATOR2</a>(GEN_CLASS_NAME,  GEN_REGISTRY_NAME)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, GEN_REGISTRY_NAME)</td></tr>
<tr class="separator:a9a745ace50c85e1e1086beda5bd7598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b1d1e407c4804e430152a081194e99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#ad4b1d1e407c4804e430152a081194e99">_HALIDE_REGISTER_GENERATOR3</a>(GEN_CLASS_NAME,  GEN_REGISTRY_NAME,  FULLY_QUALIFIED_STUB_NAME)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, FULLY_QUALIFIED_STUB_NAME)</td></tr>
<tr class="separator:ad4b1d1e407c4804e430152a081194e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569beb9a7e98718b004aee7c10f0467"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a9569beb9a7e98718b004aee7c10f0467">__HALIDE_REGISTER_ARGCOUNT_IMPL</a>(_1,  _2,  _3,  COUNT, ...)&#160;&#160;&#160;COUNT</td></tr>
<tr class="separator:a9569beb9a7e98718b004aee7c10f0467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64059dca539cf5f3f7e4c642af576ae3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a64059dca539cf5f3f7e4c642af576ae3">_HALIDE_REGISTER_ARGCOUNT_IMPL</a>(ARGS)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a9569beb9a7e98718b004aee7c10f0467">__HALIDE_REGISTER_ARGCOUNT_IMPL</a> ARGS</td></tr>
<tr class="separator:a64059dca539cf5f3f7e4c642af576ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebb701e7b5841c0e6202138cdb5dff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#ab1ebb701e7b5841c0e6202138cdb5dff">_HALIDE_REGISTER_ARGCOUNT</a>(...)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a64059dca539cf5f3f7e4c642af576ae3">_HALIDE_REGISTER_ARGCOUNT_IMPL</a>((__VA_ARGS__, 3, 2, 1, 0))</td></tr>
<tr class="separator:ab1ebb701e7b5841c0e6202138cdb5dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3703de57adb30a5044367a8eccb822b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a3703de57adb30a5044367a8eccb822b0">___HALIDE_REGISTER_CHOOSER</a>(COUNT)&#160;&#160;&#160;_HALIDE_REGISTER_GENERATOR##COUNT</td></tr>
<tr class="separator:a3703de57adb30a5044367a8eccb822b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247774bd287d01a3081de190905019c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a247774bd287d01a3081de190905019c7">__HALIDE_REGISTER_CHOOSER</a>(COUNT)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a3703de57adb30a5044367a8eccb822b0">___HALIDE_REGISTER_CHOOSER</a>(COUNT)</td></tr>
<tr class="separator:a247774bd287d01a3081de190905019c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e49dea0ba50a51195521ede9c0b20c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a33e49dea0ba50a51195521ede9c0b20c">_HALIDE_REGISTER_CHOOSER</a>(COUNT)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a247774bd287d01a3081de190905019c7">__HALIDE_REGISTER_CHOOSER</a>(COUNT)</td></tr>
<tr class="separator:a33e49dea0ba50a51195521ede9c0b20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940f7c9be73066885cb3a5d29e7cbd55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a940f7c9be73066885cb3a5d29e7cbd55">_HALIDE_REGISTER_GENERATOR_PASTE</a>(A,  B)&#160;&#160;&#160;A B</td></tr>
<tr class="separator:a940f7c9be73066885cb3a5d29e7cbd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76205e384e3152f5eda423c56accbc54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a>(...)&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a940f7c9be73066885cb3a5d29e7cbd55">_HALIDE_REGISTER_GENERATOR_PASTE</a>(<a class="el" href="_generator_8h.html#a33e49dea0ba50a51195521ede9c0b20c">_HALIDE_REGISTER_CHOOSER</a>(<a class="el" href="_generator_8h.html#ab1ebb701e7b5841c0e6202138cdb5dff">_HALIDE_REGISTER_ARGCOUNT</a>(__VA_ARGS__)), (__VA_ARGS__))</td></tr>
<tr class="separator:a76205e384e3152f5eda423c56accbc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae85638c44eb4fa948399c7b9003bf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a2ae85638c44eb4fa948399c7b9003bf4">HALIDE_REGISTER_GENERATOR_ALIAS</a>(GEN_REGISTRY_NAME,  ORIGINAL_REGISTRY_NAME, ...)</td></tr>
<tr class="separator:a2ae85638c44eb4fa948399c7b9003bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca7bae67f0d10b270349842e7f958ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a1ca7bae67f0d10b270349842e7f958ef">HALIDE_GENERATOR_PYSTUB</a>(GEN_REGISTRY_NAME,  MODULE_NAME)</td></tr>
<tr class="separator:a1ca7bae67f0d10b270349842e7f958ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd802f33601bb4a136a958078586588d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd802f33601bb4a136a958078586588d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd802f33601bb4a136a958078586588d">Halide::Internal::GeneratorParamImplBase</a> = typename select_type&lt; cond&lt; std::is_same&lt; T, Target &gt;::value, GeneratorParam_Target&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, LoopLevel &gt;::value, GeneratorParam_LoopLevel &gt;, cond&lt; std::is_same&lt; T, std::string &gt;::value, GeneratorParam_String&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, Type &gt;::value, GeneratorParam_Type&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, bool &gt;::value, GeneratorParam_Bool&lt; T &gt; &gt;, cond&lt; std::is_arithmetic&lt; T &gt;::value, GeneratorParam_Arithmetic&lt; T &gt; &gt;, cond&lt; std::is_enum&lt; T &gt;::value, GeneratorParam_Enum&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:abd802f33601bb4a136a958078586588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45bf0eb88ef1c62fc086d71eeca0f32"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab45bf0eb88ef1c62fc086d71eeca0f32"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab45bf0eb88ef1c62fc086d71eeca0f32">Halide::Internal::GeneratorInputImplBase</a> = typename select_type&lt; cond&lt; has_static_halide_type_method&lt; TBase &gt;::value, GeneratorInput_Buffer&lt; T &gt; &gt;, cond&lt; std::is_same&lt; TBase, Func &gt;::value, GeneratorInput_Func&lt; T &gt; &gt;, cond&lt; std::is_arithmetic&lt; TBase &gt;::value, GeneratorInput_Arithmetic&lt; T &gt; &gt;, cond&lt; std::is_scalar&lt; TBase &gt;::value, GeneratorInput_Scalar&lt; T &gt; &gt;, cond&lt; std::is_same&lt; TBase, Expr &gt;::value, GeneratorInput_DynamicScalar&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:ab45bf0eb88ef1c62fc086d71eeca0f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab3efc8f40050501582a4dc9dafcd18a9">Halide::Internal::GeneratorOutputImplBase</a> = typename select_type&lt; cond&lt; has_static_halide_type_method&lt; TBase &gt;::value, GeneratorOutput_Buffer&lt; T &gt; &gt;, cond&lt; std::is_same&lt; TBase, Func &gt;::value, GeneratorOutput_Func&lt; T &gt; &gt;, cond&lt; std::is_arithmetic&lt; TBase &gt;::value, GeneratorOutput_Arithmetic&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0cea9e2c59474745b6a03dd939f2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a13c0cea9e2c59474745b6a03dd939f2f">Halide::Internal::GeneratorFactory</a> = std::function&lt; AbstractGeneratorPtr(const GeneratorContext &amp;context)&gt;</td></tr>
<tr class="separator:a13c0cea9e2c59474745b6a03dd939f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a43770c59ec0f13935f4b33502ba7e817"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817">Halide::Internal::SyntheticParamType</a> { <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508">Halide::Internal::SyntheticParamType::Type</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9">Halide::Internal::SyntheticParamType::Dim</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c">Halide::Internal::SyntheticParamType::ArraySize</a>
 }</td></tr>
<tr class="separator:a43770c59ec0f13935f4b33502ba7e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4be7daed1a8c6cd914be946f22ea4df">Halide::Internal::generator_test</a> ()</td></tr>
<tr class="separator:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2672948a0299d09a067ec4dbb862723"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa2672948a0299d09a067ec4dbb862723">Halide::Internal::parameter_constraints</a> (const Parameter &amp;p)</td></tr>
<tr class="separator:aa2672948a0299d09a067ec4dbb862723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b54f450e1cd03c240743907e45487ce">Halide::Internal::enum_to_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const T &amp;t)</td></tr>
<tr class="separator:a9b54f450e1cd03c240743907e45487ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afd2308d89d4a9b9eef0803e92c383b0c">Halide::Internal::enum_from_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const std::string &amp;s)</td></tr>
<tr class="separator:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb90b52661557ff81407bc45cbdf3e6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">Halide::Internal::get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:aebb90b52661557ff81407bc45cbdf3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc7c793b324e02e15a109f1e8af548c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2cc7c793b324e02e15a109f1e8af548c">Halide::Internal::halide_type_to_enum_string</a> (const Type &amp;t)</td></tr>
<tr class="separator:a2cc7c793b324e02e15a109f1e8af548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600136fc73541f81f75ee07095a62025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a600136fc73541f81f75ee07095a62025">Halide::Internal::halide_type_to_c_source</a> (const Type &amp;t)</td></tr>
<tr class="separator:a600136fc73541f81f75ee07095a62025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e8f71298de4ece7dc2e59ae811c3fd2">Halide::Internal::halide_type_to_c_type</a> (const Type &amp;t)</td></tr>
<tr class="separator:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ec21d0b867719175de07bdf2f53a2"><td class="memItemLeft" align="right" valign="top">const GeneratorFactoryProvider &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a274ec21d0b867719175de07bdf2f53a2">Halide::Internal::get_registered_generators</a> ()</td></tr>
<tr class="memdesc:a274ec21d0b867719175de07bdf2f53a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_halide_1_1_internal_1_1_generator_factory_provider.html" title="GeneratorFactoryProvider provides a way to customize the Generators that are visible to generate_filt...">GeneratorFactoryProvider</a> that knows about all the currently-registered C++ Generators.  <a href="namespace_halide_1_1_internal.html#a274ec21d0b867719175de07bdf2f53a2">More...</a><br /></td></tr>
<tr class="separator:a274ec21d0b867719175de07bdf2f53a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239019adaa0b7ed8fb0c6c81a6f694d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a239019adaa0b7ed8fb0c6c81a6f694d3">Halide::Internal::generate_filter_main</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a239019adaa0b7ed8fb0c6c81a6f694d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#a239019adaa0b7ed8fb0c6c81a6f694d3" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a2ffc5102a3af64eff76abddc80ee4a9b">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <a href="namespace_halide_1_1_internal.html#a239019adaa0b7ed8fb0c6c81a6f694d3">More...</a><br /></td></tr>
<tr class="separator:a239019adaa0b7ed8fb0c6c81a6f694d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994b36c5b1464443ec692ee2f4b6015"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae994b36c5b1464443ec692ee2f4b6015">Halide::Internal::generate_filter_main</a> (int argc, char **argv, const GeneratorFactoryProvider &amp;generator_factory_provider)</td></tr>
<tr class="memdesc:ae994b36c5b1464443ec692ee2f4b6015"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload of generate_filter_main lets you provide your own provider for how to enumerate and/or create the generators based on registration name; this is useful if you want to re-use the 'main' logic but avoid the global <a class="el" href="class_halide_1_1_generator.html">Generator</a> registry (e.g.  <a href="namespace_halide_1_1_internal.html#ae994b36c5b1464443ec692ee2f4b6015">More...</a><br /></td></tr>
<tr class="separator:ae994b36c5b1464443ec692ee2f4b6015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffe416c9264a301f4dbee5088cd4212"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a7ffe416c9264a301f4dbee5088cd4212"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ffe416c9264a301f4dbee5088cd4212">Halide::operator+</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a+(T) b)</td></tr>
<tr class="memdesc:a7ffe416c9264a301f4dbee5088cd4212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between GeneratorParam&lt;T&gt; and any type that supports operator+ with T.  <a href="namespace_halide.html#a7ffe416c9264a301f4dbee5088cd4212">More...</a><br /></td></tr>
<tr class="separator:a7ffe416c9264a301f4dbee5088cd4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad0b04406900c92aff4fe7df31bf35d6c">Halide::operator+</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a+b)</td></tr>
<tr class="separator:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3fcc2cb5052cc21ff4819dad8d62c86f">Halide::operator-</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a -(T) b)</td></tr>
<tr class="memdesc:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between GeneratorParam&lt;T&gt; and any type that supports operator- with T.  <a href="namespace_halide.html#a3fcc2cb5052cc21ff4819dad8d62c86f">More...</a><br /></td></tr>
<tr class="separator:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad63c3bccbde6ba2a4986f11bf662bf7e">Halide::operator-</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a - b)</td></tr>
<tr class="separator:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a24aabc3f5a598cb3c662e05b01243ebb">Halide::operator*</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a *(T) b)</td></tr>
<tr class="memdesc:a24aabc3f5a598cb3c662e05b01243ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between GeneratorParam&lt;T&gt; and any type that supports operator* with T.  <a href="namespace_halide.html#a24aabc3f5a598cb3c662e05b01243ebb">More...</a><br /></td></tr>
<tr class="separator:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ffddd99ce9d53114517a17496e45b1"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a17ffddd99ce9d53114517a17496e45b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a17ffddd99ce9d53114517a17496e45b1">Halide::operator*</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a *b)</td></tr>
<tr class="separator:a17ffddd99ce9d53114517a17496e45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcc05645a8be0bf5b547891b5eedbd6"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:addcc05645a8be0bf5b547891b5eedbd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addcc05645a8be0bf5b547891b5eedbd6">Halide::operator/</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a/(T) b)</td></tr>
<tr class="memdesc:addcc05645a8be0bf5b547891b5eedbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between GeneratorParam&lt;T&gt; and any type that supports operator/ with T.  <a href="namespace_halide.html#addcc05645a8be0bf5b547891b5eedbd6">More...</a><br /></td></tr>
<tr class="separator:addcc05645a8be0bf5b547891b5eedbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb1bbedd0274448f1b81fe8de753287"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aedb1bbedd0274448f1b81fe8de753287"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aedb1bbedd0274448f1b81fe8de753287">Halide::operator/</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a/b)</td></tr>
<tr class="separator:aedb1bbedd0274448f1b81fe8de753287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993b255e504fe0b7812c60db527c997b"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a993b255e504fe0b7812c60db527c997b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a993b255e504fe0b7812c60db527c997b">Halide::operator%</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a %(T) b)</td></tr>
<tr class="memdesc:a993b255e504fe0b7812c60db527c997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo between GeneratorParam&lt;T&gt; and any type that supports operator% with T.  <a href="namespace_halide.html#a993b255e504fe0b7812c60db527c997b">More...</a><br /></td></tr>
<tr class="separator:a993b255e504fe0b7812c60db527c997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8e0eb4d1f94756aa0776e126762c4a5c">Halide::operator%</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a % b)</td></tr>
<tr class="separator:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7126caa58fad82bb502a72f7ba72dae"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ab7126caa58fad82bb502a72f7ba72dae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab7126caa58fad82bb502a72f7ba72dae">Halide::operator&gt;</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a &gt;(T) b)</td></tr>
<tr class="memdesc:ab7126caa58fad82bb502a72f7ba72dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt; with T.  <a href="namespace_halide.html#ab7126caa58fad82bb502a72f7ba72dae">More...</a><br /></td></tr>
<tr class="separator:ab7126caa58fad82bb502a72f7ba72dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a212d29d2096665d1ee6bdec6ac8cb5ad">Halide::operator&gt;</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &gt; b)</td></tr>
<tr class="separator:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99adc84a7324351d6037eacb3f9157"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a1f99adc84a7324351d6037eacb3f9157"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1f99adc84a7324351d6037eacb3f9157">Halide::operator&lt;</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a&lt;(T) b)</td></tr>
<tr class="memdesc:a1f99adc84a7324351d6037eacb3f9157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt; with T.  <a href="namespace_halide.html#a1f99adc84a7324351d6037eacb3f9157">More...</a><br /></td></tr>
<tr class="separator:a1f99adc84a7324351d6037eacb3f9157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6493da795ebe5c52ce922583d7aed4"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aab6493da795ebe5c52ce922583d7aed4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aab6493da795ebe5c52ce922583d7aed4">Halide::operator&lt;</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a&lt; b)</td></tr>
<tr class="separator:aab6493da795ebe5c52ce922583d7aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a50dc9625193a554ec0d51fb8d953"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a016a50dc9625193a554ec0d51fb8d953"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a016a50dc9625193a554ec0d51fb8d953">Halide::operator&gt;=</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a &gt;=(T) b)</td></tr>
<tr class="memdesc:a016a50dc9625193a554ec0d51fb8d953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt;= with T.  <a href="namespace_halide.html#a016a50dc9625193a554ec0d51fb8d953">More...</a><br /></td></tr>
<tr class="separator:a016a50dc9625193a554ec0d51fb8d953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598327ce18c80e8b2f89edde2554e02"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a4598327ce18c80e8b2f89edde2554e02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4598327ce18c80e8b2f89edde2554e02">Halide::operator&gt;=</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &gt;=b)</td></tr>
<tr class="separator:a4598327ce18c80e8b2f89edde2554e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4053db56eee7933acebf91f83803cff"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aa4053db56eee7933acebf91f83803cff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa4053db56eee7933acebf91f83803cff">Halide::operator&lt;=</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a&lt;=(T) b)</td></tr>
<tr class="memdesc:aa4053db56eee7933acebf91f83803cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt;= with T.  <a href="namespace_halide.html#aa4053db56eee7933acebf91f83803cff">More...</a><br /></td></tr>
<tr class="separator:aa4053db56eee7933acebf91f83803cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730bcf31dedcc336b12929d2afe35ea2"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a730bcf31dedcc336b12929d2afe35ea2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a730bcf31dedcc336b12929d2afe35ea2">Halide::operator&lt;=</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a&lt;=b)</td></tr>
<tr class="separator:a730bcf31dedcc336b12929d2afe35ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fecab5f39831c5d8444fbf700c0e04"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a12fecab5f39831c5d8444fbf700c0e04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a12fecab5f39831c5d8444fbf700c0e04">Halide::operator==</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a==(T) b)</td></tr>
<tr class="memdesc:a12fecab5f39831c5d8444fbf700c0e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between GeneratorParam&lt;T&gt; and any type that supports operator== with T.  <a href="namespace_halide.html#a12fecab5f39831c5d8444fbf700c0e04">More...</a><br /></td></tr>
<tr class="separator:a12fecab5f39831c5d8444fbf700c0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac9aa81c242a4d52174dfe07e28dd856f">Halide::operator==</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a==b)</td></tr>
<tr class="separator:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8ddebe6a310029aaf2096c17750a1e"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:abe8ddebe6a310029aaf2096c17750a1e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8ddebe6a310029aaf2096c17750a1e">Halide::operator!=</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a !=(T) b)</td></tr>
<tr class="memdesc:abe8ddebe6a310029aaf2096c17750a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between between GeneratorParam&lt;T&gt; and any type that supports operator!= with T.  <a href="namespace_halide.html#abe8ddebe6a310029aaf2096c17750a1e">More...</a><br /></td></tr>
<tr class="separator:abe8ddebe6a310029aaf2096c17750a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53392f7139bea898ab547a1aa14f8cb"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:af53392f7139bea898ab547a1aa14f8cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af53392f7139bea898ab547a1aa14f8cb">Halide::operator!=</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a !=b)</td></tr>
<tr class="separator:af53392f7139bea898ab547a1aa14f8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8e8cc876748afd9ec969b7d0d45d1008">Halide::operator&amp;&amp;</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a &amp;&amp;(T) b)</td></tr>
<tr class="memdesc:a8e8cc876748afd9ec969b7d0d45d1008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and between between GeneratorParam&lt;T&gt; and any type that supports operator&amp;&amp; with T.  <a href="namespace_halide.html#a8e8cc876748afd9ec969b7d0d45d1008">More...</a><br /></td></tr>
<tr class="separator:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228ada08fcdf1652525a98f2f0f0df44"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a228ada08fcdf1652525a98f2f0f0df44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a228ada08fcdf1652525a98f2f0f0df44">Halide::operator&amp;&amp;</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &amp;&amp;b)</td></tr>
<tr class="separator:a228ada08fcdf1652525a98f2f0f0df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fe93546b3f630e218bae59afba254f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3fe93546b3f630e218bae59afba254f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac3fe93546b3f630e218bae59afba254f">Halide::operator&amp;&amp;</a> (const GeneratorParam&lt; T &gt; &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype((T) a &amp;&amp;(T) b)</td></tr>
<tr class="separator:ac3fe93546b3f630e218bae59afba254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1d71b2448732fda75553fc7f23c89"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a2ab1d71b2448732fda75553fc7f23c89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ab1d71b2448732fda75553fc7f23c89">Halide::operator||</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a||(T) b)</td></tr>
<tr class="memdesc:a2ab1d71b2448732fda75553fc7f23c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or between between GeneratorParam&lt;T&gt; and any type that supports operator|| with T.  <a href="namespace_halide.html#a2ab1d71b2448732fda75553fc7f23c89">More...</a><br /></td></tr>
<tr class="separator:a2ab1d71b2448732fda75553fc7f23c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4786dcd28f875b5886c08221ceade3b"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:af4786dcd28f875b5886c08221ceade3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af4786dcd28f875b5886c08221ceade3b">Halide::operator||</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a||b)</td></tr>
<tr class="separator:af4786dcd28f875b5886c08221ceade3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ad1425d57e892ab6f16d66af3b882"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf2ad1425d57e892ab6f16d66af3b882"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adf2ad1425d57e892ab6f16d66af3b882">Halide::operator||</a> (const GeneratorParam&lt; T &gt; &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype((T) a||(T) b)</td></tr>
<tr class="separator:adf2ad1425d57e892ab6f16d66af3b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53911af2c697e8b725295adb70edd361"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a53911af2c697e8b725295adb70edd361"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a53911af2c697e8b725295adb70edd361">Halide::Internal::GeneratorMinMax::min_forward</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(min(a,(T) b))</td></tr>
<tr class="separator:a53911af2c697e8b725295adb70edd361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254be5aed49ae7fd863e9eb8e42ceb0d"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a254be5aed49ae7fd863e9eb8e42ceb0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a254be5aed49ae7fd863e9eb8e42ceb0d">Halide::Internal::GeneratorMinMax::min_forward</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(min((T) a, b))</td></tr>
<tr class="separator:a254be5aed49ae7fd863e9eb8e42ceb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37317f7712e4d37958974a2d71ef7c74"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a37317f7712e4d37958974a2d71ef7c74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a37317f7712e4d37958974a2d71ef7c74">Halide::Internal::GeneratorMinMax::max_forward</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(max(a,(T) b))</td></tr>
<tr class="separator:a37317f7712e4d37958974a2d71ef7c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdc48ece08d2eb96aa94f061196a258"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a7bdc48ece08d2eb96aa94f061196a258"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a7bdc48ece08d2eb96aa94f061196a258">Halide::Internal::GeneratorMinMax::max_forward</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(max((T) a, b))</td></tr>
<tr class="separator:a7bdc48ece08d2eb96aa94f061196a258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0fcc240a43e9bd59167b72a75ba39d3a">Halide::min</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(Internal::GeneratorMinMax::min_forward(a, b))</td></tr>
<tr class="memdesc:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum between GeneratorParam&lt;T&gt; and any type that supports min with T.  <a href="namespace_halide.html#a0fcc240a43e9bd59167b72a75ba39d3a">More...</a><br /></td></tr>
<tr class="separator:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f0112267498bcda0747506b9d82af8"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a38f0112267498bcda0747506b9d82af8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38f0112267498bcda0747506b9d82af8">Halide::min</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(Internal::GeneratorMinMax::min_forward(a, b))</td></tr>
<tr class="separator:a38f0112267498bcda0747506b9d82af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa350166ccd23cc6430356bb6833d3910"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aa350166ccd23cc6430356bb6833d3910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa350166ccd23cc6430356bb6833d3910">Halide::max</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(Internal::GeneratorMinMax::max_forward(a, b))</td></tr>
<tr class="memdesc:aa350166ccd23cc6430356bb6833d3910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum value between GeneratorParam&lt;T&gt; and any type that supports max with T.  <a href="namespace_halide.html#aa350166ccd23cc6430356bb6833d3910">More...</a><br /></td></tr>
<tr class="separator:aa350166ccd23cc6430356bb6833d3910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a870f8517436e4720b50792f8fdd1"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aeb5a870f8517436e4720b50792f8fdd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb5a870f8517436e4720b50792f8fdd1">Halide::max</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(Internal::GeneratorMinMax::max_forward(a, b))</td></tr>
<tr class="separator:aeb5a870f8517436e4720b50792f8fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534f823d7f303e81b20bdff79e38179c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a534f823d7f303e81b20bdff79e38179c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a> (const GeneratorParam&lt; T &gt; &amp;a) -&gt; decltype(!(T) a)</td></tr>
<tr class="memdesc:a534f823d7f303e81b20bdff79e38179c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not operator for <a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a>.  <a href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">More...</a><br /></td></tr>
<tr class="separator:a534f823d7f303e81b20bdff79e38179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae47fa4b8f49636c214b214f5d0f4ed34">Halide::Internal::parse_scalar</a> (const std::string &amp;value)</td></tr>
<tr class="separator:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7682395f90f7229826df771f8c286fac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7682395f90f7229826df771f8c286fac">Halide::Internal::parse_halide_type_list</a> (const std::string &amp;types)</td></tr>
<tr class="separator:a7682395f90f7229826df771f8c286fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8012ee5b0051705ecbc75a83ae6b465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac8012ee5b0051705ecbc75a83ae6b465">Halide::Internal::execute_generator</a> (const ExecuteGeneratorArgs &amp;args)</td></tr>
<tr class="memdesc:ac8012ee5b0051705ecbc75a83ae6b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a <a class="el" href="class_halide_1_1_generator.html">Generator</a> for AOT compilation &ndash; this provides the implementation of the command-line <a class="el" href="class_halide_1_1_generator.html">Generator</a> interface <code><a class="el" href="namespace_halide_1_1_internal.html#a239019adaa0b7ed8fb0c6c81a6f694d3" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a></code>, but with a structured API that is more suitable for calling directly from code (vs command line).  <a href="namespace_halide_1_1_internal.html#ac8012ee5b0051705ecbc75a83ae6b465">More...</a><br /></td></tr>
<tr class="separator:ac8012ee5b0051705ecbc75a83ae6b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826d983c7157d8048212c5b1fdd7fe55"><td class="memItemLeft" align="right" valign="top">Callable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a826d983c7157d8048212c5b1fdd7fe55">Halide::create_callable_from_generator</a> (const GeneratorContext &amp;context, const std::string &amp;name, const GeneratorParamsMap &amp;generator_params={})</td></tr>
<tr class="memdesc:a826d983c7157d8048212c5b1fdd7fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_halide_1_1_generator.html">Generator</a> from the currently-registered Generators, use it to create a <a class="el" href="class_halide_1_1_callable.html">Callable</a>.  <a href="namespace_halide.html#a826d983c7157d8048212c5b1fdd7fe55">More...</a><br /></td></tr>
<tr class="separator:a826d983c7157d8048212c5b1fdd7fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596e8ab4c3b028f4317d7fba6dac9a3f"><td class="memItemLeft" align="right" valign="top">Callable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a596e8ab4c3b028f4317d7fba6dac9a3f">Halide::create_callable_from_generator</a> (const Target &amp;target, const std::string &amp;name, const GeneratorParamsMap &amp;generator_params={})</td></tr>
<tr class="separator:a596e8ab4c3b028f4317d7fba6dac9a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generator is a class used to encapsulate the building of Funcs in user pipelines. A Generator is agnostic to JIT vs AOT compilation; it can be used for either purpose, but is especially convenient to use for AOT compilation.</p>
<p>A Generator explicitly declares the Inputs and Outputs associated for a given pipeline, and (optionally) separates the code for constructing the outputs from the code from scheduling them. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Blur : <span class="keyword">public</span> Generator&lt;Blur&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Input&lt;Func&gt; input{<span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(16), 2};</div>
<div class="line">    Output&lt;Func&gt; output{<span class="stringliteral">&quot;output&quot;</span>, <a class="code" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(16), 2};</div>
<div class="line">    <span class="keywordtype">void</span> generate() {</div>
<div class="line">        blur_x(x, y) = (input(x, y) + input(x+1, y) + input(x+2, y))/3;</div>
<div class="line">        blur_y(x, y) = (blur_x(x, y) + blur_x(x, y+1) + blur_x(x, y+2))/3;</div>
<div class="line">        output(x, y) = blur(x, y);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa799855594adc0f2bd7302c69d3234b5a">schedule</a>() {</div>
<div class="line">        blur_y.split(y, y, yi, 8).parallel(y).vectorize(x, 8);</div>
<div class="line">        blur_x.store_at(blur_y, y).compute_at(blur_y, yi).vectorize(x, 8);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Var x, y, xi, yi;</div>
<div class="line">    Func blur_x, blur_y;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> can compile a Generator into the correct pipeline by introspecting these values and constructing an appropriate signature based on them.</p>
<p>A Generator provides implementations of two methods:</p>
<ul>
<li>generate(), which must fill in all Output Func(s); it may optionally also do scheduling if no schedule() method is present.</li>
<li>schedule(), which (if present) should contain all scheduling code.</li>
</ul>
<p>Inputs can be any C++ scalar type:</p>
<div class="fragment"><div class="line">Input&lt;float&gt; radius{<span class="stringliteral">&quot;radius&quot;</span>};</div>
<div class="line">Input&lt;int32_t&gt; increment{<span class="stringliteral">&quot;increment&quot;</span>};</div>
</div><!-- fragment --><p>An Input&lt;Func&gt; is (essentially) like an ImageParam, except that it may (or may not) not be backed by an actual buffer, and thus has no defined extents.</p>
<div class="fragment"><div class="line">Input&lt;Func&gt; input{<span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2};</div>
</div><!-- fragment --><p>You can optionally make the type and/or dimensions of Input&lt;Func&gt; unspecified, in which case the value is simply inferred from the actual Funcs passed to them. Of course, if you specify an explicit Type or Dimension, we still require the input Func to match, or a compilation error results.</p>
<div class="fragment"><div class="line">Input&lt;Func&gt; input{ <span class="stringliteral">&quot;input&quot;</span>, 3 };  <span class="comment">// require 3-dimensional Func,</span></div>
<div class="line">                                  <span class="comment">// but leave Type unspecified</span></div>
</div><!-- fragment --><p>A Generator must explicitly list the output(s) it produces:</p>
<div class="fragment"><div class="line">Output&lt;Func&gt; output{<span class="stringliteral">&quot;output&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2};</div>
</div><!-- fragment --><p>You can specify an output that returns a Tuple by specifying a list of Types:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Tupler : Generator&lt;Tupler&gt; {</div>
<div class="line">  Input&lt;Func&gt; input{<span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), 2};</div>
<div class="line">  Output&lt;Func&gt; output{<span class="stringliteral">&quot;output&quot;</span>, {<a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), <a class="code" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(8)}, 2};</div>
<div class="line">  <span class="keywordtype">void</span> generate() {</div>
<div class="line">    Var x, y;</div>
<div class="line">    Expr a = cast&lt;float&gt;(input(x, y));</div>
<div class="line">    Expr b = cast&lt;uint8_t&gt;(input(x, y));</div>
<div class="line">    output(x, y) = Tuple(a, b);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>You can also specify Output&lt;X&gt; for any scalar type (except for Handle types); this is merely syntactic sugar on top of a zero-dimensional Func, but can be quite handy, especially when used with multiple outputs:</p>
<div class="fragment"><div class="line">Output&lt;float&gt; <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>{<span class="stringliteral">&quot;sum&quot;</span>};  <span class="comment">// equivalent to Output&lt;Func&gt; {&quot;sum&quot;, Float(32), 0}</span></div>
</div><!-- fragment --><p>As with Input&lt;Func&gt;, you can optionally make the type and/or dimensions of an Output&lt;Func&gt; unspecified; any unspecified types must be resolved via an implicit GeneratorParam in order to use top-level compilation.</p>
<p>You can also declare an <em>array</em> of Input or Output, by using an array type as the type parameter:</p>
<div class="fragment"><div class="line"><span class="comment">// Takes exactly 3 images and outputs exactly 3 sums.</span></div>
<div class="line"><span class="keyword">class </span>SumRowsAndColumns : Generator&lt;SumRowsAndColumns&gt; {</div>
<div class="line">  Input&lt;Func[3]&gt; inputs{<span class="stringliteral">&quot;inputs&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2};</div>
<div class="line">  Input&lt;int32_t[2]&gt; extents{<span class="stringliteral">&quot;extents&quot;</span>};</div>
<div class="line">  Output&lt;Func[3]&gt; sums{<span class="stringliteral">&quot;sums&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 1};</div>
<div class="line">  <span class="keywordtype">void</span> generate() {</div>
<div class="line">    assert(inputs.size() == sums.size());</div>
<div class="line">    <span class="comment">// assume all inputs are same extent</span></div>
<div class="line">    Expr width = extent[0];</div>
<div class="line">    Expr height = extent[1];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; inputs.size(); ++i) {</div>
<div class="line">      RDom r(0, width, 0, height);</div>
<div class="line">      sums[i]() = 0.f;</div>
<div class="line">      sums[i]() += inputs[i](r.x, r.y);</div>
<div class="line">     }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>You can also leave array size unspecified, with some caveats:</p><ul>
<li>For ahead-of-time compilation, Inputs must have a concrete size specified via a GeneratorParam at build time (e.g., pyramid.size=3)</li>
<li>For JIT compilation via a Stub, Inputs array sizes will be inferred from the vector passed.</li>
<li>For ahead-of-time compilation, Outputs may specify a concrete size via a GeneratorParam at build time (e.g., pyramid.size=3), or the size can be specified via a resize() method.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>Pyramid : <span class="keyword">public</span> Generator&lt;Pyramid&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GeneratorParam&lt;int32_t&gt; levels{<span class="stringliteral">&quot;levels&quot;</span>, 10};</div>
<div class="line">    Input&lt;Func&gt; input{ <span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2 };</div>
<div class="line">    Output&lt;Func[]&gt; pyramid{ <span class="stringliteral">&quot;pyramid&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2 };</div>
<div class="line">    <span class="keywordtype">void</span> generate() {</div>
<div class="line">        pyramid.resize(levels);</div>
<div class="line">        pyramid[0](x, y) = input(x, y);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; pyramid.size(); i++) {</div>
<div class="line">            pyramid[i](x, y) = (pyramid[i-1](2*x, 2*y) +</div>
<div class="line">                               pyramid[i-1](2*x+1, 2*y) +</div>
<div class="line">                               pyramid[i-1](2*x, 2*y+1) +</div>
<div class="line">                               pyramid[i-1](2*x+1, 2*y+1))/4;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>A Generator can also be customized via compile-time parameters (GeneratorParams), which affect code generation.</p>
<p>GeneratorParams, Inputs, and Outputs are (by convention) always public and always declared at the top of the Generator class, in the order</p>
<div class="fragment"><div class="line">GeneratorParam(s)</div>
<div class="line">Input&lt;Func&gt;(s)</div>
<div class="line"><a class="code" href="namespace_halide_1_1_internal.html#adb05011033eb11f001b6a4cb5a6ae619a324118a6721dd6b8a9b9f4e327df2bf5">Input</a>&lt;non-Func&gt;(s)</div>
<div class="line">Output&lt;Func&gt;(s)</div>
</div><!-- fragment --><p>Note that the Inputs and Outputs will appear in the C function call in the order they are declared. All Input&lt;Func&gt; and Output&lt;Func&gt; are represented as <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a>; all other Input&lt;&gt; are the appropriate C++ scalar type. (GeneratorParams are always referenced by name, not position, so their order is irrelevant.)</p>
<p>All Inputs and Outputs must have explicit names, and all such names must match the regex [A-Za-z][A-Za-z_0-9]* (i.e., essentially a C/C++ variable name, with some extra restrictions on underscore use). By convention, the name should match the member-variable name.</p>
<p>You can dynamically add Inputs and Outputs to your Generator via adding a configure() method; if present, it will be called before generate(). It can examine GeneratorParams but it may not examine predeclared Inputs or Outputs; the only thing it should do is call add_input&lt;&gt;() and/or add_output&lt;&gt;(), or call set_type()/set_dimensions()/set_array_size() on an Input or Output with an unspecified type. Added inputs will be appended (in order) after predeclared Inputs but before any Outputs; added outputs will be appended after predeclared Outputs.</p>
<p>Note that the pointers returned by add_input() and add_output() are owned by the Generator and will remain valid for the Generator's lifetime; user code should not attempt to delete or free them.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MultiSum : <span class="keyword">public</span> Generator&lt;MultiSum&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GeneratorParam&lt;int32_t&gt; input_count{<span class="stringliteral">&quot;input_count&quot;</span>, 10};</div>
<div class="line">    Output&lt;Func&gt; output{ <span class="stringliteral">&quot;output&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2 };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configure() {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; input_count; ++i) {</div>
<div class="line">            extra_inputs.push_back(</div>
<div class="line">                add_input&lt;Func&gt;(<span class="stringliteral">&quot;input_&quot;</span> + std::to_string(i), <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> generate() {</div>
<div class="line">        Expr <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a> = 0.f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; input_count; ++i) {</div>
<div class="line">            <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a> += (*extra_inputs)[i](x, y);</div>
<div class="line">        }</div>
<div class="line">        output(x, y) = <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>;</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Input&lt;Func&gt;* extra_inputs;</div>
<div class="line">};</div>
</div><!-- fragment --><p>All Generators have two GeneratorParams that are implicitly provided by the base class: </p><pre class="fragment">GeneratorParam&lt;Target&gt; target{"target", Target()};
GeneratorParam&lt;AutoschedulerParams&gt; autoscheduler{"autoscheduler", {}}
</pre><ul>
<li>'target' is the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Halide::Target</a> for which the Generator is producing code. It is read-only during the Generator's lifetime, and must not be modified; its value should always be filled in by the calling code: either the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> build system (for ahead-of-time compilation), or ordinary C++ code (for JIT compilation).</li>
<li>'autoscheduler' is a string-to-string map that is used to indicates whether and how an auto-scheduler should be run for this Generator:<ul>
<li>if empty, the Generator should schedule its Funcs as it sees fit; no autoscheduler will be run.</li>
<li>if the 'name' key is set, it should be one of the known autoschedulers provided with this release of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>, which will be used to schedule the Funcs in the Generator. In this case, the Generator should only provide estimate()s for its Funcs, and not call any other scheduling methods.</li>
<li>Other keys may be specified in the params, on a per-autoscheduler basis, to optimize or enhance the automatically-generated schedule. See documentation for each autoscheduler for options.</li>
</ul>
</li>
</ul>
<p>Generators are added to a global registry to simplify AOT build mechanics; this is done by simply using the HALIDE_REGISTER_GENERATOR macro at global scope:</p>
<div class="fragment"><div class="line"><a class="code" href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a>(ExampleGen, jit_example)</div>
</div><!-- fragment --><p>The registered name of the Generator is provided must match the same rules as Input names, above.</p>
<p>Note that the class name of the generated Stub class will match the registered name by default; if you want to vary it (typically, to include namespaces), you can add it as an optional third argument:</p>
<div class="fragment"><div class="line"><a class="code" href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a>(ExampleGen, jit_example, SomeNamespace::JitExampleStub)</div>
</div><!-- fragment --><p>Note that a Generator is always executed with a specific Target assigned to it, that you can access via the get_target() method. (You should <em>not</em> use the global <a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d" title="Return the target that Halide will use.">get_target_from_environment()</a>, etc. methods provided in <a class="el" href="_target_8h.html">Target.h</a>)</p>
<p>(Note that there are older variations of Generator that differ from what's documented above; these are still supported but not described here. See <a href="https://github.com/halide/Halide/wiki/Old-Generator-Documentation">https://github.com/halide/Halide/wiki/Old-Generator-Documentation</a> for more information.) </p>

<p class="definition">Definition in file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a08dae13ee17f505472e95d3bcaec9984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dae13ee17f505472e95d3bcaec9984">&#9670;&nbsp;</a></span>HALIDE_GENERATOR_PARAM_TYPED_SETTER <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_GENERATOR_PARAM_TYPED_SETTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE</td><td>)</td>
          <td>&#160;&#160;&#160;virtual void set(const TYPE &amp;new_value) = 0;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00525">525</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a08dae13ee17f505472e95d3bcaec9984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dae13ee17f505472e95d3bcaec9984">&#9670;&nbsp;</a></span>HALIDE_GENERATOR_PARAM_TYPED_SETTER <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_GENERATOR_PARAM_TYPED_SETTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordtype">void</span> set(<span class="keyword">const</span> TYPE &amp;new_value)<span class="keyword"> override </span>{     \</div>
<div class="line">        typed_setter_impl&lt;TYPE&gt;(new_value, #TYPE); \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00525">525</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f">&#9670;&nbsp;</a></span>HALIDE_FORWARD_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FORWARD_METHOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Method&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;                                                                                                                      \</div>
<div class="line">    inline <span class="keyword">auto</span> Method(Args &amp;&amp;...args)-&gt;typename std::remove_reference&lt;decltype(std::declval&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...))&gt;::type { \</div>
<div class="line">        return this-&gt;<span class="keyword">template</span> as&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...);                                                                      \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01647">1647</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a3cefa62995eaf97e7a6795e159d7e245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cefa62995eaf97e7a6795e159d7e245">&#9670;&nbsp;</a></span>HALIDE_FORWARD_METHOD_CONST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FORWARD_METHOD_CONST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Method&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;                                                                                      \</div>
<div class="line">    inline <span class="keyword">auto</span> Method(Args &amp;&amp;...args) <span class="keyword">const</span>-&gt;                                                                      \</div>
<div class="line">        typename std::remove_reference&lt;decltype(std::declval&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...))&gt;::type { \</div>
<div class="line">        this-&gt;check_gio_access();                                                                                   \</div>
<div class="line">        return this-&gt;<span class="keyword">template</span> as&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...);                                      \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01653">1653</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a5856471e468d66102a7f7c3384e7bf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856471e468d66102a7f7c3384e7bf3a">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_CLASS_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FULLY_QUALIFIED_STUB_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacehalide__register__generator.html">halide_register_generator</a> {                                                                                           \</div>
<div class="line">    struct halide_global_ns;                                                                                                        \</div>
<div class="line">    namespace GEN_REGISTRY_NAME##_ns {                                                                                              \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::AbstractGenerator&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context);                      \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::AbstractGenerator&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context) {                     \</div>
<div class="line">            using GenType = std::remove_pointer&lt;decltype(<span class="keyword">new</span> GEN_CLASS_NAME)&gt;::type; <span class="comment">/* NOLINT(bugprone-macro-parentheses) */</span>       \</div>
<div class="line">            return GenType::create(context, #GEN_REGISTRY_NAME, #FULLY_QUALIFIED_STUB_NAME);                                        \</div>
<div class="line">        }                                                                                                                           \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static <span class="keyword">auto</span> reg_##GEN_REGISTRY_NAME = <a class="code" href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a>(#GEN_REGISTRY_NAME, GEN_REGISTRY_NAME##_ns::factory); \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static_assert(std::is_same&lt;::halide_register_generator::halide_global_ns, halide_register_generator::halide_global_ns&gt;::value,  \</div>
<div class="line">                  <span class="stringliteral">&quot;HALIDE_REGISTER_GENERATOR must be used at global scope&quot;</span>);</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03980">3980</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a9a745ace50c85e1e1086beda5bd7598d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a745ace50c85e1e1086beda5bd7598d">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_CLASS_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, GEN_REGISTRY_NAME)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03995">3995</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ad4b1d1e407c4804e430152a081194e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b1d1e407c4804e430152a081194e99">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_CLASS_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FULLY_QUALIFIED_STUB_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, FULLY_QUALIFIED_STUB_NAME)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03998">3998</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a9569beb9a7e98718b004aee7c10f0467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9569beb9a7e98718b004aee7c10f0467">&#9670;&nbsp;</a></span>__HALIDE_REGISTER_ARGCOUNT_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __HALIDE_REGISTER_ARGCOUNT_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04004">4004</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a64059dca539cf5f3f7e4c642af576ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64059dca539cf5f3f7e4c642af576ae3">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_ARGCOUNT_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_ARGCOUNT_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARGS</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a9569beb9a7e98718b004aee7c10f0467">__HALIDE_REGISTER_ARGCOUNT_IMPL</a> ARGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04007">4007</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ab1ebb701e7b5841c0e6202138cdb5dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ebb701e7b5841c0e6202138cdb5dff">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_ARGCOUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_ARGCOUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a64059dca539cf5f3f7e4c642af576ae3">_HALIDE_REGISTER_ARGCOUNT_IMPL</a>((__VA_ARGS__, 3, 2, 1, 0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04010">4010</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a3703de57adb30a5044367a8eccb822b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3703de57adb30a5044367a8eccb822b0">&#9670;&nbsp;</a></span>___HALIDE_REGISTER_CHOOSER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ___HALIDE_REGISTER_CHOOSER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT</td><td>)</td>
          <td>&#160;&#160;&#160;_HALIDE_REGISTER_GENERATOR##COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04013">4013</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a247774bd287d01a3081de190905019c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247774bd287d01a3081de190905019c7">&#9670;&nbsp;</a></span>__HALIDE_REGISTER_CHOOSER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __HALIDE_REGISTER_CHOOSER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a3703de57adb30a5044367a8eccb822b0">___HALIDE_REGISTER_CHOOSER</a>(COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04016">4016</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a33e49dea0ba50a51195521ede9c0b20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e49dea0ba50a51195521ede9c0b20c">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_CHOOSER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_CHOOSER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a247774bd287d01a3081de190905019c7">__HALIDE_REGISTER_CHOOSER</a>(COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04019">4019</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a940f7c9be73066885cb3a5d29e7cbd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940f7c9be73066885cb3a5d29e7cbd55">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR_PASTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR_PASTE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">A, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;A B</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04022">4022</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a76205e384e3152f5eda423c56accbc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76205e384e3152f5eda423c56accbc54">&#9670;&nbsp;</a></span>HALIDE_REGISTER_GENERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_REGISTER_GENERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_generator_8h.html#a940f7c9be73066885cb3a5d29e7cbd55">_HALIDE_REGISTER_GENERATOR_PASTE</a>(<a class="el" href="_generator_8h.html#a33e49dea0ba50a51195521ede9c0b20c">_HALIDE_REGISTER_CHOOSER</a>(<a class="el" href="_generator_8h.html#ab1ebb701e7b5841c0e6202138cdb5dff">_HALIDE_REGISTER_ARGCOUNT</a>(__VA_ARGS__)), (__VA_ARGS__))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_15_generators_8cpp-example.html#a2">tutorial/lesson_15_generators.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04025">4025</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a2ae85638c44eb4fa948399c7b9003bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae85638c44eb4fa948399c7b9003bf4">&#9670;&nbsp;</a></span>HALIDE_REGISTER_GENERATOR_ALIAS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_REGISTER_GENERATOR_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ORIGINAL_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacehalide__register__generator.html">halide_register_generator</a> {                                                                                           \</div>
<div class="line">    struct halide_global_ns;                                                                                                        \</div>
<div class="line">    namespace ORIGINAL_REGISTRY_NAME##_ns {                                                                                         \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::AbstractGenerator&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context);                      \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    namespace GEN_REGISTRY_NAME##_ns {                                                                                              \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::AbstractGenerator&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context) {                     \</div>
<div class="line">            auto g = ORIGINAL_REGISTRY_NAME##_ns::factory(context);                                                                 \</div>
<div class="line">            const <a class="code" href="namespace_halide.html#a21f90ebbb3e77c7ef7cd181827c939e6">Halide::GeneratorParamsMap</a> m = __VA_ARGS__;                                                                       \</div>
<div class="line">            g-&gt;set_generatorparam_values(m);                                                                                        \</div>
<div class="line">            return g;                                                                                                               \</div>
<div class="line">        }                                                                                                                           \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static <span class="keyword">auto</span> reg_##GEN_REGISTRY_NAME = <a class="code" href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a>(#GEN_REGISTRY_NAME, GEN_REGISTRY_NAME##_ns::factory); \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static_assert(std::is_same&lt;::halide_register_generator::halide_global_ns, halide_register_generator::halide_global_ns&gt;::value,  \</div>
<div class="line">                  <span class="stringliteral">&quot;HALIDE_REGISTER_GENERATOR_ALIAS must be used at global scope&quot;</span>);</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04042">4042</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a1ca7bae67f0d10b270349842e7f958ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca7bae67f0d10b270349842e7f958ef">&#9670;&nbsp;</a></span>HALIDE_GENERATOR_PYSTUB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_GENERATOR_PYSTUB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MODULE_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    static_assert(PY_MAJOR_VERSION &gt;= 3, <span class="stringliteral">&quot;Python bindings for Halide require Python 3+&quot;</span>);                                 \</div>
<div class="line">    extern <span class="stringliteral">&quot;C&quot;</span> PyObject *_halide_pystub_impl(<span class="keyword">const</span> <span class="keywordtype">char</span> *module_name, <span class="keyword">const</span> <a class="code" href="namespace_halide_1_1_internal.html#a13c0cea9e2c59474745b6a03dd939f2f">Halide::Internal::GeneratorFactory</a> &amp;factory); \</div>
<div class="line">    namespace halide_register_generator::GEN_REGISTRY_NAME##_ns {                                                         \</div>
<div class="line">        extern std::unique_ptr&lt;Halide::Internal::AbstractGenerator&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context);     \</div>
<div class="line">    }                                                                                                                     \</div>
<div class="line">    extern <span class="stringliteral">&quot;C&quot;</span> <a class="code" href="_halide_runtime_8h.html#a011fabf6af2c9c965cacaf866d579f8a">HALIDE_EXPORT_SYMBOL</a> PyObject *PyInit_##MODULE_NAME() {                                                    \</div>
<div class="line">        const <span class="keyword">auto</span> factory = halide_register_generator::GEN_REGISTRY_NAME##_ns::factory;                                  \</div>
<div class="line">        return _halide_pystub_impl(#MODULE_NAME, factory);                                                                \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l04064">4064</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_halide_html_a41aa8982b04d0b5faf76de0fd4c0cc33"><div class="ttname"><a href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">Halide::sum</a></div><div class="ttdeci">Expr sum(Expr, const std::string &amp;s=&quot;sum&quot;)</div><div class="ttdoc">An inline reduction.</div></div>
<div class="ttc" id="anamespace_halide_html_a11df91175e8ac20ce33379c178e8c7bc"><div class="ttname"><a href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Halide::Float</a></div><div class="ttdeci">Type Float(int bits, int lanes=1)</div><div class="ttdoc">Construct a floating-point type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00536">Type.h:536</a></div></div>
<div class="ttc" id="anamespace_halide_html_a21f90ebbb3e77c7ef7cd181827c939e6"><div class="ttname"><a href="namespace_halide.html#a21f90ebbb3e77c7ef7cd181827c939e6">Halide::GeneratorParamsMap</a></div><div class="ttdeci">std::map&lt; std::string, std::string &gt; GeneratorParamsMap</div><div class="ttdef"><b>Definition:</b> <a href="_abstract_generator_8h_source.html#l00022">AbstractGenerator.h:22</a></div></div>
<div class="ttc" id="anamespace_halide_1_1_internal_html_a13c0cea9e2c59474745b6a03dd939f2f"><div class="ttname"><a href="namespace_halide_1_1_internal.html#a13c0cea9e2c59474745b6a03dd939f2f">Halide::Internal::GeneratorFactory</a></div><div class="ttdeci">std::function&lt; AbstractGeneratorPtr(const GeneratorContext &amp;context)&gt; GeneratorFactory</div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l03105">Generator.h:3105</a></div></div>
<div class="ttc" id="anamespace_halide_html_a0eb5f455b5c4bce0c54575bc67bf9599"><div class="ttname"><a href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">Halide::UInt</a></div><div class="ttdeci">Type UInt(int bits, int lanes=1)</div><div class="ttdoc">Constructing an unsigned integer type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00531">Type.h:531</a></div></div>
<div class="ttc" id="aclass_halide_1_1_generator_context_html"><div class="ttname"><a href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a></div><div class="ttdoc">GeneratorContext is a class that is used when using Generators (or Stubs) directly; it is used to all...</div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l02998">Generator.h:2998</a></div></div>
<div class="ttc" id="anamespace_halide_1_1_internal_html_adb05011033eb11f001b6a4cb5a6ae619a324118a6721dd6b8a9b9f4e327df2bf5"><div class="ttname"><a href="namespace_halide_1_1_internal.html#adb05011033eb11f001b6a4cb5a6ae619a324118a6721dd6b8a9b9f4e327df2bf5">Halide::Internal::ArgInfoDirection::Input</a></div><div class="ttdeci">@ Input</div></div>
<div class="ttc" id="anamespace_halide_html_a789944ad1a1864bd2b4580e52d66b2afa799855594adc0f2bd7302c69d3234b5a"><div class="ttname"><a href="namespace_halide.html#a789944ad1a1864bd2b4580e52d66b2afa799855594adc0f2bd7302c69d3234b5a">Halide::OutputFileType::schedule</a></div><div class="ttdeci">@ schedule</div></div>
<div class="ttc" id="anamespacehalide__register__generator_html"><div class="ttname"><a href="namespacehalide__register__generator.html">halide_register_generator</a></div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l03976">Generator.h:3976</a></div></div>
<div class="ttc" id="a_halide_runtime_8h_html_a011fabf6af2c9c965cacaf866d579f8a"><div class="ttname"><a href="_halide_runtime_8h.html#a011fabf6af2c9c965cacaf866d579f8a">HALIDE_EXPORT_SYMBOL</a></div><div class="ttdeci">#define HALIDE_EXPORT_SYMBOL</div><div class="ttdef"><b>Definition:</b> <a href="_halide_runtime_8h_source.html#l00074">HalideRuntime.h:74</a></div></div>
<div class="ttc" id="aclass_halide_1_1_internal_1_1_register_generator_html"><div class="ttname"><a href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a></div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l03872">Generator.h:3872</a></div></div>
<div class="ttc" id="a_generator_8h_html_a76205e384e3152f5eda423c56accbc54"><div class="ttname"><a href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a></div><div class="ttdeci">#define HALIDE_REGISTER_GENERATOR(...)</div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l04025">Generator.h:4025</a></div></div>
<div class="ttc" id="anamespace_halide_html_a70a0c034814a65d55bb848fe9c96653b"><div class="ttname"><a href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Halide::Int</a></div><div class="ttdeci">Type Int(int bits, int lanes=1)</div><div class="ttdoc">Constructing a signed integer type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00526">Type.h:526</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_generator_8h.html">Generator.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
