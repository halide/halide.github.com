<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
 Inspecting the generated code
</title>
<link rel="stylesheet" type="text/css" href="../assets/css/highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">
<script>
function toggle(id) {
    e = document.getElementById(id);
    show = document.getElementById(id + '-show');
    if (e.style.display != 'none') {
        e.style.display = 'none';
        show.innerHTML = "// Click to show output ...";
    } else {
        e.style.display = 'block';
        show.innerHTML = "// Click to hide output ...";
    }
    return false;
}
</script>
<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="/index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/index.html#gettingstarted">Getting Started</a></li>
          <li><a href="/tutorials/tutorial_introduction.html">Tutorials</a></li>
          <li><a href="/index.html#publications">Publications</a></li>
          <li><a href="/index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style='position:relative; width:900pt; top:60px;'>
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators_usage.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_17_predicated_rdom.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
17
&nbsp</b>
 Reductions over non-rectangular domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_18_parallel_associative_reductions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
18
&nbsp</b>
 Factoring an associative reduction using rfactor
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_19_wrapper_funcs.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
19
&nbsp</b>
 Wrapper Funcs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_20_cloning_funcs.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
20
&nbsp</b>
 Cloning Funcs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_21_auto_scheduler_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
21
&nbsp</b>
 Auto-Scheduler
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_21_auto_scheduler_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
21
&nbsp</b>
 Auto-Scheduler
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 3: Inspecting the generated code</span>

<span class="hl slc">// This lesson demonstrates how to inspect what the Halide compiler is producing.</span>

<span class="hl slc">// On linux, you can compile and run it like so:</span>
<span class="hl slc">// g++ lesson_03*.cpp -g -I &lt;path/to/Halide.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide -lpthread -ldl -o lesson_03 -std=c++17</span>
<span class="hl slc">// LD_LIBRARY_PATH=&lt;path/to/libHalide.so&gt; ./lesson_03</span>

<span class="hl slc">// On os x:</span>
<span class="hl slc">// g++ lesson_03*.cpp -g -I &lt;path/to/Halide.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide -o lesson_03 -std=c++17</span>
<span class="hl slc">// DYLD_LIBRARY_PATH=&lt;path/to/libHalide.dylib&gt; ./lesson_03</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_03_debugging_1</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>

<span class="hl slc">// This time we&apos;ll just import the entire Halide namespace</span>
<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>

    <span class="hl slc">// We&apos;ll start by defining the simple single-stage imaging</span>
    <span class="hl slc">// pipeline from lesson 1.</span>

    <span class="hl slc">// This lesson will be about debugging, but unfortunately in C++,</span>
    <span class="hl slc">// objects don&apos;t know their own names, which makes it hard for us</span>
    <span class="hl slc">// to understand the generated code. To get around this, you can</span>
    <span class="hl slc">// pass a string to the Func and Var constructors to give them a</span>
    <span class="hl slc">// name for debugging purposes.</span>
    Func <span class="hl kwd">gradient</span><span class="hl opt">(</span><span class="hl str">&quot;gradient&quot;</span><span class="hl opt">);</span>
    Var <span class="hl kwd">x</span><span class="hl opt">(</span><span class="hl str">&quot;x&quot;</span><span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span><span class="hl str">&quot;y&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">gradient</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>

    <span class="hl slc">// Realize the function to produce an output image. We&apos;ll keep it</span>
    <span class="hl slc">// very small for this lesson.</span>
    Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> output <span class="hl opt">=</span> gradient<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">({</span><span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">});</span>

    <span class="hl slc">// That line compiled and ran the pipeline. Try running this</span>
    <span class="hl slc">// lesson with the environment variable HL_DEBUG_CODEGEN set to</span>
    <span class="hl slc">// 1. It will print out the various stages of compilation, and a</span>
    <span class="hl slc">// pseudocode representation of the final pipeline.</span>
    <a onclick='return toggle("_44");'><b id=_44-show>// Click to show output ...</b></a><div id=_44 style= "display:none; background:#333333; color:#ffffff"><b>
 > Creating initial loop nests...
 > Injecting realization of { gradient }
 > Skipping injecting memoization...
 > Injecting tracing...
 > Adding checks for parameters
 > Computing bounds of each function's value
 > Clamping unsafe data-dependent accesses
 > Performing computation bounds inference...
 > Removing extern loops...
 > Performing sliding window optimization...
 > Uniquifying variable names...
 > Simplifying...
 > Simplifying correlated differences...
 > Performing allocation bounds inference...
 > Adding checks for images
 > Removing code that depends on undef values...
 > Performing storage folding optimization...
 > Injecting debug_to_file calls...
 > Injecting prefetches...
 > Discarding safe promises...
 > Dynamically skipping stages...
 > Forking asynchronous producers...
 > Destructuring tuple-valued realizations...
 > Bounding small realizations...
 > Performing storage flattening...
 > Adding atomic mutex allocation...
 > Unpacking buffer arguments...
 > Skipping rewriting memoized allocations...
 > Simplifying...
 > Reduce prefetch dimension...
 > Simplifying correlated differences...
 > Unrolling...
 > Vectorizing...
 > Detecting vector interleavings...
 > Partitioning loops to simplify boundary conditions...
 > Staging strided loads...
 > Trimming loops to the region over which they do something...
 > Rebasing loops to zero...
 > Hoisting loop invariant if statements...
 > Injecting early frees...
 > Simplifying correlated differences...
 > Bounding small allocations...
 > Simplifying...
 > Lowering unsafe promises...
 > Flattening nested ramps...
 > Removing dead allocations and moving loop invariant code...
 > Finding intrinsics...
 > Hoisting prefetches...
 > Lowering after final simplification:
 > assert(reinterpret<uint64>((struct halide_buffer_t *)gradient.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gradient"))
 > let gradient = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gradient.buffer)
 > let gradient.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gradient.buffer)
 > let gradient.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)gradient.buffer)
 > let gradient.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gradient.buffer)
 > let gradient.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gradient.buffer, 0)
 > let gradient.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gradient.buffer, 0)
 > let gradient.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gradient.buffer, 0)
 > let gradient.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)gradient.buffer, 1)
 > let gradient.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)gradient.buffer, 1)
 > let gradient.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)gradient.buffer, 1)
 > if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gradient.buffer)) {
 >  (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gradient.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gradient.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
 > }
 > if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gradient.buffer)) {
 >  assert(gradient.type == (uint32)73728, halide_error_bad_type("Output buffer gradient", gradient.type, (uint32)73728))
 >  assert(gradient.dimensions == 2, halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
 >  assert(0 <= gradient.extent.0, halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
 >  assert(0 <= gradient.extent.1, halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
 >  assert(gradient.stride.0 == 1, halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
 >  let gradient.total_extent.1 = int64(gradient.extent.1)*int64(gradient.extent.0)
 >  assert(uint64(gradient.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gradient", uint64(gradient.extent.0), (uint64)2147483647))
 >  assert((uint64)abs(int64(gradient.extent.1)*int64(gradient.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gradient", (uint64)abs(int64(gradient.extent.1)*int64(gradient.stride.1)), (uint64)2147483647))
 >  assert(gradient.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
 >  assert(!gradient.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer gradient"))
 >  assert(gradient != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer gradient"))
 >  produce gradient {
 >   let t2 = 0 - (gradient.min.1*gradient.stride.1)
 >   let t1 = gradient.min.0 + gradient.min.1
 >   for (gradient.s0.y.rebased, 0, gradient.extent.1) {
 >    let t4 = ((gradient.min.1 + gradient.s0.y.rebased)*gradient.stride.1) + t2
 >    let t3 = gradient.s0.y.rebased + t1
 >    for (gradient.s0.x.rebased, 0, gradient.extent.0) {
 >     gradient[gradient.s0.x.rebased + t4] = gradient.s0.x.rebased + t3
 >    }
 >   }
 >  }
 > }
 > Skipping Hexagon offload...
 > Skipping GPU offload...
 > Lowering Parallel Tasks...
 > Target triple of initial module: x86_64--linux-gnu
 > Generating llvm bitcode...
 > Generating llvm bitcode prolog for function gradient...
 > Generating llvm bitcode for function gradient...
 > JIT compiling shared runtime for x86-64-linux-tune_znver3-avx-avx2-f16c-fma-jit-sse41-user_context
 > JIT compiling gradient for x86-64-linux-tune_znver3-avx-avx2-f16c-fma-jit-sse41-user_context
 > Creating initial loop nests...
 > Injecting realization of { gradient }
 > Skipping injecting memoization...
 > Injecting tracing...
 > Adding checks for parameters
 > Computing bounds of each function's value
 > Clamping unsafe data-dependent accesses
 > Performing computation bounds inference...
 > Removing extern loops...
 > Performing sliding window optimization...
 > Uniquifying variable names...
 > Simplifying...
 > Simplifying correlated differences...
 > Performing allocation bounds inference...
 > Adding checks for images
 > Removing code that depends on undef values...
 > Performing storage folding optimization...
 > Injecting debug_to_file calls...
 > Injecting prefetches...
 > Discarding safe promises...
 > Dynamically skipping stages...
 > Forking asynchronous producers...
 > Destructuring tuple-valued realizations...
 > Bounding small realizations...
 > Performing storage flattening...
 > Adding atomic mutex allocation...
 > Unpacking buffer arguments...
 > Skipping rewriting memoized allocations...
 > Simplifying...
 > Reduce prefetch dimension...
 > Simplifying correlated differences...
 > Unrolling...
 > Vectorizing...
 > Detecting vector interleavings...
 > Partitioning loops to simplify boundary conditions...
 > Staging strided loads...
 > Trimming loops to the region over which they do something...
 > Rebasing loops to zero...
 > Hoisting loop invariant if statements...
 > Injecting early frees...
 > Simplifying correlated differences...
 > Bounding small allocations...
 > Simplifying...
 > Lowering unsafe promises...
 > Flattening nested ramps...
 > Removing dead allocations and moving loop invariant code...
 > Finding intrinsics...
 > Hoisting prefetches...
 > Lowering after final simplification:
 > assert(reinterpret<uint64>((struct halide_buffer_t *)gradient.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gradient"))
 > let gradient = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gradient.buffer)
 > let gradient.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gradient.buffer)
 > let gradient.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)gradient.buffer)
 > let gradient.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gradient.buffer)
 > let gradient.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gradient.buffer, 0)
 > let gradient.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gradient.buffer, 0)
 > let gradient.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gradient.buffer, 0)
 > let gradient.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)gradient.buffer, 1)
 > let gradient.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)gradient.buffer, 1)
 > let gradient.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)gradient.buffer, 1)
 > if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gradient.buffer)) {
 >  (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gradient.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gradient.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
 > }
 > if (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gradient.buffer)) {
 >  assert(gradient.type == (uint32)73728, halide_error_bad_type("Output buffer gradient", gradient.type, (uint32)73728))
 >  assert(gradient.dimensions == 2, halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
 >  assert(0 <= gradient.extent.0, halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
 >  assert(0 <= gradient.extent.1, halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
 >  assert(gradient.stride.0 == 1, halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
 >  let gradient.total_extent.1 = int64(gradient.extent.1)*int64(gradient.extent.0)
 >  assert(uint64(gradient.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gradient", uint64(gradient.extent.0), (uint64)2147483647))
 >  assert((uint64)abs(int64(gradient.extent.1)*int64(gradient.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gradient", (uint64)abs(int64(gradient.extent.1)*int64(gradient.stride.1)), (uint64)2147483647))
 >  assert(gradient.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
 >  assert(!gradient.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer gradient"))
 >  assert(gradient != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer gradient"))
 >  produce gradient {
 >   let t7 = 0 - (gradient.min.1*gradient.stride.1)
 >   let t6 = gradient.min.0 + gradient.min.1
 >   for (gradient.s0.y.rebased, 0, gradient.extent.1) {
 >    let t9 = ((gradient.min.1 + gradient.s0.y.rebased)*gradient.stride.1) + t7
 >    let t8 = gradient.s0.y.rebased + t6
 >    for (gradient.s0.x.rebased, 0, gradient.extent.0) {
 >     gradient[gradient.s0.x.rebased + t9] = gradient.s0.x.rebased + t8
 >    }
 >   }
 >  }
 > }
 > Skipping Hexagon offload...
 > Skipping GPU offload...
 > Lowering Parallel Tasks...
 > add_temp_object_file: /tmp/0J9DzW/gradient.stmt.html.s
 > Module.compile(): creating temp file for assembly output at /tmp/0J9DzW/gradient.stmt.html.s
 > Target triple of initial module: x86_64--linux-gnu
 > Generating llvm bitcode...
 > Generating llvm bitcode prolog for function gradient...
 > Generating llvm bitcode for function gradient...
 > Module.compile(): assembly /tmp/0J9DzW/gradient.stmt.html.s
 > emit_file.Compiling to native code...
 > Module.compile(): stmt_html gradient.stmt.html
 > Done generating HTML IR Visualization - printed to: gradient.stmt.html
 > file_unlink: /tmp/0J9DzW/gradient.stmt.html.s
 > dir_rmdir: /tmp/0J9DzW

</b></div>

    <span class="hl slc">// If you set HL_DEBUG_CODEGEN to a higher number, you can see</span>
    <span class="hl slc">// more and more details of how Halide compiles your pipeline.</span>
    <span class="hl slc">// Setting HL_DEBUG_CODEGEN=2 shows the Halide code at each stage</span>
    <span class="hl slc">// of compilation, and also the llvm bitcode we generate at the</span>
    <span class="hl slc">// end.</span>

    <span class="hl slc">// Halide will also output an HTML version of this output, which</span>
    <span class="hl slc">// supports syntax highlighting and code-folding, so it can be</span>
    <span class="hl slc">// nicer to read for large pipelines. Open gradient.stmt.html&quot; with your</span>
    <span class="hl slc">// browser after running this tutorial.</span>
    gradient<span class="hl opt">.</span><span class="hl kwd">compile_to_lowered_stmt</span><span class="hl opt">(</span><span class="hl str">&quot;gradient.stmt.html&quot;</span><span class="hl opt">, {},</span> HTML<span class="hl opt">);</span>

    <span class="hl slc">// You can usually figure out what code Halide is generating using</span>
    <span class="hl slc">// this pseudocode. In the next lesson we&apos;ll see how to snoop on</span>
    <span class="hl slc">// Halide at runtime.</span>

    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre>
</div></body></html>
